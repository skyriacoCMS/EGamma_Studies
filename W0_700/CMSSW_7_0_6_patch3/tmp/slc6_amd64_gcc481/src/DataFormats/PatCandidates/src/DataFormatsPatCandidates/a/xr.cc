// Generated at Fri Dec  5 09:57:47 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/PatCandidates/src/classes_other.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

#include "TBuffer.h"
#include "TVirtualObject.h"
#include <vector>
#include "TSchemaHelper.h"


namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("pat") );
  ::Reflex::Type type_64 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_21 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_676 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1534 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_859 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_98 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_227 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_2158 = ::Reflex::TypeBuilder(Reflex::Literal("StringMap"));
  ::Reflex::Type type_200 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_6758 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Track"));
  ::Reflex::Type type_343 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_6766 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Vertex"));
  ::Reflex::Type type_204 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_2330 = ::Reflex::TypeBuilder(Reflex::Literal("Measurement1D"));
  ::Reflex::Type type_481 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_4789 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_6777 = ::Reflex::TypeBuilder(Reflex::Literal("reco::IsoDeposit"));
  ::Reflex::Type type_2990 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<float>"));
  ::Reflex::Type type_1471 = ::Reflex::TypeBuilder(Reflex::Literal("Measurement1DFloat"));
  ::Reflex::Type type_7722 = ::Reflex::TypeBuilder(Reflex::Literal("pat::JetCorrFactors"));
  ::Reflex::Type type_7728 = ::Reflex::TypeBuilder(Reflex::Literal("pat::EventHypothesis"));
  ::Reflex::Type type_7729 = ::Reflex::EnumTypeBuilder(Reflex::Literal("pat::IsolationKeys"));
  ::Reflex::Type type_7721 = ::Reflex::TypeBuilder(Reflex::Literal("pat::CandKinResolution"));
  ::Reflex::Type type_7723 = ::Reflex::TypeBuilder(Reflex::Literal("pat::LookupTableRecord"));
  ::Reflex::Type type_7720 = ::Reflex::TypeBuilder(Reflex::Literal("pat::VertexAssociation"));
  ::Reflex::Type type_7727 = ::Reflex::TypeBuilder(Reflex::Literal("pat::TauJetCorrFactors"));
  ::Reflex::Type type_2459 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_4655 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<StringMap>"));
  ::Reflex::Type type_2979 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2719 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<StringMap>"));
  ::Reflex::Type type_4778 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::Candidate>"));
  ::Reflex::Type type_2980 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_4771 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<reco::Track>"));
  ::Reflex::Type type_1712 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::SVector<double,3>"));
  ::Reflex::Type type_29894 = ::Reflex::EnumTypeBuilder(Reflex::Literal("pat::JetCorrFactors::Flavor"));
  ::Reflex::Type type_2988 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::JetCorrFactors>"));
  ::Reflex::Type type_4711 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<StringMap>"));
  ::Reflex::Type type_2985 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::EventHypothesis>"));
  ::Reflex::Type type_4671 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<pat::JetCorrFactors>"));
  ::Reflex::Type type_2982 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::CandKinResolution>"));
  ::Reflex::Type type_2983 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::LookupTableRecord>"));
  ::Reflex::Type type_2986 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::VertexAssociation>"));
  ::Reflex::Type type_2987 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::TauJetCorrFactors>"));
  ::Reflex::Type type_3254 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::JetCorrFactors>"));
  ::Reflex::Type type_3251 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::EventHypothesis>"));
  ::Reflex::Type type_4667 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<pat::CandKinResolution>"));
  ::Reflex::Type type_21778 = ::Reflex::TypeBuilder(Reflex::Literal("pat::eventhypothesis::ParticleFilter"));
  ::Reflex::Type type_3020 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_4668 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<pat::LookupTableRecord>"));
  ::Reflex::Type type_4669 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<pat::VertexAssociation>"));
  ::Reflex::Type type_4670 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<pat::TauJetCorrFactors>"));
  ::Reflex::Type type_2951 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,int>"));
  ::Reflex::Type type_3248 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::CandKinResolution>"));
  ::Reflex::Type type_3249 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::LookupTableRecord>"));
  ::Reflex::Type type_3252 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::VertexAssociation>"));
  ::Reflex::Type type_3253 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::TauJetCorrFactors>"));
  ::Reflex::Type type_3001 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ptr<reco::Candidate> >"));
  ::Reflex::Type type_2957 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,float>"));
  ::Reflex::Type type_29865 = ::Reflex::EnumTypeBuilder(Reflex::Literal("pat::CandKinResolution::Parametrization"));
  ::Reflex::Type type_2915 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<pat::IsolationKeys,reco::IsoDeposit>"));
  ::Reflex::Type type_29928 = ::Reflex::TypeBuilder(Reflex::Literal("pat::eventhypothesis::Looper<reco::Candidate>"));
  ::Reflex::Type type_4653 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::EventHypothesis> >"));
  ::Reflex::Type type_2717 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::EventHypothesis> >"));
  ::Reflex::Type type_4658 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >"));
  ::Reflex::Type type_2722 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ValueMap<pat::JetCorrFactors> >"));
  ::Reflex::Type type_22794 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<pat::JetCorrFactors>::const_iterator"));
  ::Reflex::Type type_3017 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >"));
  ::Reflex::Type type_2981 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<edm::ProductID,unsigned int> >"));
  ::Reflex::Type type_4652 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >"));
  ::Reflex::Type type_4654 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >"));
  ::Reflex::Type type_4656 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >"));
  ::Reflex::Type type_4651 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >"));
  ::Reflex::Type type_2716 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ValueMap<pat::LookupTableRecord> >"));
  ::Reflex::Type type_2718 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ValueMap<pat::VertexAssociation> >"));
  ::Reflex::Type type_2720 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ValueMap<pat::TauJetCorrFactors> >"));
  ::Reflex::Type type_2715 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ValueMap<pat::CandKinResolution> >"));
  ::Reflex::Type type_2916 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<float> >"));
  ::Reflex::Type type_3021 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >"));
  ::Reflex::Type type_22689 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<pat::LookupTableRecord>::const_iterator"));
  ::Reflex::Type type_4419 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_22724 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<pat::VertexAssociation>::const_iterator"));
  ::Reflex::Type type_22759 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<pat::TauJetCorrFactors>::const_iterator"));
  ::Reflex::Type type_22654 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<pat::CandKinResolution>::const_iterator"));
  ::Reflex::Type type_6129 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >"));
  ::Reflex::Type type_4709 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::EventHypothesis> >"));
  ::Reflex::Type type_22792 = ::Reflex::TypeBuilder(Reflex::Literal("edm::helper::Filler<edm::ValueMap<pat::JetCorrFactors> >"));
  ::Reflex::Type type_4714 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ValueMap<pat::JetCorrFactors> >"));
  ::Reflex::Type type_2984 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >"));
  ::Reflex::Type type_22687 = ::Reflex::TypeBuilder(Reflex::Literal("edm::helper::Filler<edm::ValueMap<pat::LookupTableRecord> >"));
  ::Reflex::Type type_22722 = ::Reflex::TypeBuilder(Reflex::Literal("edm::helper::Filler<edm::ValueMap<pat::VertexAssociation> >"));
  ::Reflex::Type type_22757 = ::Reflex::TypeBuilder(Reflex::Literal("edm::helper::Filler<edm::ValueMap<pat::TauJetCorrFactors> >"));
  ::Reflex::Type type_22652 = ::Reflex::TypeBuilder(Reflex::Literal("edm::helper::Filler<edm::ValueMap<pat::CandKinResolution> >"));
  ::Reflex::Type type_2918 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,edm::Ptr<reco::Candidate> >"));
  ::Reflex::Type type_4421 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<const pat::eventhypothesis::ParticleFilter>"));
  ::Reflex::Type type_4708 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ValueMap<pat::LookupTableRecord> >"));
  ::Reflex::Type type_4710 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ValueMap<pat::VertexAssociation> >"));
  ::Reflex::Type type_4712 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ValueMap<pat::TauJetCorrFactors> >"));
  ::Reflex::Type type_4707 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ValueMap<pat::CandKinResolution> >"));
  ::Reflex::Type type_109 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >"));
  ::Reflex::Type type_3250 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<pat::IsolationKeys,reco::IsoDeposit> >"));
  ::Reflex::Type type_101 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >"));
  ::Reflex::Type type_7165 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::JetCorrFactors> >"));
  ::Reflex::Type type_7162 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::EventHypothesis> >"));
  ::Reflex::Type type_7159 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::CandKinResolution> >"));
  ::Reflex::Type type_7160 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::LookupTableRecord> >"));
  ::Reflex::Type type_7163 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::VertexAssociation> >"));
  ::Reflex::Type type_7164 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::TauJetCorrFactors> >"));
  ::Reflex::Type type_2989 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >"));
  ::Reflex::Type type_4661 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >"));
  ::Reflex::Type type_2725 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::pair<std::basic_string<char>,std::vector<float> > >"));
  ::Reflex::Type type_3255 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<std::basic_string<char>,std::vector<float> > >"));
  ::Reflex::Type type_3000 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,edm::Ptr<reco::Candidate> > >"));
  ::Reflex::Type type_2405 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::JetCorrFactors,std::allocator<pat::JetCorrFactors> >"));
  ::Reflex::Type type_2402 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::EventHypothesis,std::allocator<pat::EventHypothesis> >"));
  ::Reflex::Type type_4717 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::pair<std::basic_string<char>,std::vector<float> > >"));
  ::Reflex::Type type_2399 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::CandKinResolution,std::allocator<pat::CandKinResolution> >"));
  ::Reflex::Type type_2400 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::LookupTableRecord,std::allocator<pat::LookupTableRecord> >"));
  ::Reflex::Type type_2403 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::VertexAssociation,std::allocator<pat::VertexAssociation> >"));
  ::Reflex::Type type_2404 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::TauJetCorrFactors,std::allocator<pat::TauJetCorrFactors> >"));
  ::Reflex::Type type_4660 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >"));
  ::Reflex::Type type_6989 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >"));
  ::Reflex::Type type_2724 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >"));
  ::Reflex::Type type_6983 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> >"));
  ::Reflex::Type type_6977 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> >"));
  ::Reflex::Type type_6979 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >"));
  ::Reflex::Type type_6985 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> >"));
  ::Reflex::Type type_6987 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >"));
  ::Reflex::Type type_6990 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >"));
  ::Reflex::Type type_7161 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >"));
  ::Reflex::Type type_6984 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::EventHypothesis*,std::vector<pat::EventHypothesis> >"));
  ::Reflex::Type type_4716 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >"));
  ::Reflex::Type type_6978 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::CandKinResolution*,std::vector<pat::CandKinResolution> >"));
  ::Reflex::Type type_6980 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >"));
  ::Reflex::Type type_6986 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::VertexAssociation*,std::vector<pat::VertexAssociation> >"));
  ::Reflex::Type type_6988 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >"));
  ::Reflex::Type type_7192 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::pair<std::basic_string<char>,std::vector<float> > > >"));
  ::Reflex::Type type_3441 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> > >"));
  ::Reflex::Type type_3435 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> > >"));
  ::Reflex::Type type_3429 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> > >"));
  ::Reflex::Type type_3431 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> > >"));
  ::Reflex::Type type_3437 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> > >"));
  ::Reflex::Type type_3439 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> > >"));
  ::Reflex::Type type_3440 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> > >"));
  ::Reflex::Type type_3434 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::EventHypothesis*,std::vector<pat::EventHypothesis> > >"));
  ::Reflex::Type type_3428 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::CandKinResolution*,std::vector<pat::CandKinResolution> > >"));
  ::Reflex::Type type_3430 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> > >"));
  ::Reflex::Type type_3436 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::VertexAssociation*,std::vector<pat::VertexAssociation> > >"));
  ::Reflex::Type type_3438 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> > >"));
  ::Reflex::Type type_4792 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::Vertex>,reco::Vertex,edm::refhelper::FindUsingAdvance<std::vector<reco::Vertex>,reco::Vertex> >"));
  ::Reflex::Type type_7039 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >"));
  ::Reflex::Type type_2401 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<pat::IsolationKeys,reco::IsoDeposit>,std::allocator<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >"));
  ::Reflex::Type type_6981 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >"));
  ::Reflex::Type type_6982 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >"));
  ::Reflex::Type type_2432 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,std::vector<float> >,std::allocator<std::pair<std::basic_string<char>,std::vector<float> > > >"));
  ::Reflex::Type type_7047 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >"));
  ::Reflex::Type type_7048 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >"));
  ::Reflex::Type type_3433 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > > >"));
  ::Reflex::Type type_3432 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > > >"));
  ::Reflex::Type type_7006 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,edm::Ptr<reco::Candidate> >*,std::vector<std::pair<std::basic_string<char>,edm::Ptr<reco::Candidate> > > >"));
  ::Reflex::Type type_3511 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > > >"));
  ::Reflex::Type type_3510 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > > >"));
  ::Reflex::Type type_3458 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,edm::Ptr<reco::Candidate> >*,std::vector<std::pair<std::basic_string<char>,edm::Ptr<reco::Candidate> > > > >"));
  ::Reflex::Type type_7726 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::CandKinResolutionValueMap"), type_4667);
  ::Reflex::Type type_29827 = ::Reflex::ReferenceBuilder(type_2158);
  ::Reflex::Type type_2158c = ::Reflex::ConstBuilder(type_2158);
  ::Reflex::Type type_29828 = ::Reflex::ReferenceBuilder(type_2158c);
  ::Reflex::Type type_2460 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2459);
  ::Reflex::Type type_2460c = ::Reflex::ConstBuilder(type_2460);
  ::Reflex::Type type_16419 = ::Reflex::ReferenceBuilder(type_2460c);
  ::Reflex::Type type_230 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("int32_t"), type_64);
  ::Reflex::Type type_2047 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_343);
  ::Reflex::Type type_13013 = ::Reflex::ReferenceBuilder(type_2915);
  ::Reflex::Type type_2915c = ::Reflex::ConstBuilder(type_2915);
  ::Reflex::Type type_13015 = ::Reflex::ReferenceBuilder(type_2915c);
  ::Reflex::Type type_7729c = ::Reflex::ConstBuilder(type_7729);
  ::Reflex::Type type_31372 = ::Reflex::ReferenceBuilder(type_7729c);
  ::Reflex::Type type_6777c = ::Reflex::ConstBuilder(type_6777);
  ::Reflex::Type type_31373 = ::Reflex::ReferenceBuilder(type_6777c);
  ::Reflex::Type type_13338 = ::Reflex::ReferenceBuilder(type_2916);
  ::Reflex::Type type_2916c = ::Reflex::ConstBuilder(type_2916);
  ::Reflex::Type type_13340 = ::Reflex::ReferenceBuilder(type_2916c);
  ::Reflex::Type type_2459c = ::Reflex::ConstBuilder(type_2459);
  ::Reflex::Type type_9749 = ::Reflex::ReferenceBuilder(type_2459c);
  ::Reflex::Type type_2990c = ::Reflex::ConstBuilder(type_2990);
  ::Reflex::Type type_31374 = ::Reflex::ReferenceBuilder(type_2990c);
  ::Reflex::Type type_110 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("AlgebraicSymMatrix44"), type_109);
  ::Reflex::Type type_6130 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZTLorentzVectorD"), type_6129);
  ::Reflex::Type type_6179 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZTLorentzVector"), type_6130);
  ::Reflex::Type type_12883 = ::Reflex::ReferenceBuilder(type_7721);
  ::Reflex::Type type_7721c = ::Reflex::ConstBuilder(type_7721);
  ::Reflex::Type type_12885 = ::Reflex::ReferenceBuilder(type_7721c);
  ::Reflex::Type type_110c = ::Reflex::ConstBuilder(type_110);
  ::Reflex::Type type_37154 = ::Reflex::ReferenceBuilder(type_110c);
  ::Reflex::Type type_1494 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint32_t"), type_200);
  ::Reflex::Type type_6179c = ::Reflex::ConstBuilder(type_6179);
  ::Reflex::Type type_36133 = ::Reflex::ReferenceBuilder(type_6179c);
  ::Reflex::Type type_8376 = ::Reflex::PointerBuilder(type_7721);
  ::Reflex::Type type_12881 = ::Reflex::PointerBuilder(type_7721c);
  ::Reflex::Type type_3227 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_343);
  ::Reflex::Type type_3120 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_21);
  ::Reflex::Type type_3248c = ::Reflex::ConstBuilder(type_3248);
  ::Reflex::Type type_30109 = ::Reflex::ReferenceBuilder(type_3248c);
  ::Reflex::Type type_2982c = ::Reflex::ConstBuilder(type_2982);
  ::Reflex::Type type_31414 = ::Reflex::ReferenceBuilder(type_2982c);
  ::Reflex::Type type_31415 = ::Reflex::ReferenceBuilder(type_2982);
  ::Reflex::Type type_1728 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint16_t"), type_204);
  ::Reflex::Type type_12948 = ::Reflex::ReferenceBuilder(type_7723);
  ::Reflex::Type type_7723c = ::Reflex::ConstBuilder(type_7723);
  ::Reflex::Type type_12950 = ::Reflex::ReferenceBuilder(type_7723c);
  ::Reflex::Type type_1471c = ::Reflex::ConstBuilder(type_1471);
  ::Reflex::Type type_24152 = ::Reflex::ReferenceBuilder(type_1471c);
  ::Reflex::Type type_8395 = ::Reflex::PointerBuilder(type_7723);
  ::Reflex::Type type_12946 = ::Reflex::PointerBuilder(type_7723c);
  ::Reflex::Type type_3249c = ::Reflex::ConstBuilder(type_3249);
  ::Reflex::Type type_30122 = ::Reflex::ReferenceBuilder(type_3249c);
  ::Reflex::Type type_2983c = ::Reflex::ConstBuilder(type_2983);
  ::Reflex::Type type_31417 = ::Reflex::ReferenceBuilder(type_2983c);
  ::Reflex::Type type_31418 = ::Reflex::ReferenceBuilder(type_2983);
  ::Reflex::Type type_8414 = ::Reflex::PointerBuilder(type_2915);
  ::Reflex::Type type_13011 = ::Reflex::PointerBuilder(type_2915c);
  ::Reflex::Type type_3250c = ::Reflex::ConstBuilder(type_3250);
  ::Reflex::Type type_30135 = ::Reflex::ReferenceBuilder(type_3250c);
  ::Reflex::Type type_2984c = ::Reflex::ConstBuilder(type_2984);
  ::Reflex::Type type_31420 = ::Reflex::ReferenceBuilder(type_2984c);
  ::Reflex::Type type_31421 = ::Reflex::ReferenceBuilder(type_2984);
  ::Reflex::Type type_6778 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CandidatePtr"), type_4778);
  ::Reflex::Type type_29934 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::eventhypothesis::CandRefType"), type_6778);
  ::Reflex::Type type_29933 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::eventhypothesis::ParticleFilterPtr"), type_4421);
  ::Reflex::Type type_13078 = ::Reflex::ReferenceBuilder(type_7728);
  ::Reflex::Type type_7728c = ::Reflex::ConstBuilder(type_7728);
  ::Reflex::Type type_13080 = ::Reflex::ReferenceBuilder(type_7728c);
  ::Reflex::Type type_29934c = ::Reflex::ConstBuilder(type_29934);
  ::Reflex::Type type_37181 = ::Reflex::ReferenceBuilder(type_29934c);
  ::Reflex::Type type_21778c = ::Reflex::ConstBuilder(type_21778);
  ::Reflex::Type type_21783 = ::Reflex::ReferenceBuilder(type_21778c);
  ::Reflex::Type type_21781 = ::Reflex::PointerBuilder(type_21778c);
  ::Reflex::Type type_29933c = ::Reflex::ConstBuilder(type_29933);
  ::Reflex::Type type_37182 = ::Reflex::ReferenceBuilder(type_29933c);
  ::Reflex::Type type_8433 = ::Reflex::PointerBuilder(type_7728);
  ::Reflex::Type type_13076 = ::Reflex::PointerBuilder(type_7728c);
  ::Reflex::Type type_3251c = ::Reflex::ConstBuilder(type_3251);
  ::Reflex::Type type_30148 = ::Reflex::ReferenceBuilder(type_3251c);
  ::Reflex::Type type_2985c = ::Reflex::ConstBuilder(type_2985);
  ::Reflex::Type type_31423 = ::Reflex::ReferenceBuilder(type_2985c);
  ::Reflex::Type type_31424 = ::Reflex::ReferenceBuilder(type_2985);
  ::Reflex::Type type_6770 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::VertexRef"), type_4792);
  ::Reflex::Type type_6781 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::TrackBaseRef"), type_4771);
  ::Reflex::Type type_13143 = ::Reflex::ReferenceBuilder(type_7720);
  ::Reflex::Type type_7720c = ::Reflex::ConstBuilder(type_7720);
  ::Reflex::Type type_13145 = ::Reflex::ReferenceBuilder(type_7720c);
  ::Reflex::Type type_6770c = ::Reflex::ConstBuilder(type_6770);
  ::Reflex::Type type_37151 = ::Reflex::ReferenceBuilder(type_6770c);
  ::Reflex::Type type_6781c = ::Reflex::ConstBuilder(type_6781);
  ::Reflex::Type type_36177 = ::Reflex::ReferenceBuilder(type_6781c);
  ::Reflex::Type type_6766c = ::Reflex::ConstBuilder(type_6766);
  ::Reflex::Type type_13915 = ::Reflex::ReferenceBuilder(type_6766c);
  ::Reflex::Type type_13911 = ::Reflex::PointerBuilder(type_6766c);
  ::Reflex::Type type_6758c = ::Reflex::ConstBuilder(type_6758);
  ::Reflex::Type type_13465 = ::Reflex::PointerBuilder(type_6758c);
  ::Reflex::Type type_2330c = ::Reflex::ConstBuilder(type_2330);
  ::Reflex::Type type_30026 = ::Reflex::ReferenceBuilder(type_2330c);
  ::Reflex::Type type_1713 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("AlgebraicVector3"), type_1712);
  ::Reflex::Type type_1713c = ::Reflex::ConstBuilder(type_1713);
  ::Reflex::Type type_37152 = ::Reflex::ReferenceBuilder(type_1713c);
  ::Reflex::Type type_102 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("AlgebraicSymMatrix33"), type_101);
  ::Reflex::Type type_102c = ::Reflex::ConstBuilder(type_102);
  ::Reflex::Type type_37153 = ::Reflex::ReferenceBuilder(type_102c);
  ::Reflex::Type type_8452 = ::Reflex::PointerBuilder(type_7720);
  ::Reflex::Type type_13141 = ::Reflex::PointerBuilder(type_7720c);
  ::Reflex::Type type_3252c = ::Reflex::ConstBuilder(type_3252);
  ::Reflex::Type type_30161 = ::Reflex::ReferenceBuilder(type_3252c);
  ::Reflex::Type type_2986c = ::Reflex::ConstBuilder(type_2986);
  ::Reflex::Type type_31426 = ::Reflex::ReferenceBuilder(type_2986c);
  ::Reflex::Type type_31427 = ::Reflex::ReferenceBuilder(type_2986);
  ::Reflex::Type type_13208 = ::Reflex::ReferenceBuilder(type_7727);
  ::Reflex::Type type_7727c = ::Reflex::ConstBuilder(type_7727);
  ::Reflex::Type type_13210 = ::Reflex::ReferenceBuilder(type_7727c);
  ::Reflex::Type type_3021c = ::Reflex::ConstBuilder(type_3021);
  ::Reflex::Type type_31514 = ::Reflex::ReferenceBuilder(type_3021c);
  ::Reflex::Type type_200c = ::Reflex::ConstBuilder(type_200);
  ::Reflex::Type type_9586 = ::Reflex::ReferenceBuilder(type_200c);
  ::Reflex::Type type_8471 = ::Reflex::PointerBuilder(type_7727);
  ::Reflex::Type type_13206 = ::Reflex::PointerBuilder(type_7727c);
  ::Reflex::Type type_3253c = ::Reflex::ConstBuilder(type_3253);
  ::Reflex::Type type_30174 = ::Reflex::ReferenceBuilder(type_3253c);
  ::Reflex::Type type_2987c = ::Reflex::ConstBuilder(type_2987);
  ::Reflex::Type type_31429 = ::Reflex::ReferenceBuilder(type_2987c);
  ::Reflex::Type type_31430 = ::Reflex::ReferenceBuilder(type_2987);
  ::Reflex::Type type_13273 = ::Reflex::ReferenceBuilder(type_7722);
  ::Reflex::Type type_7722c = ::Reflex::ConstBuilder(type_7722);
  ::Reflex::Type type_13275 = ::Reflex::ReferenceBuilder(type_7722c);
  ::Reflex::Type type_2989c = ::Reflex::ConstBuilder(type_2989);
  ::Reflex::Type type_31435 = ::Reflex::ReferenceBuilder(type_2989c);
  ::Reflex::Type type_29894c = ::Reflex::ConstBuilder(type_29894);
  ::Reflex::Type type_37155 = ::Reflex::ReferenceBuilder(type_29894c);
  ::Reflex::Type type_8490 = ::Reflex::PointerBuilder(type_7722);
  ::Reflex::Type type_13271 = ::Reflex::PointerBuilder(type_7722c);
  ::Reflex::Type type_3254c = ::Reflex::ConstBuilder(type_3254);
  ::Reflex::Type type_30187 = ::Reflex::ReferenceBuilder(type_3254c);
  ::Reflex::Type type_2988c = ::Reflex::ConstBuilder(type_2988);
  ::Reflex::Type type_31432 = ::Reflex::ReferenceBuilder(type_2988c);
  ::Reflex::Type type_31433 = ::Reflex::ReferenceBuilder(type_2988);
  ::Reflex::Type type_4668c = ::Reflex::ConstBuilder(type_4668);
  ::Reflex::Type type_35635 = ::Reflex::ReferenceBuilder(type_4668c);
  ::Reflex::Type type_35636 = ::Reflex::ReferenceBuilder(type_4668);
  ::Reflex::Type type_2981c = ::Reflex::ConstBuilder(type_2981);
  ::Reflex::Type type_31411 = ::Reflex::ReferenceBuilder(type_2981c);
  ::Reflex::Type type_35585 = ::Reflex::PointerBuilder(type_4668c);
  ::Reflex::Type type_481c = ::Reflex::ConstBuilder(type_481);
  ::Reflex::Type type_19775 = ::Reflex::ReferenceBuilder(type_481c);
  ::Reflex::Type type_35586 = ::Reflex::PointerBuilder(type_4668);
  ::Reflex::Type type_4708c = ::Reflex::ConstBuilder(type_4708);
  ::Reflex::Type type_35587 = ::Reflex::PointerBuilder(type_4708c);
  ::Reflex::Type type_4789c = ::Reflex::ConstBuilder(type_4789);
  ::Reflex::Type type_19634 = ::Reflex::ReferenceBuilder(type_4789c);
  ::Reflex::Type type_19728 = ::Reflex::ReferenceBuilder(type_2979);
  ::Reflex::Type type_35354 = ::Reflex::ReferenceBuilder(type_4419);
  ::Reflex::Type type_676c = ::Reflex::ConstBuilder(type_676);
  ::Reflex::Type type_4018 = ::Reflex::PointerBuilder(type_676c);
  ::Reflex::Type type_9938 = ::Reflex::ReferenceBuilder(type_4018);
  ::Reflex::Type type_2980c = ::Reflex::ConstBuilder(type_2980);
  ::Reflex::Type type_23644 = ::Reflex::ReferenceBuilder(type_2980c);
  ::Reflex::Type type_35590 = ::Reflex::PointerBuilder(type_2985c);
  ::Reflex::Type type_35591 = ::Reflex::PointerBuilder(type_2985);
  ::Reflex::Type type_4709c = ::Reflex::ConstBuilder(type_4709);
  ::Reflex::Type type_35592 = ::Reflex::PointerBuilder(type_4709c);
  ::Reflex::Type type_4669c = ::Reflex::ConstBuilder(type_4669);
  ::Reflex::Type type_35637 = ::Reflex::ReferenceBuilder(type_4669c);
  ::Reflex::Type type_35638 = ::Reflex::ReferenceBuilder(type_4669);
  ::Reflex::Type type_35595 = ::Reflex::PointerBuilder(type_4669c);
  ::Reflex::Type type_35596 = ::Reflex::PointerBuilder(type_4669);
  ::Reflex::Type type_4710c = ::Reflex::ConstBuilder(type_4710);
  ::Reflex::Type type_35597 = ::Reflex::PointerBuilder(type_4710c);
  ::Reflex::Type type_35600 = ::Reflex::PointerBuilder(type_2158c);
  ::Reflex::Type type_35601 = ::Reflex::PointerBuilder(type_2158);
  ::Reflex::Type type_4711c = ::Reflex::ConstBuilder(type_4711);
  ::Reflex::Type type_35602 = ::Reflex::PointerBuilder(type_4711c);
  ::Reflex::Type type_4670c = ::Reflex::ConstBuilder(type_4670);
  ::Reflex::Type type_35639 = ::Reflex::ReferenceBuilder(type_4670c);
  ::Reflex::Type type_35640 = ::Reflex::ReferenceBuilder(type_4670);
  ::Reflex::Type type_35605 = ::Reflex::PointerBuilder(type_4670c);
  ::Reflex::Type type_35606 = ::Reflex::PointerBuilder(type_4670);
  ::Reflex::Type type_4712c = ::Reflex::ConstBuilder(type_4712);
  ::Reflex::Type type_35607 = ::Reflex::PointerBuilder(type_4712c);
  ::Reflex::Type type_4671c = ::Reflex::ConstBuilder(type_4671);
  ::Reflex::Type type_35641 = ::Reflex::ReferenceBuilder(type_4671c);
  ::Reflex::Type type_35642 = ::Reflex::ReferenceBuilder(type_4671);
  ::Reflex::Type type_35615 = ::Reflex::PointerBuilder(type_4671c);
  ::Reflex::Type type_35616 = ::Reflex::PointerBuilder(type_4671);
  ::Reflex::Type type_4714c = ::Reflex::ConstBuilder(type_4714);
  ::Reflex::Type type_35617 = ::Reflex::PointerBuilder(type_4714c);
  ::Reflex::Type type_13336 = ::Reflex::PointerBuilder(type_2916c);
  ::Reflex::Type type_8999 = ::Reflex::PointerBuilder(type_2916);
  ::Reflex::Type type_4717c = ::Reflex::ConstBuilder(type_4717);
  ::Reflex::Type type_35630 = ::Reflex::PointerBuilder(type_4717c);
  ::Reflex::Type type_4667c = ::Reflex::ConstBuilder(type_4667);
  ::Reflex::Type type_35633 = ::Reflex::ReferenceBuilder(type_4667c);
  ::Reflex::Type type_35634 = ::Reflex::ReferenceBuilder(type_4667);
  ::Reflex::Type type_3255c = ::Reflex::ConstBuilder(type_3255);
  ::Reflex::Type type_30538 = ::Reflex::ReferenceBuilder(type_3255c);
  ::Reflex::Type type_31436 = ::Reflex::ReferenceBuilder(type_2989);
  ::Reflex::Type type_35580 = ::Reflex::PointerBuilder(type_4667c);
  ::Reflex::Type type_35581 = ::Reflex::PointerBuilder(type_4667);
  ::Reflex::Type type_4707c = ::Reflex::ConstBuilder(type_4707);
  ::Reflex::Type type_35582 = ::Reflex::PointerBuilder(type_4707c);
  ::Reflex::Type type_35625 = ::Reflex::PointerBuilder(type_2989c);
  ::Reflex::Type type_35626 = ::Reflex::PointerBuilder(type_2989);
  ::Reflex::Type type_4716c = ::Reflex::ConstBuilder(type_4716);
  ::Reflex::Type type_35627 = ::Reflex::PointerBuilder(type_4716c);
  ::Reflex::Type type_2989f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::JetCorrFactors::CorrectionFactor>"), type_2989);
  ::Reflex::Type type_4651f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::CandKinResolutionValueMap>"), type_4651);
  ::Reflex::Type type_4660f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::JetCorrFactors::CorrectionFactor> >"), type_4660);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __StringMap
#undef __StringMap
#endif
class __StringMap {
  public:
  __StringMap();
  ::std::vector<std::pair<std::basic_string<char>,int> > entries_;
};
#ifdef __std__pair_pat__IsolationKeys_reco__IsoDeposit_
#undef __std__pair_pat__IsolationKeys_reco__IsoDeposit_
#endif
struct __std__pair_pat__IsolationKeys_reco__IsoDeposit_ {
  public:
  __std__pair_pat__IsolationKeys_reco__IsoDeposit_();
  ::pat::IsolationKeys first;
  ::reco::IsoDeposit second;
};
#ifdef __std__pair_std__basic_string_char__std__vector_float_s_
#undef __std__pair_std__basic_string_char__std__vector_float_s_
#endif
struct __std__pair_std__basic_string_char__std__vector_float_s_ {
  public:
  __std__pair_std__basic_string_char__std__vector_float_s_();
  ::std::basic_string<char> first;
  ::std::vector<float> second;
};
#ifdef __pat__CandKinResolution
#undef __pat__CandKinResolution
#endif
class __pat__CandKinResolution {
  public:
  __pat__CandKinResolution();
  ::pat::CandKinResolution::Parametrization parametrization_;
  ::std::vector<float> covariances_;
  ::std::vector<float> constraints_;
  bool hasMatrix_;
  ::AlgebraicSymMatrix44 covmatrix_;
};
#ifdef __std__vector_pat__CandKinResolution_
#undef __std__vector_pat__CandKinResolution_
#endif
class __std__vector_pat__CandKinResolution_ : protected ::std::_Vector_base<pat::CandKinResolution,std::allocator<pat::CandKinResolution> > {
  public:
  __std__vector_pat__CandKinResolution_();
};
#ifdef __pat__LookupTableRecord
#undef __pat__LookupTableRecord
#endif
class __pat__LookupTableRecord {
  public:
  __pat__LookupTableRecord();
  float value_;
  float error_;
  ::uint16_t bin_;
};
#ifdef __std__vector_pat__LookupTableRecord_
#undef __std__vector_pat__LookupTableRecord_
#endif
class __std__vector_pat__LookupTableRecord_ : protected ::std::_Vector_base<pat::LookupTableRecord,std::allocator<pat::LookupTableRecord> > {
  public:
  __std__vector_pat__LookupTableRecord_();
};
#ifdef __std__vector_std__pair_pat__IsolationKeys_reco__IsoDeposit_s_
#undef __std__vector_std__pair_pat__IsolationKeys_reco__IsoDeposit_s_
#endif
class __std__vector_std__pair_pat__IsolationKeys_reco__IsoDeposit_s_ : protected ::std::_Vector_base<std::pair<pat::IsolationKeys,reco::IsoDeposit>,std::allocator<std::pair<pat::IsolationKeys,reco::IsoDeposit> > > {
  public:
  __std__vector_std__pair_pat__IsolationKeys_reco__IsoDeposit_s_();
};
#ifdef __pat__EventHypothesis
#undef __pat__EventHypothesis
#endif
class __pat__EventHypothesis {
  public:
  __pat__EventHypothesis();
  ::std::vector<std::pair<std::basic_string<char>,edm::Ptr<reco::Candidate> > > particles_;
};
#ifdef __std__vector_pat__EventHypothesis_
#undef __std__vector_pat__EventHypothesis_
#endif
class __std__vector_pat__EventHypothesis_ : protected ::std::_Vector_base<pat::EventHypothesis,std::allocator<pat::EventHypothesis> > {
  public:
  __std__vector_pat__EventHypothesis_();
};
#ifdef __pat__VertexAssociation
#undef __pat__VertexAssociation
#endif
class __pat__VertexAssociation {
  public:
  __pat__VertexAssociation();
  ::reco::VertexRef vertex_;
  ::Measurement1DFloat dz_;
  ::Measurement1DFloat dr_;
  ::reco::TrackBaseRef track_;
};
#ifdef __std__vector_pat__VertexAssociation_
#undef __std__vector_pat__VertexAssociation_
#endif
class __std__vector_pat__VertexAssociation_ : protected ::std::_Vector_base<pat::VertexAssociation,std::allocator<pat::VertexAssociation> > {
  public:
  __std__vector_pat__VertexAssociation_();
};
#ifdef __pat__TauJetCorrFactors
#undef __pat__TauJetCorrFactors
#endif
class __pat__TauJetCorrFactors {
  public:
  __pat__TauJetCorrFactors();
  ::std::string label_;
  ::std::vector<std::pair<std::basic_string<char>,float> > jec_;
};
#ifdef __std__vector_pat__TauJetCorrFactors_
#undef __std__vector_pat__TauJetCorrFactors_
#endif
class __std__vector_pat__TauJetCorrFactors_ : protected ::std::_Vector_base<pat::TauJetCorrFactors,std::allocator<pat::TauJetCorrFactors> > {
  public:
  __std__vector_pat__TauJetCorrFactors_();
};
#ifdef __pat__JetCorrFactors
#undef __pat__JetCorrFactors
#endif
class __pat__JetCorrFactors {
  public:
  __pat__JetCorrFactors();
  ::std::string label_;
  ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > > jec_;
};
#ifdef __std__vector_pat__JetCorrFactors_
#undef __std__vector_pat__JetCorrFactors_
#endif
class __std__vector_pat__JetCorrFactors_ : protected ::std::_Vector_base<pat::JetCorrFactors,std::allocator<pat::JetCorrFactors> > {
  public:
  __std__vector_pat__JetCorrFactors_();
};
#ifdef __edm__ValueMap_pat__LookupTableRecord_
#undef __edm__ValueMap_pat__LookupTableRecord_
#endif
class __edm__ValueMap_pat__LookupTableRecord_ {
  public:
  __edm__ValueMap_pat__LookupTableRecord_();
#ifdef __edm__ValueMap_pat__LookupTableRecord___IDComparator
#undef __edm__ValueMap_pat__LookupTableRecord___IDComparator
#endif
  struct __edm__ValueMap_pat__LookupTableRecord___IDComparator {
    public:
    __edm__ValueMap_pat__LookupTableRecord___IDComparator();
  };
  ::std::vector<pat::LookupTableRecord> values_;
  ::std::vector<std::pair<edm::ProductID,unsigned int> > ids_;
};
#ifdef __edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s_
#undef __edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s_
#endif
class __edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s_ {
  public:
  __edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s_();
  bool present;
  ::edm::ValueMap<pat::LookupTableRecord> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__EventHypothesis_s_
#undef __edm__Wrapper_std__vector_pat__EventHypothesis_s_
#endif
class __edm__Wrapper_std__vector_pat__EventHypothesis_s_ {
  public:
  __edm__Wrapper_std__vector_pat__EventHypothesis_s_();
  bool present;
  ::std::vector<pat::EventHypothesis> obj;
};
#ifdef __edm__ValueMap_pat__VertexAssociation_
#undef __edm__ValueMap_pat__VertexAssociation_
#endif
class __edm__ValueMap_pat__VertexAssociation_ {
  public:
  __edm__ValueMap_pat__VertexAssociation_();
#ifdef __edm__ValueMap_pat__VertexAssociation___IDComparator
#undef __edm__ValueMap_pat__VertexAssociation___IDComparator
#endif
  struct __edm__ValueMap_pat__VertexAssociation___IDComparator {
    public:
    __edm__ValueMap_pat__VertexAssociation___IDComparator();
  };
  ::std::vector<pat::VertexAssociation> values_;
  ::std::vector<std::pair<edm::ProductID,unsigned int> > ids_;
};
#ifdef __edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s_
#undef __edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s_
#endif
class __edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s_ {
  public:
  __edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s_();
  bool present;
  ::edm::ValueMap<pat::VertexAssociation> obj;
};
#ifdef __edm__Wrapper_StringMap_
#undef __edm__Wrapper_StringMap_
#endif
class __edm__Wrapper_StringMap_ {
  public:
  __edm__Wrapper_StringMap_();
  bool present;
  ::StringMap obj;
};
#ifdef __edm__ValueMap_pat__TauJetCorrFactors_
#undef __edm__ValueMap_pat__TauJetCorrFactors_
#endif
class __edm__ValueMap_pat__TauJetCorrFactors_ {
  public:
  __edm__ValueMap_pat__TauJetCorrFactors_();
#ifdef __edm__ValueMap_pat__TauJetCorrFactors___IDComparator
#undef __edm__ValueMap_pat__TauJetCorrFactors___IDComparator
#endif
  struct __edm__ValueMap_pat__TauJetCorrFactors___IDComparator {
    public:
    __edm__ValueMap_pat__TauJetCorrFactors___IDComparator();
  };
  ::std::vector<pat::TauJetCorrFactors> values_;
  ::std::vector<std::pair<edm::ProductID,unsigned int> > ids_;
};
#ifdef __edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s_
#undef __edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s_
#endif
class __edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s_ {
  public:
  __edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s_();
  bool present;
  ::edm::ValueMap<pat::TauJetCorrFactors> obj;
};
#ifdef __edm__ValueMap_pat__JetCorrFactors_
#undef __edm__ValueMap_pat__JetCorrFactors_
#endif
class __edm__ValueMap_pat__JetCorrFactors_ {
  public:
  __edm__ValueMap_pat__JetCorrFactors_();
#ifdef __edm__ValueMap_pat__JetCorrFactors___IDComparator
#undef __edm__ValueMap_pat__JetCorrFactors___IDComparator
#endif
  struct __edm__ValueMap_pat__JetCorrFactors___IDComparator {
    public:
    __edm__ValueMap_pat__JetCorrFactors___IDComparator();
  };
  ::std::vector<pat::JetCorrFactors> values_;
  ::std::vector<std::pair<edm::ProductID,unsigned int> > ids_;
};
#ifdef __edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s_
#undef __edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s_
#endif
class __edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s_ {
  public:
  __edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s_();
  bool present;
  ::edm::ValueMap<pat::JetCorrFactors> obj;
};
#ifdef __edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s_
#undef __edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s_
#endif
class __edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s_ {
  public:
  __edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s_();
  bool present;
  ::std::pair<std::basic_string<char>,std::vector<float> > obj;
};
#ifdef __edm__ValueMap_pat__CandKinResolution_
#undef __edm__ValueMap_pat__CandKinResolution_
#endif
class __edm__ValueMap_pat__CandKinResolution_ {
  public:
  __edm__ValueMap_pat__CandKinResolution_();
#ifdef __edm__ValueMap_pat__CandKinResolution___IDComparator
#undef __edm__ValueMap_pat__CandKinResolution___IDComparator
#endif
  struct __edm__ValueMap_pat__CandKinResolution___IDComparator {
    public:
    __edm__ValueMap_pat__CandKinResolution___IDComparator();
  };
  ::std::vector<pat::CandKinResolution> values_;
  ::std::vector<std::pair<edm::ProductID,unsigned int> > ids_;
};
#ifdef __std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_
#undef __std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_
#endif
class __std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_ : protected ::std::_Vector_base<std::pair<std::basic_string<char>,std::vector<float> >,std::allocator<std::pair<std::basic_string<char>,std::vector<float> > > > {
  public:
  __std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_();
};
#ifdef __edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s_
#undef __edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s_
#endif
class __edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s_ {
  public:
  __edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s_();
  bool present;
  ::edm::ValueMap<pat::CandKinResolution> obj;
};
#ifdef __edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s_
#undef __edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s_
#endif
class __edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s_ {
  public:
  __edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s_();
  bool present;
  ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > > obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class StringMap -------------------------------
static void destructor_7705(void*, void * o, const std::vector<void*>&, void *) {
(((::StringMap*)o)->::StringMap::~StringMap)();
}
static  void operator_7706( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::StringMap*)o)->operator=)(*(const ::StringMap*)arg[0]);
  else   (((::StringMap*)o)->operator=)(*(const ::StringMap*)arg[0]);
}

static void constructor_7707( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::StringMap(*(const ::StringMap*)arg[0]);
  else ::new(mem) ::StringMap(*(const ::StringMap*)arg[0]);
}

static void constructor_7708( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::StringMap();
  else ::new(mem) ::StringMap();
}

static  void method_7709( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::StringMap*)o)->add)(*(const ::std::string*)arg[0],
    *(::int32_t*)arg[1]);
}

static  void method_7710( void*, void* o, const std::vector<void*>&, void*)
{
  (((::StringMap*)o)->sort)();
}

static  void method_7711( void*, void* o, const std::vector<void*>&, void*)
{
  (((::StringMap*)o)->clear)();
}

static  void operator_7712( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int32_t)((((const ::StringMap*)o)->operator[])(*(const ::std::string*)arg[0]));
  else   (((const ::StringMap*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_7713( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::StringMap*)o)->operator[])(*(::int32_t*)arg[0]);
  else   (((const ::StringMap*)o)->operator[])(*(::int32_t*)arg[0]);
}

static  void method_7714( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((const ::StringMap*)o)->find)(*(const ::std::string*)arg[0]));
  else   (((const ::StringMap*)o)->find)(*(const ::std::string*)arg[0]);
}

static  void method_7715( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((const ::StringMap*)o)->find)(*(::int32_t*)arg[0]));
  else   (((const ::StringMap*)o)->find)(*(::int32_t*)arg[0]);
}

static  void method_7716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((const ::StringMap*)o)->begin)());
  else   (((const ::StringMap*)o)->begin)();
}

static  void method_7717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((const ::StringMap*)o)->end)());
  else   (((const ::StringMap*)o)->end)();
}

static  void method_7718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::StringMap*)o)->size)());
  else   (((const ::StringMap*)o)->size)();
}

static void method_newdel_2158( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::StringMap >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::StringMap >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::StringMap >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::StringMap >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::StringMap >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class StringMap -------------------------------
void __StringMap_db_datamem(Reflex::Class*);
void __StringMap_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __StringMap_datamem_bld(&__StringMap_db_datamem);
Reflex::GenreflexMemberBuilder __StringMap_funcmem_bld(&__StringMap_db_funcmem);
void __StringMap_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("StringMap"), typeid(::StringMap), sizeof(::StringMap), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddTypedef(type_2951, Reflex::Literal("StringMap::value_type"))
  .AddTypedef(type_3017, Reflex::Literal("StringMap::vector_type"))
  .AddTypedef(type_7039, Reflex::Literal("StringMap::const_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StringMap"), destructor_7705, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29827, type_29828), Reflex::Literal("operator="), operator_7706, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29828), Reflex::Literal("StringMap"), constructor_7707, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("StringMap"), constructor_7708, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2158, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__StringMap_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__StringMap_funcmem_bld);
}

//------Delayed data member builder for class StringMap -------------------
void __StringMap_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3017, Reflex::Literal("entries_"), OffsetOf(__shadow__::__StringMap, entries_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class StringMap -------------------
void __StringMap_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_16419, type_230), Reflex::Literal("add"), method_7709, 0, "string;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("sort"), method_7710, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("clear"), method_7711, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_230, type_16419), Reflex::Literal("operator[]"), operator_7712, 0, "string", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16419, type_230), Reflex::Literal("operator[]"), operator_7713, 0, "number", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7039, type_16419), Reflex::Literal("find"), method_7714, 0, "string", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7039, type_230), Reflex::Literal("find"), method_7715, 0, "number", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7039), Reflex::Literal("begin"), method_7716, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7039), Reflex::Literal("end"), method_7717, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047), Reflex::Literal("size"), method_7718, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class pair<pat::IsolationKeys,reco::IsoDeposit> -------------------------------
static void destructor_12478(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)o)->::std::pair<pat::IsolationKeys,reco::IsoDeposit>::~pair)();
}
static  void operator_12479( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)o)->operator=)(*(const ::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)arg[0]);
  else   (((::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)o)->operator=)(*(const ::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)arg[0]);
}

static void constructor_12480( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<pat::IsolationKeys,reco::IsoDeposit>(*(const ::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)arg[0]);
  else ::new(mem) ::std::pair<pat::IsolationKeys,reco::IsoDeposit>(*(const ::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)arg[0]);
}

static void constructor_12481( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<pat::IsolationKeys,reco::IsoDeposit>();
  else ::new(mem) ::std::pair<pat::IsolationKeys,reco::IsoDeposit>();
}

static void constructor_12482( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<pat::IsolationKeys,reco::IsoDeposit>(*(const ::pat::IsolationKeys*)arg[0],
      *(const ::reco::IsoDeposit*)arg[1]);
  else ::new(mem) ::std::pair<pat::IsolationKeys,reco::IsoDeposit>(*(const ::pat::IsolationKeys*)arg[0],
      *(const ::reco::IsoDeposit*)arg[1]);
}

static void method_newdel_2915( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<pat::IsolationKeys,reco::IsoDeposit> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<pat::IsolationKeys,reco::IsoDeposit> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<pat::IsolationKeys,reco::IsoDeposit> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<pat::IsolationKeys,reco::IsoDeposit> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<pat::IsolationKeys,reco::IsoDeposit> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<pat::IsolationKeys,reco::IsoDeposit> -------------------------------
void __std__pair_pat__IsolationKeys_reco__IsoDeposit__db_datamem(Reflex::Class*);
void __std__pair_pat__IsolationKeys_reco__IsoDeposit__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_pat__IsolationKeys_reco__IsoDeposit__datamem_bld(&__std__pair_pat__IsolationKeys_reco__IsoDeposit__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_pat__IsolationKeys_reco__IsoDeposit__funcmem_bld(&__std__pair_pat__IsolationKeys_reco__IsoDeposit__db_funcmem);
void __std__pair_pat__IsolationKeys_reco__IsoDeposit__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<pat::IsolationKeys,reco::IsoDeposit>"), typeid(::std::pair<pat::IsolationKeys,reco::IsoDeposit>), sizeof(::std::pair<pat::IsolationKeys,reco::IsoDeposit>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_7729, Reflex::Literal("std::pair<pat::IsolationKeys,reco::IsoDeposit>::first_type"))
  .AddTypedef(type_6777, Reflex::Literal("std::pair<pat::IsolationKeys,reco::IsoDeposit>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_12478, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13013, type_13015), Reflex::Literal("operator="), operator_12479, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13015), Reflex::Literal("pair"), constructor_12480, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_12481, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31372, type_31373), Reflex::Literal("pair"), constructor_12482, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2915, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_pat__IsolationKeys_reco__IsoDeposit__datamem_bld);
}

//------Delayed data member builder for class pair<pat::IsolationKeys,reco::IsoDeposit> -------------------
void __std__pair_pat__IsolationKeys_reco__IsoDeposit__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7729, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_pat__IsolationKeys_reco__IsoDeposit_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_6777, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_pat__IsolationKeys_reco__IsoDeposit_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<pat::IsolationKeys,reco::IsoDeposit> -------------------
void __std__pair_pat__IsolationKeys_reco__IsoDeposit__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<float, std::allocator<float> > > -------------------------------
static void destructor_12487(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,std::vector<float> >*)o)->::std::pair<std::basic_string<char>,std::vector<float> >::~pair)();
}
static  void operator_12488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,std::vector<float> >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,std::vector<float> >*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,std::vector<float> >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,std::vector<float> >*)arg[0]);
}

static void constructor_12489( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::vector<float> >(*(const ::std::pair<std::basic_string<char>,std::vector<float> >*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,std::vector<float> >(*(const ::std::pair<std::basic_string<char>,std::vector<float> >*)arg[0]);
}

static void constructor_12490( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::vector<float> >();
  else ::new(mem) ::std::pair<std::basic_string<char>,std::vector<float> >();
}

static void constructor_12491( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::vector<float> >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::vector<float>*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,std::vector<float> >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::vector<float>*)arg[1]);
}

static void method_newdel_2916( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::vector<float> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::vector<float> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::vector<float> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::vector<float> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::vector<float> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<float, std::allocator<float> > > -------------------------------
void __std__pair_std__basic_string_char__std__vector_float_s__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__std__vector_float_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__std__vector_float_s__datamem_bld(&__std__pair_std__basic_string_char__std__vector_float_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__std__vector_float_s__funcmem_bld(&__std__pair_std__basic_string_char__std__vector_float_s__db_funcmem);
void __std__pair_std__basic_string_char__std__vector_float_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<float> >"), typeid(::std::pair<std::basic_string<char>,std::vector<float> >), sizeof(::std::pair<std::basic_string<char>,std::vector<float> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_2459, Reflex::Literal("std::pair<std::basic_string<char>,std::vector<float> >::first_type"))
  .AddTypedef(type_2990, Reflex::Literal("std::pair<std::basic_string<char>,std::vector<float> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_12487, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13338, type_13340), Reflex::Literal("operator="), operator_12488, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13340), Reflex::Literal("pair"), constructor_12489, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_12490, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9749, type_31374), Reflex::Literal("pair"), constructor_12491, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2916, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__std__vector_float_s__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<float, std::allocator<float> > > -------------------
void __std__pair_std__basic_string_char__std__vector_float_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2459, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__std__vector_float_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2990, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__std__vector_float_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<float, std::allocator<float> > > -------------------
void __std__pair_std__basic_string_char__std__vector_float_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class CandKinResolution -------------------------------
static  void operator_29866( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::CandKinResolution*)o)->operator=)(*(const ::pat::CandKinResolution*)arg[0]);
  else   (((::pat::CandKinResolution*)o)->operator=)(*(const ::pat::CandKinResolution*)arg[0]);
}

static void constructor_29867( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::CandKinResolution(*(const ::pat::CandKinResolution*)arg[0]);
  else ::new(mem) ::pat::CandKinResolution(*(const ::pat::CandKinResolution*)arg[0]);
}

static void constructor_29868( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::CandKinResolution();
  else ::new(mem) ::pat::CandKinResolution();
}

static void constructor_29869( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::CandKinResolution(*(::pat::CandKinResolution::Parametrization*)arg[0],
      *(const ::std::vector<float>*)arg[1]);
  else ::new(mem) ::pat::CandKinResolution(*(::pat::CandKinResolution::Parametrization*)arg[0],
      *(const ::std::vector<float>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::CandKinResolution(*(::pat::CandKinResolution::Parametrization*)arg[0],
      *(const ::std::vector<float>*)arg[1],
      *(const ::std::vector<float>*)arg[2]);
  else ::new(mem) ::pat::CandKinResolution(*(::pat::CandKinResolution::Parametrization*)arg[0],
      *(const ::std::vector<float>*)arg[1],
      *(const ::std::vector<float>*)arg[2]);
  }
}

static void constructor_29870( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::CandKinResolution(*(::pat::CandKinResolution::Parametrization*)arg[0],
      *(const ::AlgebraicSymMatrix44*)arg[1]);
  else ::new(mem) ::pat::CandKinResolution(*(::pat::CandKinResolution::Parametrization*)arg[0],
      *(const ::AlgebraicSymMatrix44*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::CandKinResolution(*(::pat::CandKinResolution::Parametrization*)arg[0],
      *(const ::AlgebraicSymMatrix44*)arg[1],
      *(const ::std::vector<float>*)arg[2]);
  else ::new(mem) ::pat::CandKinResolution(*(::pat::CandKinResolution::Parametrization*)arg[0],
      *(const ::AlgebraicSymMatrix44*)arg[1],
      *(const ::std::vector<float>*)arg[2]);
  }
}

static void destructor_29871(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::CandKinResolution*)o)->::pat::CandKinResolution::~CandKinResolution)();
}
static  void method_29872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::CandKinResolution*)o)->parametrization)());
  else   (((const ::pat::CandKinResolution*)o)->parametrization)();
}

static  void method_29873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::pat::CandKinResolution*)o)->dimension)());
  else   (((const ::pat::CandKinResolution*)o)->dimension)();
}

static  void method_29874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::CandKinResolution*)o)->covariance)();
  else   (((const ::pat::CandKinResolution*)o)->covariance)();
}

static  void method_29875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::CandKinResolution*)o)->constraints)();
  else   (((const ::pat::CandKinResolution*)o)->constraints)();
}

static  void method_29876( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::CandKinResolution*)o)->resolEta)(*(const ::math::XYZTLorentzVector*)arg[0]));
  else   (((const ::pat::CandKinResolution*)o)->resolEta)(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static  void method_29877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::CandKinResolution*)o)->resolTheta)(*(const ::math::XYZTLorentzVector*)arg[0]));
  else   (((const ::pat::CandKinResolution*)o)->resolTheta)(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static  void method_29878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::CandKinResolution*)o)->resolPhi)(*(const ::math::XYZTLorentzVector*)arg[0]));
  else   (((const ::pat::CandKinResolution*)o)->resolPhi)(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static  void method_29879( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::CandKinResolution*)o)->resolE)(*(const ::math::XYZTLorentzVector*)arg[0]));
  else   (((const ::pat::CandKinResolution*)o)->resolE)(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static  void method_29880( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::CandKinResolution*)o)->resolEt)(*(const ::math::XYZTLorentzVector*)arg[0]));
  else   (((const ::pat::CandKinResolution*)o)->resolEt)(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static  void method_29881( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::CandKinResolution*)o)->resolM)(*(const ::math::XYZTLorentzVector*)arg[0]));
  else   (((const ::pat::CandKinResolution*)o)->resolM)(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static  void method_29882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::CandKinResolution*)o)->resolP)(*(const ::math::XYZTLorentzVector*)arg[0]));
  else   (((const ::pat::CandKinResolution*)o)->resolP)(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static  void method_29883( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::CandKinResolution*)o)->resolPt)(*(const ::math::XYZTLorentzVector*)arg[0]));
  else   (((const ::pat::CandKinResolution*)o)->resolPt)(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static  void method_29884( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::CandKinResolution*)o)->resolPInv)(*(const ::math::XYZTLorentzVector*)arg[0]));
  else   (((const ::pat::CandKinResolution*)o)->resolPInv)(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static  void method_29885( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::CandKinResolution*)o)->resolPx)(*(const ::math::XYZTLorentzVector*)arg[0]));
  else   (((const ::pat::CandKinResolution*)o)->resolPx)(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static  void method_29886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::CandKinResolution*)o)->resolPy)(*(const ::math::XYZTLorentzVector*)arg[0]));
  else   (((const ::pat::CandKinResolution*)o)->resolPy)(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static  void method_29887( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::CandKinResolution*)o)->resolPz)(*(const ::math::XYZTLorentzVector*)arg[0]));
  else   (((const ::pat::CandKinResolution*)o)->resolPz)(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static void method_newdel_7721( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::CandKinResolution >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::CandKinResolution >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::CandKinResolution >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::CandKinResolution >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::CandKinResolution >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

void read___pat__CandKinResolution_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  bool &hasMatrix_ = *(bool*)(target + OffsetOf(__shadow__::__pat__CandKinResolution, hasMatrix_));

  if( oldObj ) {}
  //--- User's code ---
  hasMatrix_ = false;
  
}

//------Dictionary for class CandKinResolution -------------------------------
void __pat__CandKinResolution_db_datamem(Reflex::Class*);
void __pat__CandKinResolution_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__CandKinResolution_datamem_bld(&__pat__CandKinResolution_db_datamem);
Reflex::GenreflexMemberBuilder __pat__CandKinResolution_funcmem_bld(&__pat__CandKinResolution_db_funcmem);
void __pat__CandKinResolution_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(1);
  rule = &readrules[0];
  rule->fSourceClass = "pat::CandKinResolution";
  rule->fTarget      = "hasMatrix_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__CandKinResolution_0);
  rule->fCode        = "\n  hasMatrix_ = false;\n  ";
  rule->fVersion     = "[1-]";


  ::Reflex::ClassBuilder(Reflex::Literal("pat::CandKinResolution"), typeid(::pat::CandKinResolution), sizeof(::pat::CandKinResolution), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "12")
  .AddProperty("ioread", readrules )
  .AddTypedef(type_6179, Reflex::Literal("pat::CandKinResolution::LorentzVector"))
  .AddTypedef(type_859, Reflex::Literal("pat::CandKinResolution::Scalar"))
  .AddEnum(Reflex::Literal("pat::CandKinResolution::Parametrization"), Reflex::Literal("Invalid=0;Cart=4;ECart=20;Spher=36;ESpher=52;MomDev=68;EMomDev=84;MCCart=3;MCSpher=19;MCPInvSpher=35;EtEtaPhi=51;EtThetaPhi=67;MCMomDev=83;EScaledMomDev=99"), &typeid(pat::CandKinResolution::Parametrization), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12883, type_12885), Reflex::Literal("operator="), operator_29866, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12885), Reflex::Literal("CandKinResolution"), constructor_29867, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CandKinResolution"), constructor_29868, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29865, type_31374, type_31374), Reflex::Literal("CandKinResolution"), constructor_29869, 0, "parametrization;covariances;constraints=std::vector<float, std::allocator<float> >()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29865, type_37154, type_31374), Reflex::Literal("CandKinResolution"), constructor_29870, 0, "parametrization;covariance;constraints=std::vector<float, std::allocator<float> >()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CandKinResolution"), destructor_29871, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7721, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__CandKinResolution_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__CandKinResolution_funcmem_bld);
}

//------Delayed data member builder for class CandKinResolution -------------------
void __pat__CandKinResolution_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_29865, Reflex::Literal("parametrization_"), OffsetOf(__shadow__::__pat__CandKinResolution, parametrization_), ::Reflex::PRIVATE)
  .AddDataMember(type_2990, Reflex::Literal("covariances_"), OffsetOf(__shadow__::__pat__CandKinResolution, covariances_), ::Reflex::PRIVATE)
  .AddDataMember(type_2990, Reflex::Literal("constraints_"), OffsetOf(__shadow__::__pat__CandKinResolution, constraints_), ::Reflex::PRIVATE)
  .AddDataMember(type_1534, Reflex::Literal("hasMatrix_"), OffsetOf(__shadow__::__pat__CandKinResolution, hasMatrix_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_110, Reflex::Literal("covmatrix_"), OffsetOf(__shadow__::__pat__CandKinResolution, covmatrix_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class CandKinResolution -------------------
void __pat__CandKinResolution_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29865), Reflex::Literal("parametrization"), method_29872, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1494), Reflex::Literal("dimension"), method_29873, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37154), Reflex::Literal("covariance"), method_29874, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31374), Reflex::Literal("constraints"), method_29875, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98, type_36133), Reflex::Literal("resolEta"), method_29876, 0, "p4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98, type_36133), Reflex::Literal("resolTheta"), method_29877, 0, "p4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98, type_36133), Reflex::Literal("resolPhi"), method_29878, 0, "p4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98, type_36133), Reflex::Literal("resolE"), method_29879, 0, "p4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98, type_36133), Reflex::Literal("resolEt"), method_29880, 0, "p4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98, type_36133), Reflex::Literal("resolM"), method_29881, 0, "p4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98, type_36133), Reflex::Literal("resolP"), method_29882, 0, "p4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98, type_36133), Reflex::Literal("resolPt"), method_29883, 0, "p4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98, type_36133), Reflex::Literal("resolPInv"), method_29884, 0, "p4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98, type_36133), Reflex::Literal("resolPx"), method_29885, 0, "p4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98, type_36133), Reflex::Literal("resolPy"), method_29886, 0, "p4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98, type_36133), Reflex::Literal("resolPz"), method_29887, 0, "p4", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<pat::CandKinResolution,std::allocator<pat::CandKinResolution> > -------------------------------
static void constructor_12894( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::CandKinResolution>();
  else ::new(mem) ::std::vector<pat::CandKinResolution>();
}

static void constructor_12895( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::CandKinResolution>(*(const ::std::allocator<pat::CandKinResolution>*)arg[0]);
  else ::new(mem) ::std::vector<pat::CandKinResolution>(*(const ::std::allocator<pat::CandKinResolution>*)arg[0]);
}

static void constructor_12896( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::CandKinResolution>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::CandKinResolution>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::CandKinResolution>(*(::std::size_t*)arg[0],
      *(const ::pat::CandKinResolution*)arg[1]);
  else ::new(mem) ::std::vector<pat::CandKinResolution>(*(::std::size_t*)arg[0],
      *(const ::pat::CandKinResolution*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::CandKinResolution>(*(::std::size_t*)arg[0],
      *(const ::pat::CandKinResolution*)arg[1],
      *(const ::std::allocator<pat::CandKinResolution>*)arg[2]);
  else ::new(mem) ::std::vector<pat::CandKinResolution>(*(::std::size_t*)arg[0],
      *(const ::pat::CandKinResolution*)arg[1],
      *(const ::std::allocator<pat::CandKinResolution>*)arg[2]);
  }
}

static void constructor_12897( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::CandKinResolution>(*(const ::std::vector<pat::CandKinResolution>*)arg[0]);
  else ::new(mem) ::std::vector<pat::CandKinResolution>(*(const ::std::vector<pat::CandKinResolution>*)arg[0]);
}

static void destructor_12898(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::CandKinResolution>*)o)->::std::vector<pat::CandKinResolution>::~vector)();
}
static  void operator_12899( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::CandKinResolution>*)o)->operator=)(*(const ::std::vector<pat::CandKinResolution>*)arg[0]);
  else   (((::std::vector<pat::CandKinResolution>*)o)->operator=)(*(const ::std::vector<pat::CandKinResolution>*)arg[0]);
}

static  void method_12900( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::CandKinResolution>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::CandKinResolution*)arg[1]);
}

static  void method_12901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> >)((((::std::vector<pat::CandKinResolution>*)o)->begin)());
  else   (((::std::vector<pat::CandKinResolution>*)o)->begin)();
}

static  void method_12902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::CandKinResolution*,std::vector<pat::CandKinResolution> >)((((const ::std::vector<pat::CandKinResolution>*)o)->begin)());
  else   (((const ::std::vector<pat::CandKinResolution>*)o)->begin)();
}

static  void method_12903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> >)((((::std::vector<pat::CandKinResolution>*)o)->end)());
  else   (((::std::vector<pat::CandKinResolution>*)o)->end)();
}

static  void method_12904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::CandKinResolution*,std::vector<pat::CandKinResolution> >)((((const ::std::vector<pat::CandKinResolution>*)o)->end)());
  else   (((const ::std::vector<pat::CandKinResolution>*)o)->end)();
}

static  void method_12909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::CandKinResolution>*)o)->size)());
  else   (((const ::std::vector<pat::CandKinResolution>*)o)->size)();
}

static  void method_12910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::CandKinResolution>*)o)->max_size)());
  else   (((const ::std::vector<pat::CandKinResolution>*)o)->max_size)();
}

static  void method_12911( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::CandKinResolution>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::CandKinResolution>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::CandKinResolution*)arg[1]);
  }
}

static  void method_12912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::CandKinResolution>*)o)->capacity)());
  else   (((const ::std::vector<pat::CandKinResolution>*)o)->capacity)();
}

static  void method_12913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::CandKinResolution>*)o)->empty)());
  else   (((const ::std::vector<pat::CandKinResolution>*)o)->empty)();
}

static  void method_12914( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::CandKinResolution>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12915( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::CandKinResolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::CandKinResolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12916( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::CandKinResolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::CandKinResolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::CandKinResolution>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::CandKinResolution>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::CandKinResolution>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::CandKinResolution>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::CandKinResolution>*)o)->front)();
  else   (((::std::vector<pat::CandKinResolution>*)o)->front)();
}

static  void method_12921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::CandKinResolution>*)o)->front)();
  else   (((const ::std::vector<pat::CandKinResolution>*)o)->front)();
}

static  void method_12922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::CandKinResolution>*)o)->back)();
  else   (((::std::vector<pat::CandKinResolution>*)o)->back)();
}

static  void method_12923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::CandKinResolution>*)o)->back)();
  else   (((const ::std::vector<pat::CandKinResolution>*)o)->back)();
}

static  void method_12924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::CandKinResolution>*)o)->data)());
  else   (((::std::vector<pat::CandKinResolution>*)o)->data)();
}

static  void method_12925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::CandKinResolution>*)o)->data)());
  else   (((const ::std::vector<pat::CandKinResolution>*)o)->data)();
}

static  void method_12926( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::CandKinResolution>*)o)->push_back)(*(const ::pat::CandKinResolution*)arg[0]);
}

static  void method_12927( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::CandKinResolution>*)o)->pop_back)();
}

static  void method_12928( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> >)((((::std::vector<pat::CandKinResolution>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> >*)arg[0],
    *(const ::pat::CandKinResolution*)arg[1]));
  else   (((::std::vector<pat::CandKinResolution>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> >*)arg[0],
    *(const ::pat::CandKinResolution*)arg[1]);
}

static  void method_12929( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::CandKinResolution>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::CandKinResolution*)arg[2]);
}

static  void method_12930( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> >)((((::std::vector<pat::CandKinResolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> >*)arg[0]));
  else   (((::std::vector<pat::CandKinResolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> >*)arg[0]);
}

static  void method_12931( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> >)((((::std::vector<pat::CandKinResolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> >*)arg[1]));
  else   (((::std::vector<pat::CandKinResolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::CandKinResolution*,std::vector<pat::CandKinResolution> >*)arg[1]);
}

static  void method_12932( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::CandKinResolution>*)o)->swap)(*(::std::vector<pat::CandKinResolution>*)arg[0]);
}

static  void method_12933( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::CandKinResolution>*)o)->clear)();
}

static void method_newdel_2982( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::CandKinResolution> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::CandKinResolution> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::CandKinResolution> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::CandKinResolution> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::CandKinResolution> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::CandKinResolution,std::allocator<pat::CandKinResolution> >")), ::Reflex::BaseOffset< ::std::vector<pat::CandKinResolution>,::std::_Vector_base<pat::CandKinResolution,std::allocator<pat::CandKinResolution> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::CandKinResolution> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::CandKinResolution> >::Generate();
}

//------Dictionary for class vector<pat::CandKinResolution,std::allocator<pat::CandKinResolution> > -------------------------------
void __std__vector_pat__CandKinResolution__db_datamem(Reflex::Class*);
void __std__vector_pat__CandKinResolution__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__CandKinResolution__datamem_bld(&__std__vector_pat__CandKinResolution__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__CandKinResolution__funcmem_bld(&__std__vector_pat__CandKinResolution__db_funcmem);
void __std__vector_pat__CandKinResolution__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::CandKinResolution>"), typeid(::std::vector<pat::CandKinResolution>), sizeof(::std::vector<pat::CandKinResolution>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2399, ::Reflex::BaseOffset< ::std::vector<pat::CandKinResolution>, ::std::_Vector_base<pat::CandKinResolution,std::allocator<pat::CandKinResolution> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7721, Reflex::Literal("std::vector<pat::CandKinResolution>::_Alloc_value_type"))
  .AddTypedef(type_2399, Reflex::Literal("std::vector<pat::CandKinResolution>::_Base"))
  .AddTypedef(type_3248, Reflex::Literal("std::vector<pat::CandKinResolution>::_Tp_alloc_type"))
  .AddTypedef(type_7159, Reflex::Literal("std::vector<pat::CandKinResolution>::_Alloc_traits"))
  .AddTypedef(type_7721, Reflex::Literal("std::vector<pat::CandKinResolution>::value_type"))
  .AddTypedef(type_8376, Reflex::Literal("std::vector<pat::CandKinResolution>::pointer"))
  .AddTypedef(type_12881, Reflex::Literal("std::vector<pat::CandKinResolution>::const_pointer"))
  .AddTypedef(type_12883, Reflex::Literal("std::vector<pat::CandKinResolution>::reference"))
  .AddTypedef(type_12885, Reflex::Literal("std::vector<pat::CandKinResolution>::const_reference"))
  .AddTypedef(type_6977, Reflex::Literal("std::vector<pat::CandKinResolution>::iterator"))
  .AddTypedef(type_6978, Reflex::Literal("std::vector<pat::CandKinResolution>::const_iterator"))
  .AddTypedef(type_3428, Reflex::Literal("std::vector<pat::CandKinResolution>::const_reverse_iterator"))
  .AddTypedef(type_3429, Reflex::Literal("std::vector<pat::CandKinResolution>::reverse_iterator"))
  .AddTypedef(type_3227, Reflex::Literal("std::vector<pat::CandKinResolution>::size_type"))
  .AddTypedef(type_3120, Reflex::Literal("std::vector<pat::CandKinResolution>::difference_type"))
  .AddTypedef(type_3248, Reflex::Literal("std::vector<pat::CandKinResolution>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12894, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30109), Reflex::Literal("vector"), constructor_12895, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3227, type_12885, type_30109), Reflex::Literal("vector"), constructor_12896, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31414), Reflex::Literal("vector"), constructor_12897, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12898, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2982, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__CandKinResolution__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::CandKinResolution,std::allocator<pat::CandKinResolution> > -------------------
void __std__vector_pat__CandKinResolution__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::CandKinResolution,std::allocator<pat::CandKinResolution> > -------------------
void __std__vector_pat__CandKinResolution__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31415, type_31414), Reflex::Literal("operator="), operator_12899, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_12885), Reflex::Literal("assign"), method_12900, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6977), Reflex::Literal("begin"), method_12901, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6978), Reflex::Literal("begin"), method_12902, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6977), Reflex::Literal("end"), method_12903, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6978), Reflex::Literal("end"), method_12904, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("size"), method_12909, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("max_size"), method_12910, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_7721), Reflex::Literal("resize"), method_12911, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("capacity"), method_12912, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("empty"), method_12913, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227), Reflex::Literal("reserve"), method_12914, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12883, type_3227), Reflex::Literal("operator[]"), operator_12915, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12885, type_3227), Reflex::Literal("operator[]"), operator_12916, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12883, type_3227), Reflex::Literal("at"), method_12918, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12885, type_3227), Reflex::Literal("at"), method_12919, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12883), Reflex::Literal("front"), method_12920, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12885), Reflex::Literal("front"), method_12921, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12883), Reflex::Literal("back"), method_12922, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12885), Reflex::Literal("back"), method_12923, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8376), Reflex::Literal("data"), method_12924, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12881), Reflex::Literal("data"), method_12925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_12885), Reflex::Literal("push_back"), method_12926, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("pop_back"), method_12927, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6977, type_6977, type_12885), Reflex::Literal("insert"), method_12928, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_6977, type_3227, type_12885), Reflex::Literal("insert"), method_12929, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6977, type_6977), Reflex::Literal("erase"), method_12930, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6977, type_6977, type_6977), Reflex::Literal("erase"), method_12931, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_31415), Reflex::Literal("swap"), method_12932, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("clear"), method_12933, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class LookupTableRecord -------------------------------
static void destructor_29918(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::LookupTableRecord*)o)->::pat::LookupTableRecord::~LookupTableRecord)();
}
static  void operator_29919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::LookupTableRecord*)o)->operator=)(*(const ::pat::LookupTableRecord*)arg[0]);
  else   (((::pat::LookupTableRecord*)o)->operator=)(*(const ::pat::LookupTableRecord*)arg[0]);
}

static void constructor_29920( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::LookupTableRecord(*(const ::pat::LookupTableRecord*)arg[0]);
  else ::new(mem) ::pat::LookupTableRecord(*(const ::pat::LookupTableRecord*)arg[0]);
}

static void constructor_29921( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::LookupTableRecord();
  else ::new(mem) ::pat::LookupTableRecord();
}

static void constructor_29922( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::LookupTableRecord(*(float*)arg[0],
      *(float*)arg[1]);
  else ::new(mem) ::pat::LookupTableRecord(*(float*)arg[0],
      *(float*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::LookupTableRecord(*(float*)arg[0],
      *(float*)arg[1],
      *(::uint16_t*)arg[2]);
  else ::new(mem) ::pat::LookupTableRecord(*(float*)arg[0],
      *(float*)arg[1],
      *(::uint16_t*)arg[2]);
  }
}

static void constructor_29923( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::LookupTableRecord(*(float*)arg[0]);
  else ::new(mem) ::pat::LookupTableRecord(*(float*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::LookupTableRecord(*(float*)arg[0],
      *(::uint16_t*)arg[1]);
  else ::new(mem) ::pat::LookupTableRecord(*(float*)arg[0],
      *(::uint16_t*)arg[1]);
  }
}

static void constructor_29924( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::LookupTableRecord(*(const ::Measurement1DFloat*)arg[0]);
  else ::new(mem) ::pat::LookupTableRecord(*(const ::Measurement1DFloat*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::LookupTableRecord(*(const ::Measurement1DFloat*)arg[0],
      *(::uint16_t*)arg[1]);
  else ::new(mem) ::pat::LookupTableRecord(*(const ::Measurement1DFloat*)arg[0],
      *(::uint16_t*)arg[1]);
  }
}

static  void method_29925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::LookupTableRecord*)o)->value)());
  else   (((const ::pat::LookupTableRecord*)o)->value)();
}

static  void method_29926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::LookupTableRecord*)o)->error)());
  else   (((const ::pat::LookupTableRecord*)o)->error)();
}

static  void method_29927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint16_t)((((const ::pat::LookupTableRecord*)o)->bin)());
  else   (((const ::pat::LookupTableRecord*)o)->bin)();
}

static void method_newdel_7723( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::LookupTableRecord >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::LookupTableRecord >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::LookupTableRecord >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::LookupTableRecord >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::LookupTableRecord >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class LookupTableRecord -------------------------------
void __pat__LookupTableRecord_db_datamem(Reflex::Class*);
void __pat__LookupTableRecord_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__LookupTableRecord_datamem_bld(&__pat__LookupTableRecord_db_datamem);
Reflex::GenreflexMemberBuilder __pat__LookupTableRecord_funcmem_bld(&__pat__LookupTableRecord_db_funcmem);
void __pat__LookupTableRecord_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::LookupTableRecord"), typeid(::pat::LookupTableRecord), sizeof(::pat::LookupTableRecord), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~LookupTableRecord"), destructor_29918, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12948, type_12950), Reflex::Literal("operator="), operator_29919, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12950), Reflex::Literal("LookupTableRecord"), constructor_29920, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("LookupTableRecord"), constructor_29921, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_859, type_859, type_1728), Reflex::Literal("LookupTableRecord"), constructor_29922, 0, "value;error;bin=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_859, type_1728), Reflex::Literal("LookupTableRecord"), constructor_29923, 0, "value;bin=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24152, type_1728), Reflex::Literal("LookupTableRecord"), constructor_29924, 0, "meas;bin=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7723, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__LookupTableRecord_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__LookupTableRecord_funcmem_bld);
}

//------Delayed data member builder for class LookupTableRecord -------------------
void __pat__LookupTableRecord_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_859, Reflex::Literal("value_"), OffsetOf(__shadow__::__pat__LookupTableRecord, value_), ::Reflex::PRIVATE)
  .AddDataMember(type_859, Reflex::Literal("error_"), OffsetOf(__shadow__::__pat__LookupTableRecord, error_), ::Reflex::PRIVATE)
  .AddDataMember(type_1728, Reflex::Literal("bin_"), OffsetOf(__shadow__::__pat__LookupTableRecord, bin_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class LookupTableRecord -------------------
void __pat__LookupTableRecord_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("value"), method_29925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("error"), method_29926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1728), Reflex::Literal("bin"), method_29927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<pat::LookupTableRecord,std::allocator<pat::LookupTableRecord> > -------------------------------
static void constructor_12959( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::LookupTableRecord>();
  else ::new(mem) ::std::vector<pat::LookupTableRecord>();
}

static void constructor_12960( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::LookupTableRecord>(*(const ::std::allocator<pat::LookupTableRecord>*)arg[0]);
  else ::new(mem) ::std::vector<pat::LookupTableRecord>(*(const ::std::allocator<pat::LookupTableRecord>*)arg[0]);
}

static void constructor_12961( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::LookupTableRecord>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::LookupTableRecord>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::LookupTableRecord>(*(::std::size_t*)arg[0],
      *(const ::pat::LookupTableRecord*)arg[1]);
  else ::new(mem) ::std::vector<pat::LookupTableRecord>(*(::std::size_t*)arg[0],
      *(const ::pat::LookupTableRecord*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::LookupTableRecord>(*(::std::size_t*)arg[0],
      *(const ::pat::LookupTableRecord*)arg[1],
      *(const ::std::allocator<pat::LookupTableRecord>*)arg[2]);
  else ::new(mem) ::std::vector<pat::LookupTableRecord>(*(::std::size_t*)arg[0],
      *(const ::pat::LookupTableRecord*)arg[1],
      *(const ::std::allocator<pat::LookupTableRecord>*)arg[2]);
  }
}

static void constructor_12962( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::LookupTableRecord>(*(const ::std::vector<pat::LookupTableRecord>*)arg[0]);
  else ::new(mem) ::std::vector<pat::LookupTableRecord>(*(const ::std::vector<pat::LookupTableRecord>*)arg[0]);
}

static void destructor_12963(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::LookupTableRecord>*)o)->::std::vector<pat::LookupTableRecord>::~vector)();
}
static  void operator_12964( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::LookupTableRecord>*)o)->operator=)(*(const ::std::vector<pat::LookupTableRecord>*)arg[0]);
  else   (((::std::vector<pat::LookupTableRecord>*)o)->operator=)(*(const ::std::vector<pat::LookupTableRecord>*)arg[0]);
}

static  void method_12965( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::LookupTableRecord>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::LookupTableRecord*)arg[1]);
}

static  void method_12966( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >)((((::std::vector<pat::LookupTableRecord>*)o)->begin)());
  else   (((::std::vector<pat::LookupTableRecord>*)o)->begin)();
}

static  void method_12967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >)((((const ::std::vector<pat::LookupTableRecord>*)o)->begin)());
  else   (((const ::std::vector<pat::LookupTableRecord>*)o)->begin)();
}

static  void method_12968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >)((((::std::vector<pat::LookupTableRecord>*)o)->end)());
  else   (((::std::vector<pat::LookupTableRecord>*)o)->end)();
}

static  void method_12969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >)((((const ::std::vector<pat::LookupTableRecord>*)o)->end)());
  else   (((const ::std::vector<pat::LookupTableRecord>*)o)->end)();
}

static  void method_12974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::LookupTableRecord>*)o)->size)());
  else   (((const ::std::vector<pat::LookupTableRecord>*)o)->size)();
}

static  void method_12975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::LookupTableRecord>*)o)->max_size)());
  else   (((const ::std::vector<pat::LookupTableRecord>*)o)->max_size)();
}

static  void method_12976( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::LookupTableRecord>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::LookupTableRecord>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::LookupTableRecord*)arg[1]);
  }
}

static  void method_12977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::LookupTableRecord>*)o)->capacity)());
  else   (((const ::std::vector<pat::LookupTableRecord>*)o)->capacity)();
}

static  void method_12978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::LookupTableRecord>*)o)->empty)());
  else   (((const ::std::vector<pat::LookupTableRecord>*)o)->empty)();
}

static  void method_12979( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::LookupTableRecord>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12980( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::LookupTableRecord>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::LookupTableRecord>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::LookupTableRecord>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::LookupTableRecord>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::LookupTableRecord>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::LookupTableRecord>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::LookupTableRecord>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::LookupTableRecord>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::LookupTableRecord>*)o)->front)();
  else   (((::std::vector<pat::LookupTableRecord>*)o)->front)();
}

static  void method_12986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::LookupTableRecord>*)o)->front)();
  else   (((const ::std::vector<pat::LookupTableRecord>*)o)->front)();
}

static  void method_12987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::LookupTableRecord>*)o)->back)();
  else   (((::std::vector<pat::LookupTableRecord>*)o)->back)();
}

static  void method_12988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::LookupTableRecord>*)o)->back)();
  else   (((const ::std::vector<pat::LookupTableRecord>*)o)->back)();
}

static  void method_12989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::LookupTableRecord>*)o)->data)());
  else   (((::std::vector<pat::LookupTableRecord>*)o)->data)();
}

static  void method_12990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::LookupTableRecord>*)o)->data)());
  else   (((const ::std::vector<pat::LookupTableRecord>*)o)->data)();
}

static  void method_12991( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::LookupTableRecord>*)o)->push_back)(*(const ::pat::LookupTableRecord*)arg[0]);
}

static  void method_12992( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::LookupTableRecord>*)o)->pop_back)();
}

static  void method_12993( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >)((((::std::vector<pat::LookupTableRecord>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >*)arg[0],
    *(const ::pat::LookupTableRecord*)arg[1]));
  else   (((::std::vector<pat::LookupTableRecord>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >*)arg[0],
    *(const ::pat::LookupTableRecord*)arg[1]);
}

static  void method_12994( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::LookupTableRecord>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::LookupTableRecord*)arg[2]);
}

static  void method_12995( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >)((((::std::vector<pat::LookupTableRecord>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >*)arg[0]));
  else   (((::std::vector<pat::LookupTableRecord>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >*)arg[0]);
}

static  void method_12996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >)((((::std::vector<pat::LookupTableRecord>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >*)arg[1]));
  else   (((::std::vector<pat::LookupTableRecord>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::LookupTableRecord*,std::vector<pat::LookupTableRecord> >*)arg[1]);
}

static  void method_12997( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::LookupTableRecord>*)o)->swap)(*(::std::vector<pat::LookupTableRecord>*)arg[0]);
}

static  void method_12998( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::LookupTableRecord>*)o)->clear)();
}

static void method_newdel_2983( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::LookupTableRecord> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::LookupTableRecord> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::LookupTableRecord> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::LookupTableRecord> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::LookupTableRecord> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::LookupTableRecord,std::allocator<pat::LookupTableRecord> >")), ::Reflex::BaseOffset< ::std::vector<pat::LookupTableRecord>,::std::_Vector_base<pat::LookupTableRecord,std::allocator<pat::LookupTableRecord> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::LookupTableRecord> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::LookupTableRecord> >::Generate();
}

//------Dictionary for class vector<pat::LookupTableRecord,std::allocator<pat::LookupTableRecord> > -------------------------------
void __std__vector_pat__LookupTableRecord__db_datamem(Reflex::Class*);
void __std__vector_pat__LookupTableRecord__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__LookupTableRecord__datamem_bld(&__std__vector_pat__LookupTableRecord__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__LookupTableRecord__funcmem_bld(&__std__vector_pat__LookupTableRecord__db_funcmem);
void __std__vector_pat__LookupTableRecord__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::LookupTableRecord>"), typeid(::std::vector<pat::LookupTableRecord>), sizeof(::std::vector<pat::LookupTableRecord>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2400, ::Reflex::BaseOffset< ::std::vector<pat::LookupTableRecord>, ::std::_Vector_base<pat::LookupTableRecord,std::allocator<pat::LookupTableRecord> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7723, Reflex::Literal("std::vector<pat::LookupTableRecord>::_Alloc_value_type"))
  .AddTypedef(type_2400, Reflex::Literal("std::vector<pat::LookupTableRecord>::_Base"))
  .AddTypedef(type_3249, Reflex::Literal("std::vector<pat::LookupTableRecord>::_Tp_alloc_type"))
  .AddTypedef(type_7160, Reflex::Literal("std::vector<pat::LookupTableRecord>::_Alloc_traits"))
  .AddTypedef(type_7723, Reflex::Literal("std::vector<pat::LookupTableRecord>::value_type"))
  .AddTypedef(type_8395, Reflex::Literal("std::vector<pat::LookupTableRecord>::pointer"))
  .AddTypedef(type_12946, Reflex::Literal("std::vector<pat::LookupTableRecord>::const_pointer"))
  .AddTypedef(type_12948, Reflex::Literal("std::vector<pat::LookupTableRecord>::reference"))
  .AddTypedef(type_12950, Reflex::Literal("std::vector<pat::LookupTableRecord>::const_reference"))
  .AddTypedef(type_6979, Reflex::Literal("std::vector<pat::LookupTableRecord>::iterator"))
  .AddTypedef(type_6980, Reflex::Literal("std::vector<pat::LookupTableRecord>::const_iterator"))
  .AddTypedef(type_3430, Reflex::Literal("std::vector<pat::LookupTableRecord>::const_reverse_iterator"))
  .AddTypedef(type_3431, Reflex::Literal("std::vector<pat::LookupTableRecord>::reverse_iterator"))
  .AddTypedef(type_3227, Reflex::Literal("std::vector<pat::LookupTableRecord>::size_type"))
  .AddTypedef(type_3120, Reflex::Literal("std::vector<pat::LookupTableRecord>::difference_type"))
  .AddTypedef(type_3249, Reflex::Literal("std::vector<pat::LookupTableRecord>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12959, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30122), Reflex::Literal("vector"), constructor_12960, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3227, type_12950, type_30122), Reflex::Literal("vector"), constructor_12961, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31417), Reflex::Literal("vector"), constructor_12962, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12963, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2983, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__LookupTableRecord__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::LookupTableRecord,std::allocator<pat::LookupTableRecord> > -------------------
void __std__vector_pat__LookupTableRecord__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::LookupTableRecord,std::allocator<pat::LookupTableRecord> > -------------------
void __std__vector_pat__LookupTableRecord__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31418, type_31417), Reflex::Literal("operator="), operator_12964, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_12950), Reflex::Literal("assign"), method_12965, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6979), Reflex::Literal("begin"), method_12966, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6980), Reflex::Literal("begin"), method_12967, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6979), Reflex::Literal("end"), method_12968, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6980), Reflex::Literal("end"), method_12969, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("size"), method_12974, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("max_size"), method_12975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_7723), Reflex::Literal("resize"), method_12976, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("capacity"), method_12977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("empty"), method_12978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227), Reflex::Literal("reserve"), method_12979, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12948, type_3227), Reflex::Literal("operator[]"), operator_12980, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12950, type_3227), Reflex::Literal("operator[]"), operator_12981, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12948, type_3227), Reflex::Literal("at"), method_12983, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12950, type_3227), Reflex::Literal("at"), method_12984, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12948), Reflex::Literal("front"), method_12985, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12950), Reflex::Literal("front"), method_12986, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12948), Reflex::Literal("back"), method_12987, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12950), Reflex::Literal("back"), method_12988, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8395), Reflex::Literal("data"), method_12989, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12946), Reflex::Literal("data"), method_12990, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_12950), Reflex::Literal("push_back"), method_12991, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("pop_back"), method_12992, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6979, type_6979, type_12950), Reflex::Literal("insert"), method_12993, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_6979, type_3227, type_12950), Reflex::Literal("insert"), method_12994, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6979, type_6979), Reflex::Literal("erase"), method_12995, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6979, type_6979, type_6979), Reflex::Literal("erase"), method_12996, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_31418), Reflex::Literal("swap"), method_12997, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("clear"), method_12998, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<pat::IsolationKeys, reco::IsoDeposit>,std::allocator<std::pair<pat::IsolationKeys, reco::IsoDeposit> > > -------------------------------
static void constructor_13024( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >();
  else ::new(mem) ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >();
}

static void constructor_13025( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >(*(const ::std::allocator<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >(*(const ::std::allocator<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)arg[0]);
}

static void constructor_13026( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)arg[1],
      *(const ::std::allocator<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)arg[1],
      *(const ::std::allocator<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)arg[2]);
  }
}

static void constructor_13027( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >(*(const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >(*(const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)arg[0]);
}

static void destructor_13028(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::~vector)();
}
static  void operator_13029( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->operator=)(*(const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)arg[0]);
  else   (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->operator=)(*(const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)arg[0]);
}

static  void method_13030( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)arg[1]);
}

static  void method_13031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >)((((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->begin)());
  else   (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->begin)();
}

static  void method_13032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >)((((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->begin)();
}

static  void method_13033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >)((((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->end)());
  else   (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->end)();
}

static  void method_13034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >)((((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->end)());
  else   (((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->end)();
}

static  void method_13039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->size)());
  else   (((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->size)();
}

static  void method_13040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->max_size)();
}

static  void method_13041( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)arg[1]);
  }
}

static  void method_13042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->capacity)();
}

static  void method_13043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->empty)();
}

static  void method_13044( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13045( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13046( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13048( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13049( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->front)();
  else   (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->front)();
}

static  void method_13051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->front)();
  else   (((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->front)();
}

static  void method_13052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->back)();
  else   (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->back)();
}

static  void method_13053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->back)();
  else   (((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->back)();
}

static  void method_13054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->data)());
  else   (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->data)();
}

static  void method_13055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->data)());
  else   (((const ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->data)();
}

static  void method_13056( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->push_back)(*(const ::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)arg[0]);
}

static  void method_13057( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->pop_back)();
}

static  void method_13058( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >)((((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >*)arg[0],
    *(const ::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)arg[1]));
  else   (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >*)arg[0],
    *(const ::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)arg[1]);
}

static  void method_13059( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<pat::IsolationKeys,reco::IsoDeposit>*)arg[2]);
}

static  void method_13060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >)((((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >*)arg[0]));
  else   (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >*)arg[0]);
}

static  void method_13061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >)((((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >*)arg[1]));
  else   (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<pat::IsolationKeys,reco::IsoDeposit>*,std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >*)arg[1]);
}

static  void method_13062( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->swap)(*(::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)arg[0]);
}

static  void method_13063( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >*)o)->clear)();
}

static void method_newdel_2984( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<pat::IsolationKeys,reco::IsoDeposit>,std::allocator<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >,::std::_Vector_base<std::pair<pat::IsolationKeys,reco::IsoDeposit>,std::allocator<std::pair<pat::IsolationKeys,reco::IsoDeposit> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > >::Generate();
}

//------Dictionary for class vector<std::pair<pat::IsolationKeys, reco::IsoDeposit>,std::allocator<std::pair<pat::IsolationKeys, reco::IsoDeposit> > > -------------------------------
void __std__vector_std__pair_pat__IsolationKeys_reco__IsoDeposit_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_pat__IsolationKeys_reco__IsoDeposit_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_pat__IsolationKeys_reco__IsoDeposit_s__datamem_bld(&__std__vector_std__pair_pat__IsolationKeys_reco__IsoDeposit_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_pat__IsolationKeys_reco__IsoDeposit_s__funcmem_bld(&__std__vector_std__pair_pat__IsolationKeys_reco__IsoDeposit_s__db_funcmem);
void __std__vector_std__pair_pat__IsolationKeys_reco__IsoDeposit_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >"), typeid(::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >), sizeof(::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2401, ::Reflex::BaseOffset< ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >, ::std::_Vector_base<std::pair<pat::IsolationKeys,reco::IsoDeposit>,std::allocator<std::pair<pat::IsolationKeys,reco::IsoDeposit> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2915, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::_Alloc_value_type"))
  .AddTypedef(type_2401, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::_Base"))
  .AddTypedef(type_3250, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::_Tp_alloc_type"))
  .AddTypedef(type_7161, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::_Alloc_traits"))
  .AddTypedef(type_2915, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::value_type"))
  .AddTypedef(type_8414, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::pointer"))
  .AddTypedef(type_13011, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::const_pointer"))
  .AddTypedef(type_13013, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::reference"))
  .AddTypedef(type_13015, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::const_reference"))
  .AddTypedef(type_6981, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::iterator"))
  .AddTypedef(type_6982, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::const_iterator"))
  .AddTypedef(type_3432, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::const_reverse_iterator"))
  .AddTypedef(type_3433, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::reverse_iterator"))
  .AddTypedef(type_3227, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::size_type"))
  .AddTypedef(type_3120, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::difference_type"))
  .AddTypedef(type_3250, Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13024, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30135), Reflex::Literal("vector"), constructor_13025, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3227, type_13015, type_30135), Reflex::Literal("vector"), constructor_13026, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31420), Reflex::Literal("vector"), constructor_13027, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13028, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2984, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_pat__IsolationKeys_reco__IsoDeposit_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<pat::IsolationKeys, reco::IsoDeposit>,std::allocator<std::pair<pat::IsolationKeys, reco::IsoDeposit> > > -------------------
void __std__vector_std__pair_pat__IsolationKeys_reco__IsoDeposit_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<pat::IsolationKeys, reco::IsoDeposit>,std::allocator<std::pair<pat::IsolationKeys, reco::IsoDeposit> > > -------------------
void __std__vector_std__pair_pat__IsolationKeys_reco__IsoDeposit_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31421, type_31420), Reflex::Literal("operator="), operator_13029, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_13015), Reflex::Literal("assign"), method_13030, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6981), Reflex::Literal("begin"), method_13031, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6982), Reflex::Literal("begin"), method_13032, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6981), Reflex::Literal("end"), method_13033, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6982), Reflex::Literal("end"), method_13034, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("size"), method_13039, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("max_size"), method_13040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_2915), Reflex::Literal("resize"), method_13041, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("capacity"), method_13042, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("empty"), method_13043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227), Reflex::Literal("reserve"), method_13044, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13013, type_3227), Reflex::Literal("operator[]"), operator_13045, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13015, type_3227), Reflex::Literal("operator[]"), operator_13046, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13013, type_3227), Reflex::Literal("at"), method_13048, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13015, type_3227), Reflex::Literal("at"), method_13049, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13013), Reflex::Literal("front"), method_13050, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13015), Reflex::Literal("front"), method_13051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13013), Reflex::Literal("back"), method_13052, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13015), Reflex::Literal("back"), method_13053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8414), Reflex::Literal("data"), method_13054, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13011), Reflex::Literal("data"), method_13055, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_13015), Reflex::Literal("push_back"), method_13056, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("pop_back"), method_13057, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6981, type_6981, type_13015), Reflex::Literal("insert"), method_13058, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_6981, type_3227, type_13015), Reflex::Literal("insert"), method_13059, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6981, type_6981), Reflex::Literal("erase"), method_13060, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6981, type_6981, type_6981), Reflex::Literal("erase"), method_13061, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_31421), Reflex::Literal("swap"), method_13062, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("clear"), method_13063, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class EventHypothesis -------------------------------
static void destructor_29962(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::EventHypothesis*)o)->::pat::EventHypothesis::~EventHypothesis)();
}
static  void operator_29963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::EventHypothesis*)o)->operator=)(*(const ::pat::EventHypothesis*)arg[0]);
  else   (((::pat::EventHypothesis*)o)->operator=)(*(const ::pat::EventHypothesis*)arg[0]);
}

static void constructor_29964( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::EventHypothesis(*(const ::pat::EventHypothesis*)arg[0]);
  else ::new(mem) ::pat::EventHypothesis(*(const ::pat::EventHypothesis*)arg[0]);
}

static void constructor_29965( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::EventHypothesis();
  else ::new(mem) ::pat::EventHypothesis();
}

static  void method_29966( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::EventHypothesis*)o)->add)(*(const ::pat::eventhypothesis::CandRefType*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_29967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,edm::Ptr<reco::Candidate> >*,std::vector<std::pair<std::basic_string<char>,edm::Ptr<reco::Candidate> > > >)((((const ::pat::EventHypothesis*)o)->begin)());
  else   (((const ::pat::EventHypothesis*)o)->begin)();
}

static  void method_29968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,edm::Ptr<reco::Candidate> >*,std::vector<std::pair<std::basic_string<char>,edm::Ptr<reco::Candidate> > > >)((((const ::pat::EventHypothesis*)o)->end)());
  else   (((const ::pat::EventHypothesis*)o)->end)();
}

static  void method_29971( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::EventHypothesis*)o)->get)(*(const ::std::string*)arg[0]);
    else     (((const ::pat::EventHypothesis*)o)->get)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::EventHypothesis*)o)->get)(*(const ::std::string*)arg[0],
      *(int*)arg[1]);
    else     (((const ::pat::EventHypothesis*)o)->get)(*(const ::std::string*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_29972( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::EventHypothesis*)o)->get)(*(const ::pat::eventhypothesis::ParticleFilter*)arg[0]);
    else     (((const ::pat::EventHypothesis*)o)->get)(*(const ::pat::eventhypothesis::ParticleFilter*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::EventHypothesis*)o)->get)(*(const ::pat::eventhypothesis::ParticleFilter*)arg[0],
      *(int*)arg[1]);
    else     (((const ::pat::EventHypothesis*)o)->get)(*(const ::pat::eventhypothesis::ParticleFilter*)arg[0],
      *(int*)arg[1]);
  }
}

static  void operator_29973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::EventHypothesis*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((const ::pat::EventHypothesis*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_29974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::EventHypothesis*)o)->operator[])(*(const ::pat::eventhypothesis::ParticleFilter*)arg[0]);
  else   (((const ::pat::EventHypothesis*)o)->operator[])(*(const ::pat::eventhypothesis::ParticleFilter*)arg[0]);
}

static  void method_29975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ptr<reco::Candidate> >)((((const ::pat::EventHypothesis*)o)->all)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::EventHypothesis*)o)->all)(*(const ::std::string*)arg[0]);
}

static  void method_29976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ptr<reco::Candidate> >)((((const ::pat::EventHypothesis*)o)->all)(*(const ::pat::eventhypothesis::ParticleFilter*)arg[0]));
  else   (((const ::pat::EventHypothesis*)o)->all)(*(const ::pat::eventhypothesis::ParticleFilter*)arg[0]);
}

static  void method_29977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::EventHypothesis*)o)->count)());
  else   (((const ::pat::EventHypothesis*)o)->count)();
}

static  void method_29978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::EventHypothesis*)o)->count)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::EventHypothesis*)o)->count)(*(const ::std::string*)arg[0]);
}

static  void method_29979( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::EventHypothesis*)o)->count)(*(const ::pat::eventhypothesis::ParticleFilter*)arg[0]));
  else   (((const ::pat::EventHypothesis*)o)->count)(*(const ::pat::eventhypothesis::ParticleFilter*)arg[0]);
}

static  void method_29980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::eventhypothesis::Looper<reco::Candidate>)((((const ::pat::EventHypothesis*)o)->loop)());
  else   (((const ::pat::EventHypothesis*)o)->loop)();
}

static  void method_29981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::eventhypothesis::Looper<reco::Candidate>)((((const ::pat::EventHypothesis*)o)->loop)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::EventHypothesis*)o)->loop)(*(const ::std::string*)arg[0]);
}

static  void method_29982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::eventhypothesis::Looper<reco::Candidate>)((((const ::pat::EventHypothesis*)o)->loop)(*(const ::pat::eventhypothesis::ParticleFilter*)arg[0]));
  else   (((const ::pat::EventHypothesis*)o)->loop)(*(const ::pat::eventhypothesis::ParticleFilter*)arg[0]);
}

static  void method_29983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::eventhypothesis::Looper<reco::Candidate>)((((const ::pat::EventHypothesis*)o)->loop)((const ::pat::eventhypothesis::ParticleFilter*)arg[0]));
  else   (((const ::pat::EventHypothesis*)o)->loop)((const ::pat::eventhypothesis::ParticleFilter*)arg[0]);
}

static  void method_29984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::eventhypothesis::Looper<reco::Candidate>)((((const ::pat::EventHypothesis*)o)->loop)(*(const ::pat::eventhypothesis::ParticleFilterPtr*)arg[0]));
  else   (((const ::pat::EventHypothesis*)o)->loop)(*(const ::pat::eventhypothesis::ParticleFilterPtr*)arg[0]);
}

static void method_newdel_7728( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::EventHypothesis >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::EventHypothesis >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::EventHypothesis >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::EventHypothesis >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::EventHypothesis >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class EventHypothesis -------------------------------
void __pat__EventHypothesis_db_datamem(Reflex::Class*);
void __pat__EventHypothesis_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__EventHypothesis_datamem_bld(&__pat__EventHypothesis_db_datamem);
Reflex::GenreflexMemberBuilder __pat__EventHypothesis_funcmem_bld(&__pat__EventHypothesis_db_funcmem);
void __pat__EventHypothesis_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::EventHypothesis"), typeid(::pat::EventHypothesis), sizeof(::pat::EventHypothesis), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddTypedef(type_29934, Reflex::Literal("pat::EventHypothesis::CandRefType"))
  .AddTypedef(type_2918, Reflex::Literal("pat::EventHypothesis::value_type"))
  .AddTypedef(type_3000, Reflex::Literal("pat::EventHypothesis::vector_type"))
  .AddTypedef(type_7006, Reflex::Literal("pat::EventHypothesis::const_iterator"))
  .AddTypedef(type_3458, Reflex::Literal("pat::EventHypothesis::const_reverse_iterator"))
  .AddTypedef(type_29928, Reflex::Literal("pat::EventHypothesis::CandLooper"))
  .AddTypedef(type_21778, Reflex::Literal("pat::EventHypothesis::ParticleFilter"))
  .AddTypedef(type_29933, Reflex::Literal("pat::EventHypothesis::ParticleFilterPtr"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~EventHypothesis"), destructor_29962, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13078, type_13080), Reflex::Literal("operator="), operator_29963, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13080), Reflex::Literal("EventHypothesis"), constructor_29964, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("EventHypothesis"), constructor_29965, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7728, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__EventHypothesis_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__EventHypothesis_funcmem_bld);
}

//------Delayed data member builder for class EventHypothesis -------------------
void __pat__EventHypothesis_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3000, Reflex::Literal("particles_"), OffsetOf(__shadow__::__pat__EventHypothesis, particles_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class EventHypothesis -------------------
void __pat__EventHypothesis_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_37181, type_16419), Reflex::Literal("add"), method_29966, 0, "ref;role", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7006), Reflex::Literal("begin"), method_29967, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7006), Reflex::Literal("end"), method_29968, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37181, type_16419, type_64), Reflex::Literal("get"), method_29971, 0, "role;index=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37181, type_21783, type_64), Reflex::Literal("get"), method_29972, 0, "filter;index=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37181, type_16419), Reflex::Literal("operator[]"), operator_29973, 0, "role", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37181, type_21783), Reflex::Literal("operator[]"), operator_29974, 0, "filter", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3001, type_16419), Reflex::Literal("all"), method_29975, 0, "roleRegexp", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3001, type_21783), Reflex::Literal("all"), method_29976, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047), Reflex::Literal("count"), method_29977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047, type_16419), Reflex::Literal("count"), method_29978, 0, "roleRegexp", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047, type_21783), Reflex::Literal("count"), method_29979, 0, "role", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29928), Reflex::Literal("loop"), method_29980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29928, type_16419), Reflex::Literal("loop"), method_29981, 0, "roleRegexp", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29928, type_21783), Reflex::Literal("loop"), method_29982, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29928, type_21781), Reflex::Literal("loop"), method_29983, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29928, type_37182), Reflex::Literal("loop"), method_29984, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<pat::EventHypothesis,std::allocator<pat::EventHypothesis> > -------------------------------
static void constructor_13089( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::EventHypothesis>();
  else ::new(mem) ::std::vector<pat::EventHypothesis>();
}

static void constructor_13090( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::EventHypothesis>(*(const ::std::allocator<pat::EventHypothesis>*)arg[0]);
  else ::new(mem) ::std::vector<pat::EventHypothesis>(*(const ::std::allocator<pat::EventHypothesis>*)arg[0]);
}

static void constructor_13091( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::EventHypothesis>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::EventHypothesis>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::EventHypothesis>(*(::std::size_t*)arg[0],
      *(const ::pat::EventHypothesis*)arg[1]);
  else ::new(mem) ::std::vector<pat::EventHypothesis>(*(::std::size_t*)arg[0],
      *(const ::pat::EventHypothesis*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::EventHypothesis>(*(::std::size_t*)arg[0],
      *(const ::pat::EventHypothesis*)arg[1],
      *(const ::std::allocator<pat::EventHypothesis>*)arg[2]);
  else ::new(mem) ::std::vector<pat::EventHypothesis>(*(::std::size_t*)arg[0],
      *(const ::pat::EventHypothesis*)arg[1],
      *(const ::std::allocator<pat::EventHypothesis>*)arg[2]);
  }
}

static void constructor_13092( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::EventHypothesis>(*(const ::std::vector<pat::EventHypothesis>*)arg[0]);
  else ::new(mem) ::std::vector<pat::EventHypothesis>(*(const ::std::vector<pat::EventHypothesis>*)arg[0]);
}

static void destructor_13093(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::EventHypothesis>*)o)->::std::vector<pat::EventHypothesis>::~vector)();
}
static  void operator_13094( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::EventHypothesis>*)o)->operator=)(*(const ::std::vector<pat::EventHypothesis>*)arg[0]);
  else   (((::std::vector<pat::EventHypothesis>*)o)->operator=)(*(const ::std::vector<pat::EventHypothesis>*)arg[0]);
}

static  void method_13095( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::EventHypothesis>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::EventHypothesis*)arg[1]);
}

static  void method_13096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> >)((((::std::vector<pat::EventHypothesis>*)o)->begin)());
  else   (((::std::vector<pat::EventHypothesis>*)o)->begin)();
}

static  void method_13097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::EventHypothesis*,std::vector<pat::EventHypothesis> >)((((const ::std::vector<pat::EventHypothesis>*)o)->begin)());
  else   (((const ::std::vector<pat::EventHypothesis>*)o)->begin)();
}

static  void method_13098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> >)((((::std::vector<pat::EventHypothesis>*)o)->end)());
  else   (((::std::vector<pat::EventHypothesis>*)o)->end)();
}

static  void method_13099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::EventHypothesis*,std::vector<pat::EventHypothesis> >)((((const ::std::vector<pat::EventHypothesis>*)o)->end)());
  else   (((const ::std::vector<pat::EventHypothesis>*)o)->end)();
}

static  void method_13104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::EventHypothesis>*)o)->size)());
  else   (((const ::std::vector<pat::EventHypothesis>*)o)->size)();
}

static  void method_13105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::EventHypothesis>*)o)->max_size)());
  else   (((const ::std::vector<pat::EventHypothesis>*)o)->max_size)();
}

static  void method_13106( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::EventHypothesis>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::EventHypothesis>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::EventHypothesis*)arg[1]);
  }
}

static  void method_13107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::EventHypothesis>*)o)->capacity)());
  else   (((const ::std::vector<pat::EventHypothesis>*)o)->capacity)();
}

static  void method_13108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::EventHypothesis>*)o)->empty)());
  else   (((const ::std::vector<pat::EventHypothesis>*)o)->empty)();
}

static  void method_13109( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::EventHypothesis>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13110( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::EventHypothesis>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::EventHypothesis>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13111( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::EventHypothesis>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::EventHypothesis>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13113( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::EventHypothesis>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::EventHypothesis>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::EventHypothesis>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::EventHypothesis>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::EventHypothesis>*)o)->front)();
  else   (((::std::vector<pat::EventHypothesis>*)o)->front)();
}

static  void method_13116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::EventHypothesis>*)o)->front)();
  else   (((const ::std::vector<pat::EventHypothesis>*)o)->front)();
}

static  void method_13117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::EventHypothesis>*)o)->back)();
  else   (((::std::vector<pat::EventHypothesis>*)o)->back)();
}

static  void method_13118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::EventHypothesis>*)o)->back)();
  else   (((const ::std::vector<pat::EventHypothesis>*)o)->back)();
}

static  void method_13119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::EventHypothesis>*)o)->data)());
  else   (((::std::vector<pat::EventHypothesis>*)o)->data)();
}

static  void method_13120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::EventHypothesis>*)o)->data)());
  else   (((const ::std::vector<pat::EventHypothesis>*)o)->data)();
}

static  void method_13121( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::EventHypothesis>*)o)->push_back)(*(const ::pat::EventHypothesis*)arg[0]);
}

static  void method_13122( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::EventHypothesis>*)o)->pop_back)();
}

static  void method_13123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> >)((((::std::vector<pat::EventHypothesis>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> >*)arg[0],
    *(const ::pat::EventHypothesis*)arg[1]));
  else   (((::std::vector<pat::EventHypothesis>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> >*)arg[0],
    *(const ::pat::EventHypothesis*)arg[1]);
}

static  void method_13124( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::EventHypothesis>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::EventHypothesis*)arg[2]);
}

static  void method_13125( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> >)((((::std::vector<pat::EventHypothesis>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> >*)arg[0]));
  else   (((::std::vector<pat::EventHypothesis>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> >*)arg[0]);
}

static  void method_13126( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> >)((((::std::vector<pat::EventHypothesis>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> >*)arg[1]));
  else   (((::std::vector<pat::EventHypothesis>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::EventHypothesis*,std::vector<pat::EventHypothesis> >*)arg[1]);
}

static  void method_13127( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::EventHypothesis>*)o)->swap)(*(::std::vector<pat::EventHypothesis>*)arg[0]);
}

static  void method_13128( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::EventHypothesis>*)o)->clear)();
}

static void method_newdel_2985( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::EventHypothesis> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::EventHypothesis> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::EventHypothesis> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::EventHypothesis> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::EventHypothesis> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::EventHypothesis,std::allocator<pat::EventHypothesis> >")), ::Reflex::BaseOffset< ::std::vector<pat::EventHypothesis>,::std::_Vector_base<pat::EventHypothesis,std::allocator<pat::EventHypothesis> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::EventHypothesis> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::EventHypothesis> >::Generate();
}

//------Dictionary for class vector<pat::EventHypothesis,std::allocator<pat::EventHypothesis> > -------------------------------
void __std__vector_pat__EventHypothesis__db_datamem(Reflex::Class*);
void __std__vector_pat__EventHypothesis__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__EventHypothesis__datamem_bld(&__std__vector_pat__EventHypothesis__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__EventHypothesis__funcmem_bld(&__std__vector_pat__EventHypothesis__db_funcmem);
void __std__vector_pat__EventHypothesis__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::EventHypothesis>"), typeid(::std::vector<pat::EventHypothesis>), sizeof(::std::vector<pat::EventHypothesis>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2402, ::Reflex::BaseOffset< ::std::vector<pat::EventHypothesis>, ::std::_Vector_base<pat::EventHypothesis,std::allocator<pat::EventHypothesis> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7728, Reflex::Literal("std::vector<pat::EventHypothesis>::_Alloc_value_type"))
  .AddTypedef(type_2402, Reflex::Literal("std::vector<pat::EventHypothesis>::_Base"))
  .AddTypedef(type_3251, Reflex::Literal("std::vector<pat::EventHypothesis>::_Tp_alloc_type"))
  .AddTypedef(type_7162, Reflex::Literal("std::vector<pat::EventHypothesis>::_Alloc_traits"))
  .AddTypedef(type_7728, Reflex::Literal("std::vector<pat::EventHypothesis>::value_type"))
  .AddTypedef(type_8433, Reflex::Literal("std::vector<pat::EventHypothesis>::pointer"))
  .AddTypedef(type_13076, Reflex::Literal("std::vector<pat::EventHypothesis>::const_pointer"))
  .AddTypedef(type_13078, Reflex::Literal("std::vector<pat::EventHypothesis>::reference"))
  .AddTypedef(type_13080, Reflex::Literal("std::vector<pat::EventHypothesis>::const_reference"))
  .AddTypedef(type_6983, Reflex::Literal("std::vector<pat::EventHypothesis>::iterator"))
  .AddTypedef(type_6984, Reflex::Literal("std::vector<pat::EventHypothesis>::const_iterator"))
  .AddTypedef(type_3434, Reflex::Literal("std::vector<pat::EventHypothesis>::const_reverse_iterator"))
  .AddTypedef(type_3435, Reflex::Literal("std::vector<pat::EventHypothesis>::reverse_iterator"))
  .AddTypedef(type_3227, Reflex::Literal("std::vector<pat::EventHypothesis>::size_type"))
  .AddTypedef(type_3120, Reflex::Literal("std::vector<pat::EventHypothesis>::difference_type"))
  .AddTypedef(type_3251, Reflex::Literal("std::vector<pat::EventHypothesis>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13089, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30148), Reflex::Literal("vector"), constructor_13090, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3227, type_13080, type_30148), Reflex::Literal("vector"), constructor_13091, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31423), Reflex::Literal("vector"), constructor_13092, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13093, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2985, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__EventHypothesis__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::EventHypothesis,std::allocator<pat::EventHypothesis> > -------------------
void __std__vector_pat__EventHypothesis__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::EventHypothesis,std::allocator<pat::EventHypothesis> > -------------------
void __std__vector_pat__EventHypothesis__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31424, type_31423), Reflex::Literal("operator="), operator_13094, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_13080), Reflex::Literal("assign"), method_13095, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6983), Reflex::Literal("begin"), method_13096, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6984), Reflex::Literal("begin"), method_13097, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6983), Reflex::Literal("end"), method_13098, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6984), Reflex::Literal("end"), method_13099, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("size"), method_13104, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("max_size"), method_13105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_7728), Reflex::Literal("resize"), method_13106, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("capacity"), method_13107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("empty"), method_13108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227), Reflex::Literal("reserve"), method_13109, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13078, type_3227), Reflex::Literal("operator[]"), operator_13110, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13080, type_3227), Reflex::Literal("operator[]"), operator_13111, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13078, type_3227), Reflex::Literal("at"), method_13113, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13080, type_3227), Reflex::Literal("at"), method_13114, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13078), Reflex::Literal("front"), method_13115, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13080), Reflex::Literal("front"), method_13116, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13078), Reflex::Literal("back"), method_13117, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13080), Reflex::Literal("back"), method_13118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8433), Reflex::Literal("data"), method_13119, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13076), Reflex::Literal("data"), method_13120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_13080), Reflex::Literal("push_back"), method_13121, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("pop_back"), method_13122, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6983, type_6983, type_13080), Reflex::Literal("insert"), method_13123, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_6983, type_3227, type_13080), Reflex::Literal("insert"), method_13124, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6983, type_6983), Reflex::Literal("erase"), method_13125, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6983, type_6983, type_6983), Reflex::Literal("erase"), method_13126, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_31424), Reflex::Literal("swap"), method_13127, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("clear"), method_13128, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class VertexAssociation -------------------------------
static void destructor_29833(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::VertexAssociation*)o)->::pat::VertexAssociation::~VertexAssociation)();
}
static  void operator_29834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::VertexAssociation*)o)->operator=)(*(const ::pat::VertexAssociation*)arg[0]);
  else   (((::pat::VertexAssociation*)o)->operator=)(*(const ::pat::VertexAssociation*)arg[0]);
}

static void constructor_29835( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::VertexAssociation(*(const ::pat::VertexAssociation*)arg[0]);
  else ::new(mem) ::pat::VertexAssociation(*(const ::pat::VertexAssociation*)arg[0]);
}

static void constructor_29836( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::VertexAssociation();
  else ::new(mem) ::pat::VertexAssociation();
}

static void constructor_29837( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::VertexAssociation(*(const ::reco::VertexRef*)arg[0]);
  else ::new(mem) ::pat::VertexAssociation(*(const ::reco::VertexRef*)arg[0]);
}

static void constructor_29838( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::VertexAssociation(*(const ::reco::VertexRef*)arg[0],
      *(const ::reco::TrackBaseRef*)arg[1]);
  else ::new(mem) ::pat::VertexAssociation(*(const ::reco::VertexRef*)arg[0],
      *(const ::reco::TrackBaseRef*)arg[1]);
}

static  void method_29839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::VertexAssociation*)o)->isNull)());
  else   (((const ::pat::VertexAssociation*)o)->isNull)();
}

static  void method_29840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::VertexAssociation*)o)->isNonnull)());
  else   (((const ::pat::VertexAssociation*)o)->isNonnull)();
}

static  void method_29841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::VertexAssociation*)o)->isAvailable)());
  else   (((const ::pat::VertexAssociation*)o)->isAvailable)();
}

static  void operator_29842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::VertexAssociation*)o)->operator*)();
  else   (((const ::pat::VertexAssociation*)o)->operator*)();
}

static  void operator_29843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::VertexAssociation*)o)->operator->)());
  else   (((const ::pat::VertexAssociation*)o)->operator->)();
}

static  void method_29844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::VertexAssociation*)o)->vertexRef)();
  else   (((const ::pat::VertexAssociation*)o)->vertexRef)();
}

static  void method_29845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::VertexAssociation*)o)->vertex)());
  else   (((const ::pat::VertexAssociation*)o)->vertex)();
}

static  void method_29846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::VertexAssociation*)o)->hasTrack)());
  else   (((const ::pat::VertexAssociation*)o)->hasTrack)();
}

static  void method_29847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::VertexAssociation*)o)->trackRef)();
  else   (((const ::pat::VertexAssociation*)o)->trackRef)();
}

static  void method_29848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::VertexAssociation*)o)->track)());
  else   (((const ::pat::VertexAssociation*)o)->track)();
}

static  void method_29849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::VertexAssociation*)o)->dz)();
  else   (((const ::pat::VertexAssociation*)o)->dz)();
}

static  void method_29850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::VertexAssociation*)o)->dr)();
  else   (((const ::pat::VertexAssociation*)o)->dr)();
}

static  void method_29851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::VertexAssociation*)o)->hasTransverseIP)());
  else   (((const ::pat::VertexAssociation*)o)->hasTransverseIP)();
}

static  void method_29852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::VertexAssociation*)o)->hasErrors)());
  else   (((const ::pat::VertexAssociation*)o)->hasErrors)();
}

static  void method_29853( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::VertexAssociation*)o)->setDz)(*(const ::Measurement1DFloat*)arg[0]);
}

static  void method_29854( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::VertexAssociation*)o)->setDr)(*(const ::Measurement1DFloat*)arg[0]);
}

static  void method_29855( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::VertexAssociation*)o)->setDz)(*(const ::Measurement1D*)arg[0]);
}

static  void method_29856( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::VertexAssociation*)o)->setDr)(*(const ::Measurement1D*)arg[0]);
}

static  void method_29857( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::VertexAssociation*)o)->setDistances)(*(const ::AlgebraicVector3*)arg[0],
    *(const ::AlgebraicSymMatrix33*)arg[1]);
}

static void method_newdel_7720( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::VertexAssociation >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::VertexAssociation >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::VertexAssociation >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::VertexAssociation >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::VertexAssociation >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class VertexAssociation -------------------------------
void __pat__VertexAssociation_db_datamem(Reflex::Class*);
void __pat__VertexAssociation_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__VertexAssociation_datamem_bld(&__pat__VertexAssociation_db_datamem);
Reflex::GenreflexMemberBuilder __pat__VertexAssociation_funcmem_bld(&__pat__VertexAssociation_db_funcmem);
void __pat__VertexAssociation_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::VertexAssociation"), typeid(::pat::VertexAssociation), sizeof(::pat::VertexAssociation), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~VertexAssociation"), destructor_29833, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13143, type_13145), Reflex::Literal("operator="), operator_29834, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13145), Reflex::Literal("VertexAssociation"), constructor_29835, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("VertexAssociation"), constructor_29836, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_37151), Reflex::Literal("VertexAssociation"), constructor_29837, 0, "vertex", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_37151, type_36177), Reflex::Literal("VertexAssociation"), constructor_29838, 0, "vertex;tk", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7720, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__VertexAssociation_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__VertexAssociation_funcmem_bld);
}

//------Delayed data member builder for class VertexAssociation -------------------
void __pat__VertexAssociation_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6770, Reflex::Literal("vertex_"), OffsetOf(__shadow__::__pat__VertexAssociation, vertex_), ::Reflex::PRIVATE)
  .AddDataMember(type_1471, Reflex::Literal("dz_"), OffsetOf(__shadow__::__pat__VertexAssociation, dz_), ::Reflex::PRIVATE)
  .AddDataMember(type_1471, Reflex::Literal("dr_"), OffsetOf(__shadow__::__pat__VertexAssociation, dr_), ::Reflex::PRIVATE)
  .AddDataMember(type_6781, Reflex::Literal("track_"), OffsetOf(__shadow__::__pat__VertexAssociation, track_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class VertexAssociation -------------------
void __pat__VertexAssociation_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("isNull"), method_29839, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("isNonnull"), method_29840, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("isAvailable"), method_29841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13915), Reflex::Literal("operator*"), operator_29842, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13911), Reflex::Literal("operator->"), operator_29843, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37151), Reflex::Literal("vertexRef"), method_29844, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13911), Reflex::Literal("vertex"), method_29845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("hasTrack"), method_29846, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36177), Reflex::Literal("trackRef"), method_29847, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13465), Reflex::Literal("track"), method_29848, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24152), Reflex::Literal("dz"), method_29849, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24152), Reflex::Literal("dr"), method_29850, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("hasTransverseIP"), method_29851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("hasErrors"), method_29852, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_24152), Reflex::Literal("setDz"), method_29853, 0, "dz", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_24152), Reflex::Literal("setDr"), method_29854, 0, "dr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_30026), Reflex::Literal("setDz"), method_29855, 0, "dz", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_30026), Reflex::Literal("setDr"), method_29856, 0, "dr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_37152, type_37153), Reflex::Literal("setDistances"), method_29857, 0, "dist;err", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<pat::VertexAssociation,std::allocator<pat::VertexAssociation> > -------------------------------
static void constructor_13154( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::VertexAssociation>();
  else ::new(mem) ::std::vector<pat::VertexAssociation>();
}

static void constructor_13155( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::VertexAssociation>(*(const ::std::allocator<pat::VertexAssociation>*)arg[0]);
  else ::new(mem) ::std::vector<pat::VertexAssociation>(*(const ::std::allocator<pat::VertexAssociation>*)arg[0]);
}

static void constructor_13156( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::VertexAssociation>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::VertexAssociation>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::VertexAssociation>(*(::std::size_t*)arg[0],
      *(const ::pat::VertexAssociation*)arg[1]);
  else ::new(mem) ::std::vector<pat::VertexAssociation>(*(::std::size_t*)arg[0],
      *(const ::pat::VertexAssociation*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::VertexAssociation>(*(::std::size_t*)arg[0],
      *(const ::pat::VertexAssociation*)arg[1],
      *(const ::std::allocator<pat::VertexAssociation>*)arg[2]);
  else ::new(mem) ::std::vector<pat::VertexAssociation>(*(::std::size_t*)arg[0],
      *(const ::pat::VertexAssociation*)arg[1],
      *(const ::std::allocator<pat::VertexAssociation>*)arg[2]);
  }
}

static void constructor_13157( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::VertexAssociation>(*(const ::std::vector<pat::VertexAssociation>*)arg[0]);
  else ::new(mem) ::std::vector<pat::VertexAssociation>(*(const ::std::vector<pat::VertexAssociation>*)arg[0]);
}

static void destructor_13158(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::VertexAssociation>*)o)->::std::vector<pat::VertexAssociation>::~vector)();
}
static  void operator_13159( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::VertexAssociation>*)o)->operator=)(*(const ::std::vector<pat::VertexAssociation>*)arg[0]);
  else   (((::std::vector<pat::VertexAssociation>*)o)->operator=)(*(const ::std::vector<pat::VertexAssociation>*)arg[0]);
}

static  void method_13160( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::VertexAssociation>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::VertexAssociation*)arg[1]);
}

static  void method_13161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> >)((((::std::vector<pat::VertexAssociation>*)o)->begin)());
  else   (((::std::vector<pat::VertexAssociation>*)o)->begin)();
}

static  void method_13162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::VertexAssociation*,std::vector<pat::VertexAssociation> >)((((const ::std::vector<pat::VertexAssociation>*)o)->begin)());
  else   (((const ::std::vector<pat::VertexAssociation>*)o)->begin)();
}

static  void method_13163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> >)((((::std::vector<pat::VertexAssociation>*)o)->end)());
  else   (((::std::vector<pat::VertexAssociation>*)o)->end)();
}

static  void method_13164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::VertexAssociation*,std::vector<pat::VertexAssociation> >)((((const ::std::vector<pat::VertexAssociation>*)o)->end)());
  else   (((const ::std::vector<pat::VertexAssociation>*)o)->end)();
}

static  void method_13169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::VertexAssociation>*)o)->size)());
  else   (((const ::std::vector<pat::VertexAssociation>*)o)->size)();
}

static  void method_13170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::VertexAssociation>*)o)->max_size)());
  else   (((const ::std::vector<pat::VertexAssociation>*)o)->max_size)();
}

static  void method_13171( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::VertexAssociation>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::VertexAssociation>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::VertexAssociation*)arg[1]);
  }
}

static  void method_13172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::VertexAssociation>*)o)->capacity)());
  else   (((const ::std::vector<pat::VertexAssociation>*)o)->capacity)();
}

static  void method_13173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::VertexAssociation>*)o)->empty)());
  else   (((const ::std::vector<pat::VertexAssociation>*)o)->empty)();
}

static  void method_13174( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::VertexAssociation>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13175( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::VertexAssociation>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::VertexAssociation>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13176( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::VertexAssociation>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::VertexAssociation>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::VertexAssociation>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::VertexAssociation>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::VertexAssociation>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::VertexAssociation>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::VertexAssociation>*)o)->front)();
  else   (((::std::vector<pat::VertexAssociation>*)o)->front)();
}

static  void method_13181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::VertexAssociation>*)o)->front)();
  else   (((const ::std::vector<pat::VertexAssociation>*)o)->front)();
}

static  void method_13182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::VertexAssociation>*)o)->back)();
  else   (((::std::vector<pat::VertexAssociation>*)o)->back)();
}

static  void method_13183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::VertexAssociation>*)o)->back)();
  else   (((const ::std::vector<pat::VertexAssociation>*)o)->back)();
}

static  void method_13184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::VertexAssociation>*)o)->data)());
  else   (((::std::vector<pat::VertexAssociation>*)o)->data)();
}

static  void method_13185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::VertexAssociation>*)o)->data)());
  else   (((const ::std::vector<pat::VertexAssociation>*)o)->data)();
}

static  void method_13186( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::VertexAssociation>*)o)->push_back)(*(const ::pat::VertexAssociation*)arg[0]);
}

static  void method_13187( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::VertexAssociation>*)o)->pop_back)();
}

static  void method_13188( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> >)((((::std::vector<pat::VertexAssociation>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> >*)arg[0],
    *(const ::pat::VertexAssociation*)arg[1]));
  else   (((::std::vector<pat::VertexAssociation>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> >*)arg[0],
    *(const ::pat::VertexAssociation*)arg[1]);
}

static  void method_13189( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::VertexAssociation>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::VertexAssociation*)arg[2]);
}

static  void method_13190( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> >)((((::std::vector<pat::VertexAssociation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> >*)arg[0]));
  else   (((::std::vector<pat::VertexAssociation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> >*)arg[0]);
}

static  void method_13191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> >)((((::std::vector<pat::VertexAssociation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> >*)arg[1]));
  else   (((::std::vector<pat::VertexAssociation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::VertexAssociation*,std::vector<pat::VertexAssociation> >*)arg[1]);
}

static  void method_13192( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::VertexAssociation>*)o)->swap)(*(::std::vector<pat::VertexAssociation>*)arg[0]);
}

static  void method_13193( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::VertexAssociation>*)o)->clear)();
}

static void method_newdel_2986( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::VertexAssociation> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::VertexAssociation> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::VertexAssociation> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::VertexAssociation> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::VertexAssociation> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::VertexAssociation,std::allocator<pat::VertexAssociation> >")), ::Reflex::BaseOffset< ::std::vector<pat::VertexAssociation>,::std::_Vector_base<pat::VertexAssociation,std::allocator<pat::VertexAssociation> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::VertexAssociation> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::VertexAssociation> >::Generate();
}

//------Dictionary for class vector<pat::VertexAssociation,std::allocator<pat::VertexAssociation> > -------------------------------
void __std__vector_pat__VertexAssociation__db_datamem(Reflex::Class*);
void __std__vector_pat__VertexAssociation__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__VertexAssociation__datamem_bld(&__std__vector_pat__VertexAssociation__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__VertexAssociation__funcmem_bld(&__std__vector_pat__VertexAssociation__db_funcmem);
void __std__vector_pat__VertexAssociation__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::VertexAssociation>"), typeid(::std::vector<pat::VertexAssociation>), sizeof(::std::vector<pat::VertexAssociation>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2403, ::Reflex::BaseOffset< ::std::vector<pat::VertexAssociation>, ::std::_Vector_base<pat::VertexAssociation,std::allocator<pat::VertexAssociation> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7720, Reflex::Literal("std::vector<pat::VertexAssociation>::_Alloc_value_type"))
  .AddTypedef(type_2403, Reflex::Literal("std::vector<pat::VertexAssociation>::_Base"))
  .AddTypedef(type_3252, Reflex::Literal("std::vector<pat::VertexAssociation>::_Tp_alloc_type"))
  .AddTypedef(type_7163, Reflex::Literal("std::vector<pat::VertexAssociation>::_Alloc_traits"))
  .AddTypedef(type_7720, Reflex::Literal("std::vector<pat::VertexAssociation>::value_type"))
  .AddTypedef(type_8452, Reflex::Literal("std::vector<pat::VertexAssociation>::pointer"))
  .AddTypedef(type_13141, Reflex::Literal("std::vector<pat::VertexAssociation>::const_pointer"))
  .AddTypedef(type_13143, Reflex::Literal("std::vector<pat::VertexAssociation>::reference"))
  .AddTypedef(type_13145, Reflex::Literal("std::vector<pat::VertexAssociation>::const_reference"))
  .AddTypedef(type_6985, Reflex::Literal("std::vector<pat::VertexAssociation>::iterator"))
  .AddTypedef(type_6986, Reflex::Literal("std::vector<pat::VertexAssociation>::const_iterator"))
  .AddTypedef(type_3436, Reflex::Literal("std::vector<pat::VertexAssociation>::const_reverse_iterator"))
  .AddTypedef(type_3437, Reflex::Literal("std::vector<pat::VertexAssociation>::reverse_iterator"))
  .AddTypedef(type_3227, Reflex::Literal("std::vector<pat::VertexAssociation>::size_type"))
  .AddTypedef(type_3120, Reflex::Literal("std::vector<pat::VertexAssociation>::difference_type"))
  .AddTypedef(type_3252, Reflex::Literal("std::vector<pat::VertexAssociation>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13154, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30161), Reflex::Literal("vector"), constructor_13155, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3227, type_13145, type_30161), Reflex::Literal("vector"), constructor_13156, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31426), Reflex::Literal("vector"), constructor_13157, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13158, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2986, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__VertexAssociation__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::VertexAssociation,std::allocator<pat::VertexAssociation> > -------------------
void __std__vector_pat__VertexAssociation__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::VertexAssociation,std::allocator<pat::VertexAssociation> > -------------------
void __std__vector_pat__VertexAssociation__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31427, type_31426), Reflex::Literal("operator="), operator_13159, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_13145), Reflex::Literal("assign"), method_13160, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6985), Reflex::Literal("begin"), method_13161, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6986), Reflex::Literal("begin"), method_13162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6985), Reflex::Literal("end"), method_13163, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6986), Reflex::Literal("end"), method_13164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("size"), method_13169, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("max_size"), method_13170, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_7720), Reflex::Literal("resize"), method_13171, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("capacity"), method_13172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("empty"), method_13173, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227), Reflex::Literal("reserve"), method_13174, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13143, type_3227), Reflex::Literal("operator[]"), operator_13175, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13145, type_3227), Reflex::Literal("operator[]"), operator_13176, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13143, type_3227), Reflex::Literal("at"), method_13178, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13145, type_3227), Reflex::Literal("at"), method_13179, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13143), Reflex::Literal("front"), method_13180, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13145), Reflex::Literal("front"), method_13181, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13143), Reflex::Literal("back"), method_13182, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13145), Reflex::Literal("back"), method_13183, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8452), Reflex::Literal("data"), method_13184, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13141), Reflex::Literal("data"), method_13185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_13145), Reflex::Literal("push_back"), method_13186, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("pop_back"), method_13187, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6985, type_6985, type_13145), Reflex::Literal("insert"), method_13188, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_6985, type_3227, type_13145), Reflex::Literal("insert"), method_13189, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6985, type_6985), Reflex::Literal("erase"), method_13190, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6985, type_6985, type_6985), Reflex::Literal("erase"), method_13191, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_31427), Reflex::Literal("swap"), method_13192, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("clear"), method_13193, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class TauJetCorrFactors -------------------------------
static void destructor_29938(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::TauJetCorrFactors*)o)->::pat::TauJetCorrFactors::~TauJetCorrFactors)();
}
static  void operator_29939( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::TauJetCorrFactors*)o)->operator=)(*(const ::pat::TauJetCorrFactors*)arg[0]);
  else   (((::pat::TauJetCorrFactors*)o)->operator=)(*(const ::pat::TauJetCorrFactors*)arg[0]);
}

static void constructor_29940( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TauJetCorrFactors(*(const ::pat::TauJetCorrFactors*)arg[0]);
  else ::new(mem) ::pat::TauJetCorrFactors(*(const ::pat::TauJetCorrFactors*)arg[0]);
}

static void constructor_29941( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TauJetCorrFactors();
  else ::new(mem) ::pat::TauJetCorrFactors();
}

static void constructor_29942( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TauJetCorrFactors(*(const ::std::string*)arg[0],
      *(const ::std::vector<std::pair<std::basic_string<char>,float> >*)arg[1]);
  else ::new(mem) ::pat::TauJetCorrFactors(*(const ::std::string*)arg[0],
      *(const ::std::vector<std::pair<std::basic_string<char>,float> >*)arg[1]);
}

static  void method_29943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::pat::TauJetCorrFactors*)o)->jecSet)());
  else   (((const ::pat::TauJetCorrFactors*)o)->jecSet)();
}

static  void method_29944( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::pat::TauJetCorrFactors*)o)->jecLevel)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::TauJetCorrFactors*)o)->jecLevel)(*(const unsigned int*)arg[0]);
}

static  void method_29945( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::TauJetCorrFactors*)o)->jecLevel)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TauJetCorrFactors*)o)->jecLevel)(*(const ::std::string*)arg[0]);
}

static  void method_29946( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::TauJetCorrFactors*)o)->correction)(*(unsigned int*)arg[0]));
  else   (((const ::pat::TauJetCorrFactors*)o)->correction)(*(unsigned int*)arg[0]);
}

static  void method_29947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::pat::TauJetCorrFactors*)o)->correctionLabelString)());
  else   (((const ::pat::TauJetCorrFactors*)o)->correctionLabelString)();
}

static  void method_29948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::TauJetCorrFactors*)o)->correctionLabels)());
  else   (((const ::pat::TauJetCorrFactors*)o)->correctionLabels)();
}

static  void method_29949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::pat::TauJetCorrFactors*)o)->correctionLabel)(*(unsigned int*)arg[0]));
  else   (((const ::pat::TauJetCorrFactors*)o)->correctionLabel)(*(unsigned int*)arg[0]);
}

static  void method_29950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::pat::TauJetCorrFactors*)o)->numberOfCorrectionLevels)());
  else   (((const ::pat::TauJetCorrFactors*)o)->numberOfCorrectionLevels)();
}

static  void method_29951( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::pat::TauJetCorrFactors*)o)->print)();
}

static void method_newdel_7727( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::TauJetCorrFactors >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::TauJetCorrFactors >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::TauJetCorrFactors >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::TauJetCorrFactors >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::TauJetCorrFactors >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TauJetCorrFactors -------------------------------
void __pat__TauJetCorrFactors_db_datamem(Reflex::Class*);
void __pat__TauJetCorrFactors_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__TauJetCorrFactors_datamem_bld(&__pat__TauJetCorrFactors_db_datamem);
Reflex::GenreflexMemberBuilder __pat__TauJetCorrFactors_funcmem_bld(&__pat__TauJetCorrFactors_db_funcmem);
void __pat__TauJetCorrFactors_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::TauJetCorrFactors"), typeid(::pat::TauJetCorrFactors), sizeof(::pat::TauJetCorrFactors), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2957, Reflex::Literal("pat::TauJetCorrFactors::CorrectionFactor"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TauJetCorrFactors"), destructor_29938, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13208, type_13210), Reflex::Literal("operator="), operator_29939, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13210), Reflex::Literal("TauJetCorrFactors"), constructor_29940, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TauJetCorrFactors"), constructor_29941, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16419, type_31514), Reflex::Literal("TauJetCorrFactors"), constructor_29942, 0, "label;jec", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7727, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__TauJetCorrFactors_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__TauJetCorrFactors_funcmem_bld);
}

//------Delayed data member builder for class TauJetCorrFactors -------------------
void __pat__TauJetCorrFactors_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2460, Reflex::Literal("label_"), OffsetOf(__shadow__::__pat__TauJetCorrFactors, label_), ::Reflex::PRIVATE)
  .AddDataMember(type_3021, Reflex::Literal("jec_"), OffsetOf(__shadow__::__pat__TauJetCorrFactors, jec_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TauJetCorrFactors -------------------
void __pat__TauJetCorrFactors_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2460), Reflex::Literal("jecSet"), method_29943, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2460, type_9586), Reflex::Literal("jecLevel"), method_29944, 0, "level", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_64, type_16419), Reflex::Literal("jecLevel"), method_29945, 0, "level", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859, type_200), Reflex::Literal("correction"), method_29946, 0, "level", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2460), Reflex::Literal("correctionLabelString"), method_29947, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3020), Reflex::Literal("correctionLabels"), method_29948, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2460, type_200), Reflex::Literal("correctionLabel"), method_29949, 0, "level", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_200), Reflex::Literal("numberOfCorrectionLevels"), method_29950, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("print"), method_29951, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<pat::TauJetCorrFactors,std::allocator<pat::TauJetCorrFactors> > -------------------------------
static void constructor_13219( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TauJetCorrFactors>();
  else ::new(mem) ::std::vector<pat::TauJetCorrFactors>();
}

static void constructor_13220( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TauJetCorrFactors>(*(const ::std::allocator<pat::TauJetCorrFactors>*)arg[0]);
  else ::new(mem) ::std::vector<pat::TauJetCorrFactors>(*(const ::std::allocator<pat::TauJetCorrFactors>*)arg[0]);
}

static void constructor_13221( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TauJetCorrFactors>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::TauJetCorrFactors>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TauJetCorrFactors>(*(::std::size_t*)arg[0],
      *(const ::pat::TauJetCorrFactors*)arg[1]);
  else ::new(mem) ::std::vector<pat::TauJetCorrFactors>(*(::std::size_t*)arg[0],
      *(const ::pat::TauJetCorrFactors*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TauJetCorrFactors>(*(::std::size_t*)arg[0],
      *(const ::pat::TauJetCorrFactors*)arg[1],
      *(const ::std::allocator<pat::TauJetCorrFactors>*)arg[2]);
  else ::new(mem) ::std::vector<pat::TauJetCorrFactors>(*(::std::size_t*)arg[0],
      *(const ::pat::TauJetCorrFactors*)arg[1],
      *(const ::std::allocator<pat::TauJetCorrFactors>*)arg[2]);
  }
}

static void constructor_13222( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TauJetCorrFactors>(*(const ::std::vector<pat::TauJetCorrFactors>*)arg[0]);
  else ::new(mem) ::std::vector<pat::TauJetCorrFactors>(*(const ::std::vector<pat::TauJetCorrFactors>*)arg[0]);
}

static void destructor_13223(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::TauJetCorrFactors>*)o)->::std::vector<pat::TauJetCorrFactors>::~vector)();
}
static  void operator_13224( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TauJetCorrFactors>*)o)->operator=)(*(const ::std::vector<pat::TauJetCorrFactors>*)arg[0]);
  else   (((::std::vector<pat::TauJetCorrFactors>*)o)->operator=)(*(const ::std::vector<pat::TauJetCorrFactors>*)arg[0]);
}

static  void method_13225( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TauJetCorrFactors>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::TauJetCorrFactors*)arg[1]);
}

static  void method_13226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >)((((::std::vector<pat::TauJetCorrFactors>*)o)->begin)());
  else   (((::std::vector<pat::TauJetCorrFactors>*)o)->begin)();
}

static  void method_13227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >)((((const ::std::vector<pat::TauJetCorrFactors>*)o)->begin)());
  else   (((const ::std::vector<pat::TauJetCorrFactors>*)o)->begin)();
}

static  void method_13228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >)((((::std::vector<pat::TauJetCorrFactors>*)o)->end)());
  else   (((::std::vector<pat::TauJetCorrFactors>*)o)->end)();
}

static  void method_13229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >)((((const ::std::vector<pat::TauJetCorrFactors>*)o)->end)());
  else   (((const ::std::vector<pat::TauJetCorrFactors>*)o)->end)();
}

static  void method_13234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TauJetCorrFactors>*)o)->size)());
  else   (((const ::std::vector<pat::TauJetCorrFactors>*)o)->size)();
}

static  void method_13235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TauJetCorrFactors>*)o)->max_size)());
  else   (((const ::std::vector<pat::TauJetCorrFactors>*)o)->max_size)();
}

static  void method_13236( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::TauJetCorrFactors>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::TauJetCorrFactors>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::TauJetCorrFactors*)arg[1]);
  }
}

static  void method_13237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TauJetCorrFactors>*)o)->capacity)());
  else   (((const ::std::vector<pat::TauJetCorrFactors>*)o)->capacity)();
}

static  void method_13238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::TauJetCorrFactors>*)o)->empty)());
  else   (((const ::std::vector<pat::TauJetCorrFactors>*)o)->empty)();
}

static  void method_13239( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TauJetCorrFactors>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13240( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TauJetCorrFactors>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::TauJetCorrFactors>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13241( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TauJetCorrFactors>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::TauJetCorrFactors>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13243( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TauJetCorrFactors>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::TauJetCorrFactors>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13244( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TauJetCorrFactors>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::TauJetCorrFactors>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TauJetCorrFactors>*)o)->front)();
  else   (((::std::vector<pat::TauJetCorrFactors>*)o)->front)();
}

static  void method_13246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TauJetCorrFactors>*)o)->front)();
  else   (((const ::std::vector<pat::TauJetCorrFactors>*)o)->front)();
}

static  void method_13247( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TauJetCorrFactors>*)o)->back)();
  else   (((::std::vector<pat::TauJetCorrFactors>*)o)->back)();
}

static  void method_13248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TauJetCorrFactors>*)o)->back)();
  else   (((const ::std::vector<pat::TauJetCorrFactors>*)o)->back)();
}

static  void method_13249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::TauJetCorrFactors>*)o)->data)());
  else   (((::std::vector<pat::TauJetCorrFactors>*)o)->data)();
}

static  void method_13250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::TauJetCorrFactors>*)o)->data)());
  else   (((const ::std::vector<pat::TauJetCorrFactors>*)o)->data)();
}

static  void method_13251( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TauJetCorrFactors>*)o)->push_back)(*(const ::pat::TauJetCorrFactors*)arg[0]);
}

static  void method_13252( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::TauJetCorrFactors>*)o)->pop_back)();
}

static  void method_13253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >)((((::std::vector<pat::TauJetCorrFactors>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >*)arg[0],
    *(const ::pat::TauJetCorrFactors*)arg[1]));
  else   (((::std::vector<pat::TauJetCorrFactors>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >*)arg[0],
    *(const ::pat::TauJetCorrFactors*)arg[1]);
}

static  void method_13254( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TauJetCorrFactors>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::TauJetCorrFactors*)arg[2]);
}

static  void method_13255( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >)((((::std::vector<pat::TauJetCorrFactors>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >*)arg[0]));
  else   (((::std::vector<pat::TauJetCorrFactors>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >*)arg[0]);
}

static  void method_13256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >)((((::std::vector<pat::TauJetCorrFactors>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >*)arg[1]));
  else   (((::std::vector<pat::TauJetCorrFactors>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::TauJetCorrFactors*,std::vector<pat::TauJetCorrFactors> >*)arg[1]);
}

static  void method_13257( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TauJetCorrFactors>*)o)->swap)(*(::std::vector<pat::TauJetCorrFactors>*)arg[0]);
}

static  void method_13258( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::TauJetCorrFactors>*)o)->clear)();
}

static void method_newdel_2987( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TauJetCorrFactors> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TauJetCorrFactors> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TauJetCorrFactors> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TauJetCorrFactors> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TauJetCorrFactors> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::TauJetCorrFactors,std::allocator<pat::TauJetCorrFactors> >")), ::Reflex::BaseOffset< ::std::vector<pat::TauJetCorrFactors>,::std::_Vector_base<pat::TauJetCorrFactors,std::allocator<pat::TauJetCorrFactors> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x25( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::TauJetCorrFactors> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::TauJetCorrFactors> >::Generate();
}

//------Dictionary for class vector<pat::TauJetCorrFactors,std::allocator<pat::TauJetCorrFactors> > -------------------------------
void __std__vector_pat__TauJetCorrFactors__db_datamem(Reflex::Class*);
void __std__vector_pat__TauJetCorrFactors__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__TauJetCorrFactors__datamem_bld(&__std__vector_pat__TauJetCorrFactors__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__TauJetCorrFactors__funcmem_bld(&__std__vector_pat__TauJetCorrFactors__db_funcmem);
void __std__vector_pat__TauJetCorrFactors__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::TauJetCorrFactors>"), typeid(::std::vector<pat::TauJetCorrFactors>), sizeof(::std::vector<pat::TauJetCorrFactors>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2404, ::Reflex::BaseOffset< ::std::vector<pat::TauJetCorrFactors>, ::std::_Vector_base<pat::TauJetCorrFactors,std::allocator<pat::TauJetCorrFactors> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7727, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::_Alloc_value_type"))
  .AddTypedef(type_2404, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::_Base"))
  .AddTypedef(type_3253, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::_Tp_alloc_type"))
  .AddTypedef(type_7164, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::_Alloc_traits"))
  .AddTypedef(type_7727, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::value_type"))
  .AddTypedef(type_8471, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::pointer"))
  .AddTypedef(type_13206, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::const_pointer"))
  .AddTypedef(type_13208, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::reference"))
  .AddTypedef(type_13210, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::const_reference"))
  .AddTypedef(type_6987, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::iterator"))
  .AddTypedef(type_6988, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::const_iterator"))
  .AddTypedef(type_3438, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::const_reverse_iterator"))
  .AddTypedef(type_3439, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::reverse_iterator"))
  .AddTypedef(type_3227, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::size_type"))
  .AddTypedef(type_3120, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::difference_type"))
  .AddTypedef(type_3253, Reflex::Literal("std::vector<pat::TauJetCorrFactors>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13219, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30174), Reflex::Literal("vector"), constructor_13220, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3227, type_13210, type_30174), Reflex::Literal("vector"), constructor_13221, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31429), Reflex::Literal("vector"), constructor_13222, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13223, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2987, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x25, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__TauJetCorrFactors__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::TauJetCorrFactors,std::allocator<pat::TauJetCorrFactors> > -------------------
void __std__vector_pat__TauJetCorrFactors__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::TauJetCorrFactors,std::allocator<pat::TauJetCorrFactors> > -------------------
void __std__vector_pat__TauJetCorrFactors__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31430, type_31429), Reflex::Literal("operator="), operator_13224, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_13210), Reflex::Literal("assign"), method_13225, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6987), Reflex::Literal("begin"), method_13226, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6988), Reflex::Literal("begin"), method_13227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6987), Reflex::Literal("end"), method_13228, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6988), Reflex::Literal("end"), method_13229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("size"), method_13234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("max_size"), method_13235, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_7727), Reflex::Literal("resize"), method_13236, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("capacity"), method_13237, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("empty"), method_13238, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227), Reflex::Literal("reserve"), method_13239, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13208, type_3227), Reflex::Literal("operator[]"), operator_13240, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13210, type_3227), Reflex::Literal("operator[]"), operator_13241, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13208, type_3227), Reflex::Literal("at"), method_13243, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13210, type_3227), Reflex::Literal("at"), method_13244, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13208), Reflex::Literal("front"), method_13245, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13210), Reflex::Literal("front"), method_13246, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13208), Reflex::Literal("back"), method_13247, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13210), Reflex::Literal("back"), method_13248, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8471), Reflex::Literal("data"), method_13249, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13206), Reflex::Literal("data"), method_13250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_13210), Reflex::Literal("push_back"), method_13251, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("pop_back"), method_13252, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6987, type_6987, type_13210), Reflex::Literal("insert"), method_13253, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_6987, type_3227, type_13210), Reflex::Literal("insert"), method_13254, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6987, type_6987), Reflex::Literal("erase"), method_13255, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6987, type_6987, type_6987), Reflex::Literal("erase"), method_13256, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_31430), Reflex::Literal("swap"), method_13257, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("clear"), method_13258, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class JetCorrFactors -------------------------------
static void destructor_29895(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::JetCorrFactors*)o)->::pat::JetCorrFactors::~JetCorrFactors)();
}
static  void operator_29896( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::JetCorrFactors*)o)->operator=)(*(const ::pat::JetCorrFactors*)arg[0]);
  else   (((::pat::JetCorrFactors*)o)->operator=)(*(const ::pat::JetCorrFactors*)arg[0]);
}

static void constructor_29897( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::JetCorrFactors(*(const ::pat::JetCorrFactors*)arg[0]);
  else ::new(mem) ::pat::JetCorrFactors(*(const ::pat::JetCorrFactors*)arg[0]);
}

static void constructor_29898( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::JetCorrFactors();
  else ::new(mem) ::pat::JetCorrFactors();
}

static void constructor_29899( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::JetCorrFactors(*(const ::std::string*)arg[0],
      *(const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)arg[1]);
  else ::new(mem) ::pat::JetCorrFactors(*(const ::std::string*)arg[0],
      *(const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)arg[1]);
}

static  void method_29900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::pat::JetCorrFactors*)o)->jecSet)());
  else   (((const ::pat::JetCorrFactors*)o)->jecSet)();
}

static  void method_29901( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::pat::JetCorrFactors*)o)->jecLevel)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::JetCorrFactors*)o)->jecLevel)(*(const unsigned int*)arg[0]);
}

static  void method_29902( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::JetCorrFactors*)o)->jecLevel)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::JetCorrFactors*)o)->jecLevel)(*(const ::std::string*)arg[0]);
}

static  void method_29903( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::pat::JetCorrFactors*)o)->jecFlavor)(*(const ::pat::JetCorrFactors::Flavor*)arg[0]));
  else   (((const ::pat::JetCorrFactors*)o)->jecFlavor)(*(const ::pat::JetCorrFactors::Flavor*)arg[0]);
}

static  void method_29904( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::JetCorrFactors*)o)->jecFlavor)(*(::std::string*)arg[0]));
  else   (((const ::pat::JetCorrFactors*)o)->jecFlavor)(*(::std::string*)arg[0]);
}

static  void method_29905( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (float)((((const ::pat::JetCorrFactors*)o)->correction)(*(unsigned int*)arg[0]));
    else     (((const ::pat::JetCorrFactors*)o)->correction)(*(unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::JetCorrFactors*)o)->correction)(*(unsigned int*)arg[0],
      *(::pat::JetCorrFactors::Flavor*)arg[1]));
    else     (((const ::pat::JetCorrFactors*)o)->correction)(*(unsigned int*)arg[0],
      *(::pat::JetCorrFactors::Flavor*)arg[1]);
  }
}

static  void method_29906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::pat::JetCorrFactors*)o)->correctionLabelString)());
  else   (((const ::pat::JetCorrFactors*)o)->correctionLabelString)();
}

static  void method_29907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::JetCorrFactors*)o)->correctionLabels)());
  else   (((const ::pat::JetCorrFactors*)o)->correctionLabels)();
}

static  void method_29908( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::pat::JetCorrFactors*)o)->correctionLabel)(*(unsigned int*)arg[0]));
  else   (((const ::pat::JetCorrFactors*)o)->correctionLabel)(*(unsigned int*)arg[0]);
}

static  void method_29909( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::JetCorrFactors*)o)->flavorDependent)(*(unsigned int*)arg[0]));
  else   (((const ::pat::JetCorrFactors*)o)->flavorDependent)(*(unsigned int*)arg[0]);
}

static  void method_29910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::pat::JetCorrFactors*)o)->numberOfCorrectionLevels)());
  else   (((const ::pat::JetCorrFactors*)o)->numberOfCorrectionLevels)();
}

static  void method_29911( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::pat::JetCorrFactors*)o)->print)();
}

static void method_newdel_7722( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::JetCorrFactors >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::JetCorrFactors >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::JetCorrFactors >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::JetCorrFactors >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::JetCorrFactors >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class JetCorrFactors -------------------------------
void __pat__JetCorrFactors_db_datamem(Reflex::Class*);
void __pat__JetCorrFactors_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__JetCorrFactors_datamem_bld(&__pat__JetCorrFactors_db_datamem);
Reflex::GenreflexMemberBuilder __pat__JetCorrFactors_funcmem_bld(&__pat__JetCorrFactors_db_funcmem);
void __pat__JetCorrFactors_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::JetCorrFactors"), typeid(::pat::JetCorrFactors), sizeof(::pat::JetCorrFactors), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddTypedef(type_2916, Reflex::Literal("pat::JetCorrFactors::CorrectionFactor"))
  .AddEnum(Reflex::Literal("pat::JetCorrFactors::Flavor"), Reflex::Literal("GLUON=0;UDS=1;CHARM=2;BOTTOM=3;NONE=4"), &typeid(pat::JetCorrFactors::Flavor), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~JetCorrFactors"), destructor_29895, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13273, type_13275), Reflex::Literal("operator="), operator_29896, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13275), Reflex::Literal("JetCorrFactors"), constructor_29897, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("JetCorrFactors"), constructor_29898, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16419, type_31435), Reflex::Literal("JetCorrFactors"), constructor_29899, 0, "label;jec", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7722, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__JetCorrFactors_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__JetCorrFactors_funcmem_bld);
}

//------Delayed data member builder for class JetCorrFactors -------------------
void __pat__JetCorrFactors_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2460, Reflex::Literal("label_"), OffsetOf(__shadow__::__pat__JetCorrFactors, label_), ::Reflex::PRIVATE)
  .AddDataMember(type_2989, Reflex::Literal("jec_"), OffsetOf(__shadow__::__pat__JetCorrFactors, jec_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class JetCorrFactors -------------------
void __pat__JetCorrFactors_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2460), Reflex::Literal("jecSet"), method_29900, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2460, type_9586), Reflex::Literal("jecLevel"), method_29901, 0, "level", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_64, type_16419), Reflex::Literal("jecLevel"), method_29902, 0, "level", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2460, type_37155), Reflex::Literal("jecFlavor"), method_29903, 0, "flavor", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29894, type_2460), Reflex::Literal("jecFlavor"), method_29904, 0, "flavor", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859, type_200, type_29894), Reflex::Literal("correction"), method_29905, 0, "level;flavor=NONE", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2460), Reflex::Literal("correctionLabelString"), method_29906, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3020), Reflex::Literal("correctionLabels"), method_29907, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2460, type_200), Reflex::Literal("correctionLabel"), method_29908, 0, "level", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534, type_200), Reflex::Literal("flavorDependent"), method_29909, 0, "level", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_200), Reflex::Literal("numberOfCorrectionLevels"), method_29910, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("print"), method_29911, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<pat::JetCorrFactors,std::allocator<pat::JetCorrFactors> > -------------------------------
static void constructor_13284( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::JetCorrFactors>();
  else ::new(mem) ::std::vector<pat::JetCorrFactors>();
}

static void constructor_13285( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::JetCorrFactors>(*(const ::std::allocator<pat::JetCorrFactors>*)arg[0]);
  else ::new(mem) ::std::vector<pat::JetCorrFactors>(*(const ::std::allocator<pat::JetCorrFactors>*)arg[0]);
}

static void constructor_13286( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::JetCorrFactors>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::JetCorrFactors>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::JetCorrFactors>(*(::std::size_t*)arg[0],
      *(const ::pat::JetCorrFactors*)arg[1]);
  else ::new(mem) ::std::vector<pat::JetCorrFactors>(*(::std::size_t*)arg[0],
      *(const ::pat::JetCorrFactors*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::JetCorrFactors>(*(::std::size_t*)arg[0],
      *(const ::pat::JetCorrFactors*)arg[1],
      *(const ::std::allocator<pat::JetCorrFactors>*)arg[2]);
  else ::new(mem) ::std::vector<pat::JetCorrFactors>(*(::std::size_t*)arg[0],
      *(const ::pat::JetCorrFactors*)arg[1],
      *(const ::std::allocator<pat::JetCorrFactors>*)arg[2]);
  }
}

static void constructor_13287( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::JetCorrFactors>(*(const ::std::vector<pat::JetCorrFactors>*)arg[0]);
  else ::new(mem) ::std::vector<pat::JetCorrFactors>(*(const ::std::vector<pat::JetCorrFactors>*)arg[0]);
}

static void destructor_13288(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::JetCorrFactors>*)o)->::std::vector<pat::JetCorrFactors>::~vector)();
}
static  void operator_13289( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::JetCorrFactors>*)o)->operator=)(*(const ::std::vector<pat::JetCorrFactors>*)arg[0]);
  else   (((::std::vector<pat::JetCorrFactors>*)o)->operator=)(*(const ::std::vector<pat::JetCorrFactors>*)arg[0]);
}

static  void method_13290( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::JetCorrFactors>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::JetCorrFactors*)arg[1]);
}

static  void method_13291( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >)((((::std::vector<pat::JetCorrFactors>*)o)->begin)());
  else   (((::std::vector<pat::JetCorrFactors>*)o)->begin)();
}

static  void method_13292( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >)((((const ::std::vector<pat::JetCorrFactors>*)o)->begin)());
  else   (((const ::std::vector<pat::JetCorrFactors>*)o)->begin)();
}

static  void method_13293( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >)((((::std::vector<pat::JetCorrFactors>*)o)->end)());
  else   (((::std::vector<pat::JetCorrFactors>*)o)->end)();
}

static  void method_13294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >)((((const ::std::vector<pat::JetCorrFactors>*)o)->end)());
  else   (((const ::std::vector<pat::JetCorrFactors>*)o)->end)();
}

static  void method_13299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::JetCorrFactors>*)o)->size)());
  else   (((const ::std::vector<pat::JetCorrFactors>*)o)->size)();
}

static  void method_13300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::JetCorrFactors>*)o)->max_size)());
  else   (((const ::std::vector<pat::JetCorrFactors>*)o)->max_size)();
}

static  void method_13301( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::JetCorrFactors>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::JetCorrFactors>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::JetCorrFactors*)arg[1]);
  }
}

static  void method_13302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::JetCorrFactors>*)o)->capacity)());
  else   (((const ::std::vector<pat::JetCorrFactors>*)o)->capacity)();
}

static  void method_13303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::JetCorrFactors>*)o)->empty)());
  else   (((const ::std::vector<pat::JetCorrFactors>*)o)->empty)();
}

static  void method_13304( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::JetCorrFactors>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13305( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::JetCorrFactors>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::JetCorrFactors>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13306( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::JetCorrFactors>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::JetCorrFactors>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13308( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::JetCorrFactors>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::JetCorrFactors>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13309( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::JetCorrFactors>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::JetCorrFactors>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::JetCorrFactors>*)o)->front)();
  else   (((::std::vector<pat::JetCorrFactors>*)o)->front)();
}

static  void method_13311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::JetCorrFactors>*)o)->front)();
  else   (((const ::std::vector<pat::JetCorrFactors>*)o)->front)();
}

static  void method_13312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::JetCorrFactors>*)o)->back)();
  else   (((::std::vector<pat::JetCorrFactors>*)o)->back)();
}

static  void method_13313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::JetCorrFactors>*)o)->back)();
  else   (((const ::std::vector<pat::JetCorrFactors>*)o)->back)();
}

static  void method_13314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::JetCorrFactors>*)o)->data)());
  else   (((::std::vector<pat::JetCorrFactors>*)o)->data)();
}

static  void method_13315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::JetCorrFactors>*)o)->data)());
  else   (((const ::std::vector<pat::JetCorrFactors>*)o)->data)();
}

static  void method_13316( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::JetCorrFactors>*)o)->push_back)(*(const ::pat::JetCorrFactors*)arg[0]);
}

static  void method_13317( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::JetCorrFactors>*)o)->pop_back)();
}

static  void method_13318( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >)((((::std::vector<pat::JetCorrFactors>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >*)arg[0],
    *(const ::pat::JetCorrFactors*)arg[1]));
  else   (((::std::vector<pat::JetCorrFactors>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >*)arg[0],
    *(const ::pat::JetCorrFactors*)arg[1]);
}

static  void method_13319( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::JetCorrFactors>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::JetCorrFactors*)arg[2]);
}

static  void method_13320( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >)((((::std::vector<pat::JetCorrFactors>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >*)arg[0]));
  else   (((::std::vector<pat::JetCorrFactors>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >*)arg[0]);
}

static  void method_13321( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >)((((::std::vector<pat::JetCorrFactors>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >*)arg[1]));
  else   (((::std::vector<pat::JetCorrFactors>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::JetCorrFactors*,std::vector<pat::JetCorrFactors> >*)arg[1]);
}

static  void method_13322( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::JetCorrFactors>*)o)->swap)(*(::std::vector<pat::JetCorrFactors>*)arg[0]);
}

static  void method_13323( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::JetCorrFactors>*)o)->clear)();
}

static void method_newdel_2988( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::JetCorrFactors> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::JetCorrFactors> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::JetCorrFactors> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::JetCorrFactors> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::JetCorrFactors> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::JetCorrFactors,std::allocator<pat::JetCorrFactors> >")), ::Reflex::BaseOffset< ::std::vector<pat::JetCorrFactors>,::std::_Vector_base<pat::JetCorrFactors,std::allocator<pat::JetCorrFactors> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x29( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::JetCorrFactors> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::JetCorrFactors> >::Generate();
}

//------Dictionary for class vector<pat::JetCorrFactors,std::allocator<pat::JetCorrFactors> > -------------------------------
void __std__vector_pat__JetCorrFactors__db_datamem(Reflex::Class*);
void __std__vector_pat__JetCorrFactors__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__JetCorrFactors__datamem_bld(&__std__vector_pat__JetCorrFactors__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__JetCorrFactors__funcmem_bld(&__std__vector_pat__JetCorrFactors__db_funcmem);
void __std__vector_pat__JetCorrFactors__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::JetCorrFactors>"), typeid(::std::vector<pat::JetCorrFactors>), sizeof(::std::vector<pat::JetCorrFactors>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2405, ::Reflex::BaseOffset< ::std::vector<pat::JetCorrFactors>, ::std::_Vector_base<pat::JetCorrFactors,std::allocator<pat::JetCorrFactors> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7722, Reflex::Literal("std::vector<pat::JetCorrFactors>::_Alloc_value_type"))
  .AddTypedef(type_2405, Reflex::Literal("std::vector<pat::JetCorrFactors>::_Base"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<pat::JetCorrFactors>::_Tp_alloc_type"))
  .AddTypedef(type_7165, Reflex::Literal("std::vector<pat::JetCorrFactors>::_Alloc_traits"))
  .AddTypedef(type_7722, Reflex::Literal("std::vector<pat::JetCorrFactors>::value_type"))
  .AddTypedef(type_8490, Reflex::Literal("std::vector<pat::JetCorrFactors>::pointer"))
  .AddTypedef(type_13271, Reflex::Literal("std::vector<pat::JetCorrFactors>::const_pointer"))
  .AddTypedef(type_13273, Reflex::Literal("std::vector<pat::JetCorrFactors>::reference"))
  .AddTypedef(type_13275, Reflex::Literal("std::vector<pat::JetCorrFactors>::const_reference"))
  .AddTypedef(type_6989, Reflex::Literal("std::vector<pat::JetCorrFactors>::iterator"))
  .AddTypedef(type_6990, Reflex::Literal("std::vector<pat::JetCorrFactors>::const_iterator"))
  .AddTypedef(type_3440, Reflex::Literal("std::vector<pat::JetCorrFactors>::const_reverse_iterator"))
  .AddTypedef(type_3441, Reflex::Literal("std::vector<pat::JetCorrFactors>::reverse_iterator"))
  .AddTypedef(type_3227, Reflex::Literal("std::vector<pat::JetCorrFactors>::size_type"))
  .AddTypedef(type_3120, Reflex::Literal("std::vector<pat::JetCorrFactors>::difference_type"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<pat::JetCorrFactors>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13284, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30187), Reflex::Literal("vector"), constructor_13285, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3227, type_13275, type_30187), Reflex::Literal("vector"), constructor_13286, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31432), Reflex::Literal("vector"), constructor_13287, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13288, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2988, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x29, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__JetCorrFactors__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::JetCorrFactors,std::allocator<pat::JetCorrFactors> > -------------------
void __std__vector_pat__JetCorrFactors__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::JetCorrFactors,std::allocator<pat::JetCorrFactors> > -------------------
void __std__vector_pat__JetCorrFactors__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31433, type_31432), Reflex::Literal("operator="), operator_13289, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_13275), Reflex::Literal("assign"), method_13290, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6989), Reflex::Literal("begin"), method_13291, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6990), Reflex::Literal("begin"), method_13292, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6989), Reflex::Literal("end"), method_13293, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6990), Reflex::Literal("end"), method_13294, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("size"), method_13299, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("max_size"), method_13300, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_7722), Reflex::Literal("resize"), method_13301, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("capacity"), method_13302, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("empty"), method_13303, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227), Reflex::Literal("reserve"), method_13304, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13273, type_3227), Reflex::Literal("operator[]"), operator_13305, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13275, type_3227), Reflex::Literal("operator[]"), operator_13306, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13273, type_3227), Reflex::Literal("at"), method_13308, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13275, type_3227), Reflex::Literal("at"), method_13309, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13273), Reflex::Literal("front"), method_13310, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13275), Reflex::Literal("front"), method_13311, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13273), Reflex::Literal("back"), method_13312, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13275), Reflex::Literal("back"), method_13313, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8490), Reflex::Literal("data"), method_13314, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13271), Reflex::Literal("data"), method_13315, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_13275), Reflex::Literal("push_back"), method_13316, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("pop_back"), method_13317, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6989, type_6989, type_13275), Reflex::Literal("insert"), method_13318, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_6989, type_3227, type_13275), Reflex::Literal("insert"), method_13319, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6989, type_6989), Reflex::Literal("erase"), method_13320, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6989, type_6989, type_6989), Reflex::Literal("erase"), method_13321, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_31433), Reflex::Literal("swap"), method_13322, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("clear"), method_13323, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class ValueMap<pat::LookupTableRecord> -------------------------------
static void destructor_22691(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ValueMap<pat::LookupTableRecord>*)o)->::edm::ValueMap<pat::LookupTableRecord>::~ValueMap)();
}
static void constructor_22692( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<pat::LookupTableRecord>(*(const ::edm::ValueMap<pat::LookupTableRecord>*)arg[0]);
  else ::new(mem) ::edm::ValueMap<pat::LookupTableRecord>(*(const ::edm::ValueMap<pat::LookupTableRecord>*)arg[0]);
}

static void constructor_22693( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<pat::LookupTableRecord>();
  else ::new(mem) ::edm::ValueMap<pat::LookupTableRecord>();
}

static  void method_22694( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::ValueMap<pat::LookupTableRecord>*)o)->swap)(*(::edm::ValueMap<pat::LookupTableRecord>*)arg[0]);
}

static  void operator_22695( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<pat::LookupTableRecord>*)o)->operator=)(*(const ::edm::ValueMap<pat::LookupTableRecord>*)arg[0]);
  else   (((::edm::ValueMap<pat::LookupTableRecord>*)o)->operator=)(*(const ::edm::ValueMap<pat::LookupTableRecord>*)arg[0]);
}

static  void method_22696( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_22697( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_22698( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<pat::LookupTableRecord>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::edm::ValueMap<pat::LookupTableRecord>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_22699( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<pat::LookupTableRecord>*)o)->operator+=)(*(const ::edm::ValueMap<pat::LookupTableRecord>*)arg[0]);
  else   (((::edm::ValueMap<pat::LookupTableRecord>*)o)->operator+=)(*(const ::edm::ValueMap<pat::LookupTableRecord>*)arg[0]);
}

static  void method_22700( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_22701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->size)());
  else   (((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->size)();
}

static  void method_22702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->idSize)());
  else   (((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->idSize)();
}

static  void method_22703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->empty)());
  else   (((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->empty)();
}

static  void method_22704( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::ValueMap<pat::LookupTableRecord>*)o)->clear)();
}

static  void method_22705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<pat::LookupTableRecord>::const_iterator)((((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->begin)());
  else   (((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->begin)();
}

static  void method_22706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<pat::LookupTableRecord>::const_iterator)((((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->end)());
  else   (((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->end)();
}

static  void method_22707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->ids)();
  else   (((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->ids)();
}

static  void method_22708( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->get)(*(::size_t*)arg[0]);
  else   (((const ::edm::ValueMap<pat::LookupTableRecord>*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_22709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::ValueMap<pat::LookupTableRecord>*)o)->Class_Version)());
  else   (((::edm::ValueMap<pat::LookupTableRecord>*)o)->Class_Version)();
}

static void method_newdel_4668( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::LookupTableRecord> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::LookupTableRecord> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::LookupTableRecord> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::LookupTableRecord> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::LookupTableRecord> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ValueMap<pat::LookupTableRecord> -------------------------------
void __edm__ValueMap_pat__LookupTableRecord__db_datamem(Reflex::Class*);
void __edm__ValueMap_pat__LookupTableRecord__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ValueMap_pat__LookupTableRecord__datamem_bld(&__edm__ValueMap_pat__LookupTableRecord__db_datamem);
Reflex::GenreflexMemberBuilder __edm__ValueMap_pat__LookupTableRecord__funcmem_bld(&__edm__ValueMap_pat__LookupTableRecord__db_funcmem);
void __edm__ValueMap_pat__LookupTableRecord__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ValueMap<pat::LookupTableRecord>"), typeid(::edm::ValueMap<pat::LookupTableRecord>), sizeof(::edm::ValueMap<pat::LookupTableRecord>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::ValueMap<pat::LookupTableRecord>::Class_Version())
  .AddTypedef(type_7723, Reflex::Literal("edm::ValueMap<pat::LookupTableRecord>::value_type"))
  .AddTypedef(type_2983, Reflex::Literal("edm::ValueMap<pat::LookupTableRecord>::container"))
  .AddTypedef(type_200, Reflex::Literal("edm::ValueMap<pat::LookupTableRecord>::offset"))
  .AddTypedef(type_2981, Reflex::Literal("edm::ValueMap<pat::LookupTableRecord>::id_offset_vector"))
  .AddTypedef(type_12948, Reflex::Literal("edm::ValueMap<pat::LookupTableRecord>::reference_type"))
  .AddTypedef(type_12950, Reflex::Literal("edm::ValueMap<pat::LookupTableRecord>::const_reference_type"))
  .AddTypedef(type_22687, Reflex::Literal("edm::ValueMap<pat::LookupTableRecord>::Filler"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValueMap"), destructor_22691, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35635), Reflex::Literal("ValueMap"), constructor_22692, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ValueMap"), constructor_22693, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4668, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ValueMap_pat__LookupTableRecord__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ValueMap_pat__LookupTableRecord__funcmem_bld);
}

//------Delayed data member builder for class ValueMap<pat::LookupTableRecord> -------------------
void __edm__ValueMap_pat__LookupTableRecord__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2983, Reflex::Literal("values_"), OffsetOf(__shadow__::__edm__ValueMap_pat__LookupTableRecord_, values_), ::Reflex::PROTECTED)
  .AddDataMember(type_2981, Reflex::Literal("ids_"), OffsetOf(__shadow__::__edm__ValueMap_pat__LookupTableRecord_, ids_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class ValueMap<pat::LookupTableRecord> -------------------
void __edm__ValueMap_pat__LookupTableRecord__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_35636), Reflex::Literal("swap"), method_22694, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35636, type_35635), Reflex::Literal("operator="), operator_22695, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047, type_4789, type_2047), Reflex::Literal("rawIndexOf"), method_22696, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12950, type_4789, type_2047), Reflex::Literal("get"), method_22697, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12948, type_4789, type_2047), Reflex::Literal("get"), method_22698, 0, "id;idx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35636, type_35635), Reflex::Literal("operator+="), operator_22699, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534, type_4789), Reflex::Literal("contains"), method_22700, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047), Reflex::Literal("size"), method_22701, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047), Reflex::Literal("idSize"), method_22702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("empty"), method_22703, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("clear"), method_22704, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22689), Reflex::Literal("begin"), method_22705, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22689), Reflex::Literal("end"), method_22706, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31411), Reflex::Literal("ids"), method_22707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12950, type_2047), Reflex::Literal("get"), method_22708, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("Class_Version"), method_22709, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::ValueMap<pat::LookupTableRecord> > -------------------------------
static void constructor_22438( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >();
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >();
}

static void constructor_22439( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >(*(::std::auto_ptr<edm::ValueMap<pat::LookupTableRecord> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >(*(::std::auto_ptr<edm::ValueMap<pat::LookupTableRecord> >*)arg[0]);
}

static void destructor_22440(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >::~Wrapper)();
}
static  void method_22441( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->product)();
}

static  void operator_22442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->operator->)();
}

static  void method_22443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->productTypeInfo)();
}

static  void method_22444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->typeInfo)();
}

static void constructor_22445( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >((::edm::ValueMap<pat::LookupTableRecord>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >((::edm::ValueMap<pat::LookupTableRecord>*)arg[0]);
}

static  void method_22446( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->getInterface)();
}

static  void method_22447( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_22448( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_22449( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_22450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->dynamicTypeInfo)();
}

static  void method_22451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->isPresent)();
}

static  void method_22452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4652( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ValueMap<pat::LookupTableRecord> > -------------------------------
void __edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s__datamem_bld(&__edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s__funcmem_bld(&__edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s__db_funcmem);
void __edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >"), typeid(::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >), sizeof(::edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4668, Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >::value_type"))
  .AddTypedef(type_4668, Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_22438, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2716), Reflex::Literal("Wrapper"), constructor_22439, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_22440, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35586), Reflex::Literal("Wrapper"), constructor_22445, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4652, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ValueMap<pat::LookupTableRecord> > -------------------
void __edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1534, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4668, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ValueMap<pat::LookupTableRecord> > -------------------
void __edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35585), Reflex::Literal("product"), method_22441, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35585), Reflex::Literal("operator->"), operator_22442, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("productTypeInfo"), method_22443, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("typeInfo"), method_22444, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35587), Reflex::Literal("getInterface"), method_22446, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19634, type_19728, type_35354), Reflex::Literal("fillView"), method_22447, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_343, type_9938), Reflex::Literal("setPtr"), method_22448, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_23644, type_19728), Reflex::Literal("fillPtrVector"), method_22449, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo"), method_22450, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("isPresent"), method_22451, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo_"), method_22452, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::EventHypothesis, std::allocator<pat::EventHypothesis> > > -------------------------------
static void constructor_22459( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::EventHypothesis> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::EventHypothesis> >();
}

static void constructor_22460( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::EventHypothesis> >(*(::std::auto_ptr<std::vector<pat::EventHypothesis> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::EventHypothesis> >(*(::std::auto_ptr<std::vector<pat::EventHypothesis> >*)arg[0]);
}

static void destructor_22461(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->::edm::Wrapper<std::vector<pat::EventHypothesis> >::~Wrapper)();
}
static  void method_22462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->product)();
}

static  void operator_22463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->operator->)();
}

static  void method_22464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->productTypeInfo)();
}

static  void method_22465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->typeInfo)();
}

static void constructor_22466( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::EventHypothesis> >((::std::vector<pat::EventHypothesis>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::EventHypothesis> >((::std::vector<pat::EventHypothesis>*)arg[0]);
}

static  void method_22467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->getInterface)();
}

static  void method_22468( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_22469( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_22470( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_22471( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->dynamicTypeInfo)();
}

static  void method_22472( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->isPresent)();
}

static  void method_22473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::EventHypothesis> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4653( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::EventHypothesis> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::EventHypothesis> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::EventHypothesis> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::EventHypothesis> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::EventHypothesis> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::EventHypothesis, std::allocator<pat::EventHypothesis> > > -------------------------------
void __edm__Wrapper_std__vector_pat__EventHypothesis_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__EventHypothesis_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__EventHypothesis_s__datamem_bld(&__edm__Wrapper_std__vector_pat__EventHypothesis_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__EventHypothesis_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__EventHypothesis_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__EventHypothesis_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::EventHypothesis> >"), typeid(::edm::Wrapper<std::vector<pat::EventHypothesis> >), sizeof(::edm::Wrapper<std::vector<pat::EventHypothesis> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2985, Reflex::Literal("edm::Wrapper<std::vector<pat::EventHypothesis> >::value_type"))
  .AddTypedef(type_2985, Reflex::Literal("edm::Wrapper<std::vector<pat::EventHypothesis> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_22459, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2717), Reflex::Literal("Wrapper"), constructor_22460, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_22461, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35591), Reflex::Literal("Wrapper"), constructor_22466, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4653, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__EventHypothesis_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__EventHypothesis_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::EventHypothesis, std::allocator<pat::EventHypothesis> > > -------------------
void __edm__Wrapper_std__vector_pat__EventHypothesis_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1534, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__EventHypothesis_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2985, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__EventHypothesis_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::EventHypothesis, std::allocator<pat::EventHypothesis> > > -------------------
void __edm__Wrapper_std__vector_pat__EventHypothesis_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35590), Reflex::Literal("product"), method_22462, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35590), Reflex::Literal("operator->"), operator_22463, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("productTypeInfo"), method_22464, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("typeInfo"), method_22465, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35592), Reflex::Literal("getInterface"), method_22467, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19634, type_19728, type_35354), Reflex::Literal("fillView"), method_22468, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_343, type_9938), Reflex::Literal("setPtr"), method_22469, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_23644, type_19728), Reflex::Literal("fillPtrVector"), method_22470, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo"), method_22471, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("isPresent"), method_22472, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo_"), method_22473, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ValueMap<pat::VertexAssociation> -------------------------------
static void destructor_22726(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ValueMap<pat::VertexAssociation>*)o)->::edm::ValueMap<pat::VertexAssociation>::~ValueMap)();
}
static void constructor_22727( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<pat::VertexAssociation>(*(const ::edm::ValueMap<pat::VertexAssociation>*)arg[0]);
  else ::new(mem) ::edm::ValueMap<pat::VertexAssociation>(*(const ::edm::ValueMap<pat::VertexAssociation>*)arg[0]);
}

static void constructor_22728( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<pat::VertexAssociation>();
  else ::new(mem) ::edm::ValueMap<pat::VertexAssociation>();
}

static  void method_22729( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::ValueMap<pat::VertexAssociation>*)o)->swap)(*(::edm::ValueMap<pat::VertexAssociation>*)arg[0]);
}

static  void operator_22730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<pat::VertexAssociation>*)o)->operator=)(*(const ::edm::ValueMap<pat::VertexAssociation>*)arg[0]);
  else   (((::edm::ValueMap<pat::VertexAssociation>*)o)->operator=)(*(const ::edm::ValueMap<pat::VertexAssociation>*)arg[0]);
}

static  void method_22731( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<pat::VertexAssociation>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::ValueMap<pat::VertexAssociation>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_22732( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<pat::VertexAssociation>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((const ::edm::ValueMap<pat::VertexAssociation>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_22733( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<pat::VertexAssociation>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::edm::ValueMap<pat::VertexAssociation>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_22734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<pat::VertexAssociation>*)o)->operator+=)(*(const ::edm::ValueMap<pat::VertexAssociation>*)arg[0]);
  else   (((::edm::ValueMap<pat::VertexAssociation>*)o)->operator+=)(*(const ::edm::ValueMap<pat::VertexAssociation>*)arg[0]);
}

static  void method_22735( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<pat::VertexAssociation>*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::ValueMap<pat::VertexAssociation>*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_22736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<pat::VertexAssociation>*)o)->size)());
  else   (((const ::edm::ValueMap<pat::VertexAssociation>*)o)->size)();
}

static  void method_22737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<pat::VertexAssociation>*)o)->idSize)());
  else   (((const ::edm::ValueMap<pat::VertexAssociation>*)o)->idSize)();
}

static  void method_22738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<pat::VertexAssociation>*)o)->empty)());
  else   (((const ::edm::ValueMap<pat::VertexAssociation>*)o)->empty)();
}

static  void method_22739( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::ValueMap<pat::VertexAssociation>*)o)->clear)();
}

static  void method_22740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<pat::VertexAssociation>::const_iterator)((((const ::edm::ValueMap<pat::VertexAssociation>*)o)->begin)());
  else   (((const ::edm::ValueMap<pat::VertexAssociation>*)o)->begin)();
}

static  void method_22741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<pat::VertexAssociation>::const_iterator)((((const ::edm::ValueMap<pat::VertexAssociation>*)o)->end)());
  else   (((const ::edm::ValueMap<pat::VertexAssociation>*)o)->end)();
}

static  void method_22742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<pat::VertexAssociation>*)o)->ids)();
  else   (((const ::edm::ValueMap<pat::VertexAssociation>*)o)->ids)();
}

static  void method_22743( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<pat::VertexAssociation>*)o)->get)(*(::size_t*)arg[0]);
  else   (((const ::edm::ValueMap<pat::VertexAssociation>*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_22744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::ValueMap<pat::VertexAssociation>*)o)->Class_Version)());
  else   (((::edm::ValueMap<pat::VertexAssociation>*)o)->Class_Version)();
}

static void method_newdel_4669( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::VertexAssociation> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::VertexAssociation> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::VertexAssociation> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::VertexAssociation> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::VertexAssociation> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ValueMap<pat::VertexAssociation> -------------------------------
void __edm__ValueMap_pat__VertexAssociation__db_datamem(Reflex::Class*);
void __edm__ValueMap_pat__VertexAssociation__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ValueMap_pat__VertexAssociation__datamem_bld(&__edm__ValueMap_pat__VertexAssociation__db_datamem);
Reflex::GenreflexMemberBuilder __edm__ValueMap_pat__VertexAssociation__funcmem_bld(&__edm__ValueMap_pat__VertexAssociation__db_funcmem);
void __edm__ValueMap_pat__VertexAssociation__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ValueMap<pat::VertexAssociation>"), typeid(::edm::ValueMap<pat::VertexAssociation>), sizeof(::edm::ValueMap<pat::VertexAssociation>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::ValueMap<pat::VertexAssociation>::Class_Version())
  .AddTypedef(type_7720, Reflex::Literal("edm::ValueMap<pat::VertexAssociation>::value_type"))
  .AddTypedef(type_2986, Reflex::Literal("edm::ValueMap<pat::VertexAssociation>::container"))
  .AddTypedef(type_200, Reflex::Literal("edm::ValueMap<pat::VertexAssociation>::offset"))
  .AddTypedef(type_2981, Reflex::Literal("edm::ValueMap<pat::VertexAssociation>::id_offset_vector"))
  .AddTypedef(type_13143, Reflex::Literal("edm::ValueMap<pat::VertexAssociation>::reference_type"))
  .AddTypedef(type_13145, Reflex::Literal("edm::ValueMap<pat::VertexAssociation>::const_reference_type"))
  .AddTypedef(type_22722, Reflex::Literal("edm::ValueMap<pat::VertexAssociation>::Filler"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValueMap"), destructor_22726, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35637), Reflex::Literal("ValueMap"), constructor_22727, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ValueMap"), constructor_22728, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4669, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ValueMap_pat__VertexAssociation__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ValueMap_pat__VertexAssociation__funcmem_bld);
}

//------Delayed data member builder for class ValueMap<pat::VertexAssociation> -------------------
void __edm__ValueMap_pat__VertexAssociation__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2986, Reflex::Literal("values_"), OffsetOf(__shadow__::__edm__ValueMap_pat__VertexAssociation_, values_), ::Reflex::PROTECTED)
  .AddDataMember(type_2981, Reflex::Literal("ids_"), OffsetOf(__shadow__::__edm__ValueMap_pat__VertexAssociation_, ids_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class ValueMap<pat::VertexAssociation> -------------------
void __edm__ValueMap_pat__VertexAssociation__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_35638), Reflex::Literal("swap"), method_22729, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35638, type_35637), Reflex::Literal("operator="), operator_22730, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047, type_4789, type_2047), Reflex::Literal("rawIndexOf"), method_22731, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13145, type_4789, type_2047), Reflex::Literal("get"), method_22732, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13143, type_4789, type_2047), Reflex::Literal("get"), method_22733, 0, "id;idx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35638, type_35637), Reflex::Literal("operator+="), operator_22734, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534, type_4789), Reflex::Literal("contains"), method_22735, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047), Reflex::Literal("size"), method_22736, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047), Reflex::Literal("idSize"), method_22737, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("empty"), method_22738, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("clear"), method_22739, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22724), Reflex::Literal("begin"), method_22740, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22724), Reflex::Literal("end"), method_22741, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31411), Reflex::Literal("ids"), method_22742, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13145, type_2047), Reflex::Literal("get"), method_22743, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("Class_Version"), method_22744, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::ValueMap<pat::VertexAssociation> > -------------------------------
static void constructor_22480( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >();
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >();
}

static void constructor_22481( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >(*(::std::auto_ptr<edm::ValueMap<pat::VertexAssociation> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >(*(::std::auto_ptr<edm::ValueMap<pat::VertexAssociation> >*)arg[0]);
}

static void destructor_22482(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >::~Wrapper)();
}
static  void method_22483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->product)();
}

static  void operator_22484( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->operator->)();
}

static  void method_22485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->productTypeInfo)();
}

static  void method_22486( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->typeInfo)();
}

static void constructor_22487( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >((::edm::ValueMap<pat::VertexAssociation>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >((::edm::ValueMap<pat::VertexAssociation>*)arg[0]);
}

static  void method_22488( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->getInterface)();
}

static  void method_22489( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_22490( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_22491( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_22492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->dynamicTypeInfo)();
}

static  void method_22493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->isPresent)();
}

static  void method_22494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4654( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ValueMap<pat::VertexAssociation> > -------------------------------
void __edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s__datamem_bld(&__edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s__funcmem_bld(&__edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s__db_funcmem);
void __edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >"), typeid(::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >), sizeof(::edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4669, Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >::value_type"))
  .AddTypedef(type_4669, Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::VertexAssociation> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_22480, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2718), Reflex::Literal("Wrapper"), constructor_22481, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_22482, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35596), Reflex::Literal("Wrapper"), constructor_22487, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4654, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ValueMap<pat::VertexAssociation> > -------------------
void __edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1534, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4669, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ValueMap<pat::VertexAssociation> > -------------------
void __edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35595), Reflex::Literal("product"), method_22483, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35595), Reflex::Literal("operator->"), operator_22484, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("productTypeInfo"), method_22485, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("typeInfo"), method_22486, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35597), Reflex::Literal("getInterface"), method_22488, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19634, type_19728, type_35354), Reflex::Literal("fillView"), method_22489, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_343, type_9938), Reflex::Literal("setPtr"), method_22490, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_23644, type_19728), Reflex::Literal("fillPtrVector"), method_22491, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo"), method_22492, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("isPresent"), method_22493, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo_"), method_22494, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<StringMap> -------------------------------
static void constructor_22501( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<StringMap>();
  else ::new(mem) ::edm::Wrapper<StringMap>();
}

static void constructor_22502( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<StringMap>(*(::std::auto_ptr<StringMap>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<StringMap>(*(::std::auto_ptr<StringMap>*)arg[0]);
}

static void destructor_22503(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<StringMap>*)o)->::edm::Wrapper<StringMap>::~Wrapper)();
}
static  void method_22504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<StringMap>*)o)->product)());
  else   (((const ::edm::Wrapper<StringMap>*)o)->product)();
}

static  void operator_22505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<StringMap>*)o)->operator->)());
  else   (((const ::edm::Wrapper<StringMap>*)o)->operator->)();
}

static  void method_22506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<StringMap>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<StringMap>*)o)->productTypeInfo)();
}

static  void method_22507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<StringMap>*)o)->typeInfo)();
  else   (((::edm::Wrapper<StringMap>*)o)->typeInfo)();
}

static void constructor_22508( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<StringMap>((::StringMap*)arg[0]);
  else ::new(mem) ::edm::Wrapper<StringMap>((::StringMap*)arg[0]);
}

static  void method_22509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<StringMap>*)o)->getInterface)());
  else   (((::edm::Wrapper<StringMap>*)o)->getInterface)();
}

static  void method_22510( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<StringMap>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_22511( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<StringMap>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_22512( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<StringMap>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_22513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<StringMap>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<StringMap>*)o)->dynamicTypeInfo)();
}

static  void method_22514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<StringMap>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<StringMap>*)o)->isPresent)();
}

static  void method_22515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<StringMap>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<StringMap>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4655( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<StringMap> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<StringMap> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<StringMap> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<StringMap> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<StringMap> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<StringMap> -------------------------------
void __edm__Wrapper_StringMap__db_datamem(Reflex::Class*);
void __edm__Wrapper_StringMap__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_StringMap__datamem_bld(&__edm__Wrapper_StringMap__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_StringMap__funcmem_bld(&__edm__Wrapper_StringMap__db_funcmem);
void __edm__Wrapper_StringMap__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<StringMap>"), typeid(::edm::Wrapper<StringMap>), sizeof(::edm::Wrapper<StringMap>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2158, Reflex::Literal("edm::Wrapper<StringMap>::value_type"))
  .AddTypedef(type_2158, Reflex::Literal("edm::Wrapper<StringMap>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_22501, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2719), Reflex::Literal("Wrapper"), constructor_22502, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_22503, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35601), Reflex::Literal("Wrapper"), constructor_22508, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4655, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_StringMap__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_StringMap__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<StringMap> -------------------
void __edm__Wrapper_StringMap__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1534, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_StringMap_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2158, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_StringMap_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<StringMap> -------------------
void __edm__Wrapper_StringMap__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35600), Reflex::Literal("product"), method_22504, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35600), Reflex::Literal("operator->"), operator_22505, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("productTypeInfo"), method_22506, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("typeInfo"), method_22507, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35602), Reflex::Literal("getInterface"), method_22509, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19634, type_19728, type_35354), Reflex::Literal("fillView"), method_22510, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_343, type_9938), Reflex::Literal("setPtr"), method_22511, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_23644, type_19728), Reflex::Literal("fillPtrVector"), method_22512, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo"), method_22513, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("isPresent"), method_22514, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo_"), method_22515, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ValueMap<pat::TauJetCorrFactors> -------------------------------
static void destructor_22761(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ValueMap<pat::TauJetCorrFactors>*)o)->::edm::ValueMap<pat::TauJetCorrFactors>::~ValueMap)();
}
static void constructor_22762( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<pat::TauJetCorrFactors>(*(const ::edm::ValueMap<pat::TauJetCorrFactors>*)arg[0]);
  else ::new(mem) ::edm::ValueMap<pat::TauJetCorrFactors>(*(const ::edm::ValueMap<pat::TauJetCorrFactors>*)arg[0]);
}

static void constructor_22763( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<pat::TauJetCorrFactors>();
  else ::new(mem) ::edm::ValueMap<pat::TauJetCorrFactors>();
}

static  void method_22764( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::ValueMap<pat::TauJetCorrFactors>*)o)->swap)(*(::edm::ValueMap<pat::TauJetCorrFactors>*)arg[0]);
}

static  void operator_22765( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<pat::TauJetCorrFactors>*)o)->operator=)(*(const ::edm::ValueMap<pat::TauJetCorrFactors>*)arg[0]);
  else   (((::edm::ValueMap<pat::TauJetCorrFactors>*)o)->operator=)(*(const ::edm::ValueMap<pat::TauJetCorrFactors>*)arg[0]);
}

static  void method_22766( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_22767( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_22768( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<pat::TauJetCorrFactors>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::edm::ValueMap<pat::TauJetCorrFactors>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_22769( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<pat::TauJetCorrFactors>*)o)->operator+=)(*(const ::edm::ValueMap<pat::TauJetCorrFactors>*)arg[0]);
  else   (((::edm::ValueMap<pat::TauJetCorrFactors>*)o)->operator+=)(*(const ::edm::ValueMap<pat::TauJetCorrFactors>*)arg[0]);
}

static  void method_22770( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_22771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->size)());
  else   (((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->size)();
}

static  void method_22772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->idSize)());
  else   (((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->idSize)();
}

static  void method_22773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->empty)());
  else   (((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->empty)();
}

static  void method_22774( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::ValueMap<pat::TauJetCorrFactors>*)o)->clear)();
}

static  void method_22775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<pat::TauJetCorrFactors>::const_iterator)((((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->begin)());
  else   (((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->begin)();
}

static  void method_22776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<pat::TauJetCorrFactors>::const_iterator)((((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->end)());
  else   (((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->end)();
}

static  void method_22777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->ids)();
  else   (((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->ids)();
}

static  void method_22778( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->get)(*(::size_t*)arg[0]);
  else   (((const ::edm::ValueMap<pat::TauJetCorrFactors>*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_22779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::ValueMap<pat::TauJetCorrFactors>*)o)->Class_Version)());
  else   (((::edm::ValueMap<pat::TauJetCorrFactors>*)o)->Class_Version)();
}

static void method_newdel_4670( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::TauJetCorrFactors> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::TauJetCorrFactors> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::TauJetCorrFactors> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::TauJetCorrFactors> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::TauJetCorrFactors> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ValueMap<pat::TauJetCorrFactors> -------------------------------
void __edm__ValueMap_pat__TauJetCorrFactors__db_datamem(Reflex::Class*);
void __edm__ValueMap_pat__TauJetCorrFactors__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ValueMap_pat__TauJetCorrFactors__datamem_bld(&__edm__ValueMap_pat__TauJetCorrFactors__db_datamem);
Reflex::GenreflexMemberBuilder __edm__ValueMap_pat__TauJetCorrFactors__funcmem_bld(&__edm__ValueMap_pat__TauJetCorrFactors__db_funcmem);
void __edm__ValueMap_pat__TauJetCorrFactors__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ValueMap<pat::TauJetCorrFactors>"), typeid(::edm::ValueMap<pat::TauJetCorrFactors>), sizeof(::edm::ValueMap<pat::TauJetCorrFactors>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::ValueMap<pat::TauJetCorrFactors>::Class_Version())
  .AddTypedef(type_7727, Reflex::Literal("edm::ValueMap<pat::TauJetCorrFactors>::value_type"))
  .AddTypedef(type_2987, Reflex::Literal("edm::ValueMap<pat::TauJetCorrFactors>::container"))
  .AddTypedef(type_200, Reflex::Literal("edm::ValueMap<pat::TauJetCorrFactors>::offset"))
  .AddTypedef(type_2981, Reflex::Literal("edm::ValueMap<pat::TauJetCorrFactors>::id_offset_vector"))
  .AddTypedef(type_13208, Reflex::Literal("edm::ValueMap<pat::TauJetCorrFactors>::reference_type"))
  .AddTypedef(type_13210, Reflex::Literal("edm::ValueMap<pat::TauJetCorrFactors>::const_reference_type"))
  .AddTypedef(type_22757, Reflex::Literal("edm::ValueMap<pat::TauJetCorrFactors>::Filler"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValueMap"), destructor_22761, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35639), Reflex::Literal("ValueMap"), constructor_22762, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ValueMap"), constructor_22763, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4670, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ValueMap_pat__TauJetCorrFactors__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ValueMap_pat__TauJetCorrFactors__funcmem_bld);
}

//------Delayed data member builder for class ValueMap<pat::TauJetCorrFactors> -------------------
void __edm__ValueMap_pat__TauJetCorrFactors__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2987, Reflex::Literal("values_"), OffsetOf(__shadow__::__edm__ValueMap_pat__TauJetCorrFactors_, values_), ::Reflex::PROTECTED)
  .AddDataMember(type_2981, Reflex::Literal("ids_"), OffsetOf(__shadow__::__edm__ValueMap_pat__TauJetCorrFactors_, ids_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class ValueMap<pat::TauJetCorrFactors> -------------------
void __edm__ValueMap_pat__TauJetCorrFactors__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_35640), Reflex::Literal("swap"), method_22764, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35640, type_35639), Reflex::Literal("operator="), operator_22765, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047, type_4789, type_2047), Reflex::Literal("rawIndexOf"), method_22766, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13210, type_4789, type_2047), Reflex::Literal("get"), method_22767, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13208, type_4789, type_2047), Reflex::Literal("get"), method_22768, 0, "id;idx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35640, type_35639), Reflex::Literal("operator+="), operator_22769, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534, type_4789), Reflex::Literal("contains"), method_22770, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047), Reflex::Literal("size"), method_22771, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047), Reflex::Literal("idSize"), method_22772, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("empty"), method_22773, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("clear"), method_22774, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22759), Reflex::Literal("begin"), method_22775, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22759), Reflex::Literal("end"), method_22776, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31411), Reflex::Literal("ids"), method_22777, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13210, type_2047), Reflex::Literal("get"), method_22778, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("Class_Version"), method_22779, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::ValueMap<pat::TauJetCorrFactors> > -------------------------------
static void constructor_22522( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >();
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >();
}

static void constructor_22523( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >(*(::std::auto_ptr<edm::ValueMap<pat::TauJetCorrFactors> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >(*(::std::auto_ptr<edm::ValueMap<pat::TauJetCorrFactors> >*)arg[0]);
}

static void destructor_22524(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >::~Wrapper)();
}
static  void method_22525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->product)();
}

static  void operator_22526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->operator->)();
}

static  void method_22527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->productTypeInfo)();
}

static  void method_22528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->typeInfo)();
}

static void constructor_22529( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >((::edm::ValueMap<pat::TauJetCorrFactors>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >((::edm::ValueMap<pat::TauJetCorrFactors>*)arg[0]);
}

static  void method_22530( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->getInterface)();
}

static  void method_22531( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_22532( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_22533( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_22534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->dynamicTypeInfo)();
}

static  void method_22535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->isPresent)();
}

static  void method_22536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4656( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ValueMap<pat::TauJetCorrFactors> > -------------------------------
void __edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s__datamem_bld(&__edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s__funcmem_bld(&__edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s__db_funcmem);
void __edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >"), typeid(::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >), sizeof(::edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4670, Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >::value_type"))
  .AddTypedef(type_4670, Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_22522, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2720), Reflex::Literal("Wrapper"), constructor_22523, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_22524, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35606), Reflex::Literal("Wrapper"), constructor_22529, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4656, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ValueMap<pat::TauJetCorrFactors> > -------------------
void __edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1534, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4670, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ValueMap<pat::TauJetCorrFactors> > -------------------
void __edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35605), Reflex::Literal("product"), method_22525, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35605), Reflex::Literal("operator->"), operator_22526, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("productTypeInfo"), method_22527, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("typeInfo"), method_22528, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35607), Reflex::Literal("getInterface"), method_22530, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19634, type_19728, type_35354), Reflex::Literal("fillView"), method_22531, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_343, type_9938), Reflex::Literal("setPtr"), method_22532, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_23644, type_19728), Reflex::Literal("fillPtrVector"), method_22533, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo"), method_22534, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("isPresent"), method_22535, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo_"), method_22536, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ValueMap<pat::JetCorrFactors> -------------------------------
static void destructor_22796(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ValueMap<pat::JetCorrFactors>*)o)->::edm::ValueMap<pat::JetCorrFactors>::~ValueMap)();
}
static void constructor_22797( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<pat::JetCorrFactors>(*(const ::edm::ValueMap<pat::JetCorrFactors>*)arg[0]);
  else ::new(mem) ::edm::ValueMap<pat::JetCorrFactors>(*(const ::edm::ValueMap<pat::JetCorrFactors>*)arg[0]);
}

static void constructor_22798( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<pat::JetCorrFactors>();
  else ::new(mem) ::edm::ValueMap<pat::JetCorrFactors>();
}

static  void method_22799( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::ValueMap<pat::JetCorrFactors>*)o)->swap)(*(::edm::ValueMap<pat::JetCorrFactors>*)arg[0]);
}

static  void operator_22800( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<pat::JetCorrFactors>*)o)->operator=)(*(const ::edm::ValueMap<pat::JetCorrFactors>*)arg[0]);
  else   (((::edm::ValueMap<pat::JetCorrFactors>*)o)->operator=)(*(const ::edm::ValueMap<pat::JetCorrFactors>*)arg[0]);
}

static  void method_22801( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_22802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_22803( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<pat::JetCorrFactors>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::edm::ValueMap<pat::JetCorrFactors>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_22804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<pat::JetCorrFactors>*)o)->operator+=)(*(const ::edm::ValueMap<pat::JetCorrFactors>*)arg[0]);
  else   (((::edm::ValueMap<pat::JetCorrFactors>*)o)->operator+=)(*(const ::edm::ValueMap<pat::JetCorrFactors>*)arg[0]);
}

static  void method_22805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_22806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->size)());
  else   (((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->size)();
}

static  void method_22807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->idSize)());
  else   (((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->idSize)();
}

static  void method_22808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->empty)());
  else   (((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->empty)();
}

static  void method_22809( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::ValueMap<pat::JetCorrFactors>*)o)->clear)();
}

static  void method_22810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<pat::JetCorrFactors>::const_iterator)((((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->begin)());
  else   (((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->begin)();
}

static  void method_22811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<pat::JetCorrFactors>::const_iterator)((((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->end)());
  else   (((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->end)();
}

static  void method_22812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->ids)();
  else   (((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->ids)();
}

static  void method_22813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->get)(*(::size_t*)arg[0]);
  else   (((const ::edm::ValueMap<pat::JetCorrFactors>*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_22814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::ValueMap<pat::JetCorrFactors>*)o)->Class_Version)());
  else   (((::edm::ValueMap<pat::JetCorrFactors>*)o)->Class_Version)();
}

static void method_newdel_4671( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::JetCorrFactors> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::JetCorrFactors> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::JetCorrFactors> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::JetCorrFactors> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::JetCorrFactors> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ValueMap<pat::JetCorrFactors> -------------------------------
void __edm__ValueMap_pat__JetCorrFactors__db_datamem(Reflex::Class*);
void __edm__ValueMap_pat__JetCorrFactors__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ValueMap_pat__JetCorrFactors__datamem_bld(&__edm__ValueMap_pat__JetCorrFactors__db_datamem);
Reflex::GenreflexMemberBuilder __edm__ValueMap_pat__JetCorrFactors__funcmem_bld(&__edm__ValueMap_pat__JetCorrFactors__db_funcmem);
void __edm__ValueMap_pat__JetCorrFactors__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ValueMap<pat::JetCorrFactors>"), typeid(::edm::ValueMap<pat::JetCorrFactors>), sizeof(::edm::ValueMap<pat::JetCorrFactors>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::ValueMap<pat::JetCorrFactors>::Class_Version())
  .AddTypedef(type_7722, Reflex::Literal("edm::ValueMap<pat::JetCorrFactors>::value_type"))
  .AddTypedef(type_2988, Reflex::Literal("edm::ValueMap<pat::JetCorrFactors>::container"))
  .AddTypedef(type_200, Reflex::Literal("edm::ValueMap<pat::JetCorrFactors>::offset"))
  .AddTypedef(type_2981, Reflex::Literal("edm::ValueMap<pat::JetCorrFactors>::id_offset_vector"))
  .AddTypedef(type_13273, Reflex::Literal("edm::ValueMap<pat::JetCorrFactors>::reference_type"))
  .AddTypedef(type_13275, Reflex::Literal("edm::ValueMap<pat::JetCorrFactors>::const_reference_type"))
  .AddTypedef(type_22792, Reflex::Literal("edm::ValueMap<pat::JetCorrFactors>::Filler"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValueMap"), destructor_22796, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35641), Reflex::Literal("ValueMap"), constructor_22797, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ValueMap"), constructor_22798, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4671, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ValueMap_pat__JetCorrFactors__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ValueMap_pat__JetCorrFactors__funcmem_bld);
}

//------Delayed data member builder for class ValueMap<pat::JetCorrFactors> -------------------
void __edm__ValueMap_pat__JetCorrFactors__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2988, Reflex::Literal("values_"), OffsetOf(__shadow__::__edm__ValueMap_pat__JetCorrFactors_, values_), ::Reflex::PROTECTED)
  .AddDataMember(type_2981, Reflex::Literal("ids_"), OffsetOf(__shadow__::__edm__ValueMap_pat__JetCorrFactors_, ids_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class ValueMap<pat::JetCorrFactors> -------------------
void __edm__ValueMap_pat__JetCorrFactors__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_35642), Reflex::Literal("swap"), method_22799, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35642, type_35641), Reflex::Literal("operator="), operator_22800, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047, type_4789, type_2047), Reflex::Literal("rawIndexOf"), method_22801, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13275, type_4789, type_2047), Reflex::Literal("get"), method_22802, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13273, type_4789, type_2047), Reflex::Literal("get"), method_22803, 0, "id;idx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35642, type_35641), Reflex::Literal("operator+="), operator_22804, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534, type_4789), Reflex::Literal("contains"), method_22805, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047), Reflex::Literal("size"), method_22806, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047), Reflex::Literal("idSize"), method_22807, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("empty"), method_22808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("clear"), method_22809, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22794), Reflex::Literal("begin"), method_22810, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22794), Reflex::Literal("end"), method_22811, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31411), Reflex::Literal("ids"), method_22812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13275, type_2047), Reflex::Literal("get"), method_22813, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("Class_Version"), method_22814, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::ValueMap<pat::JetCorrFactors> > -------------------------------
static void constructor_22564( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >();
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >();
}

static void constructor_22565( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >(*(::std::auto_ptr<edm::ValueMap<pat::JetCorrFactors> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >(*(::std::auto_ptr<edm::ValueMap<pat::JetCorrFactors> >*)arg[0]);
}

static void destructor_22566(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >::~Wrapper)();
}
static  void method_22567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->product)();
}

static  void operator_22568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->operator->)();
}

static  void method_22569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->productTypeInfo)();
}

static  void method_22570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->typeInfo)();
}

static void constructor_22571( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >((::edm::ValueMap<pat::JetCorrFactors>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >((::edm::ValueMap<pat::JetCorrFactors>*)arg[0]);
}

static  void method_22572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->getInterface)();
}

static  void method_22573( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_22574( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_22575( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_22576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->dynamicTypeInfo)();
}

static  void method_22577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->isPresent)();
}

static  void method_22578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4658( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ValueMap<pat::JetCorrFactors> > -------------------------------
void __edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s__datamem_bld(&__edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s__funcmem_bld(&__edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s__db_funcmem);
void __edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >"), typeid(::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >), sizeof(::edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4671, Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >::value_type"))
  .AddTypedef(type_4671, Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_22564, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2722), Reflex::Literal("Wrapper"), constructor_22565, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_22566, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35616), Reflex::Literal("Wrapper"), constructor_22571, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4658, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ValueMap<pat::JetCorrFactors> > -------------------
void __edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1534, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4671, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ValueMap<pat::JetCorrFactors> > -------------------
void __edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35615), Reflex::Literal("product"), method_22567, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35615), Reflex::Literal("operator->"), operator_22568, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("productTypeInfo"), method_22569, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("typeInfo"), method_22570, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35617), Reflex::Literal("getInterface"), method_22572, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19634, type_19728, type_35354), Reflex::Literal("fillView"), method_22573, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_343, type_9938), Reflex::Literal("setPtr"), method_22574, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_23644, type_19728), Reflex::Literal("fillPtrVector"), method_22575, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo"), method_22576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("isPresent"), method_22577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo_"), method_22578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > > > -------------------------------
static void constructor_22627( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >();
  else ::new(mem) ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >();
}

static void constructor_22628( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >(*(::std::auto_ptr<std::pair<std::basic_string<char>,std::vector<float> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >(*(::std::auto_ptr<std::pair<std::basic_string<char>,std::vector<float> > >*)arg[0]);
}

static void destructor_22629(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >::~Wrapper)();
}
static  void method_22630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->product)();
}

static  void operator_22631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->operator->)();
}

static  void method_22632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->productTypeInfo)();
}

static  void method_22633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->typeInfo)();
}

static void constructor_22634( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >((::std::pair<std::basic_string<char>,std::vector<float> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >((::std::pair<std::basic_string<char>,std::vector<float> >*)arg[0]);
}

static  void method_22635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->getInterface)();
}

static  void method_22636( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_22637( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_22638( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_22639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->dynamicTypeInfo)();
}

static  void method_22640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->isPresent)();
}

static  void method_22641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4661( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > > > -------------------------------
void __edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s__datamem_bld(&__edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s__funcmem_bld(&__edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s__db_funcmem);
void __edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >"), typeid(::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >), sizeof(::edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2916, Reflex::Literal("edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >::value_type"))
  .AddTypedef(type_2916, Reflex::Literal("edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_22627, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2725), Reflex::Literal("Wrapper"), constructor_22628, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_22629, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8999), Reflex::Literal("Wrapper"), constructor_22634, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4661, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > > > -------------------
void __edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1534, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2916, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > > > -------------------
void __edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13336), Reflex::Literal("product"), method_22630, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13336), Reflex::Literal("operator->"), operator_22631, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("productTypeInfo"), method_22632, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("typeInfo"), method_22633, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35630), Reflex::Literal("getInterface"), method_22635, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19634, type_19728, type_35354), Reflex::Literal("fillView"), method_22636, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_343, type_9938), Reflex::Literal("setPtr"), method_22637, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_23644, type_19728), Reflex::Literal("fillPtrVector"), method_22638, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo"), method_22639, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("isPresent"), method_22640, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo_"), method_22641, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ValueMap<pat::CandKinResolution> -------------------------------
static void destructor_22656(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ValueMap<pat::CandKinResolution>*)o)->::edm::ValueMap<pat::CandKinResolution>::~ValueMap)();
}
static void constructor_22657( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<pat::CandKinResolution>(*(const ::edm::ValueMap<pat::CandKinResolution>*)arg[0]);
  else ::new(mem) ::edm::ValueMap<pat::CandKinResolution>(*(const ::edm::ValueMap<pat::CandKinResolution>*)arg[0]);
}

static void constructor_22658( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<pat::CandKinResolution>();
  else ::new(mem) ::edm::ValueMap<pat::CandKinResolution>();
}

static  void method_22659( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::ValueMap<pat::CandKinResolution>*)o)->swap)(*(::edm::ValueMap<pat::CandKinResolution>*)arg[0]);
}

static  void operator_22660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<pat::CandKinResolution>*)o)->operator=)(*(const ::edm::ValueMap<pat::CandKinResolution>*)arg[0]);
  else   (((::edm::ValueMap<pat::CandKinResolution>*)o)->operator=)(*(const ::edm::ValueMap<pat::CandKinResolution>*)arg[0]);
}

static  void method_22661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<pat::CandKinResolution>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::ValueMap<pat::CandKinResolution>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_22662( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<pat::CandKinResolution>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((const ::edm::ValueMap<pat::CandKinResolution>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_22663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<pat::CandKinResolution>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::edm::ValueMap<pat::CandKinResolution>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_22664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<pat::CandKinResolution>*)o)->operator+=)(*(const ::edm::ValueMap<pat::CandKinResolution>*)arg[0]);
  else   (((::edm::ValueMap<pat::CandKinResolution>*)o)->operator+=)(*(const ::edm::ValueMap<pat::CandKinResolution>*)arg[0]);
}

static  void method_22665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<pat::CandKinResolution>*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::ValueMap<pat::CandKinResolution>*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_22666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<pat::CandKinResolution>*)o)->size)());
  else   (((const ::edm::ValueMap<pat::CandKinResolution>*)o)->size)();
}

static  void method_22667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<pat::CandKinResolution>*)o)->idSize)());
  else   (((const ::edm::ValueMap<pat::CandKinResolution>*)o)->idSize)();
}

static  void method_22668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<pat::CandKinResolution>*)o)->empty)());
  else   (((const ::edm::ValueMap<pat::CandKinResolution>*)o)->empty)();
}

static  void method_22669( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::ValueMap<pat::CandKinResolution>*)o)->clear)();
}

static  void method_22670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<pat::CandKinResolution>::const_iterator)((((const ::edm::ValueMap<pat::CandKinResolution>*)o)->begin)());
  else   (((const ::edm::ValueMap<pat::CandKinResolution>*)o)->begin)();
}

static  void method_22671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<pat::CandKinResolution>::const_iterator)((((const ::edm::ValueMap<pat::CandKinResolution>*)o)->end)());
  else   (((const ::edm::ValueMap<pat::CandKinResolution>*)o)->end)();
}

static  void method_22672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<pat::CandKinResolution>*)o)->ids)();
  else   (((const ::edm::ValueMap<pat::CandKinResolution>*)o)->ids)();
}

static  void method_22673( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<pat::CandKinResolution>*)o)->get)(*(::size_t*)arg[0]);
  else   (((const ::edm::ValueMap<pat::CandKinResolution>*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_22674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::ValueMap<pat::CandKinResolution>*)o)->Class_Version)());
  else   (((::edm::ValueMap<pat::CandKinResolution>*)o)->Class_Version)();
}

static void method_newdel_4667( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::CandKinResolution> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::CandKinResolution> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::CandKinResolution> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::CandKinResolution> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<pat::CandKinResolution> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ValueMap<pat::CandKinResolution> -------------------------------
void __edm__ValueMap_pat__CandKinResolution__db_datamem(Reflex::Class*);
void __edm__ValueMap_pat__CandKinResolution__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ValueMap_pat__CandKinResolution__datamem_bld(&__edm__ValueMap_pat__CandKinResolution__db_datamem);
Reflex::GenreflexMemberBuilder __edm__ValueMap_pat__CandKinResolution__funcmem_bld(&__edm__ValueMap_pat__CandKinResolution__db_funcmem);
void __edm__ValueMap_pat__CandKinResolution__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ValueMap<pat::CandKinResolution>"), typeid(::edm::ValueMap<pat::CandKinResolution>), sizeof(::edm::ValueMap<pat::CandKinResolution>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::ValueMap<pat::CandKinResolution>::Class_Version())
  .AddTypedef(type_7721, Reflex::Literal("edm::ValueMap<pat::CandKinResolution>::value_type"))
  .AddTypedef(type_2982, Reflex::Literal("edm::ValueMap<pat::CandKinResolution>::container"))
  .AddTypedef(type_200, Reflex::Literal("edm::ValueMap<pat::CandKinResolution>::offset"))
  .AddTypedef(type_2981, Reflex::Literal("edm::ValueMap<pat::CandKinResolution>::id_offset_vector"))
  .AddTypedef(type_12883, Reflex::Literal("edm::ValueMap<pat::CandKinResolution>::reference_type"))
  .AddTypedef(type_12885, Reflex::Literal("edm::ValueMap<pat::CandKinResolution>::const_reference_type"))
  .AddTypedef(type_22652, Reflex::Literal("edm::ValueMap<pat::CandKinResolution>::Filler"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValueMap"), destructor_22656, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35633), Reflex::Literal("ValueMap"), constructor_22657, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ValueMap"), constructor_22658, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4667, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ValueMap_pat__CandKinResolution__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ValueMap_pat__CandKinResolution__funcmem_bld);
}

//------Delayed data member builder for class ValueMap<pat::CandKinResolution> -------------------
void __edm__ValueMap_pat__CandKinResolution__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2982, Reflex::Literal("values_"), OffsetOf(__shadow__::__edm__ValueMap_pat__CandKinResolution_, values_), ::Reflex::PROTECTED)
  .AddDataMember(type_2981, Reflex::Literal("ids_"), OffsetOf(__shadow__::__edm__ValueMap_pat__CandKinResolution_, ids_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class ValueMap<pat::CandKinResolution> -------------------
void __edm__ValueMap_pat__CandKinResolution__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_35634), Reflex::Literal("swap"), method_22659, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35634, type_35633), Reflex::Literal("operator="), operator_22660, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047, type_4789, type_2047), Reflex::Literal("rawIndexOf"), method_22661, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12885, type_4789, type_2047), Reflex::Literal("get"), method_22662, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12883, type_4789, type_2047), Reflex::Literal("get"), method_22663, 0, "id;idx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35634, type_35633), Reflex::Literal("operator+="), operator_22664, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534, type_4789), Reflex::Literal("contains"), method_22665, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047), Reflex::Literal("size"), method_22666, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2047), Reflex::Literal("idSize"), method_22667, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("empty"), method_22668, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("clear"), method_22669, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22654), Reflex::Literal("begin"), method_22670, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22654), Reflex::Literal("end"), method_22671, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31411), Reflex::Literal("ids"), method_22672, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12885, type_2047), Reflex::Literal("get"), method_22673, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("Class_Version"), method_22674, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > > > > -------------------------------
static void constructor_13349( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >();
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >();
}

static void constructor_13350( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >(*(const ::std::allocator<std::pair<std::basic_string<char>,std::vector<float> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >(*(const ::std::allocator<std::pair<std::basic_string<char>,std::vector<float> > >*)arg[0]);
}

static void constructor_13351( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::vector<float> >*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::vector<float> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::vector<float> >*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,std::vector<float> > >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::vector<float> >*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,std::vector<float> > >*)arg[2]);
  }
}

static void constructor_13352( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >(*(const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >(*(const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)arg[0]);
}

static void destructor_13353(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::~vector)();
}
static  void operator_13354( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)arg[0]);
}

static  void method_13355( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<std::basic_string<char>,std::vector<float> >*)arg[1]);
}

static  void method_13356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->begin)());
  else   (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->begin)();
}

static  void method_13357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >)((((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->begin)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->begin)();
}

static  void method_13358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->end)());
  else   (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->end)();
}

static  void method_13359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >)((((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->end)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->end)();
}

static  void method_13364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->size)();
}

static  void method_13365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->max_size)();
}

static  void method_13366( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<std::basic_string<char>,std::vector<float> >*)arg[1]);
  }
}

static  void method_13367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->capacity)();
}

static  void method_13368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->empty)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->empty)();
}

static  void method_13369( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13370( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13371( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13374( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->front)();
  else   (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->front)();
}

static  void method_13376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->front)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->front)();
}

static  void method_13377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->back)();
  else   (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->back)();
}

static  void method_13378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->back)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->back)();
}

static  void method_13379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->data)());
  else   (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->data)();
}

static  void method_13380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->data)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->data)();
}

static  void method_13381( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->push_back)(*(const ::std::pair<std::basic_string<char>,std::vector<float> >*)arg[0]);
}

static  void method_13382( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->pop_back)();
}

static  void method_13383( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,std::vector<float> >*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,std::vector<float> >*)arg[1]);
}

static  void method_13384( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<std::basic_string<char>,std::vector<float> >*)arg[2]);
}

static  void method_13385( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)arg[0]));
  else   (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)arg[0]);
}

static  void method_13386( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::vector<float> >*,std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)arg[1]);
}

static  void method_13387( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->swap)(*(::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)arg[0]);
}

static  void method_13388( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)o)->clear)();
}

static void method_newdel_2989( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x43( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,std::vector<float> >,std::allocator<std::pair<std::basic_string<char>,std::vector<float> > > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >,::std::_Vector_base<std::pair<std::basic_string<char>,std::vector<float> >,std::allocator<std::pair<std::basic_string<char>,std::vector<float> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x44( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >::Generate();
}

//------Dictionary for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > > > > -------------------------------
void __std__vector_std__pair_std__basic_string_char__std__vector_float_s_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_std__basic_string_char__std__vector_float_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__std__vector_float_s_s__datamem_bld(&__std__vector_std__pair_std__basic_string_char__std__vector_float_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__std__vector_float_s_s__funcmem_bld(&__std__vector_std__pair_std__basic_string_char__std__vector_float_s_s__db_funcmem);
void __std__vector_std__pair_std__basic_string_char__std__vector_float_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >"), typeid(::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >), sizeof(::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "std::vector<pat::JetCorrFactors::CorrectionFactor>")
  .AddBase(type_2432, ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >, ::std::_Vector_base<std::pair<std::basic_string<char>,std::vector<float> >,std::allocator<std::pair<std::basic_string<char>,std::vector<float> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2916, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::_Alloc_value_type"))
  .AddTypedef(type_2432, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::_Base"))
  .AddTypedef(type_3255, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::_Tp_alloc_type"))
  .AddTypedef(type_7192, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::_Alloc_traits"))
  .AddTypedef(type_2916, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::value_type"))
  .AddTypedef(type_8999, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::pointer"))
  .AddTypedef(type_13336, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::const_pointer"))
  .AddTypedef(type_13338, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::reference"))
  .AddTypedef(type_13340, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::const_reference"))
  .AddTypedef(type_7047, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::iterator"))
  .AddTypedef(type_7048, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::const_iterator"))
  .AddTypedef(type_3510, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::const_reverse_iterator"))
  .AddTypedef(type_3511, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::reverse_iterator"))
  .AddTypedef(type_3227, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::size_type"))
  .AddTypedef(type_3120, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::difference_type"))
  .AddTypedef(type_3255, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::vector<float> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13349, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30538), Reflex::Literal("vector"), constructor_13350, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3227, type_13340, type_30538), Reflex::Literal("vector"), constructor_13351, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31435), Reflex::Literal("vector"), constructor_13352, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13353, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2989, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x43, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x44, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_std__basic_string_char__std__vector_float_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > > > > -------------------
void __std__vector_std__pair_std__basic_string_char__std__vector_float_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > > > > -------------------
void __std__vector_std__pair_std__basic_string_char__std__vector_float_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31436, type_31435), Reflex::Literal("operator="), operator_13354, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_13340), Reflex::Literal("assign"), method_13355, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7047), Reflex::Literal("begin"), method_13356, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7048), Reflex::Literal("begin"), method_13357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7047), Reflex::Literal("end"), method_13358, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7048), Reflex::Literal("end"), method_13359, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("size"), method_13364, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("max_size"), method_13365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227, type_2916), Reflex::Literal("resize"), method_13366, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3227), Reflex::Literal("capacity"), method_13367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("empty"), method_13368, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_3227), Reflex::Literal("reserve"), method_13369, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13338, type_3227), Reflex::Literal("operator[]"), operator_13370, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13340, type_3227), Reflex::Literal("operator[]"), operator_13371, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13338, type_3227), Reflex::Literal("at"), method_13373, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13340, type_3227), Reflex::Literal("at"), method_13374, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13338), Reflex::Literal("front"), method_13375, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13340), Reflex::Literal("front"), method_13376, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13338), Reflex::Literal("back"), method_13377, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13340), Reflex::Literal("back"), method_13378, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8999), Reflex::Literal("data"), method_13379, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13336), Reflex::Literal("data"), method_13380, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_13340), Reflex::Literal("push_back"), method_13381, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("pop_back"), method_13382, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7047, type_7047, type_13340), Reflex::Literal("insert"), method_13383, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_7047, type_3227, type_13340), Reflex::Literal("insert"), method_13384, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7047, type_7047), Reflex::Literal("erase"), method_13385, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7047, type_7047, type_7047), Reflex::Literal("erase"), method_13386, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_31436), Reflex::Literal("swap"), method_13387, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676), Reflex::Literal("clear"), method_13388, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<edm::ValueMap<pat::CandKinResolution> > -------------------------------
static void constructor_22417( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >();
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >();
}

static void constructor_22418( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >(*(::std::auto_ptr<edm::ValueMap<pat::CandKinResolution> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >(*(::std::auto_ptr<edm::ValueMap<pat::CandKinResolution> >*)arg[0]);
}

static void destructor_22419(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >::~Wrapper)();
}
static  void method_22420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->product)();
}

static  void operator_22421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->operator->)();
}

static  void method_22422( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->productTypeInfo)();
}

static  void method_22423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->typeInfo)();
}

static void constructor_22424( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >((::edm::ValueMap<pat::CandKinResolution>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >((::edm::ValueMap<pat::CandKinResolution>*)arg[0]);
}

static  void method_22425( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->getInterface)();
}

static  void method_22426( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_22427( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_22428( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_22429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->dynamicTypeInfo)();
}

static  void method_22430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->isPresent)();
}

static  void method_22431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4651( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ValueMap<pat::CandKinResolution> > -------------------------------
void __edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s__datamem_bld(&__edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s__funcmem_bld(&__edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s__db_funcmem);
void __edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >"), typeid(::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >), sizeof(::edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::CandKinResolutionValueMap>")
  .AddTypedef(type_4667, Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >::value_type"))
  .AddTypedef(type_4667, Reflex::Literal("edm::Wrapper<edm::ValueMap<pat::CandKinResolution> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_22417, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2715), Reflex::Literal("Wrapper"), constructor_22418, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_22419, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35581), Reflex::Literal("Wrapper"), constructor_22424, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4651, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ValueMap<pat::CandKinResolution> > -------------------
void __edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1534, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4667, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ValueMap<pat::CandKinResolution> > -------------------
void __edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35580), Reflex::Literal("product"), method_22420, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35580), Reflex::Literal("operator->"), operator_22421, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("productTypeInfo"), method_22422, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("typeInfo"), method_22423, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35582), Reflex::Literal("getInterface"), method_22425, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19634, type_19728, type_35354), Reflex::Literal("fillView"), method_22426, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_343, type_9938), Reflex::Literal("setPtr"), method_22427, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_23644, type_19728), Reflex::Literal("fillPtrVector"), method_22428, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo"), method_22429, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("isPresent"), method_22430, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo_"), method_22431, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > > > > > -------------------------------
static void constructor_22606( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >();
  else ::new(mem) ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >();
}

static void constructor_22607( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >(*(::std::auto_ptr<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >(*(::std::auto_ptr<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)arg[0]);
}

static void destructor_22608(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >::~Wrapper)();
}
static  void method_22609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->product)();
}

static  void operator_22610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->operator->)();
}

static  void method_22611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->productTypeInfo)();
}

static  void method_22612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->typeInfo)();
}

static void constructor_22613( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >((::std::vector<std::pair<std::basic_string<char>,std::vector<float> > >*)arg[0]);
}

static  void method_22614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->getInterface)();
}

static  void method_22615( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_22616( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_22617( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_22618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->dynamicTypeInfo)();
}

static  void method_22619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->isPresent)();
}

static  void method_22620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4660( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > > > > > -------------------------------
void __edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s__datamem_bld(&__edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s__funcmem_bld(&__edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s__db_funcmem);
void __edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >"), typeid(::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >), sizeof(::edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<std::vector<pat::JetCorrFactors::CorrectionFactor> >")
  .AddTypedef(type_2989, Reflex::Literal("edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >::value_type"))
  .AddTypedef(type_2989, Reflex::Literal("edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_22606, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2724), Reflex::Literal("Wrapper"), constructor_22607, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_22608, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35626), Reflex::Literal("Wrapper"), constructor_22613, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4660, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > > > > > -------------------
void __edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1534, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2989, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<float, std::allocator<float> > > > > > -------------------
void __edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35625), Reflex::Literal("product"), method_22609, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35625), Reflex::Literal("operator->"), operator_22610, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("productTypeInfo"), method_22611, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("typeInfo"), method_22612, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35627), Reflex::Literal("getInterface"), method_22614, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19634, type_19728, type_35354), Reflex::Literal("fillView"), method_22615, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_343, type_9938), Reflex::Literal("setPtr"), method_22616, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_676, type_19775, type_23644, type_19728), Reflex::Literal("fillPtrVector"), method_22617, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo"), method_22618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1534), Reflex::Literal("isPresent"), method_22619, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19775), Reflex::Literal("dynamicTypeInfo_"), method_22620, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __StringMap_dict(); 
      __std__pair_pat__IsolationKeys_reco__IsoDeposit__dict(); 
      __std__pair_std__basic_string_char__std__vector_float_s__dict(); 
      __pat__CandKinResolution_dict(); 
      __std__vector_pat__CandKinResolution__dict(); 
      __pat__LookupTableRecord_dict(); 
      __std__vector_pat__LookupTableRecord__dict(); 
      __std__vector_std__pair_pat__IsolationKeys_reco__IsoDeposit_s__dict(); 
      __pat__EventHypothesis_dict(); 
      __std__vector_pat__EventHypothesis__dict(); 
      __pat__VertexAssociation_dict(); 
      __std__vector_pat__VertexAssociation__dict(); 
      __pat__TauJetCorrFactors_dict(); 
      __std__vector_pat__TauJetCorrFactors__dict(); 
      __pat__JetCorrFactors_dict(); 
      __std__vector_pat__JetCorrFactors__dict(); 
      __edm__ValueMap_pat__LookupTableRecord__dict(); 
      __edm__Wrapper_edm__ValueMap_pat__LookupTableRecord_s__dict(); 
      __edm__Wrapper_std__vector_pat__EventHypothesis_s__dict(); 
      __edm__ValueMap_pat__VertexAssociation__dict(); 
      __edm__Wrapper_edm__ValueMap_pat__VertexAssociation_s__dict(); 
      __edm__Wrapper_StringMap__dict(); 
      __edm__ValueMap_pat__TauJetCorrFactors__dict(); 
      __edm__Wrapper_edm__ValueMap_pat__TauJetCorrFactors_s__dict(); 
      __edm__ValueMap_pat__JetCorrFactors__dict(); 
      __edm__Wrapper_edm__ValueMap_pat__JetCorrFactors_s__dict(); 
      __edm__Wrapper_std__pair_std__basic_string_char__std__vector_float_s_s__dict(); 
      __edm__ValueMap_pat__CandKinResolution__dict(); 
      __std__vector_std__pair_std__basic_string_char__std__vector_float_s_s__dict(); 
      __edm__Wrapper_edm__ValueMap_pat__CandKinResolution_s__dict(); 
      __edm__Wrapper_std__vector_std__pair_std__basic_string_char__std__vector_float_s_s_s__dict(); 
      ::Reflex::EnumBuilder(Reflex::Literal("pat::IsolationKeys"),typeid(::pat::IsolationKeys), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("TrackIso"),0)
        .AddItem(Reflex::Literal("EcalIso"),1)
        .AddItem(Reflex::Literal("HcalIso"),2)
        .AddItem(Reflex::Literal("PfAllParticleIso"),3)
        .AddItem(Reflex::Literal("PfChargedHadronIso"),4)
        .AddItem(Reflex::Literal("PfNeutralHadronIso"),5)
        .AddItem(Reflex::Literal("PfGammaIso"),6)
        .AddItem(Reflex::Literal("User1Iso"),7)
        .AddItem(Reflex::Literal("User2Iso"),8)
        .AddItem(Reflex::Literal("User3Iso"),9)
        .AddItem(Reflex::Literal("User4Iso"),10)
        .AddItem(Reflex::Literal("User5Iso"),11)
        .AddItem(Reflex::Literal("UserBaseIso"),7)
        .AddItem(Reflex::Literal("CaloIso"),-1)
        .AddItem(Reflex::Literal("PfPUChargedHadronIso"),12)
        .AddItem(Reflex::Literal("PfChargedAllIso"),13);
    }
    ~Dictionaries() {
      type_2158.Unload(); // class StringMap 
      type_2915.Unload(); // class std::pair<pat::IsolationKeys,reco::IsoDeposit> 
      type_2916.Unload(); // class std::pair<std::basic_string<char>,std::vector<float> > 
      type_7721.Unload(); // class pat::CandKinResolution 
      type_2982.Unload(); // class std::vector<pat::CandKinResolution> 
      type_7723.Unload(); // class pat::LookupTableRecord 
      type_2983.Unload(); // class std::vector<pat::LookupTableRecord> 
      type_2984.Unload(); // class std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > 
      type_7728.Unload(); // class pat::EventHypothesis 
      type_2985.Unload(); // class std::vector<pat::EventHypothesis> 
      type_7720.Unload(); // class pat::VertexAssociation 
      type_2986.Unload(); // class std::vector<pat::VertexAssociation> 
      type_7727.Unload(); // class pat::TauJetCorrFactors 
      type_2987.Unload(); // class std::vector<pat::TauJetCorrFactors> 
      type_7722.Unload(); // class pat::JetCorrFactors 
      type_2988.Unload(); // class std::vector<pat::JetCorrFactors> 
      type_4668.Unload(); // class edm::ValueMap<pat::LookupTableRecord> 
      type_4652.Unload(); // class edm::Wrapper<edm::ValueMap<pat::LookupTableRecord> > 
      type_4653.Unload(); // class edm::Wrapper<std::vector<pat::EventHypothesis> > 
      type_4669.Unload(); // class edm::ValueMap<pat::VertexAssociation> 
      type_4654.Unload(); // class edm::Wrapper<edm::ValueMap<pat::VertexAssociation> > 
      type_4655.Unload(); // class edm::Wrapper<StringMap> 
      type_4670.Unload(); // class edm::ValueMap<pat::TauJetCorrFactors> 
      type_4656.Unload(); // class edm::Wrapper<edm::ValueMap<pat::TauJetCorrFactors> > 
      type_4671.Unload(); // class edm::ValueMap<pat::JetCorrFactors> 
      type_4658.Unload(); // class edm::Wrapper<edm::ValueMap<pat::JetCorrFactors> > 
      type_4661.Unload(); // class edm::Wrapper<std::pair<std::basic_string<char>,std::vector<float> > > 
      type_4667.Unload(); // class edm::ValueMap<pat::CandKinResolution> 
      type_2989.Unload(); // class std::vector<std::pair<std::basic_string<char>,std::vector<float> > > 
      type_4651.Unload(); // class edm::Wrapper<edm::ValueMap<pat::CandKinResolution> > 
      type_4660.Unload(); // class edm::Wrapper<std::vector<std::pair<std::basic_string<char>,std::vector<float> > > > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
