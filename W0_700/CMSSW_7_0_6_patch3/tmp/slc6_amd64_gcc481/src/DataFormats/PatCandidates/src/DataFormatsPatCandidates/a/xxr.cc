// Generated at Fri Dec  5 09:57:44 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/PatCandidates/src/classes_trigger.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

#include "TBuffer.h"
#include "TVirtualObject.h"
#include <vector>
#include "TSchemaHelper.h"


namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("__gnu_cxx") );
  ::Reflex::NamespaceBuilder nsb3( Reflex::Literal("pat") );
  ::Reflex::NamespaceBuilder nsb4( Reflex::Literal("edm::reftobase") );
  ::Reflex::Type type_71 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_66 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_601 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1454 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_217 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_782 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_2039 = ::Reflex::TypeBuilder(Reflex::Literal("L1GctEtHad"));
  ::Reflex::Type type_289 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_1671 = ::Reflex::TypeBuilder(Reflex::Literal("L1GctEmCand"));
  ::Reflex::Type type_1948 = ::Reflex::TypeBuilder(Reflex::Literal("L1GctEtMiss"));
  ::Reflex::Type type_923 = ::Reflex::TypeBuilder(Reflex::Literal("L1GctEtTotal"));
  ::Reflex::Type type_1611 = ::Reflex::TypeBuilder(Reflex::Literal("L1GctHtMiss"));
  ::Reflex::Type type_820 = ::Reflex::TypeBuilder(Reflex::Literal("L1GctJetCand"));
  ::Reflex::Type type_281 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_4286 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCore"));
  ::Reflex::Type type_4042 = ::Reflex::TypeBuilder(Reflex::Literal("edm::InputTag"));
  ::Reflex::Type type_414 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_192 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_4341 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_5318 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate"));
  ::Reflex::Type type_2755 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_7348 = ::Reflex::TypeBuilder(Reflex::Literal("pat::TriggerPath"));
  ::Reflex::Type type_2761 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<bool>"));
  ::Reflex::Type type_4285 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TriggerNames"));
  ::Reflex::Type type_7350 = ::Reflex::TypeBuilder(Reflex::Literal("pat::TriggerEvent"));
  ::Reflex::Type type_7357 = ::Reflex::TypeBuilder(Reflex::Literal("pat::TriggerObject"));
  ::Reflex::Type type_255 = ::Reflex::TypeBuilder(Reflex::Literal("L1MuGMTExtendedCand"));
  ::Reflex::Type type_7359 = ::Reflex::TypeBuilder(Reflex::Literal("pat::TriggerFilter"));
  ::Reflex::Type type_4152 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<int>"));
  ::Reflex::Type type_5317 = ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate"));
  ::Reflex::Type type_4336 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TriggerResults"));
  ::Reflex::Type type_4339 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EDProductGetter"));
  ::Reflex::Type type_7368 = ::Reflex::TypeBuilder(Reflex::Literal("pat::TriggerAlgorithm"));
  ::Reflex::Type type_2123 = ::Reflex::EnumTypeBuilder(Reflex::Literal("L1GtConditionType"));
  ::Reflex::Type type_7332 = ::Reflex::TypeBuilder(Reflex::Literal("pat::TriggerCondition"));
  ::Reflex::Type type_4367 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCoreWithIndex"));
  ::Reflex::Type type_7388 = ::Reflex::TypeBuilder(Reflex::Literal("trigger::TriggerObject"));
  ::Reflex::Type type_2328 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_3060 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_node_base"));
  ::Reflex::Type type_2751 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2753 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_2166 = ::Reflex::EnumTypeBuilder(Reflex::Literal("L1GtConditionCategory"));
  ::Reflex::Type type_2752 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_2760 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned short>"));
  ::Reflex::Type type_7330 = ::Reflex::TypeBuilder(Reflex::Literal("pat::PackedTriggerPrescales"));
  ::Reflex::Type type_7344 = ::Reflex::TypeBuilder(Reflex::Literal("pat::TriggerObjectStandAlone"));
  ::Reflex::Type type_2750 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::TriggerPath>"));
  ::Reflex::Type type_7391 = ::Reflex::EnumTypeBuilder(Reflex::Literal("trigger::TriggerObjectType"));
  ::Reflex::Type type_10254 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase"));
  ::Reflex::Type type_2391 = ::Reflex::TypeBuilder(Reflex::Literal("std::random_access_iterator_tag"));
  ::Reflex::Type type_4320 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<reco::Candidate>"));
  ::Reflex::Type type_2747 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::TriggerObject>"));
  ::Reflex::Type type_2748 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::TriggerFilter>"));
  ::Reflex::Type type_2448 = ::Reflex::TypeBuilder(Reflex::Literal("std::bidirectional_iterator_tag"));
  ::Reflex::Type type_4131 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<pat::TriggerEvent>"));
  ::Reflex::Type type_2945 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::TriggerPath>"));
  ::Reflex::Type type_4369 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<edm::TriggerResults>"));
  ::Reflex::Type type_2522 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<pat::TriggerEvent>"));
  ::Reflex::Type type_4296 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorBase<unsigned int>"));
  ::Reflex::Type type_2942 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::TriggerObject>"));
  ::Reflex::Type type_2745 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::TriggerAlgorithm>"));
  ::Reflex::Type type_2746 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::TriggerCondition>"));
  ::Reflex::Type type_2943 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::TriggerFilter>"));
  ::Reflex::Type type_2439 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<std::basic_string<char> >"));
  ::Reflex::Type type_4287 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolderBase"));
  ::Reflex::Type type_2756 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_2940 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::TriggerAlgorithm>"));
  ::Reflex::Type type_2941 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::TriggerCondition>"));
  ::Reflex::Type type_2758 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<trigger::TriggerObjectType>"));
  ::Reflex::Type type_2722 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<bool,std::basic_string<char> >"));
  ::Reflex::Type type_4215 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<pat::TriggerEvent>"));
  ::Reflex::Type type_2749 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>"));
  ::Reflex::Type type_4130 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<pat::PackedTriggerPrescales>"));
  ::Reflex::Type type_2521 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<pat::PackedTriggerPrescales>"));
  ::Reflex::Type type_4373 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::TriggerPath> >"));
  ::Reflex::Type type_4306 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::TriggerPath> >"));
  ::Reflex::Type type_2944 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::TriggerObjectStandAlone>"));
  ::Reflex::Type type_18280 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>"));
  ::Reflex::Type type_2538 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::RefHolderBase>"));
  ::Reflex::Type type_4137 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerPath> >"));
  ::Reflex::Type type_4372 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::TriggerFilter> >"));
  ::Reflex::Type type_4371 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::TriggerObject> >"));
  ::Reflex::Type type_2531 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::TriggerPath> >"));
  ::Reflex::Type type_2342 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::TriggerPath*>"));
  ::Reflex::Type type_4303 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::TriggerObject> >"));
  ::Reflex::Type type_4305 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::TriggerFilter> >"));
  ::Reflex::Type type_4139 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerFilter> >"));
  ::Reflex::Type type_4146 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerObject> >"));
  ::Reflex::Type type_2534 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::TriggerFilter> >"));
  ::Reflex::Type type_2546 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::TriggerObject> >"));
  ::Reflex::Type type_4200 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::TriggerPath> >"));
  ::Reflex::Type type_2346 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::TriggerObject*>"));
  ::Reflex::Type type_2343 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::TriggerFilter*>"));
  ::Reflex::Type type_4375 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::TriggerAlgorithm> >"));
  ::Reflex::Type type_4374 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::TriggerCondition> >"));
  ::Reflex::Type type_4307 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::TriggerCondition> >"));
  ::Reflex::Type type_4308 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::TriggerAlgorithm> >"));
  ::Reflex::Type type_4259 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::TriggerPath> >"));
  ::Reflex::Type type_4199 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::TriggerFilter> >"));
  ::Reflex::Type type_4198 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::TriggerObject> >"));
  ::Reflex::Type type_4133 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerAlgorithm> >"));
  ::Reflex::Type type_4135 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerCondition> >"));
  ::Reflex::Type type_4338 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Association<std::vector<pat::TriggerObject> >"));
  ::Reflex::Type type_4214 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<pat::PackedTriggerPrescales>"));
  ::Reflex::Type type_2525 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::TriggerAlgorithm> >"));
  ::Reflex::Type type_2528 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::TriggerCondition> >"));
  ::Reflex::Type type_2339 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::TriggerAlgorithm*>"));
  ::Reflex::Type type_2340 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::TriggerCondition*>"));
  ::Reflex::Type type_2536 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_4258 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::TriggerFilter> >"));
  ::Reflex::Type type_4257 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::TriggerObject> >"));
  ::Reflex::Type type_2754 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<edm::ProductID,unsigned int> >"));
  ::Reflex::Type type_4201 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::TriggerCondition> >"));
  ::Reflex::Type type_4202 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::TriggerAlgorithm> >"));
  ::Reflex::Type type_4221 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::TriggerPath> >"));
  ::Reflex::Type type_2759 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >"));
  ::Reflex::Type type_3946 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_4260 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::TriggerCondition> >"));
  ::Reflex::Type type_4261 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::TriggerAlgorithm> >"));
  ::Reflex::Type type_4223 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::TriggerFilter> >"));
  ::Reflex::Type type_4230 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::TriggerObject> >"));
  ::Reflex::Type type_4368 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_4302 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_4142 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_5701 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >"));
  ::Reflex::Type type_2541 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_2344 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::TriggerObjectStandAlone*>"));
  ::Reflex::Type type_2961 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<bool,std::basic_string<char> > >"));
  ::Reflex::Type type_4217 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::TriggerAlgorithm> >"));
  ::Reflex::Type type_4219 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::TriggerCondition> >"));
  ::Reflex::Type type_5705 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >"));
  ::Reflex::Type type_4196 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_4136 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >"));
  ::Reflex::Type type_6701 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::TriggerPath> >"));
  ::Reflex::Type type_4337 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Association<std::vector<pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_2530 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefProd<std::vector<pat::TriggerPath> > >"));
  ::Reflex::Type type_4255 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_4138 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >"));
  ::Reflex::Type type_4145 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >"));
  ::Reflex::Type type_6708 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::TriggerObject> >"));
  ::Reflex::Type type_6700 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::TriggerFilter> >"));
  ::Reflex::Type type_2533 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefProd<std::vector<pat::TriggerFilter> > >"));
  ::Reflex::Type type_2545 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefProd<std::vector<pat::TriggerObject> > >"));
  ::Reflex::Type type_4370 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<edm::Association<std::vector<pat::TriggerObject> > >"));
  ::Reflex::Type type_4132 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >"));
  ::Reflex::Type type_4134 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >"));
  ::Reflex::Type type_4304 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >"));
  ::Reflex::Type type_6704 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::TriggerAlgorithm> >"));
  ::Reflex::Type type_6703 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::TriggerCondition> >"));
  ::Reflex::Type type_4226 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_2524 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >"));
  ::Reflex::Type type_2527 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefProd<std::vector<pat::TriggerCondition> > >"));
  ::Reflex::Type type_2537 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >"));
  ::Reflex::Type type_4144 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >"));
  ::Reflex::Type type_2543 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::Association<std::vector<pat::TriggerObject> > >"));
  ::Reflex::Type type_4197 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<edm::Association<std::vector<pat::TriggerObject> > >"));
  ::Reflex::Type type_4220 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefProd<std::vector<pat::TriggerPath> > >"));
  ::Reflex::Type type_2283 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::TriggerPath,std::allocator<pat::TriggerPath> >"));
  ::Reflex::Type type_2341 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const std::pair<bool,std::basic_string<char> >*>"));
  ::Reflex::Type type_4256 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<edm::Association<std::vector<pat::TriggerObject> > >"));
  ::Reflex::Type type_4222 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefProd<std::vector<pat::TriggerFilter> > >"));
  ::Reflex::Type type_4229 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefProd<std::vector<pat::TriggerObject> > >"));
  ::Reflex::Type type_4141 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >"));
  ::Reflex::Type type_6706 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_2540 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >"));
  ::Reflex::Type type_2290 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::TriggerObject,std::allocator<pat::TriggerObject> >"));
  ::Reflex::Type type_2282 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::TriggerFilter,std::allocator<pat::TriggerFilter> >"));
  ::Reflex::Type type_4216 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >"));
  ::Reflex::Type type_4218 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefProd<std::vector<pat::TriggerCondition> > >"));
  ::Reflex::Type type_4228 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::Association<std::vector<pat::TriggerObject> > >"));
  ::Reflex::Type type_4140 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >"));
  ::Reflex::Type type_2535 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >"));
  ::Reflex::Type type_6578 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >"));
  ::Reflex::Type type_6583 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> >"));
  ::Reflex::Type type_2286 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::TriggerAlgorithm,std::allocator<pat::TriggerAlgorithm> >"));
  ::Reflex::Type type_2285 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::TriggerCondition,std::allocator<pat::TriggerCondition> >"));
  ::Reflex::Type type_4225 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >"));
  ::Reflex::Type type_15828 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath>"));
  ::Reflex::Type type_6591 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> >"));
  ::Reflex::Type type_6582 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> >"));
  ::Reflex::Type type_17533 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::TriggerPath> >"));
  ::Reflex::Type type_6575 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >"));
  ::Reflex::Type type_4224 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >"));
  ::Reflex::Type type_15816 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter>"));
  ::Reflex::Type type_17531 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::TriggerFilter> >"));
  ::Reflex::Type type_15876 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject>"));
  ::Reflex::Type type_17541 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::TriggerObject> >"));
  ::Reflex::Type type_6702 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::pair<bool,std::basic_string<char> > > >"));
  ::Reflex::Type type_6579 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >"));
  ::Reflex::Type type_6576 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >"));
  ::Reflex::Type type_6586 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >"));
  ::Reflex::Type type_6585 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> >"));
  ::Reflex::Type type_17535 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::TriggerCondition> >"));
  ::Reflex::Type type_17537 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::TriggerAlgorithm> >"));
  ::Reflex::Type type_15852 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm>"));
  ::Reflex::Type type_15840 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition>"));
  ::Reflex::Type type_2288 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::TriggerObjectStandAlone,std::allocator<pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_6572 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >"));
  ::Reflex::Type type_6573 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >"));
  ::Reflex::Type type_17539 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_2868 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >"));
  ::Reflex::Type type_2707 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >"));
  ::Reflex::Type type_6588 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_3103 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> > >"));
  ::Reflex::Type type_15864 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone>"));
  ::Reflex::Type type_3119 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> > >"));
  ::Reflex::Type type_3101 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> > >"));
  ::Reflex::Type type_2719 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >"));
  ::Reflex::Type type_6577 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_3102 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> > >"));
  ::Reflex::Type type_3118 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> > >"));
  ::Reflex::Type type_3109 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> > >"));
  ::Reflex::Type type_3107 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> > >"));
  ::Reflex::Type type_3100 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> > >"));
  ::Reflex::Type type_4143 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >"));
  ::Reflex::Type type_2542 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >"));
  ::Reflex::Type type_3108 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> > >"));
  ::Reflex::Type type_3106 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> > >"));
  ::Reflex::Type type_2284 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<bool,std::basic_string<char> >,std::allocator<std::pair<bool,std::basic_string<char> > > >"));
  ::Reflex::Type type_2959 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >"));
  ::Reflex::Type type_4227 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >"));
  ::Reflex::Type type_3113 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> > >"));
  ::Reflex::Type type_6584 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >"));
  ::Reflex::Type type_2420 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_node<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >"));
  ::Reflex::Type type_3112 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> > >"));
  ::Reflex::Type type_2819 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >"));
  ::Reflex::Type type_6574 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >"));
  ::Reflex::Type type_4347 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >"));
  ::Reflex::Type type_2928 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >"));
  ::Reflex::Type type_4054 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >"));
  ::Reflex::Type type_4345 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >"));
  ::Reflex::Type type_4344 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >"));
  ::Reflex::Type type_2721 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >,bool>"));
  ::Reflex::Type type_3105 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > > >"));
  ::Reflex::Type type_4017 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >"));
  ::Reflex::Type type_4057 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >"));
  ::Reflex::Type type_4055 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >"));
  ::Reflex::Type type_2529 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >"));
  ::Reflex::Type type_3099 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >"));
  ::Reflex::Type type_3104 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > > >"));
  ::Reflex::Type type_4343 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >"));
  ::Reflex::Type type_4342 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >"));
  ::Reflex::Type type_3986 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<l1extra::L1EmParticle>,l1extra::L1EmParticle,edm::refhelper::FindUsingAdvance<std::vector<l1extra::L1EmParticle>,l1extra::L1EmParticle> >"));
  ::Reflex::Type type_4018 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >"));
  ::Reflex::Type type_4020 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >"));
  ::Reflex::Type type_3994 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<l1extra::L1JetParticle>,l1extra::L1JetParticle,edm::refhelper::FindUsingAdvance<std::vector<l1extra::L1JetParticle>,l1extra::L1JetParticle> >"));
  ::Reflex::Type type_3098 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >"));
  ::Reflex::Type type_2532 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >"));
  ::Reflex::Type type_2544 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >"));
  ::Reflex::Type type_4052 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >"));
  ::Reflex::Type type_4053 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >"));
  ::Reflex::Type type_3989 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<l1extra::L1MuonParticle>,l1extra::L1MuonParticle,edm::refhelper::FindUsingAdvance<std::vector<l1extra::L1MuonParticle>,l1extra::L1MuonParticle> >"));
  ::Reflex::Type type_4015 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >"));
  ::Reflex::Type type_4016 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >"));
  ::Reflex::Type type_4001 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<l1extra::L1EtMissParticle>,l1extra::L1EtMissParticle,edm::refhelper::FindUsingAdvance<std::vector<l1extra::L1EtMissParticle>,l1extra::L1EtMissParticle> >"));
  ::Reflex::Type type_2523 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >"));
  ::Reflex::Type type_2526 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >"));
  ::Reflex::Type type_18282 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >"));
  ::Reflex::Type type_2866 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >"));
  ::Reflex::Type type_2713 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >"));
  ::Reflex::Type type_4346 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_2709 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >"));
  ::Reflex::Type type_18289 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >"));
  ::Reflex::Type type_17534 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >"));
  ::Reflex::Type type_4056 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_17532 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >"));
  ::Reflex::Type type_17542 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >"));
  ::Reflex::Type type_4019 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >"));
  ::Reflex::Type type_2539 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >"));
  ::Reflex::Type type_2952 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >"));
  ::Reflex::Type type_17536 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >"));
  ::Reflex::Type type_17538 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >"));
  ::Reflex::Type type_2820 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >"));
  ::Reflex::Type type_18281 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >"));
  ::Reflex::Type type_2929 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >"));
  ::Reflex::Type type_18288 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >"));
  ::Reflex::Type type_2711 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >,bool>"));
  ::Reflex::Type type_17540 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >"));
  ::Reflex::Type type_3093 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > > >"));
  ::Reflex::Type type_3092 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > > >"));
  ::Reflex::Type type_2720 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >"));
  ::Reflex::Type type_2718 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >"));
  ::Reflex::Type type_2483 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >,std::_Select1st<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >"));
  ::Reflex::Type type_2710 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > > >"));
  ::Reflex::Type type_2708 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > > >"));
  ::Reflex::Type type_2646 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>"));
  ::Reflex::Type type_2643 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>"));
  ::Reflex::Type type_2644 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>"));
  ::Reflex::Type type_2641 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>"));
  ::Reflex::Type type_2642 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>"));
  ::Reflex::Type type_2645 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>"));
  ::Reflex::Type type_2481 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >,std::_Select1st<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > > >"));
  ::Reflex::Type type_7329 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerPathRef"), type_4347);
  ::Reflex::Type type_7331 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerObjectStandAloneRefVector"), type_4056);
  ::Reflex::Type type_7333 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerFilterRef"), type_4345);
  ::Reflex::Type type_7335 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerPathRefVectorIterator"), type_4017);
  ::Reflex::Type type_7338 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerAlgorithmRefVectorIterator"), type_4015);
  ::Reflex::Type type_7339 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerPathRefProd"), type_4306);
  ::Reflex::Type type_7340 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerAlgorithmRefVector"), type_4052);
  ::Reflex::Type type_7341 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerObjectRef"), type_4344);
  ::Reflex::Type type_7342 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerConditionRef"), type_4343);
  ::Reflex::Type type_7343 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerObjectStandAloneRefProd"), type_4302);
  ::Reflex::Type type_7349 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerAlgorithmRef"), type_4342);
  ::Reflex::Type type_7351 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerConditionRefVectorIterator"), type_4016);
  ::Reflex::Type type_7352 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::L1Seed"), type_2722);
  ::Reflex::Type type_7353 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerFilterRefVectorIterator"), type_4018);
  ::Reflex::Type type_7354 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerObjectStandAloneRef"), type_4346);
  ::Reflex::Type type_7355 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerConditionRefVector"), type_4053);
  ::Reflex::Type type_7356 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerObjectRefProd"), type_4303);
  ::Reflex::Type type_7360 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerConditionRefProd"), type_4307);
  ::Reflex::Type type_7362 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerAlgorithmRefProd"), type_4308);
  ::Reflex::Type type_7363 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerObjectRefVector"), type_4057);
  ::Reflex::Type type_7364 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerObjectStandAloneRefVectorIterator"), type_4019);
  ::Reflex::Type type_7366 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerObjectRefVectorIterator"), type_4020);
  ::Reflex::Type type_7367 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerPathRefVector"), type_4054);
  ::Reflex::Type type_7369 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerFilterRefVector"), type_4055);
  ::Reflex::Type type_7373 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerFilterRefProd"), type_4305);
  ::Reflex::Type type_10923 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::TriggerAlgorithm>::const_iterator"), type_6572);
  ::Reflex::Type type_10986 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::TriggerCondition>::const_iterator"), type_6573);
  ::Reflex::Type type_11049 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::TriggerObject>::const_iterator"), type_6579);
  ::Reflex::Type type_11112 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::TriggerFilter>::const_iterator"), type_6576);
  ::Reflex::Type type_11175 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::const_iterator"), type_6577);
  ::Reflex::Type type_11238 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::TriggerPath>::const_iterator"), type_6575);
  ::Reflex::Type type_13528 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::const_iterator"), type_2928);
  ::Reflex::Type type_2329 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2328);
  ::Reflex::Type type_10919 = ::Reflex::ReferenceBuilder(type_7368);
  ::Reflex::Type type_7368c = ::Reflex::ConstBuilder(type_7368);
  ::Reflex::Type type_8858 = ::Reflex::ReferenceBuilder(type_7368c);
  ::Reflex::Type type_2329c = ::Reflex::ConstBuilder(type_2329);
  ::Reflex::Type type_4393 = ::Reflex::ReferenceBuilder(type_2329c);
  ::Reflex::Type type_2753c = ::Reflex::ConstBuilder(type_2753);
  ::Reflex::Type type_20074 = ::Reflex::ReferenceBuilder(type_2753c);
  ::Reflex::Type type_10348 = ::Reflex::PointerBuilder(type_4342);
  ::Reflex::Type type_10350 = ::Reflex::ReferenceBuilder(type_4342);
  ::Reflex::Type type_26355 = ::Reflex::ReferenceBuilder(type_2641);
  ::Reflex::Type type_2641c = ::Reflex::ConstBuilder(type_2641);
  ::Reflex::Type type_26356 = ::Reflex::ReferenceBuilder(type_2641c);
  ::Reflex::Type type_10982 = ::Reflex::ReferenceBuilder(type_7332);
  ::Reflex::Type type_7332c = ::Reflex::ConstBuilder(type_7332);
  ::Reflex::Type type_8869 = ::Reflex::ReferenceBuilder(type_7332c);
  ::Reflex::Type type_10359 = ::Reflex::PointerBuilder(type_4343);
  ::Reflex::Type type_10361 = ::Reflex::ReferenceBuilder(type_4343);
  ::Reflex::Type type_26357 = ::Reflex::ReferenceBuilder(type_2642);
  ::Reflex::Type type_2642c = ::Reflex::ConstBuilder(type_2642);
  ::Reflex::Type type_26358 = ::Reflex::ReferenceBuilder(type_2642c);
  ::Reflex::Type type_6401 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CandidateBaseRef"), type_4320);
  ::Reflex::Type type_11045 = ::Reflex::ReferenceBuilder(type_7357);
  ::Reflex::Type type_7357c = ::Reflex::ConstBuilder(type_7357);
  ::Reflex::Type type_8935 = ::Reflex::ReferenceBuilder(type_7357c);
  ::Reflex::Type type_7388c = ::Reflex::ConstBuilder(type_7388);
  ::Reflex::Type type_30881 = ::Reflex::ReferenceBuilder(type_7388c);
  ::Reflex::Type type_5317c = ::Reflex::ConstBuilder(type_5317);
  ::Reflex::Type type_29992 = ::Reflex::ReferenceBuilder(type_5317c);
  ::Reflex::Type type_6401c = ::Reflex::ConstBuilder(type_6401);
  ::Reflex::Type type_29996 = ::Reflex::ReferenceBuilder(type_6401c);
  ::Reflex::Type type_5702 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZTLorentzVectorD"), type_5701);
  ::Reflex::Type type_5743 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZTLorentzVector"), type_5702);
  ::Reflex::Type type_5743c = ::Reflex::ConstBuilder(type_5743);
  ::Reflex::Type type_28937 = ::Reflex::ReferenceBuilder(type_5743c);
  ::Reflex::Type type_5706 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::PtEtaPhiMLorentzVectorD"), type_5705);
  ::Reflex::Type type_5725 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::PtEtaPhiMLorentzVector"), type_5706);
  ::Reflex::Type type_5725c = ::Reflex::ConstBuilder(type_5725);
  ::Reflex::Type type_28939 = ::Reflex::ReferenceBuilder(type_5725c);
  ::Reflex::Type type_4042c = ::Reflex::ConstBuilder(type_4042);
  ::Reflex::Type type_18397 = ::Reflex::ReferenceBuilder(type_4042c);
  ::Reflex::Type type_5318c = ::Reflex::ConstBuilder(type_5318);
  ::Reflex::Type type_29555 = ::Reflex::PointerBuilder(type_5318c);
  ::Reflex::Type type_3987 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("l1extra::L1EmParticleRef"), type_3986);
  ::Reflex::Type type_3987c = ::Reflex::ConstBuilder(type_3987);
  ::Reflex::Type type_1671c = ::Reflex::ConstBuilder(type_1671);
  ::Reflex::Type type_3603 = ::Reflex::PointerBuilder(type_1671c);
  ::Reflex::Type type_4002 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("l1extra::L1EtMissParticleRef"), type_4001);
  ::Reflex::Type type_4002c = ::Reflex::ConstBuilder(type_4002);
  ::Reflex::Type type_1948c = ::Reflex::ConstBuilder(type_1948);
  ::Reflex::Type type_3685 = ::Reflex::PointerBuilder(type_1948c);
  ::Reflex::Type type_923c = ::Reflex::ConstBuilder(type_923);
  ::Reflex::Type type_5129 = ::Reflex::PointerBuilder(type_923c);
  ::Reflex::Type type_1611c = ::Reflex::ConstBuilder(type_1611);
  ::Reflex::Type type_3496 = ::Reflex::PointerBuilder(type_1611c);
  ::Reflex::Type type_2039c = ::Reflex::ConstBuilder(type_2039);
  ::Reflex::Type type_4869 = ::Reflex::PointerBuilder(type_2039c);
  ::Reflex::Type type_3995 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("l1extra::L1JetParticleRef"), type_3994);
  ::Reflex::Type type_3995c = ::Reflex::ConstBuilder(type_3995);
  ::Reflex::Type type_820c = ::Reflex::ConstBuilder(type_820);
  ::Reflex::Type type_5906 = ::Reflex::PointerBuilder(type_820c);
  ::Reflex::Type type_3990 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("l1extra::L1MuonParticleRef"), type_3989);
  ::Reflex::Type type_3990c = ::Reflex::ConstBuilder(type_3990);
  ::Reflex::Type type_255c = ::Reflex::ConstBuilder(type_255);
  ::Reflex::Type type_13586 = ::Reflex::PointerBuilder(type_255c);
  ::Reflex::Type type_10370 = ::Reflex::PointerBuilder(type_4344);
  ::Reflex::Type type_10372 = ::Reflex::ReferenceBuilder(type_4344);
  ::Reflex::Type type_26359 = ::Reflex::ReferenceBuilder(type_2643);
  ::Reflex::Type type_2643c = ::Reflex::ConstBuilder(type_2643);
  ::Reflex::Type type_26360 = ::Reflex::ReferenceBuilder(type_2643c);
  ::Reflex::Type type_11108 = ::Reflex::ReferenceBuilder(type_7359);
  ::Reflex::Type type_7359c = ::Reflex::ConstBuilder(type_7359);
  ::Reflex::Type type_8902 = ::Reflex::ReferenceBuilder(type_7359c);
  ::Reflex::Type type_10381 = ::Reflex::PointerBuilder(type_4345);
  ::Reflex::Type type_10383 = ::Reflex::ReferenceBuilder(type_4345);
  ::Reflex::Type type_26361 = ::Reflex::ReferenceBuilder(type_2644);
  ::Reflex::Type type_2644c = ::Reflex::ConstBuilder(type_2644);
  ::Reflex::Type type_26362 = ::Reflex::ReferenceBuilder(type_2644c);
  ::Reflex::Type type_11171 = ::Reflex::ReferenceBuilder(type_7344);
  ::Reflex::Type type_7344c = ::Reflex::ConstBuilder(type_7344);
  ::Reflex::Type type_8913 = ::Reflex::ReferenceBuilder(type_7344c);
  ::Reflex::Type type_2756c = ::Reflex::ConstBuilder(type_2756);
  ::Reflex::Type type_26474 = ::Reflex::ReferenceBuilder(type_2756c);
  ::Reflex::Type type_4285c = ::Reflex::ConstBuilder(type_4285);
  ::Reflex::Type type_29483 = ::Reflex::ReferenceBuilder(type_4285c);
  ::Reflex::Type type_10392 = ::Reflex::PointerBuilder(type_4346);
  ::Reflex::Type type_10394 = ::Reflex::ReferenceBuilder(type_4346);
  ::Reflex::Type type_26363 = ::Reflex::ReferenceBuilder(type_2645);
  ::Reflex::Type type_2645c = ::Reflex::ConstBuilder(type_2645);
  ::Reflex::Type type_26364 = ::Reflex::ReferenceBuilder(type_2645c);
  ::Reflex::Type type_7372 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::L1SeedCollection"), type_2759);
  ::Reflex::Type type_11234 = ::Reflex::ReferenceBuilder(type_7348);
  ::Reflex::Type type_7348c = ::Reflex::ConstBuilder(type_7348);
  ::Reflex::Type type_8891 = ::Reflex::ReferenceBuilder(type_7348c);
  ::Reflex::Type type_289c = ::Reflex::ConstBuilder(type_289);
  ::Reflex::Type type_7352c = ::Reflex::ConstBuilder(type_7352);
  ::Reflex::Type type_30882 = ::Reflex::ReferenceBuilder(type_7352c);
  ::Reflex::Type type_7372c = ::Reflex::ConstBuilder(type_7372);
  ::Reflex::Type type_30883 = ::Reflex::ReferenceBuilder(type_7372c);
  ::Reflex::Type type_1454c = ::Reflex::ConstBuilder(type_1454);
  ::Reflex::Type type_10403 = ::Reflex::PointerBuilder(type_4347);
  ::Reflex::Type type_10405 = ::Reflex::ReferenceBuilder(type_4347);
  ::Reflex::Type type_26365 = ::Reflex::ReferenceBuilder(type_2646);
  ::Reflex::Type type_2646c = ::Reflex::ConstBuilder(type_2646);
  ::Reflex::Type type_26366 = ::Reflex::ReferenceBuilder(type_2646c);
  ::Reflex::Type type_8063 = ::Reflex::PointerBuilder(type_7357);
  ::Reflex::Type type_8933 = ::Reflex::PointerBuilder(type_7357c);
  ::Reflex::Type type_2926 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_281);
  ::Reflex::Type type_2844 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_66);
  ::Reflex::Type type_2942c = ::Reflex::ConstBuilder(type_2942);
  ::Reflex::Type type_25589 = ::Reflex::ReferenceBuilder(type_2942c);
  ::Reflex::Type type_2747c = ::Reflex::ConstBuilder(type_2747);
  ::Reflex::Type type_15881 = ::Reflex::ReferenceBuilder(type_2747c);
  ::Reflex::Type type_26461 = ::Reflex::ReferenceBuilder(type_2747);
  ::Reflex::Type type_4338c = ::Reflex::ConstBuilder(type_4338);
  ::Reflex::Type type_29444 = ::Reflex::ReferenceBuilder(type_4338c);
  ::Reflex::Type type_1924 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_281);
  ::Reflex::Type type_29573 = ::Reflex::ReferenceBuilder(type_4338);
  ::Reflex::Type type_4303c = ::Reflex::ConstBuilder(type_4303);
  ::Reflex::Type type_29535 = ::Reflex::ReferenceBuilder(type_4303c);
  ::Reflex::Type type_2754c = ::Reflex::ConstBuilder(type_2754);
  ::Reflex::Type type_26470 = ::Reflex::ReferenceBuilder(type_2754c);
  ::Reflex::Type type_26446 = ::Reflex::ReferenceBuilder(type_2707);
  ::Reflex::Type type_2707c = ::Reflex::ConstBuilder(type_2707);
  ::Reflex::Type type_26447 = ::Reflex::ReferenceBuilder(type_2707c);
  ::Reflex::Type type_2328c = ::Reflex::ConstBuilder(type_2328);
  ::Reflex::Type type_8978 = ::Reflex::ReferenceBuilder(type_2328c);
  ::Reflex::Type type_4304c = ::Reflex::ConstBuilder(type_4304);
  ::Reflex::Type type_26448 = ::Reflex::ReferenceBuilder(type_4304c);
  ::Reflex::Type type_7989 = ::Reflex::PointerBuilder(type_7368);
  ::Reflex::Type type_8856 = ::Reflex::PointerBuilder(type_7368c);
  ::Reflex::Type type_2940c = ::Reflex::ConstBuilder(type_2940);
  ::Reflex::Type type_25537 = ::Reflex::ReferenceBuilder(type_2940c);
  ::Reflex::Type type_2745c = ::Reflex::ConstBuilder(type_2745);
  ::Reflex::Type type_15857 = ::Reflex::ReferenceBuilder(type_2745c);
  ::Reflex::Type type_26459 = ::Reflex::ReferenceBuilder(type_2745);
  ::Reflex::Type type_7970 = ::Reflex::PointerBuilder(type_7332);
  ::Reflex::Type type_8867 = ::Reflex::PointerBuilder(type_7332c);
  ::Reflex::Type type_2941c = ::Reflex::ConstBuilder(type_2941);
  ::Reflex::Type type_25524 = ::Reflex::ReferenceBuilder(type_2941c);
  ::Reflex::Type type_2746c = ::Reflex::ConstBuilder(type_2746);
  ::Reflex::Type type_15845 = ::Reflex::ReferenceBuilder(type_2746c);
  ::Reflex::Type type_26460 = ::Reflex::ReferenceBuilder(type_2746);
  ::Reflex::Type type_7913 = ::Reflex::PointerBuilder(type_7359);
  ::Reflex::Type type_8900 = ::Reflex::PointerBuilder(type_7359c);
  ::Reflex::Type type_2943c = ::Reflex::ConstBuilder(type_2943);
  ::Reflex::Type type_25485 = ::Reflex::ReferenceBuilder(type_2943c);
  ::Reflex::Type type_2748c = ::Reflex::ConstBuilder(type_2748);
  ::Reflex::Type type_15821 = ::Reflex::ReferenceBuilder(type_2748c);
  ::Reflex::Type type_26462 = ::Reflex::ReferenceBuilder(type_2748);
  ::Reflex::Type type_8026 = ::Reflex::PointerBuilder(type_7344);
  ::Reflex::Type type_8911 = ::Reflex::PointerBuilder(type_7344c);
  ::Reflex::Type type_2944c = ::Reflex::ConstBuilder(type_2944);
  ::Reflex::Type type_25563 = ::Reflex::ReferenceBuilder(type_2944c);
  ::Reflex::Type type_2749c = ::Reflex::ConstBuilder(type_2749);
  ::Reflex::Type type_15869 = ::Reflex::ReferenceBuilder(type_2749c);
  ::Reflex::Type type_26463 = ::Reflex::ReferenceBuilder(type_2749);
  ::Reflex::Type type_7932 = ::Reflex::PointerBuilder(type_7348);
  ::Reflex::Type type_8889 = ::Reflex::PointerBuilder(type_7348c);
  ::Reflex::Type type_2945c = ::Reflex::ConstBuilder(type_2945);
  ::Reflex::Type type_25498 = ::Reflex::ReferenceBuilder(type_2945c);
  ::Reflex::Type type_2750c = ::Reflex::ConstBuilder(type_2750);
  ::Reflex::Type type_15833 = ::Reflex::ReferenceBuilder(type_2750c);
  ::Reflex::Type type_26464 = ::Reflex::ReferenceBuilder(type_2750);
  ::Reflex::Type type_9888 = ::Reflex::PointerBuilder(type_2719);
  ::Reflex::Type type_2719c = ::Reflex::ConstBuilder(type_2719);
  ::Reflex::Type type_9890 = ::Reflex::PointerBuilder(type_2719c);
  ::Reflex::Type type_9892 = ::Reflex::ReferenceBuilder(type_2719);
  ::Reflex::Type type_9894 = ::Reflex::ReferenceBuilder(type_2719c);
  ::Reflex::Type type_2439c = ::Reflex::ConstBuilder(type_2439);
  ::Reflex::Type type_26205 = ::Reflex::ReferenceBuilder(type_2439c);
  ::Reflex::Type type_2959c = ::Reflex::ConstBuilder(type_2959);
  ::Reflex::Type type_26290 = ::Reflex::ReferenceBuilder(type_2959c);
  ::Reflex::Type type_2868c = ::Reflex::ConstBuilder(type_2868);
  ::Reflex::Type type_26605 = ::Reflex::ReferenceBuilder(type_2868c);
  ::Reflex::Type type_26606 = ::Reflex::ReferenceBuilder(type_2868);
  ::Reflex::Type type_26607 = ::Reflex::ReferenceBuilder(type_4304);
  ::Reflex::Type type_30877 = ::Reflex::PointerBuilder(type_4285c);
  ::Reflex::Type type_30878 = ::Reflex::ReferenceBuilder(type_7330);
  ::Reflex::Type type_7330c = ::Reflex::ConstBuilder(type_7330);
  ::Reflex::Type type_30879 = ::Reflex::ReferenceBuilder(type_7330c);
  ::Reflex::Type type_4369c = ::Reflex::ConstBuilder(type_4369);
  ::Reflex::Type type_30880 = ::Reflex::ReferenceBuilder(type_4369c);
  ::Reflex::Type type_4336c = ::Reflex::ConstBuilder(type_4336);
  ::Reflex::Type type_29570 = ::Reflex::ReferenceBuilder(type_4336c);
  ::Reflex::Type type_29235 = ::Reflex::PointerBuilder(type_7330c);
  ::Reflex::Type type_414c = ::Reflex::ConstBuilder(type_414);
  ::Reflex::Type type_15648 = ::Reflex::ReferenceBuilder(type_414c);
  ::Reflex::Type type_29236 = ::Reflex::PointerBuilder(type_7330);
  ::Reflex::Type type_4214c = ::Reflex::ConstBuilder(type_4214);
  ::Reflex::Type type_29237 = ::Reflex::PointerBuilder(type_4214c);
  ::Reflex::Type type_4341c = ::Reflex::ConstBuilder(type_4341);
  ::Reflex::Type type_15634 = ::Reflex::ReferenceBuilder(type_4341c);
  ::Reflex::Type type_26466 = ::Reflex::ReferenceBuilder(type_2751);
  ::Reflex::Type type_28869 = ::Reflex::ReferenceBuilder(type_3946);
  ::Reflex::Type type_601c = ::Reflex::ConstBuilder(type_601);
  ::Reflex::Type type_3434 = ::Reflex::PointerBuilder(type_601c);
  ::Reflex::Type type_9167 = ::Reflex::ReferenceBuilder(type_3434);
  ::Reflex::Type type_2752c = ::Reflex::ConstBuilder(type_2752);
  ::Reflex::Type type_26467 = ::Reflex::ReferenceBuilder(type_2752c);
  ::Reflex::Type type_1418 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint32_t"), type_289);
  ::Reflex::Type type_1624 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint16_t"), type_192);
  ::Reflex::Type type_7370 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerObjectMatchContainer"), type_2868);
  ::Reflex::Type type_30884 = ::Reflex::ReferenceBuilder(type_7350);
  ::Reflex::Type type_7350c = ::Reflex::ConstBuilder(type_7350);
  ::Reflex::Type type_30885 = ::Reflex::ReferenceBuilder(type_7350c);
  ::Reflex::Type type_4375c = ::Reflex::ConstBuilder(type_4375);
  ::Reflex::Type type_29549 = ::Reflex::ReferenceBuilder(type_4375c);
  ::Reflex::Type type_7336 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerAlgorithmCollection"), type_2745);
  ::Reflex::Type type_7336c = ::Reflex::ConstBuilder(type_7336);
  ::Reflex::Type type_30886 = ::Reflex::PointerBuilder(type_7336c);
  ::Reflex::Type type_7340c = ::Reflex::ConstBuilder(type_7340);
  ::Reflex::Type type_7349c = ::Reflex::ConstBuilder(type_7349);
  ::Reflex::Type type_4374c = ::Reflex::ConstBuilder(type_4374);
  ::Reflex::Type type_29546 = ::Reflex::ReferenceBuilder(type_4374c);
  ::Reflex::Type type_7371 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerConditionCollection"), type_2746);
  ::Reflex::Type type_7371c = ::Reflex::ConstBuilder(type_7371);
  ::Reflex::Type type_30889 = ::Reflex::PointerBuilder(type_7371c);
  ::Reflex::Type type_7355c = ::Reflex::ConstBuilder(type_7355);
  ::Reflex::Type type_7342c = ::Reflex::ConstBuilder(type_7342);
  ::Reflex::Type type_4373c = ::Reflex::ConstBuilder(type_4373);
  ::Reflex::Type type_29543 = ::Reflex::ReferenceBuilder(type_4373c);
  ::Reflex::Type type_7361 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerPathCollection"), type_2750);
  ::Reflex::Type type_7361c = ::Reflex::ConstBuilder(type_7361);
  ::Reflex::Type type_30892 = ::Reflex::PointerBuilder(type_7361c);
  ::Reflex::Type type_7367c = ::Reflex::ConstBuilder(type_7367);
  ::Reflex::Type type_7329c = ::Reflex::ConstBuilder(type_7329);
  ::Reflex::Type type_4372c = ::Reflex::ConstBuilder(type_4372);
  ::Reflex::Type type_29540 = ::Reflex::ReferenceBuilder(type_4372c);
  ::Reflex::Type type_7345 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerFilterCollection"), type_2748);
  ::Reflex::Type type_7345c = ::Reflex::ConstBuilder(type_7345);
  ::Reflex::Type type_30895 = ::Reflex::PointerBuilder(type_7345c);
  ::Reflex::Type type_7369c = ::Reflex::ConstBuilder(type_7369);
  ::Reflex::Type type_7333c = ::Reflex::ConstBuilder(type_7333);
  ::Reflex::Type type_4371c = ::Reflex::ConstBuilder(type_4371);
  ::Reflex::Type type_29536 = ::Reflex::ReferenceBuilder(type_4371c);
  ::Reflex::Type type_7365 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerObjectCollection"), type_2747);
  ::Reflex::Type type_7365c = ::Reflex::ConstBuilder(type_7365);
  ::Reflex::Type type_30898 = ::Reflex::PointerBuilder(type_7365c);
  ::Reflex::Type type_7363c = ::Reflex::ConstBuilder(type_7363);
  ::Reflex::Type type_30900 = ::Reflex::ReferenceBuilder(type_7342c);
  ::Reflex::Type type_7341c = ::Reflex::ConstBuilder(type_7341);
  ::Reflex::Type type_30901 = ::Reflex::ReferenceBuilder(type_7341c);
  ::Reflex::Type type_30902 = ::Reflex::ReferenceBuilder(type_7333c);
  ::Reflex::Type type_7337 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerObjectMatchRefProd"), type_4304);
  ::Reflex::Type type_7337c = ::Reflex::ConstBuilder(type_7337);
  ::Reflex::Type type_30903 = ::Reflex::ReferenceBuilder(type_7337c);
  ::Reflex::Type type_4370c = ::Reflex::ConstBuilder(type_4370);
  ::Reflex::Type type_29537 = ::Reflex::ReferenceBuilder(type_4370c);
  ::Reflex::Type type_4256c = ::Reflex::ConstBuilder(type_4256);
  ::Reflex::Type type_29471 = ::Reflex::ReferenceBuilder(type_4256c);
  ::Reflex::Type type_7370c = ::Reflex::ConstBuilder(type_7370);
  ::Reflex::Type type_30904 = ::Reflex::PointerBuilder(type_7370c);
  ::Reflex::Type type_7358 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TriggerObjectMatch"), type_4338);
  ::Reflex::Type type_7358c = ::Reflex::ConstBuilder(type_7358);
  ::Reflex::Type type_30905 = ::Reflex::PointerBuilder(type_7358c);
  ::Reflex::Type type_29240 = ::Reflex::PointerBuilder(type_7350c);
  ::Reflex::Type type_29241 = ::Reflex::PointerBuilder(type_7350);
  ::Reflex::Type type_4215c = ::Reflex::ConstBuilder(type_4215);
  ::Reflex::Type type_29242 = ::Reflex::PointerBuilder(type_4215c);
  ::Reflex::Type type_29213 = ::Reflex::PointerBuilder(type_2745c);
  ::Reflex::Type type_29250 = ::Reflex::PointerBuilder(type_2745);
  ::Reflex::Type type_4217c = ::Reflex::ConstBuilder(type_4217);
  ::Reflex::Type type_29251 = ::Reflex::PointerBuilder(type_4217c);
  ::Reflex::Type type_29218 = ::Reflex::PointerBuilder(type_2746c);
  ::Reflex::Type type_29259 = ::Reflex::PointerBuilder(type_2746);
  ::Reflex::Type type_4219c = ::Reflex::ConstBuilder(type_4219);
  ::Reflex::Type type_29260 = ::Reflex::PointerBuilder(type_4219c);
  ::Reflex::Type type_29222 = ::Reflex::PointerBuilder(type_2750c);
  ::Reflex::Type type_29268 = ::Reflex::PointerBuilder(type_2750);
  ::Reflex::Type type_4221c = ::Reflex::ConstBuilder(type_4221);
  ::Reflex::Type type_29269 = ::Reflex::PointerBuilder(type_4221c);
  ::Reflex::Type type_29226 = ::Reflex::PointerBuilder(type_2748c);
  ::Reflex::Type type_29277 = ::Reflex::PointerBuilder(type_2748);
  ::Reflex::Type type_4223c = ::Reflex::ConstBuilder(type_4223);
  ::Reflex::Type type_29278 = ::Reflex::PointerBuilder(type_4223c);
  ::Reflex::Type type_4337c = ::Reflex::ConstBuilder(type_4337);
  ::Reflex::Type type_29571 = ::Reflex::ReferenceBuilder(type_4337c);
  ::Reflex::Type type_29572 = ::Reflex::ReferenceBuilder(type_4337);
  ::Reflex::Type type_4302c = ::Reflex::ConstBuilder(type_4302);
  ::Reflex::Type type_29530 = ::Reflex::ReferenceBuilder(type_4302c);
  ::Reflex::Type type_29281 = ::Reflex::PointerBuilder(type_4337c);
  ::Reflex::Type type_29282 = ::Reflex::PointerBuilder(type_4337);
  ::Reflex::Type type_4224c = ::Reflex::ConstBuilder(type_4224);
  ::Reflex::Type type_29283 = ::Reflex::PointerBuilder(type_4224c);
  ::Reflex::Type type_29230 = ::Reflex::PointerBuilder(type_2749c);
  ::Reflex::Type type_29291 = ::Reflex::PointerBuilder(type_2749);
  ::Reflex::Type type_4226c = ::Reflex::ConstBuilder(type_4226);
  ::Reflex::Type type_29292 = ::Reflex::PointerBuilder(type_4226c);
  ::Reflex::Type type_29295 = ::Reflex::PointerBuilder(type_2868c);
  ::Reflex::Type type_29296 = ::Reflex::PointerBuilder(type_2868);
  ::Reflex::Type type_4227c = ::Reflex::ConstBuilder(type_4227);
  ::Reflex::Type type_29297 = ::Reflex::PointerBuilder(type_4227c);
  ::Reflex::Type type_29300 = ::Reflex::PointerBuilder(type_4338c);
  ::Reflex::Type type_29301 = ::Reflex::PointerBuilder(type_4338);
  ::Reflex::Type type_4228c = ::Reflex::ConstBuilder(type_4228);
  ::Reflex::Type type_29302 = ::Reflex::PointerBuilder(type_4228c);
  ::Reflex::Type type_29233 = ::Reflex::PointerBuilder(type_2747c);
  ::Reflex::Type type_29310 = ::Reflex::PointerBuilder(type_2747);
  ::Reflex::Type type_4230c = ::Reflex::ConstBuilder(type_4230);
  ::Reflex::Type type_29311 = ::Reflex::PointerBuilder(type_4230c);
  ::Reflex::Type type_4197c = ::Reflex::ConstBuilder(type_4197);
  ::Reflex::Type type_29443 = ::Reflex::ReferenceBuilder(type_4197c);
  ::Reflex::Type type_4339c = ::Reflex::ConstBuilder(type_4339);
  ::Reflex::Type type_19013 = ::Reflex::PointerBuilder(type_4339c);
  ::Reflex::Type type_4286c = ::Reflex::ConstBuilder(type_4286);
  ::Reflex::Type type_17508 = ::Reflex::ReferenceBuilder(type_4286c);
  ::Reflex::Type type_4347c = ::Reflex::ConstBuilder(type_4347);
  ::Reflex::Type type_29221 = ::Reflex::ReferenceBuilder(type_4347c);
  ::Reflex::Type type_4259c = ::Reflex::ConstBuilder(type_4259);
  ::Reflex::Type type_29477 = ::Reflex::ReferenceBuilder(type_4259c);
  ::Reflex::Type type_4054c = ::Reflex::ConstBuilder(type_4054);
  ::Reflex::Type type_29220 = ::Reflex::ReferenceBuilder(type_4054c);
  ::Reflex::Type type_4200c = ::Reflex::ConstBuilder(type_4200);
  ::Reflex::Type type_29450 = ::Reflex::ReferenceBuilder(type_4200c);
  ::Reflex::Type type_4306c = ::Reflex::ConstBuilder(type_4306);
  ::Reflex::Type type_29542 = ::Reflex::ReferenceBuilder(type_4306c);
  ::Reflex::Type type_8924 = ::Reflex::ReferenceBuilder(type_289c);
  ::Reflex::Type type_4346c = ::Reflex::ConstBuilder(type_4346);
  ::Reflex::Type type_4056c = ::Reflex::ConstBuilder(type_4056);
  ::Reflex::Type type_29228 = ::Reflex::ReferenceBuilder(type_4056c);
  ::Reflex::Type type_29229 = ::Reflex::ReferenceBuilder(type_4346c);
  ::Reflex::Type type_4296c = ::Reflex::ConstBuilder(type_4296);
  ::Reflex::Type type_29212 = ::Reflex::ReferenceBuilder(type_4296c);
  ::Reflex::Type type_4019c = ::Reflex::ConstBuilder(type_4019);
  ::Reflex::Type type_28980 = ::Reflex::ReferenceBuilder(type_4019c);
  ::Reflex::Type type_29231 = ::Reflex::ReferenceBuilder(type_4056);
  ::Reflex::Type type_4288 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::helper_vector"), type_4287);
  ::Reflex::Type type_29215 = ::Reflex::ReferenceBuilder(type_4288);
  ::Reflex::Type type_4345c = ::Reflex::ConstBuilder(type_4345);
  ::Reflex::Type type_29225 = ::Reflex::ReferenceBuilder(type_4345c);
  ::Reflex::Type type_4258c = ::Reflex::ConstBuilder(type_4258);
  ::Reflex::Type type_29475 = ::Reflex::ReferenceBuilder(type_4258c);
  ::Reflex::Type type_4055c = ::Reflex::ConstBuilder(type_4055);
  ::Reflex::Type type_29224 = ::Reflex::ReferenceBuilder(type_4055c);
  ::Reflex::Type type_4199c = ::Reflex::ConstBuilder(type_4199);
  ::Reflex::Type type_29448 = ::Reflex::ReferenceBuilder(type_4199c);
  ::Reflex::Type type_4305c = ::Reflex::ConstBuilder(type_4305);
  ::Reflex::Type type_29539 = ::Reflex::ReferenceBuilder(type_4305c);
  ::Reflex::Type type_28973 = ::Reflex::ReferenceBuilder(type_4017);
  ::Reflex::Type type_4017c = ::Reflex::ConstBuilder(type_4017);
  ::Reflex::Type type_28974 = ::Reflex::ReferenceBuilder(type_4017c);
  ::Reflex::Type type_6578c = ::Reflex::ConstBuilder(type_6578);
  ::Reflex::Type type_28968 = ::Reflex::ReferenceBuilder(type_6578c);
  ::Reflex::Type type_4342c = ::Reflex::ConstBuilder(type_4342);
  ::Reflex::Type type_28966 = ::Reflex::ReferenceBuilder(type_4015);
  ::Reflex::Type type_4015c = ::Reflex::ConstBuilder(type_4015);
  ::Reflex::Type type_28967 = ::Reflex::ReferenceBuilder(type_4015c);
  ::Reflex::Type type_29541 = ::Reflex::ReferenceBuilder(type_4306);
  ::Reflex::Type type_4052c = ::Reflex::ConstBuilder(type_4052);
  ::Reflex::Type type_29210 = ::Reflex::ReferenceBuilder(type_4052c);
  ::Reflex::Type type_29211 = ::Reflex::ReferenceBuilder(type_4342c);
  ::Reflex::Type type_29214 = ::Reflex::ReferenceBuilder(type_4052);
  ::Reflex::Type type_4344c = ::Reflex::ConstBuilder(type_4344);
  ::Reflex::Type type_26451 = ::Reflex::ReferenceBuilder(type_4344c);
  ::Reflex::Type type_4257c = ::Reflex::ConstBuilder(type_4257);
  ::Reflex::Type type_29473 = ::Reflex::ReferenceBuilder(type_4257c);
  ::Reflex::Type type_4057c = ::Reflex::ConstBuilder(type_4057);
  ::Reflex::Type type_29232 = ::Reflex::ReferenceBuilder(type_4057c);
  ::Reflex::Type type_4198c = ::Reflex::ConstBuilder(type_4198);
  ::Reflex::Type type_29446 = ::Reflex::ReferenceBuilder(type_4198c);
  ::Reflex::Type type_4343c = ::Reflex::ConstBuilder(type_4343);
  ::Reflex::Type type_29217 = ::Reflex::ReferenceBuilder(type_4343c);
  ::Reflex::Type type_4260c = ::Reflex::ConstBuilder(type_4260);
  ::Reflex::Type type_29479 = ::Reflex::ReferenceBuilder(type_4260c);
  ::Reflex::Type type_4053c = ::Reflex::ConstBuilder(type_4053);
  ::Reflex::Type type_29216 = ::Reflex::ReferenceBuilder(type_4053c);
  ::Reflex::Type type_4201c = ::Reflex::ConstBuilder(type_4201);
  ::Reflex::Type type_29452 = ::Reflex::ReferenceBuilder(type_4201c);
  ::Reflex::Type type_4307c = ::Reflex::ConstBuilder(type_4307);
  ::Reflex::Type type_29545 = ::Reflex::ReferenceBuilder(type_4307c);
  ::Reflex::Type type_29529 = ::Reflex::ReferenceBuilder(type_4302);
  ::Reflex::Type type_4368c = ::Reflex::ConstBuilder(type_4368);
  ::Reflex::Type type_29531 = ::Reflex::ReferenceBuilder(type_4368c);
  ::Reflex::Type type_4255c = ::Reflex::ConstBuilder(type_4255);
  ::Reflex::Type type_29532 = ::Reflex::ReferenceBuilder(type_4255c);
  ::Reflex::Type type_4196c = ::Reflex::ConstBuilder(type_4196);
  ::Reflex::Type type_29533 = ::Reflex::ReferenceBuilder(type_4196c);
  ::Reflex::Type type_4261c = ::Reflex::ConstBuilder(type_4261);
  ::Reflex::Type type_29481 = ::Reflex::ReferenceBuilder(type_4261c);
  ::Reflex::Type type_4202c = ::Reflex::ConstBuilder(type_4202);
  ::Reflex::Type type_29454 = ::Reflex::ReferenceBuilder(type_4202c);
  ::Reflex::Type type_4308c = ::Reflex::ConstBuilder(type_4308);
  ::Reflex::Type type_29548 = ::Reflex::ReferenceBuilder(type_4308c);
  ::Reflex::Type type_28970 = ::Reflex::ReferenceBuilder(type_4016);
  ::Reflex::Type type_4016c = ::Reflex::ConstBuilder(type_4016);
  ::Reflex::Type type_28971 = ::Reflex::ReferenceBuilder(type_4016c);
  ::Reflex::Type type_11802 = ::Reflex::ReferenceBuilder(type_2722);
  ::Reflex::Type type_2722c = ::Reflex::ConstBuilder(type_2722);
  ::Reflex::Type type_8880 = ::Reflex::ReferenceBuilder(type_2722c);
  ::Reflex::Type type_14138 = ::Reflex::ReferenceBuilder(type_1454c);
  ::Reflex::Type type_28976 = ::Reflex::ReferenceBuilder(type_4018);
  ::Reflex::Type type_4018c = ::Reflex::ConstBuilder(type_4018);
  ::Reflex::Type type_28977 = ::Reflex::ReferenceBuilder(type_4018c);
  ::Reflex::Type type_29219 = ::Reflex::ReferenceBuilder(type_4053);
  ::Reflex::Type type_29534 = ::Reflex::ReferenceBuilder(type_4303);
  ::Reflex::Type type_29544 = ::Reflex::ReferenceBuilder(type_4307);
  ::Reflex::Type type_29547 = ::Reflex::ReferenceBuilder(type_4308);
  ::Reflex::Type type_4020c = ::Reflex::ConstBuilder(type_4020);
  ::Reflex::Type type_28983 = ::Reflex::ReferenceBuilder(type_4020c);
  ::Reflex::Type type_29234 = ::Reflex::ReferenceBuilder(type_4057);
  ::Reflex::Type type_28979 = ::Reflex::ReferenceBuilder(type_4019);
  ::Reflex::Type type_28982 = ::Reflex::ReferenceBuilder(type_4020);
  ::Reflex::Type type_29223 = ::Reflex::ReferenceBuilder(type_4054);
  ::Reflex::Type type_29227 = ::Reflex::ReferenceBuilder(type_4055);
  ::Reflex::Type type_29538 = ::Reflex::ReferenceBuilder(type_4305);
  ::Reflex::Type type_30211 = ::Reflex::ReferenceBuilder(type_6572);
  ::Reflex::Type type_6572c = ::Reflex::ConstBuilder(type_6572);
  ::Reflex::Type type_30212 = ::Reflex::ReferenceBuilder(type_6572c);
  ::Reflex::Type type_8856c = ::Reflex::ConstBuilder(type_8856);
  ::Reflex::Type type_30213 = ::Reflex::ReferenceBuilder(type_8856c);
  ::Reflex::Type type_2844c = ::Reflex::ConstBuilder(type_2844);
  ::Reflex::Type type_30214 = ::Reflex::ReferenceBuilder(type_2844c);
  ::Reflex::Type type_30215 = ::Reflex::ReferenceBuilder(type_6573);
  ::Reflex::Type type_6573c = ::Reflex::ConstBuilder(type_6573);
  ::Reflex::Type type_30216 = ::Reflex::ReferenceBuilder(type_6573c);
  ::Reflex::Type type_8867c = ::Reflex::ConstBuilder(type_8867);
  ::Reflex::Type type_30217 = ::Reflex::ReferenceBuilder(type_8867c);
  ::Reflex::Type type_30232 = ::Reflex::ReferenceBuilder(type_6579);
  ::Reflex::Type type_6579c = ::Reflex::ConstBuilder(type_6579);
  ::Reflex::Type type_30233 = ::Reflex::ReferenceBuilder(type_6579c);
  ::Reflex::Type type_8933c = ::Reflex::ConstBuilder(type_8933);
  ::Reflex::Type type_30234 = ::Reflex::ReferenceBuilder(type_8933c);
  ::Reflex::Type type_30224 = ::Reflex::ReferenceBuilder(type_6576);
  ::Reflex::Type type_6576c = ::Reflex::ConstBuilder(type_6576);
  ::Reflex::Type type_30225 = ::Reflex::ReferenceBuilder(type_6576c);
  ::Reflex::Type type_8900c = ::Reflex::ConstBuilder(type_8900);
  ::Reflex::Type type_30226 = ::Reflex::ReferenceBuilder(type_8900c);
  ::Reflex::Type type_30227 = ::Reflex::ReferenceBuilder(type_6577);
  ::Reflex::Type type_6577c = ::Reflex::ConstBuilder(type_6577);
  ::Reflex::Type type_30228 = ::Reflex::ReferenceBuilder(type_6577c);
  ::Reflex::Type type_8911c = ::Reflex::ConstBuilder(type_8911);
  ::Reflex::Type type_30229 = ::Reflex::ReferenceBuilder(type_8911c);
  ::Reflex::Type type_30221 = ::Reflex::ReferenceBuilder(type_6575);
  ::Reflex::Type type_6575c = ::Reflex::ConstBuilder(type_6575);
  ::Reflex::Type type_30222 = ::Reflex::ReferenceBuilder(type_6575c);
  ::Reflex::Type type_8889c = ::Reflex::ConstBuilder(type_8889);
  ::Reflex::Type type_30223 = ::Reflex::ReferenceBuilder(type_8889c);
  ::Reflex::Type type_3060c = ::Reflex::ConstBuilder(type_3060);
  ::Reflex::Type type_9666 = ::Reflex::PointerBuilder(type_3060c);
  ::Reflex::Type type_2420c = ::Reflex::ConstBuilder(type_2420);
  ::Reflex::Type type_9898 = ::Reflex::PointerBuilder(type_2420c);
  ::Reflex::Type type_26656 = ::Reflex::ReferenceBuilder(type_2928);
  ::Reflex::Type type_2928c = ::Reflex::ConstBuilder(type_2928);
  ::Reflex::Type type_26657 = ::Reflex::ReferenceBuilder(type_2928c);
  ::Reflex::Type type_2819c = ::Reflex::ConstBuilder(type_2819);
  ::Reflex::Type type_26658 = ::Reflex::ReferenceBuilder(type_2819c);
  ::Reflex::Type type_26449 = ::Reflex::ReferenceBuilder(type_2713);
  ::Reflex::Type type_2713c = ::Reflex::ConstBuilder(type_2713);
  ::Reflex::Type type_26450 = ::Reflex::ReferenceBuilder(type_2713c);
  ::Reflex::Type type_7951 = ::Reflex::PointerBuilder(type_2722);
  ::Reflex::Type type_8878 = ::Reflex::PointerBuilder(type_2722c);
  ::Reflex::Type type_2961c = ::Reflex::ConstBuilder(type_2961);
  ::Reflex::Type type_25511 = ::Reflex::ReferenceBuilder(type_2961c);
  ::Reflex::Type type_2759c = ::Reflex::ConstBuilder(type_2759);
  ::Reflex::Type type_26482 = ::Reflex::ReferenceBuilder(type_2759c);
  ::Reflex::Type type_26483 = ::Reflex::ReferenceBuilder(type_2759);
  ::Reflex::Type type_9670 = ::Reflex::PointerBuilder(type_2709);
  ::Reflex::Type type_2709c = ::Reflex::ConstBuilder(type_2709);
  ::Reflex::Type type_9672 = ::Reflex::PointerBuilder(type_2709c);
  ::Reflex::Type type_9674 = ::Reflex::ReferenceBuilder(type_2709);
  ::Reflex::Type type_9676 = ::Reflex::ReferenceBuilder(type_2709c);
  ::Reflex::Type type_2952c = ::Reflex::ConstBuilder(type_2952);
  ::Reflex::Type type_26276 = ::Reflex::ReferenceBuilder(type_2952c);
  ::Reflex::Type type_2866c = ::Reflex::ConstBuilder(type_2866);
  ::Reflex::Type type_26601 = ::Reflex::ReferenceBuilder(type_2866c);
  ::Reflex::Type type_26602 = ::Reflex::ReferenceBuilder(type_2866);
  ::Reflex::Type type_29245 = ::Reflex::PointerBuilder(type_4308c);
  ::Reflex::Type type_29246 = ::Reflex::PointerBuilder(type_4308);
  ::Reflex::Type type_4216c = ::Reflex::ConstBuilder(type_4216);
  ::Reflex::Type type_29247 = ::Reflex::PointerBuilder(type_4216c);
  ::Reflex::Type type_29254 = ::Reflex::PointerBuilder(type_4307c);
  ::Reflex::Type type_29255 = ::Reflex::PointerBuilder(type_4307);
  ::Reflex::Type type_4218c = ::Reflex::ConstBuilder(type_4218);
  ::Reflex::Type type_29256 = ::Reflex::PointerBuilder(type_4218c);
  ::Reflex::Type type_29263 = ::Reflex::PointerBuilder(type_4306c);
  ::Reflex::Type type_29264 = ::Reflex::PointerBuilder(type_4306);
  ::Reflex::Type type_4220c = ::Reflex::ConstBuilder(type_4220);
  ::Reflex::Type type_29265 = ::Reflex::PointerBuilder(type_4220c);
  ::Reflex::Type type_29272 = ::Reflex::PointerBuilder(type_4305c);
  ::Reflex::Type type_29273 = ::Reflex::PointerBuilder(type_4305);
  ::Reflex::Type type_4222c = ::Reflex::ConstBuilder(type_4222);
  ::Reflex::Type type_29274 = ::Reflex::PointerBuilder(type_4222c);
  ::Reflex::Type type_29286 = ::Reflex::PointerBuilder(type_4302c);
  ::Reflex::Type type_29287 = ::Reflex::PointerBuilder(type_4302);
  ::Reflex::Type type_4225c = ::Reflex::ConstBuilder(type_4225);
  ::Reflex::Type type_29288 = ::Reflex::PointerBuilder(type_4225c);
  ::Reflex::Type type_29305 = ::Reflex::PointerBuilder(type_4303c);
  ::Reflex::Type type_29306 = ::Reflex::PointerBuilder(type_4303);
  ::Reflex::Type type_4229c = ::Reflex::ConstBuilder(type_4229);
  ::Reflex::Type type_29307 = ::Reflex::PointerBuilder(type_4229c);
  ::Reflex::Type type_30218 = ::Reflex::ReferenceBuilder(type_6574);
  ::Reflex::Type type_6574c = ::Reflex::ConstBuilder(type_6574);
  ::Reflex::Type type_30219 = ::Reflex::ReferenceBuilder(type_6574c);
  ::Reflex::Type type_8878c = ::Reflex::ConstBuilder(type_8878);
  ::Reflex::Type type_30220 = ::Reflex::ReferenceBuilder(type_8878c);
  ::Reflex::Type type_33422 = ::Reflex::ReferenceBuilder(type_18281);
  ::Reflex::Type type_18281c = ::Reflex::ConstBuilder(type_18281);
  ::Reflex::Type type_33423 = ::Reflex::ReferenceBuilder(type_18281c);
  ::Reflex::Type type_16859 = ::Reflex::PointerBuilder(type_10254);
  ::Reflex::Type type_10254c = ::Reflex::ConstBuilder(type_10254);
  ::Reflex::Type type_31203 = ::Reflex::ReferenceBuilder(type_10254c);
  ::Reflex::Type type_16861 = ::Reflex::ReferenceBuilder(type_10254);
  ::Reflex::Type type_8988 = ::Reflex::ReferenceBuilder(type_2328);
  ::Reflex::Type type_33424 = ::Reflex::ReferenceBuilder(type_18282);
  ::Reflex::Type type_18282c = ::Reflex::ConstBuilder(type_18282);
  ::Reflex::Type type_33425 = ::Reflex::ReferenceBuilder(type_18282c);
  ::Reflex::Type type_18288c = ::Reflex::ConstBuilder(type_18288);
  ::Reflex::Type type_33432 = ::Reflex::ReferenceBuilder(type_18288c);
  ::Reflex::Type type_33433 = ::Reflex::ReferenceBuilder(type_18288);
  ::Reflex::Type type_29550 = ::Reflex::PointerBuilder(type_18280);
  ::Reflex::Type type_18280c = ::Reflex::ConstBuilder(type_18280);
  ::Reflex::Type type_33421 = ::Reflex::ReferenceBuilder(type_18280c);
  ::Reflex::Type type_18289c = ::Reflex::ConstBuilder(type_18289);
  ::Reflex::Type type_33434 = ::Reflex::ReferenceBuilder(type_18289c);
  ::Reflex::Type type_33435 = ::Reflex::ReferenceBuilder(type_18289);
  ::Reflex::Type type_2713f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<std::string, pat::TriggerObjectRef>"), type_2713);
  ::Reflex::Type type_2759f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::L1Seed>"), type_2759);
  ::Reflex::Type type_2866f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::map<std::string, pat::TriggerObjectRef>"), type_2866);
  ::Reflex::Type type_4132f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::TriggerAlgorithmRefProd >"), type_4132);
  ::Reflex::Type type_4134f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::TriggerConditionRefProd >"), type_4134);
  ::Reflex::Type type_4136f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::TriggerPathRefProd >"), type_4136);
  ::Reflex::Type type_4138f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::TriggerFilterRefProd >"), type_4138);
  ::Reflex::Type type_4141f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::TriggerObjectStandAloneRefProd>"), type_4141);
  ::Reflex::Type type_4145f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::TriggerObjectRefProd>"), type_4145);
  ::Reflex::Type type_6574f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::L1Seed>::const_iterator"), type_6574);
  ::Reflex::Type type_18281f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<pat::TriggerObjectStandAloneRef>"), type_18281);
  ::Reflex::Type type_18282f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<pat::TriggerObjectRef>"), type_18282);
  ::Reflex::Type type_18288f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,pat::TriggerObjectStandAloneRef>"), type_18288);
  ::Reflex::Type type_18289f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,pat::TriggerObjectRef>"), type_18289);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __pat__TriggerAlgorithm
#undef __pat__TriggerAlgorithm
#endif
class __pat__TriggerAlgorithm {
  public:
  __pat__TriggerAlgorithm();
  virtual ~__pat__TriggerAlgorithm() throw();
  ::std::string name_;
  ::std::string alias_;
  ::std::string logic_;
  bool tech_;
  unsigned int bit_;
  bool gtlResult_;
  unsigned int prescale_;
  bool mask_;
  bool decisionBeforeMask_;
  bool decisionAfterMask_;
  ::std::vector<unsigned int> conditionKeys_;
};
#ifdef __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__long_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_p_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_r_
#undef __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__long_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_p_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_r_
#endif
struct __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__long_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_p_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_r_ {
  public:
  __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__long_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_p_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_r_();
};
#ifdef __pat__TriggerCondition
#undef __pat__TriggerCondition
#endif
class __pat__TriggerCondition {
  public:
  __pat__TriggerCondition();
  virtual ~__pat__TriggerCondition() throw();
  ::std::string name_;
  bool accept_;
  ::L1GtConditionCategory category_;
  ::L1GtConditionType type_;
  ::std::vector<trigger::TriggerObjectType> triggerObjectTypes_;
  ::std::vector<unsigned int> objectKeys_;
};
#ifdef __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__long_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_p_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_r_
#undef __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__long_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_p_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_r_
#endif
struct __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__long_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_p_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_r_ {
  public:
  __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__long_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_p_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_r_();
};
#ifdef __pat__TriggerObject
#undef __pat__TriggerObject
#endif
class __pat__TriggerObject : public ::reco::LeafCandidate {
  public:
  __pat__TriggerObject();
  virtual ~__pat__TriggerObject() throw();
  virtual bool hasCollection(std::string const&) const throw();
  virtual bool hasCollection(edm::InputTag const&) const throw();
  virtual bool coll(std::string const&) const throw();
  ::std::string collection_;
  ::std::vector<trigger::TriggerObjectType> triggerObjectTypes_;
  ::reco::CandidateBaseRef refToOrig_;
};
#ifdef __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__long_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_p_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_r_
#undef __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__long_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_p_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_r_
#endif
struct __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__long_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_p_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_r_ {
  public:
  __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__long_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_p_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_r_();
};
#ifdef __pat__TriggerFilter
#undef __pat__TriggerFilter
#endif
class __pat__TriggerFilter {
  public:
  __pat__TriggerFilter();
  virtual ~__pat__TriggerFilter() throw();
  ::std::string label_;
  ::std::string type_;
  ::std::vector<unsigned int> objectKeys_;
  ::std::vector<trigger::TriggerObjectType> triggerObjectTypes_;
  int status_;
  bool saveTags_;
};
#ifdef __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__long_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_p_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_r_
#undef __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__long_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_p_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_r_
#endif
struct __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__long_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_p_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_r_ {
  public:
  __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__long_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_p_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_r_();
};
#ifdef __pat__TriggerObjectStandAlone
#undef __pat__TriggerObjectStandAlone
#endif
class __pat__TriggerObjectStandAlone : public ::pat::TriggerObject {
  public:
  __pat__TriggerObjectStandAlone();
  virtual ~__pat__TriggerObjectStandAlone() throw();
  virtual bool hasCollection(std::string const&) const throw();
  virtual bool hasCollection(edm::InputTag const&) const throw();
  virtual bool coll(std::string const&) const throw();
  ::std::vector<std::basic_string<char> > filterLabels_;
  ::std::vector<std::basic_string<char> > pathNames_;
  ::std::vector<unsigned short> pathIndices_;
  ::std::vector<bool> pathLastFilterAccepted_;
  ::std::vector<bool> pathL3FilterAccepted_;
};
#ifdef __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__long_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_p_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_r_
#undef __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__long_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_p_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_r_
#endif
struct __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__long_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_p_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_r_ {
  public:
  __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__long_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_p_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_r_();
};
#ifdef __pat__TriggerPath
#undef __pat__TriggerPath
#endif
class __pat__TriggerPath {
  public:
  __pat__TriggerPath();
  virtual ~__pat__TriggerPath() throw();
  ::std::string name_;
  unsigned int index_;
  unsigned int prescale_;
  bool run_;
  bool accept_;
  bool error_;
  ::std::vector<std::basic_string<char> > modules_;
  ::std::vector<unsigned int> filterIndices_;
  unsigned int lastActiveFilterSlot_;
  unsigned int l3Filters_;
  ::pat::L1SeedCollection l1Seeds_;
};
#ifdef __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__long_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_p_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_r_
#undef __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__long_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_p_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_r_
#endif
struct __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__long_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_p_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_r_ {
  public:
  __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__long_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_p_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_r_();
};
#ifdef __std__vector_pat__TriggerObject_
#undef __std__vector_pat__TriggerObject_
#endif
class __std__vector_pat__TriggerObject_ : protected ::std::_Vector_base<pat::TriggerObject,std::allocator<pat::TriggerObject> > {
  public:
  __std__vector_pat__TriggerObject_();
};
#ifdef __edm__Association_std__vector_pat__TriggerObject_s_
#undef __edm__Association_std__vector_pat__TriggerObject_s_
#endif
class __edm__Association_std__vector_pat__TriggerObject_s_ : private ::edm::ValueMap<int> {
  public:
  __edm__Association_std__vector_pat__TriggerObject_s_();
  ::edm::RefProd<std::vector<pat::TriggerObject> > ref_;
};
#ifdef __std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_
#undef __std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_
#endif
struct __std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_ {
  public:
  __std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_();
  ::std::basic_string<char> first;
  ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > second;
};
#ifdef __std__vector_pat__TriggerAlgorithm_
#undef __std__vector_pat__TriggerAlgorithm_
#endif
class __std__vector_pat__TriggerAlgorithm_ : protected ::std::_Vector_base<pat::TriggerAlgorithm,std::allocator<pat::TriggerAlgorithm> > {
  public:
  __std__vector_pat__TriggerAlgorithm_();
};
#ifdef __std__vector_pat__TriggerCondition_
#undef __std__vector_pat__TriggerCondition_
#endif
class __std__vector_pat__TriggerCondition_ : protected ::std::_Vector_base<pat::TriggerCondition,std::allocator<pat::TriggerCondition> > {
  public:
  __std__vector_pat__TriggerCondition_();
};
#ifdef __std__vector_pat__TriggerFilter_
#undef __std__vector_pat__TriggerFilter_
#endif
class __std__vector_pat__TriggerFilter_ : protected ::std::_Vector_base<pat::TriggerFilter,std::allocator<pat::TriggerFilter> > {
  public:
  __std__vector_pat__TriggerFilter_();
};
#ifdef __std__vector_pat__TriggerObjectStandAlone_
#undef __std__vector_pat__TriggerObjectStandAlone_
#endif
class __std__vector_pat__TriggerObjectStandAlone_ : protected ::std::_Vector_base<pat::TriggerObjectStandAlone,std::allocator<pat::TriggerObjectStandAlone> > {
  public:
  __std__vector_pat__TriggerObjectStandAlone_();
};
#ifdef __std__vector_pat__TriggerPath_
#undef __std__vector_pat__TriggerPath_
#endif
class __std__vector_pat__TriggerPath_ : protected ::std::_Vector_base<pat::TriggerPath,std::allocator<pat::TriggerPath> > {
  public:
  __std__vector_pat__TriggerPath_();
};
#ifdef __std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_
#undef __std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_
#endif
class __std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_ {
  public:
  __std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_();
  ::std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >,std::_Select1st<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > > _M_t;
};
#ifdef __pat__PackedTriggerPrescales
#undef __pat__PackedTriggerPrescales
#endif
class __pat__PackedTriggerPrescales {
  public:
  __pat__PackedTriggerPrescales();
  ::std::vector<int> prescaleValues_;
  ::edm::RefCore triggerResults_;
  void* triggerNames_;
};
#ifdef __edm__Wrapper_pat__PackedTriggerPrescales_
#undef __edm__Wrapper_pat__PackedTriggerPrescales_
#endif
class __edm__Wrapper_pat__PackedTriggerPrescales_ {
  public:
  __edm__Wrapper_pat__PackedTriggerPrescales_();
  bool present;
  ::pat::PackedTriggerPrescales obj;
};
#ifdef __pat__TriggerEvent
#undef __pat__TriggerEvent
#endif
class __pat__TriggerEvent {
  public:
  __pat__TriggerEvent();
  virtual ~__pat__TriggerEvent() throw();
  ::std::string nameL1Menu_;
  ::std::string nameHltTable_;
  bool run_;
  bool accept_;
  bool error_;
  bool physDecl_;
  ::uint32_t lhcFill_;
  ::uint16_t beamMode_;
  ::uint16_t beamMomentum_;
  ::uint32_t intensityBeam1_;
  ::uint32_t intensityBeam2_;
  ::uint16_t bstMasterStatus_;
  ::uint32_t turnCount_;
  float bCurrentStart_;
  float bCurrentStop_;
  float bCurrentAvg_;
  ::pat::TriggerAlgorithmRefProd algorithms_;
  ::pat::TriggerConditionRefProd conditions_;
  ::pat::TriggerPathRefProd paths_;
  ::pat::TriggerFilterRefProd filters_;
  ::pat::TriggerObjectRefProd objects_;
  ::pat::TriggerObjectMatchContainer objectMatchResults_;
};
#ifdef __edm__Wrapper_pat__TriggerEvent_
#undef __edm__Wrapper_pat__TriggerEvent_
#endif
class __edm__Wrapper_pat__TriggerEvent_ {
  public:
  __edm__Wrapper_pat__TriggerEvent_();
  bool present;
  ::pat::TriggerEvent obj;
};
#ifdef __edm__Wrapper_std__vector_pat__TriggerAlgorithm_s_
#undef __edm__Wrapper_std__vector_pat__TriggerAlgorithm_s_
#endif
class __edm__Wrapper_std__vector_pat__TriggerAlgorithm_s_ {
  public:
  __edm__Wrapper_std__vector_pat__TriggerAlgorithm_s_();
  bool present;
  ::std::vector<pat::TriggerAlgorithm> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__TriggerCondition_s_
#undef __edm__Wrapper_std__vector_pat__TriggerCondition_s_
#endif
class __edm__Wrapper_std__vector_pat__TriggerCondition_s_ {
  public:
  __edm__Wrapper_std__vector_pat__TriggerCondition_s_();
  bool present;
  ::std::vector<pat::TriggerCondition> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__TriggerPath_s_
#undef __edm__Wrapper_std__vector_pat__TriggerPath_s_
#endif
class __edm__Wrapper_std__vector_pat__TriggerPath_s_ {
  public:
  __edm__Wrapper_std__vector_pat__TriggerPath_s_();
  bool present;
  ::std::vector<pat::TriggerPath> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__TriggerFilter_s_
#undef __edm__Wrapper_std__vector_pat__TriggerFilter_s_
#endif
class __edm__Wrapper_std__vector_pat__TriggerFilter_s_ {
  public:
  __edm__Wrapper_std__vector_pat__TriggerFilter_s_();
  bool present;
  ::std::vector<pat::TriggerFilter> obj;
};
#ifdef __edm__Association_std__vector_pat__TriggerObjectStandAlone_s_
#undef __edm__Association_std__vector_pat__TriggerObjectStandAlone_s_
#endif
class __edm__Association_std__vector_pat__TriggerObjectStandAlone_s_ : private ::edm::ValueMap<int> {
  public:
  __edm__Association_std__vector_pat__TriggerObjectStandAlone_s_();
  ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > ref_;
};
#ifdef __edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s_
#undef __edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s_
#endif
class __edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s_ {
  public:
  __edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s_();
  bool present;
  ::edm::Association<std::vector<pat::TriggerObjectStandAlone> > obj;
};
#ifdef __edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s_
#undef __edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s_
#endif
class __edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s_ {
  public:
  __edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s_();
  bool present;
  ::std::vector<pat::TriggerObjectStandAlone> obj;
};
#ifdef __edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s_
#undef __edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s_
#endif
class __edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s_ {
  public:
  __edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s_();
  bool present;
  ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > obj;
};
#ifdef __edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s_
#undef __edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s_
#endif
class __edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s_ {
  public:
  __edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s_();
  bool present;
  ::edm::Association<std::vector<pat::TriggerObject> > obj;
};
#ifdef __edm__Wrapper_std__vector_pat__TriggerObject_s_
#undef __edm__Wrapper_std__vector_pat__TriggerObject_s_
#endif
class __edm__Wrapper_std__vector_pat__TriggerObject_s_ {
  public:
  __edm__Wrapper_std__vector_pat__TriggerObject_s_();
  bool present;
  ::std::vector<pat::TriggerObject> obj;
};
#ifdef __edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_
#undef __edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_
#endif
class __edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_ {
  public:
  __edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_
#undef __edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_
#endif
class __edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_ {
  public:
  __edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_
#undef __edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_
#endif
class __edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_ {
  public:
  __edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_
#undef __edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_
#endif
class __edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_ {
  public:
  __edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_
#undef __edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_
#endif
class __edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_ : public ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&> {
  public:
  __edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_();
  ::edm::RefCore product_;
  ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> > iter_;
};
#ifdef __edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_
#undef __edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_
#endif
class __edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_ : public ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&> {
  public:
  __edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_();
  ::edm::RefCore product_;
  ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> > iter_;
};
#ifdef __edm__RefProd_std__vector_pat__TriggerPath_s_
#undef __edm__RefProd_std__vector_pat__TriggerPath_s_
#endif
class __edm__RefProd_std__vector_pat__TriggerPath_s_ {
  public:
  __edm__RefProd_std__vector_pat__TriggerPath_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_
#undef __edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_
#endif
class __edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_ {
  public:
  __edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_
#undef __edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_
#endif
class __edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_ {
  public:
  __edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_
#undef __edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_
#endif
class __edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_ {
  public:
  __edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_
#undef __edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_
#endif
class __edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_ {
  public:
  __edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_
#undef __edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_
#endif
class __edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_ {
  public:
  __edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_
#undef __edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_
#endif
class __edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_ : public ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&> {
  public:
  __edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_();
  ::edm::RefCore product_;
  ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> > iter_;
};
#ifdef __std__pair_bool_std__basic_string_char_s_
#undef __std__pair_bool_std__basic_string_char_s_
#endif
struct __std__pair_bool_std__basic_string_char_s_ {
  public:
  __std__pair_bool_std__basic_string_char_s_();
  bool first;
  ::std::basic_string<char> second;
};
#ifdef __edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_
#undef __edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_
#endif
class __edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_ : public ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&> {
  public:
  __edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_();
  ::edm::RefCore product_;
  ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> > iter_;
};
#ifdef __edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_
#undef __edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_
#endif
class __edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_ {
  public:
  __edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_
#undef __edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_
#endif
class __edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_ {
  public:
  __edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefProd_std__vector_pat__TriggerObject_s_
#undef __edm__RefProd_std__vector_pat__TriggerObject_s_
#endif
class __edm__RefProd_std__vector_pat__TriggerObject_s_ {
  public:
  __edm__RefProd_std__vector_pat__TriggerObject_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_std__vector_pat__TriggerCondition_s_
#undef __edm__RefProd_std__vector_pat__TriggerCondition_s_
#endif
class __edm__RefProd_std__vector_pat__TriggerCondition_s_ {
  public:
  __edm__RefProd_std__vector_pat__TriggerCondition_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_std__vector_pat__TriggerAlgorithm_s_
#undef __edm__RefProd_std__vector_pat__TriggerAlgorithm_s_
#endif
class __edm__RefProd_std__vector_pat__TriggerAlgorithm_s_ {
  public:
  __edm__RefProd_std__vector_pat__TriggerAlgorithm_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_
#undef __edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_
#endif
class __edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_ {
  public:
  __edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_
#undef __edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_
#endif
class __edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_ : public ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&> {
  public:
  __edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_();
  ::edm::RefCore product_;
  ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> > iter_;
};
#ifdef __edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_
#undef __edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_
#endif
class __edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_ : public ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&> {
  public:
  __edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_();
  ::edm::RefCore product_;
  ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> > iter_;
};
#ifdef __edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_
#undef __edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_
#endif
class __edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_ {
  public:
  __edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_
#undef __edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_
#endif
class __edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_ {
  public:
  __edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefProd_std__vector_pat__TriggerFilter_s_
#undef __edm__RefProd_std__vector_pat__TriggerFilter_s_
#endif
class __edm__RefProd_std__vector_pat__TriggerFilter_s_ {
  public:
  __edm__RefProd_std__vector_pat__TriggerFilter_s_();
  ::edm::RefCore product_;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s_
#undef ____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s_
#undef ____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s_
#undef ____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s_
#undef ____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s_
#undef ____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s_
#undef ____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s_();
  void* _M_current;
};
#ifdef __std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s_
#undef __std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s_
#endif
struct __std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s_ {
  public:
  __std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s_();
  void* _M_node;
};
#ifdef __std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_
#undef __std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_
#endif
struct __std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_ {
  public:
  __std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_();
  ::std::basic_string<char> first;
  ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > second;
};
#ifdef __std__vector_std__pair_bool_std__basic_string_char_s_s_
#undef __std__vector_std__pair_bool_std__basic_string_char_s_s_
#endif
class __std__vector_std__pair_bool_std__basic_string_char_s_s_ : protected ::std::_Vector_base<std::pair<bool,std::basic_string<char> >,std::allocator<std::pair<bool,std::basic_string<char> > > > {
  public:
  __std__vector_std__pair_bool_std__basic_string_char_s_s_();
};
#ifdef __std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_
#undef __std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_
#endif
class __std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_ {
  public:
  __std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_();
  ::std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >,std::_Select1st<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > > > _M_t;
};
#ifdef __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s_
#undef __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s_
#endif
class __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s_ {
  public:
  __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s_();
  bool present;
  ::edm::RefProd<std::vector<pat::TriggerAlgorithm> > obj;
};
#ifdef __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s_
#undef __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s_
#endif
class __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s_ {
  public:
  __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s_();
  bool present;
  ::edm::RefProd<std::vector<pat::TriggerCondition> > obj;
};
#ifdef __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s_
#undef __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s_
#endif
class __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s_ {
  public:
  __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s_();
  bool present;
  ::edm::RefProd<std::vector<pat::TriggerPath> > obj;
};
#ifdef __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s_
#undef __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s_
#endif
class __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s_ {
  public:
  __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s_();
  bool present;
  ::edm::RefProd<std::vector<pat::TriggerFilter> > obj;
};
#ifdef __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s_
#undef __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s_
#endif
class __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s_ {
  public:
  __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s_();
  bool present;
  ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > obj;
};
#ifdef __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s_
#undef __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s_
#endif
class __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s_ {
  public:
  __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s_();
  bool present;
  ::edm::RefProd<std::vector<pat::TriggerObject> > obj;
};
#ifdef ____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s_
#undef ____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s_
#endif
class ____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s_ {
  public:
  ____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s_();
  void* _M_current;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s_() throw();
  ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_() throw();
  ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s_() throw();
  ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_() throw();
  ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > ref_;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class TriggerAlgorithm -------------------------------
static  void operator_25249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::TriggerAlgorithm*)o)->operator=)(*(const ::pat::TriggerAlgorithm*)arg[0]);
  else   (((::pat::TriggerAlgorithm*)o)->operator=)(*(const ::pat::TriggerAlgorithm*)arg[0]);
}

static void constructor_25250( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerAlgorithm(*(const ::pat::TriggerAlgorithm*)arg[0]);
  else ::new(mem) ::pat::TriggerAlgorithm(*(const ::pat::TriggerAlgorithm*)arg[0]);
}

static void constructor_25251( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerAlgorithm();
  else ::new(mem) ::pat::TriggerAlgorithm();
}

static void constructor_25252( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerAlgorithm(*(const ::std::string*)arg[0]);
  else ::new(mem) ::pat::TriggerAlgorithm(*(const ::std::string*)arg[0]);
}

static void constructor_25253( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerAlgorithm(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2],
      *(unsigned int*)arg[3],
      *(unsigned int*)arg[4],
      *(bool*)arg[5],
      *(bool*)arg[6],
      *(bool*)arg[7]);
  else ::new(mem) ::pat::TriggerAlgorithm(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2],
      *(unsigned int*)arg[3],
      *(unsigned int*)arg[4],
      *(bool*)arg[5],
      *(bool*)arg[6],
      *(bool*)arg[7]);
}

static void constructor_25254( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerAlgorithm(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2],
      *(unsigned int*)arg[3],
      *(bool*)arg[4],
      *(unsigned int*)arg[5],
      *(bool*)arg[6],
      *(bool*)arg[7],
      *(bool*)arg[8]);
  else ::new(mem) ::pat::TriggerAlgorithm(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2],
      *(unsigned int*)arg[3],
      *(bool*)arg[4],
      *(unsigned int*)arg[5],
      *(bool*)arg[6],
      *(bool*)arg[7],
      *(bool*)arg[8]);
}

static void destructor_25255(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::TriggerAlgorithm*)o)->::pat::TriggerAlgorithm::~TriggerAlgorithm)();
}
static  void method_25256( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerAlgorithm*)o)->setName)(*(const ::std::string*)arg[0]);
}

static  void method_25257( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerAlgorithm*)o)->setAlias)(*(const ::std::string*)arg[0]);
}

static  void method_25258( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerAlgorithm*)o)->setLogicalExpression)(*(const ::std::string*)arg[0]);
}

static  void method_25259( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerAlgorithm*)o)->setTechTrigger)(*(bool*)arg[0]);
}

static  void method_25260( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerAlgorithm*)o)->setBit)(*(unsigned int*)arg[0]);
}

static  void method_25261( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerAlgorithm*)o)->setGtlResult)(*(bool*)arg[0]);
}

static  void method_25262( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerAlgorithm*)o)->setPrescale)(*(unsigned int*)arg[0]);
}

static  void method_25263( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerAlgorithm*)o)->setMask)(*(bool*)arg[0]);
}

static  void method_25264( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerAlgorithm*)o)->setDecisionBeforeMask)(*(bool*)arg[0]);
}

static  void method_25265( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerAlgorithm*)o)->setDecisionAfterMas)(*(bool*)arg[0]);
}

static  void method_25266( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerAlgorithm*)o)->addConditionKey)(*(unsigned int*)arg[0]);
}

static  void method_25267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerAlgorithm*)o)->name)();
  else   (((const ::pat::TriggerAlgorithm*)o)->name)();
}

static  void method_25268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerAlgorithm*)o)->alias)();
  else   (((const ::pat::TriggerAlgorithm*)o)->alias)();
}

static  void method_25269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerAlgorithm*)o)->logicalExpression)();
  else   (((const ::pat::TriggerAlgorithm*)o)->logicalExpression)();
}

static  void method_25270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerAlgorithm*)o)->techTrigger)());
  else   (((const ::pat::TriggerAlgorithm*)o)->techTrigger)();
}

static  void method_25271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::pat::TriggerAlgorithm*)o)->bit)());
  else   (((const ::pat::TriggerAlgorithm*)o)->bit)();
}

static  void method_25272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerAlgorithm*)o)->gtlResult)());
  else   (((const ::pat::TriggerAlgorithm*)o)->gtlResult)();
}

static  void method_25273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::pat::TriggerAlgorithm*)o)->prescale)());
  else   (((const ::pat::TriggerAlgorithm*)o)->prescale)();
}

static  void method_25274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerAlgorithm*)o)->mask)());
  else   (((const ::pat::TriggerAlgorithm*)o)->mask)();
}

static  void method_25275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerAlgorithm*)o)->decisionBeforeMask)());
  else   (((const ::pat::TriggerAlgorithm*)o)->decisionBeforeMask)();
}

static  void method_25276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerAlgorithm*)o)->decisionAfterMask)());
  else   (((const ::pat::TriggerAlgorithm*)o)->decisionAfterMask)();
}

static  void method_25277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerAlgorithm*)o)->decision)());
  else   (((const ::pat::TriggerAlgorithm*)o)->decision)();
}

static  void method_25278( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerAlgorithm*)o)->conditionKeys)();
  else   (((const ::pat::TriggerAlgorithm*)o)->conditionKeys)();
}

static  void method_25279( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerAlgorithm*)o)->hasConditionKey)(*(unsigned int*)arg[0]));
  else   (((const ::pat::TriggerAlgorithm*)o)->hasConditionKey)(*(unsigned int*)arg[0]);
}

static void method_newdel_7368( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::TriggerAlgorithm >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::TriggerAlgorithm >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::TriggerAlgorithm >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::TriggerAlgorithm >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::TriggerAlgorithm >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TriggerAlgorithm -------------------------------
void __pat__TriggerAlgorithm_db_datamem(Reflex::Class*);
void __pat__TriggerAlgorithm_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__TriggerAlgorithm_datamem_bld(&__pat__TriggerAlgorithm_db_datamem);
Reflex::GenreflexMemberBuilder __pat__TriggerAlgorithm_funcmem_bld(&__pat__TriggerAlgorithm_db_funcmem);
void __pat__TriggerAlgorithm_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::TriggerAlgorithm"), typeid(::pat::TriggerAlgorithm), sizeof(::pat::TriggerAlgorithm), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10919, type_8858), Reflex::Literal("operator="), operator_25249, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8858), Reflex::Literal("TriggerAlgorithm"), constructor_25250, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerAlgorithm"), constructor_25251, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4393), Reflex::Literal("TriggerAlgorithm"), constructor_25252, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4393, type_4393, type_1454, type_289, type_289, type_1454, type_1454, type_1454), Reflex::Literal("TriggerAlgorithm"), constructor_25253, 0, "name;alias;tech;bit;prescale;mask;decisionBeforeMask;decisionAfterMask", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4393, type_4393, type_1454, type_289, type_1454, type_289, type_1454, type_1454, type_1454), Reflex::Literal("TriggerAlgorithm"), constructor_25254, 0, "name;alias;tech;bit;gtlResult;prescale;mask;decisionBeforeMask;decisionAfterMask", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerAlgorithm"), destructor_25255, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7368, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__TriggerAlgorithm_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__TriggerAlgorithm_funcmem_bld);
}

//------Delayed data member builder for class TriggerAlgorithm -------------------
void __pat__TriggerAlgorithm_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2329, Reflex::Literal("name_"), OffsetOf(__shadow__::__pat__TriggerAlgorithm, name_), ::Reflex::PRIVATE)
  .AddDataMember(type_2329, Reflex::Literal("alias_"), OffsetOf(__shadow__::__pat__TriggerAlgorithm, alias_), ::Reflex::PRIVATE)
  .AddDataMember(type_2329, Reflex::Literal("logic_"), OffsetOf(__shadow__::__pat__TriggerAlgorithm, logic_), ::Reflex::PRIVATE)
  .AddDataMember(type_1454, Reflex::Literal("tech_"), OffsetOf(__shadow__::__pat__TriggerAlgorithm, tech_), ::Reflex::PRIVATE)
  .AddDataMember(type_289, Reflex::Literal("bit_"), OffsetOf(__shadow__::__pat__TriggerAlgorithm, bit_), ::Reflex::PRIVATE)
  .AddDataMember(type_1454, Reflex::Literal("gtlResult_"), OffsetOf(__shadow__::__pat__TriggerAlgorithm, gtlResult_), ::Reflex::PRIVATE)
  .AddDataMember(type_289, Reflex::Literal("prescale_"), OffsetOf(__shadow__::__pat__TriggerAlgorithm, prescale_), ::Reflex::PRIVATE)
  .AddDataMember(type_1454, Reflex::Literal("mask_"), OffsetOf(__shadow__::__pat__TriggerAlgorithm, mask_), ::Reflex::PRIVATE)
  .AddDataMember(type_1454, Reflex::Literal("decisionBeforeMask_"), OffsetOf(__shadow__::__pat__TriggerAlgorithm, decisionBeforeMask_), ::Reflex::PRIVATE)
  .AddDataMember(type_1454, Reflex::Literal("decisionAfterMask_"), OffsetOf(__shadow__::__pat__TriggerAlgorithm, decisionAfterMask_), ::Reflex::PRIVATE)
  .AddDataMember(type_2753, Reflex::Literal("conditionKeys_"), OffsetOf(__shadow__::__pat__TriggerAlgorithm, conditionKeys_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TriggerAlgorithm -------------------
void __pat__TriggerAlgorithm_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4393), Reflex::Literal("setName"), method_25256, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4393), Reflex::Literal("setAlias"), method_25257, 0, "alias", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4393), Reflex::Literal("setLogicalExpression"), method_25258, 0, "expression", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1454), Reflex::Literal("setTechTrigger"), method_25259, 0, "tech", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_289), Reflex::Literal("setBit"), method_25260, 0, "bit", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1454), Reflex::Literal("setGtlResult"), method_25261, 0, "gtlResult", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_289), Reflex::Literal("setPrescale"), method_25262, 0, "prescale", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1454), Reflex::Literal("setMask"), method_25263, 0, "mask", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1454), Reflex::Literal("setDecisionBeforeMask"), method_25264, 0, "decisionBeforeMask", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1454), Reflex::Literal("setDecisionAfterMas"), method_25265, 0, "decisionAfterMask", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_289), Reflex::Literal("addConditionKey"), method_25266, 0, "conditionKey", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4393), Reflex::Literal("name"), method_25267, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4393), Reflex::Literal("alias"), method_25268, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4393), Reflex::Literal("logicalExpression"), method_25269, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("techTrigger"), method_25270, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("bit"), method_25271, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("gtlResult"), method_25272, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("prescale"), method_25273, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("mask"), method_25274, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("decisionBeforeMask"), method_25275, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("decisionAfterMask"), method_25276, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("decision"), method_25277, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20074), Reflex::Literal("conditionKeys"), method_25278, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_289), Reflex::Literal("hasConditionKey"), method_25279, 0, "conditionKey", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> >,long int,edm::Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> >&> -------------------------------
static void destructor_10352(void*, void * o, const std::vector<void*>&, void *) {
(((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>*)o)->::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>::~iterator)();
}
static  void operator_10353( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>*)o)->operator=)(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>*)arg[0]);
  else   (((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>*)o)->operator=)(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>*)arg[0]);
}

static void constructor_10354( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>*)arg[0]);
  else ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>*)arg[0]);
}

static void constructor_10355( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>();
  else ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>();
}

static void method_newdel_2641( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> >,long int,edm::Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> >&> -------------------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__long_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_p_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_r__db_datamem(Reflex::Class*);
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__long_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_p_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_r__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__long_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_p_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_r__datamem_bld(&__std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__long_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_p_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_r__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__long_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_p_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_r__funcmem_bld(&__std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__long_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_p_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_r__db_funcmem);
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__long_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_p_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_r__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>"), typeid(::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>), sizeof(::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm>>,*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm>>*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm>>&>")
  .AddTypedef(type_2391, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>::iterator_category"))
  .AddTypedef(type_4342, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>::value_type"))
  .AddTypedef(type_66, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>::difference_type"))
  .AddTypedef(type_10348, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>::pointer"))
  .AddTypedef(type_10350, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator"), destructor_10352, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26355, type_26356), Reflex::Literal("operator="), operator_10353, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26356), Reflex::Literal("iterator"), constructor_10354, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator"), constructor_10355, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2641, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> >,long int,edm::Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> >&> -------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__long_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_p_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_r__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> >,long int,edm::Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> >&> -------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__long_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_p_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_r__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class TriggerCondition -------------------------------
static  void operator_24911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::TriggerCondition*)o)->operator=)(*(const ::pat::TriggerCondition*)arg[0]);
  else   (((::pat::TriggerCondition*)o)->operator=)(*(const ::pat::TriggerCondition*)arg[0]);
}

static void constructor_24912( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerCondition(*(const ::pat::TriggerCondition*)arg[0]);
  else ::new(mem) ::pat::TriggerCondition(*(const ::pat::TriggerCondition*)arg[0]);
}

static void constructor_24913( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerCondition();
  else ::new(mem) ::pat::TriggerCondition();
}

static void constructor_24914( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerCondition(*(const ::std::string*)arg[0]);
  else ::new(mem) ::pat::TriggerCondition(*(const ::std::string*)arg[0]);
}

static void constructor_24915( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerCondition(*(const ::std::string*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::pat::TriggerCondition(*(const ::std::string*)arg[0],
      *(bool*)arg[1]);
}

static void destructor_24916(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::TriggerCondition*)o)->::pat::TriggerCondition::~TriggerCondition)();
}
static  void method_24917( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerCondition*)o)->setName)(*(const ::std::string*)arg[0]);
}

static  void method_24918( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerCondition*)o)->setAccept)(*(bool*)arg[0]);
}

static  void method_24919( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerCondition*)o)->setCategory)(*(::L1GtConditionCategory*)arg[0]);
}

static  void method_24920( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerCondition*)o)->setCategory)(*(int*)arg[0]);
}

static  void method_24921( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerCondition*)o)->setType)(*(::L1GtConditionType*)arg[0]);
}

static  void method_24922( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerCondition*)o)->setType)(*(int*)arg[0]);
}

static  void method_24923( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerCondition*)o)->addTriggerObjectType)(*(::trigger::TriggerObjectType*)arg[0]);
}

static  void method_24924( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerCondition*)o)->addTriggerObjectType)(*(int*)arg[0]);
}

static  void method_24925( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerCondition*)o)->addObjectKey)(*(unsigned int*)arg[0]);
}

static  void method_24926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerCondition*)o)->name)();
  else   (((const ::pat::TriggerCondition*)o)->name)();
}

static  void method_24927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerCondition*)o)->wasAccept)());
  else   (((const ::pat::TriggerCondition*)o)->wasAccept)();
}

static  void method_24928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::TriggerCondition*)o)->category)());
  else   (((const ::pat::TriggerCondition*)o)->category)();
}

static  void method_24929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::TriggerCondition*)o)->type)());
  else   (((const ::pat::TriggerCondition*)o)->type)();
}

static  void method_24930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<int>)((((const ::pat::TriggerCondition*)o)->triggerObjectTypes)());
  else   (((const ::pat::TriggerCondition*)o)->triggerObjectTypes)();
}

static  void method_24931( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerCondition*)o)->hasTriggerObjectType)(*(::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::TriggerCondition*)o)->hasTriggerObjectType)(*(::trigger::TriggerObjectType*)arg[0]);
}

static  void method_24932( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerCondition*)o)->hasTriggerObjectType)(*(int*)arg[0]));
  else   (((const ::pat::TriggerCondition*)o)->hasTriggerObjectType)(*(int*)arg[0]);
}

static  void method_24933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerCondition*)o)->objectKeys)();
  else   (((const ::pat::TriggerCondition*)o)->objectKeys)();
}

static  void method_24934( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerCondition*)o)->hasObjectKey)(*(unsigned int*)arg[0]));
  else   (((const ::pat::TriggerCondition*)o)->hasObjectKey)(*(unsigned int*)arg[0]);
}

static void method_newdel_7332( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::TriggerCondition >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::TriggerCondition >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::TriggerCondition >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::TriggerCondition >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::TriggerCondition >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TriggerCondition -------------------------------
void __pat__TriggerCondition_db_datamem(Reflex::Class*);
void __pat__TriggerCondition_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__TriggerCondition_datamem_bld(&__pat__TriggerCondition_db_datamem);
Reflex::GenreflexMemberBuilder __pat__TriggerCondition_funcmem_bld(&__pat__TriggerCondition_db_funcmem);
void __pat__TriggerCondition_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::TriggerCondition"), typeid(::pat::TriggerCondition), sizeof(::pat::TriggerCondition), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10982, type_8869), Reflex::Literal("operator="), operator_24911, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8869), Reflex::Literal("TriggerCondition"), constructor_24912, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerCondition"), constructor_24913, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4393), Reflex::Literal("TriggerCondition"), constructor_24914, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4393, type_1454), Reflex::Literal("TriggerCondition"), constructor_24915, 0, "name;accept", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerCondition"), destructor_24916, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7332, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__TriggerCondition_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__TriggerCondition_funcmem_bld);
}

//------Delayed data member builder for class TriggerCondition -------------------
void __pat__TriggerCondition_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2329, Reflex::Literal("name_"), OffsetOf(__shadow__::__pat__TriggerCondition, name_), ::Reflex::PRIVATE)
  .AddDataMember(type_1454, Reflex::Literal("accept_"), OffsetOf(__shadow__::__pat__TriggerCondition, accept_), ::Reflex::PRIVATE)
  .AddDataMember(type_2166, Reflex::Literal("category_"), OffsetOf(__shadow__::__pat__TriggerCondition, category_), ::Reflex::PRIVATE)
  .AddDataMember(type_2123, Reflex::Literal("type_"), OffsetOf(__shadow__::__pat__TriggerCondition, type_), ::Reflex::PRIVATE)
  .AddDataMember(type_2758, Reflex::Literal("triggerObjectTypes_"), OffsetOf(__shadow__::__pat__TriggerCondition, triggerObjectTypes_), ::Reflex::PRIVATE)
  .AddDataMember(type_2753, Reflex::Literal("objectKeys_"), OffsetOf(__shadow__::__pat__TriggerCondition, objectKeys_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TriggerCondition -------------------
void __pat__TriggerCondition_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4393), Reflex::Literal("setName"), method_24917, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1454), Reflex::Literal("setAccept"), method_24918, 0, "accept", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2166), Reflex::Literal("setCategory"), method_24919, 0, "category", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_71), Reflex::Literal("setCategory"), method_24920, 0, "category", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2123), Reflex::Literal("setType"), method_24921, 0, "type", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_71), Reflex::Literal("setType"), method_24922, 0, "type", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_7391), Reflex::Literal("addTriggerObjectType"), method_24923, 0, "triggerObjectType", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_71), Reflex::Literal("addTriggerObjectType"), method_24924, 0, "triggerObjectType", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_289), Reflex::Literal("addObjectKey"), method_24925, 0, "objectKey", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4393), Reflex::Literal("name"), method_24926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("wasAccept"), method_24927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71), Reflex::Literal("category"), method_24928, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71), Reflex::Literal("type"), method_24929, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2755), Reflex::Literal("triggerObjectTypes"), method_24930, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_7391), Reflex::Literal("hasTriggerObjectType"), method_24931, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_71), Reflex::Literal("hasTriggerObjectType"), method_24932, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20074), Reflex::Literal("objectKeys"), method_24933, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_289), Reflex::Literal("hasObjectKey"), method_24934, 0, "objectKey", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> >,long int,edm::Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> >&> -------------------------------
static void destructor_10363(void*, void * o, const std::vector<void*>&, void *) {
(((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>*)o)->::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>::~iterator)();
}
static  void operator_10364( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>*)o)->operator=)(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>*)arg[0]);
  else   (((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>*)o)->operator=)(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>*)arg[0]);
}

static void constructor_10365( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>*)arg[0]);
  else ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>*)arg[0]);
}

static void constructor_10366( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>();
  else ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>();
}

static void method_newdel_2642( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> >,long int,edm::Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> >&> -------------------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__long_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_p_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_r__db_datamem(Reflex::Class*);
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__long_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_p_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_r__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__long_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_p_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_r__datamem_bld(&__std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__long_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_p_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_r__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__long_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_p_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_r__funcmem_bld(&__std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__long_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_p_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_r__db_funcmem);
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__long_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_p_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_r__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>"), typeid(::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>), sizeof(::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition>>,*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition>>*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition>>&>")
  .AddTypedef(type_2391, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>::iterator_category"))
  .AddTypedef(type_4343, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>::value_type"))
  .AddTypedef(type_66, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>::difference_type"))
  .AddTypedef(type_10359, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>::pointer"))
  .AddTypedef(type_10361, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator"), destructor_10363, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26357, type_26358), Reflex::Literal("operator="), operator_10364, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26358), Reflex::Literal("iterator"), constructor_10365, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator"), constructor_10366, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2642, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> >,long int,edm::Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> >&> -------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__long_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_p_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_r__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> >,long int,edm::Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> >&> -------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__long_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_p_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_r__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class TriggerObject -------------------------------
static  void operator_25161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::TriggerObject*)o)->operator=)(*(const ::pat::TriggerObject*)arg[0]);
  else   (((::pat::TriggerObject*)o)->operator=)(*(const ::pat::TriggerObject*)arg[0]);
}

static void constructor_25162( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObject(*(const ::pat::TriggerObject*)arg[0]);
  else ::new(mem) ::pat::TriggerObject(*(const ::pat::TriggerObject*)arg[0]);
}

static void constructor_25163( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObject();
  else ::new(mem) ::pat::TriggerObject();
}

static void constructor_25164( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObject(*(const ::trigger::TriggerObject*)arg[0]);
  else ::new(mem) ::pat::TriggerObject(*(const ::trigger::TriggerObject*)arg[0]);
}

static void constructor_25165( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObject(*(const ::reco::LeafCandidate*)arg[0]);
  else ::new(mem) ::pat::TriggerObject(*(const ::reco::LeafCandidate*)arg[0]);
}

static void constructor_25166( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObject(*(const ::reco::CandidateBaseRef*)arg[0]);
  else ::new(mem) ::pat::TriggerObject(*(const ::reco::CandidateBaseRef*)arg[0]);
}

static void constructor_25167( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObject(*(const ::math::XYZTLorentzVector*)arg[0]);
  else ::new(mem) ::pat::TriggerObject(*(const ::math::XYZTLorentzVector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObject(*(const ::math::XYZTLorentzVector*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::pat::TriggerObject(*(const ::math::XYZTLorentzVector*)arg[0],
      *(int*)arg[1]);
  }
}

static void constructor_25168( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObject(*(const ::math::PtEtaPhiMLorentzVector*)arg[0]);
  else ::new(mem) ::pat::TriggerObject(*(const ::math::PtEtaPhiMLorentzVector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObject(*(const ::math::PtEtaPhiMLorentzVector*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::pat::TriggerObject(*(const ::math::PtEtaPhiMLorentzVector*)arg[0],
      *(int*)arg[1]);
  }
}

static void destructor_25169(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::TriggerObject*)o)->::pat::TriggerObject::~TriggerObject)();
}
static  void method_25170( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerObject*)o)->setCollection)(*(const ::std::string*)arg[0]);
}

static  void method_25171( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerObject*)o)->setCollection)(*(const ::edm::InputTag*)arg[0]);
}

static  void method_25172( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerObject*)o)->addTriggerObjectType)(*(::trigger::TriggerObjectType*)arg[0]);
}

static  void method_25173( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerObject*)o)->addTriggerObjectType)(*(int*)arg[0]);
}

static  void method_25174( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerObject*)o)->addFilterId)(*(::trigger::TriggerObjectType*)arg[0]);
}

static  void method_25175( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerObject*)o)->addFilterId)(*(int*)arg[0]);
}

static  void method_25176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerObject*)o)->collection)();
  else   (((const ::pat::TriggerObject*)o)->collection)();
}

static  void method_25177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<int>)((((const ::pat::TriggerObject*)o)->triggerObjectTypes)());
  else   (((const ::pat::TriggerObject*)o)->triggerObjectTypes)();
}

static  void method_25178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<int>)((((const ::pat::TriggerObject*)o)->filterIds)());
  else   (((const ::pat::TriggerObject*)o)->filterIds)();
}

static  void method_25179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObject*)o)->hasCollection)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerObject*)o)->hasCollection)(*(const ::std::string*)arg[0]);
}

static  void method_25180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObject*)o)->hasCollection)(*(const ::edm::InputTag*)arg[0]));
  else   (((const ::pat::TriggerObject*)o)->hasCollection)(*(const ::edm::InputTag*)arg[0]);
}

static  void method_25181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObject*)o)->hasTriggerObjectType)(*(::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::TriggerObject*)o)->hasTriggerObjectType)(*(::trigger::TriggerObjectType*)arg[0]);
}

static  void method_25182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObject*)o)->hasTriggerObjectType)(*(int*)arg[0]));
  else   (((const ::pat::TriggerObject*)o)->hasTriggerObjectType)(*(int*)arg[0]);
}

static  void method_25183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObject*)o)->hasFilterId)(*(::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::TriggerObject*)o)->hasFilterId)(*(::trigger::TriggerObjectType*)arg[0]);
}

static  void method_25184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObject*)o)->hasFilterId)(*(int*)arg[0]));
  else   (((const ::pat::TriggerObject*)o)->hasFilterId)(*(int*)arg[0]);
}

static  void method_25185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerObject*)o)->origObjRef)();
  else   (((const ::pat::TriggerObject*)o)->origObjRef)();
}

static  void method_25186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerObject*)o)->origObjCand)());
  else   (((const ::pat::TriggerObject*)o)->origObjCand)();
}

static  void method_25187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (l1extra::L1EmParticleRef)((((const ::pat::TriggerObject*)o)->origL1EmRef)());
  else   (((const ::pat::TriggerObject*)o)->origL1EmRef)();
}

static  void method_25188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerObject*)o)->origL1GctEmCand)());
  else   (((const ::pat::TriggerObject*)o)->origL1GctEmCand)();
}

static  void method_25189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (l1extra::L1EtMissParticleRef)((((const ::pat::TriggerObject*)o)->origL1EtMissRef)());
  else   (((const ::pat::TriggerObject*)o)->origL1EtMissRef)();
}

static  void method_25190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerObject*)o)->origL1GctEtMiss)());
  else   (((const ::pat::TriggerObject*)o)->origL1GctEtMiss)();
}

static  void method_25191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerObject*)o)->origL1GctEtTotal)());
  else   (((const ::pat::TriggerObject*)o)->origL1GctEtTotal)();
}

static  void method_25192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerObject*)o)->origL1GctHtMiss)());
  else   (((const ::pat::TriggerObject*)o)->origL1GctHtMiss)();
}

static  void method_25193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerObject*)o)->origL1GctEtHad)());
  else   (((const ::pat::TriggerObject*)o)->origL1GctEtHad)();
}

static  void method_25194( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (l1extra::L1JetParticleRef)((((const ::pat::TriggerObject*)o)->origL1JetRef)());
  else   (((const ::pat::TriggerObject*)o)->origL1JetRef)();
}

static  void method_25195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerObject*)o)->origL1GctJetCand)());
  else   (((const ::pat::TriggerObject*)o)->origL1GctJetCand)();
}

static  void method_25196( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (l1extra::L1MuonParticleRef)((((const ::pat::TriggerObject*)o)->origL1MuonRef)());
  else   (((const ::pat::TriggerObject*)o)->origL1MuonRef)();
}

static  void method_25197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerObject*)o)->origL1GmtMuonCand)());
  else   (((const ::pat::TriggerObject*)o)->origL1GmtMuonCand)();
}

static  void method_25198( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObject*)o)->coll)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerObject*)o)->coll)(*(const ::std::string*)arg[0]);
}

static  void method_25199( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObject*)o)->type)(*(::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::TriggerObject*)o)->type)(*(::trigger::TriggerObjectType*)arg[0]);
}

static  void method_25200( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObject*)o)->type)(*(int*)arg[0]));
  else   (((const ::pat::TriggerObject*)o)->type)(*(int*)arg[0]);
}

static  void method_25201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObject*)o)->id)(*(::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::TriggerObject*)o)->id)(*(::trigger::TriggerObjectType*)arg[0]);
}

static  void method_25202( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObject*)o)->id)(*(int*)arg[0]));
  else   (((const ::pat::TriggerObject*)o)->id)(*(int*)arg[0]);
}

static void method_newdel_7357( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::TriggerObject >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::TriggerObject >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::TriggerObject >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::TriggerObject >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::TriggerObject >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::TriggerObject,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::TriggerObject,::reco::Candidate >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TriggerObject -------------------------------
void __pat__TriggerObject_db_datamem(Reflex::Class*);
void __pat__TriggerObject_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__TriggerObject_datamem_bld(&__pat__TriggerObject_db_datamem);
Reflex::GenreflexMemberBuilder __pat__TriggerObject_funcmem_bld(&__pat__TriggerObject_db_funcmem);
void __pat__TriggerObject_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::TriggerObject"), typeid(::pat::TriggerObject), sizeof(::pat::TriggerObject), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_5317, ::Reflex::BaseOffset< ::pat::TriggerObject, ::reco::LeafCandidate >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11045, type_8935), Reflex::Literal("operator="), operator_25161, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8935), Reflex::Literal("TriggerObject"), constructor_25162, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerObject"), constructor_25163, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30881), Reflex::Literal("TriggerObject"), constructor_25164, 0, "trigObj", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29992), Reflex::Literal("TriggerObject"), constructor_25165, 0, "leafCand", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29996), Reflex::Literal("TriggerObject"), constructor_25166, 0, "candRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28937, type_71), Reflex::Literal("TriggerObject"), constructor_25167, 0, "vec;id=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28939, type_71), Reflex::Literal("TriggerObject"), constructor_25168, 0, "vec;id=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerObject"), destructor_25169, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7357, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__TriggerObject_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__TriggerObject_funcmem_bld);
}

//------Delayed data member builder for class TriggerObject -------------------
void __pat__TriggerObject_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2329, Reflex::Literal("collection_"), OffsetOf(__shadow__::__pat__TriggerObject, collection_), ::Reflex::PRIVATE)
  .AddDataMember(type_2758, Reflex::Literal("triggerObjectTypes_"), OffsetOf(__shadow__::__pat__TriggerObject, triggerObjectTypes_), ::Reflex::PRIVATE)
  .AddDataMember(type_6401, Reflex::Literal("refToOrig_"), OffsetOf(__shadow__::__pat__TriggerObject, refToOrig_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TriggerObject -------------------
void __pat__TriggerObject_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4393), Reflex::Literal("setCollection"), method_25170, 0, "collName", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_18397), Reflex::Literal("setCollection"), method_25171, 0, "collName", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_7391), Reflex::Literal("addTriggerObjectType"), method_25172, 0, "triggerObjectType", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_71), Reflex::Literal("addTriggerObjectType"), method_25173, 0, "triggerObjectType", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_7391), Reflex::Literal("addFilterId"), method_25174, 0, "triggerObjectType", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_71), Reflex::Literal("addFilterId"), method_25175, 0, "triggerObjectType", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4393), Reflex::Literal("collection"), method_25176, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2755), Reflex::Literal("triggerObjectTypes"), method_25177, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2755), Reflex::Literal("filterIds"), method_25178, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_4393), Reflex::Literal("hasCollection"), method_25179, 0, "collName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_18397), Reflex::Literal("hasCollection"), method_25180, 0, "collName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_7391), Reflex::Literal("hasTriggerObjectType"), method_25181, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_71), Reflex::Literal("hasTriggerObjectType"), method_25182, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_7391), Reflex::Literal("hasFilterId"), method_25183, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_71), Reflex::Literal("hasFilterId"), method_25184, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29996), Reflex::Literal("origObjRef"), method_25185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29555), Reflex::Literal("origObjCand"), method_25186, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3987c), Reflex::Literal("origL1EmRef"), method_25187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3603), Reflex::Literal("origL1GctEmCand"), method_25188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4002c), Reflex::Literal("origL1EtMissRef"), method_25189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3685), Reflex::Literal("origL1GctEtMiss"), method_25190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5129), Reflex::Literal("origL1GctEtTotal"), method_25191, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3496), Reflex::Literal("origL1GctHtMiss"), method_25192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4869), Reflex::Literal("origL1GctEtHad"), method_25193, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3995c), Reflex::Literal("origL1JetRef"), method_25194, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5906), Reflex::Literal("origL1GctJetCand"), method_25195, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3990c), Reflex::Literal("origL1MuonRef"), method_25196, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13586), Reflex::Literal("origL1GmtMuonCand"), method_25197, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_4393), Reflex::Literal("coll"), method_25198, 0, "collName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_7391), Reflex::Literal("type"), method_25199, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_71), Reflex::Literal("type"), method_25200, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_7391), Reflex::Literal("id"), method_25201, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_71), Reflex::Literal("id"), method_25202, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >,long int,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >&> -------------------------------
static void destructor_10374(void*, void * o, const std::vector<void*>&, void *) {
(((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>*)o)->::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>::~iterator)();
}
static  void operator_10375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>*)o)->operator=)(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>*)arg[0]);
  else   (((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>*)o)->operator=)(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>*)arg[0]);
}

static void constructor_10376( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>*)arg[0]);
  else ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>*)arg[0]);
}

static void constructor_10377( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>();
  else ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>();
}

static void method_newdel_2643( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >,long int,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >&> -------------------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__long_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_p_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_r__db_datamem(Reflex::Class*);
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__long_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_p_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_r__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__long_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_p_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_r__datamem_bld(&__std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__long_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_p_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_r__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__long_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_p_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_r__funcmem_bld(&__std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__long_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_p_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_r__db_funcmem);
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__long_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_p_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_r__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>"), typeid(::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>), sizeof(::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject>>,*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject>>*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject>>&>")
  .AddTypedef(type_2391, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>::iterator_category"))
  .AddTypedef(type_4344, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>::value_type"))
  .AddTypedef(type_66, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>::difference_type"))
  .AddTypedef(type_10370, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>::pointer"))
  .AddTypedef(type_10372, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator"), destructor_10374, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26359, type_26360), Reflex::Literal("operator="), operator_10375, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26360), Reflex::Literal("iterator"), constructor_10376, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator"), constructor_10377, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2643, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >,long int,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >&> -------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__long_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_p_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_r__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >,long int,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >&> -------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__long_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_p_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_r__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class TriggerFilter -------------------------------
static  void operator_25209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::TriggerFilter*)o)->operator=)(*(const ::pat::TriggerFilter*)arg[0]);
  else   (((::pat::TriggerFilter*)o)->operator=)(*(const ::pat::TriggerFilter*)arg[0]);
}

static void constructor_25210( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerFilter(*(const ::pat::TriggerFilter*)arg[0]);
  else ::new(mem) ::pat::TriggerFilter(*(const ::pat::TriggerFilter*)arg[0]);
}

static void constructor_25211( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerFilter();
  else ::new(mem) ::pat::TriggerFilter();
}

static void constructor_25212( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerFilter(*(const ::std::string*)arg[0]);
  else ::new(mem) ::pat::TriggerFilter(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerFilter(*(const ::std::string*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::pat::TriggerFilter(*(const ::std::string*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerFilter(*(const ::std::string*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::pat::TriggerFilter(*(const ::std::string*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25213( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerFilter(*(const ::edm::InputTag*)arg[0]);
  else ::new(mem) ::pat::TriggerFilter(*(const ::edm::InputTag*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerFilter(*(const ::edm::InputTag*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::pat::TriggerFilter(*(const ::edm::InputTag*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerFilter(*(const ::edm::InputTag*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::pat::TriggerFilter(*(const ::edm::InputTag*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void destructor_25214(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::TriggerFilter*)o)->::pat::TriggerFilter::~TriggerFilter)();
}
static  void method_25215( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerFilter*)o)->setLabel)(*(const ::std::string*)arg[0]);
}

static  void method_25216( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerFilter*)o)->setType)(*(const ::std::string*)arg[0]);
}

static  void method_25217( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerFilter*)o)->addObjectKey)(*(unsigned int*)arg[0]);
}

static  void method_25218( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerFilter*)o)->addTriggerObjectType)(*(::trigger::TriggerObjectType*)arg[0]);
}

static  void method_25219( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerFilter*)o)->addTriggerObjectType)(*(int*)arg[0]);
}

static  void method_25220( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerFilter*)o)->addObjectId)(*(::trigger::TriggerObjectType*)arg[0]);
}

static  void method_25221( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerFilter*)o)->addObjectId)(*(int*)arg[0]);
}

static  void method_25222( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::pat::TriggerFilter*)o)->setStatus)(*(int*)arg[0]));
  else   (((::pat::TriggerFilter*)o)->setStatus)(*(int*)arg[0]);
}

static  void method_25223( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerFilter*)o)->setSaveTags)(*(bool*)arg[0]);
}

static  void method_25224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerFilter*)o)->label)();
  else   (((const ::pat::TriggerFilter*)o)->label)();
}

static  void method_25225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerFilter*)o)->type)();
  else   (((const ::pat::TriggerFilter*)o)->type)();
}

static  void method_25226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerFilter*)o)->objectKeys)();
  else   (((const ::pat::TriggerFilter*)o)->objectKeys)();
}

static  void method_25227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<int>)((((const ::pat::TriggerFilter*)o)->triggerObjectTypes)());
  else   (((const ::pat::TriggerFilter*)o)->triggerObjectTypes)();
}

static  void method_25228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<int>)((((const ::pat::TriggerFilter*)o)->objectIds)());
  else   (((const ::pat::TriggerFilter*)o)->objectIds)();
}

static  void method_25229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::TriggerFilter*)o)->status)());
  else   (((const ::pat::TriggerFilter*)o)->status)();
}

static  void method_25230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerFilter*)o)->saveTags)());
  else   (((const ::pat::TriggerFilter*)o)->saveTags)();
}

static  void method_25231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerFilter*)o)->isL3)());
  else   (((const ::pat::TriggerFilter*)o)->isL3)();
}

static  void method_25232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerFilter*)o)->isFiring)());
  else   (((const ::pat::TriggerFilter*)o)->isFiring)();
}

static  void method_25233( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerFilter*)o)->hasObjectKey)(*(unsigned int*)arg[0]));
  else   (((const ::pat::TriggerFilter*)o)->hasObjectKey)(*(unsigned int*)arg[0]);
}

static  void method_25234( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerFilter*)o)->hasTriggerObjectType)(*(::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::TriggerFilter*)o)->hasTriggerObjectType)(*(::trigger::TriggerObjectType*)arg[0]);
}

static  void method_25235( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerFilter*)o)->hasTriggerObjectType)(*(int*)arg[0]));
  else   (((const ::pat::TriggerFilter*)o)->hasTriggerObjectType)(*(int*)arg[0]);
}

static  void method_25236( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerFilter*)o)->hasObjectId)(*(::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::TriggerFilter*)o)->hasObjectId)(*(::trigger::TriggerObjectType*)arg[0]);
}

static  void method_25237( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerFilter*)o)->hasObjectId)(*(int*)arg[0]));
  else   (((const ::pat::TriggerFilter*)o)->hasObjectId)(*(int*)arg[0]);
}

static void method_newdel_7359( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::TriggerFilter >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::TriggerFilter >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::TriggerFilter >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::TriggerFilter >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::TriggerFilter >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TriggerFilter -------------------------------
void __pat__TriggerFilter_db_datamem(Reflex::Class*);
void __pat__TriggerFilter_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__TriggerFilter_datamem_bld(&__pat__TriggerFilter_db_datamem);
Reflex::GenreflexMemberBuilder __pat__TriggerFilter_funcmem_bld(&__pat__TriggerFilter_db_funcmem);
void __pat__TriggerFilter_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::TriggerFilter"), typeid(::pat::TriggerFilter), sizeof(::pat::TriggerFilter), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11108, type_8902), Reflex::Literal("operator="), operator_25209, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8902), Reflex::Literal("TriggerFilter"), constructor_25210, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerFilter"), constructor_25211, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4393, type_71, type_1454), Reflex::Literal("TriggerFilter"), constructor_25212, 0, "label;status=-0x00000000000000001;saveTags=false", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18397, type_71, type_1454), Reflex::Literal("TriggerFilter"), constructor_25213, 0, "tag;status=-0x00000000000000001;saveTags=false", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerFilter"), destructor_25214, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7359, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__TriggerFilter_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__TriggerFilter_funcmem_bld);
}

//------Delayed data member builder for class TriggerFilter -------------------
void __pat__TriggerFilter_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2329, Reflex::Literal("label_"), OffsetOf(__shadow__::__pat__TriggerFilter, label_), ::Reflex::PRIVATE)
  .AddDataMember(type_2329, Reflex::Literal("type_"), OffsetOf(__shadow__::__pat__TriggerFilter, type_), ::Reflex::PRIVATE)
  .AddDataMember(type_2753, Reflex::Literal("objectKeys_"), OffsetOf(__shadow__::__pat__TriggerFilter, objectKeys_), ::Reflex::PRIVATE)
  .AddDataMember(type_2758, Reflex::Literal("triggerObjectTypes_"), OffsetOf(__shadow__::__pat__TriggerFilter, triggerObjectTypes_), ::Reflex::PRIVATE)
  .AddDataMember(type_71, Reflex::Literal("status_"), OffsetOf(__shadow__::__pat__TriggerFilter, status_), ::Reflex::PRIVATE)
  .AddDataMember(type_1454, Reflex::Literal("saveTags_"), OffsetOf(__shadow__::__pat__TriggerFilter, saveTags_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TriggerFilter -------------------
void __pat__TriggerFilter_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4393), Reflex::Literal("setLabel"), method_25215, 0, "label", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4393), Reflex::Literal("setType"), method_25216, 0, "type", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_289), Reflex::Literal("addObjectKey"), method_25217, 0, "objectKey", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_7391), Reflex::Literal("addTriggerObjectType"), method_25218, 0, "triggerObjectType", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_71), Reflex::Literal("addTriggerObjectType"), method_25219, 0, "triggerObjectType", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_7391), Reflex::Literal("addObjectId"), method_25220, 0, "triggerObjectType", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_71), Reflex::Literal("addObjectId"), method_25221, 0, "triggerObjectType", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_71), Reflex::Literal("setStatus"), method_25222, 0, "status", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1454), Reflex::Literal("setSaveTags"), method_25223, 0, "saveTags", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4393), Reflex::Literal("label"), method_25224, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4393), Reflex::Literal("type"), method_25225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20074), Reflex::Literal("objectKeys"), method_25226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2755), Reflex::Literal("triggerObjectTypes"), method_25227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2755), Reflex::Literal("objectIds"), method_25228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71), Reflex::Literal("status"), method_25229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("saveTags"), method_25230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isL3"), method_25231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isFiring"), method_25232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_289), Reflex::Literal("hasObjectKey"), method_25233, 0, "objectKey", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_7391), Reflex::Literal("hasTriggerObjectType"), method_25234, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_71), Reflex::Literal("hasTriggerObjectType"), method_25235, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_7391), Reflex::Literal("hasObjectId"), method_25236, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_71), Reflex::Literal("hasObjectId"), method_25237, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> >,long int,edm::Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> >&> -------------------------------
static void destructor_10385(void*, void * o, const std::vector<void*>&, void *) {
(((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>*)o)->::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>::~iterator)();
}
static  void operator_10386( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>*)o)->operator=)(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>*)arg[0]);
  else   (((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>*)o)->operator=)(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>*)arg[0]);
}

static void constructor_10387( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>*)arg[0]);
  else ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>*)arg[0]);
}

static void constructor_10388( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>();
  else ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>();
}

static void method_newdel_2644( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> >,long int,edm::Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> >&> -------------------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__long_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_p_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_r__db_datamem(Reflex::Class*);
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__long_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_p_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_r__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__long_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_p_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_r__datamem_bld(&__std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__long_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_p_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_r__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__long_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_p_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_r__funcmem_bld(&__std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__long_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_p_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_r__db_funcmem);
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__long_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_p_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_r__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>"), typeid(::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>), sizeof(::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter>>,*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter>>*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter>>&>")
  .AddTypedef(type_2391, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>::iterator_category"))
  .AddTypedef(type_4345, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>::value_type"))
  .AddTypedef(type_66, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>::difference_type"))
  .AddTypedef(type_10381, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>::pointer"))
  .AddTypedef(type_10383, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator"), destructor_10385, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26361, type_26362), Reflex::Literal("operator="), operator_10386, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26362), Reflex::Literal("iterator"), constructor_10387, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator"), constructor_10388, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2644, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> >,long int,edm::Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> >&> -------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__long_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_p_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_r__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> >,long int,edm::Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> >&> -------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__long_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_p_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_r__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class TriggerObjectStandAlone -------------------------------
static  void operator_24941( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::TriggerObjectStandAlone*)o)->operator=)(*(const ::pat::TriggerObjectStandAlone*)arg[0]);
  else   (((::pat::TriggerObjectStandAlone*)o)->operator=)(*(const ::pat::TriggerObjectStandAlone*)arg[0]);
}

static void constructor_24942( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::pat::TriggerObjectStandAlone*)arg[0]);
  else ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::pat::TriggerObjectStandAlone*)arg[0]);
}

static void constructor_24953( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObjectStandAlone();
  else ::new(mem) ::pat::TriggerObjectStandAlone();
}

static void constructor_24954( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::pat::TriggerObject*)arg[0]);
  else ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::pat::TriggerObject*)arg[0]);
}

static void constructor_24955( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::trigger::TriggerObject*)arg[0]);
  else ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::trigger::TriggerObject*)arg[0]);
}

static void constructor_24956( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::reco::LeafCandidate*)arg[0]);
  else ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::reco::LeafCandidate*)arg[0]);
}

static void constructor_24957( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::math::XYZTLorentzVector*)arg[0]);
  else ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::math::XYZTLorentzVector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::math::XYZTLorentzVector*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::math::XYZTLorentzVector*)arg[0],
      *(int*)arg[1]);
  }
}

static void constructor_24958( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::math::PtEtaPhiMLorentzVector*)arg[0]);
  else ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::math::PtEtaPhiMLorentzVector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::math::PtEtaPhiMLorentzVector*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::pat::TriggerObjectStandAlone(*(const ::math::PtEtaPhiMLorentzVector*)arg[0],
      *(int*)arg[1]);
  }
}

static void destructor_24959(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::TriggerObjectStandAlone*)o)->::pat::TriggerObjectStandAlone::~TriggerObjectStandAlone)();
}
static  void method_24960( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerObjectStandAlone*)o)->addFilterLabel)(*(const ::std::string*)arg[0]);
}

static  void method_24961( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerObjectStandAlone*)o)->addConditionName)(*(const ::std::string*)arg[0]);
}

static  void method_24962( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::TriggerObjectStandAlone*)o)->addPathName)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::TriggerObjectStandAlone*)o)->addPathName)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::pat::TriggerObjectStandAlone*)o)->addPathName)(*(const ::std::string*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2]);
  }
}

static  void method_24963( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::TriggerObjectStandAlone*)o)->addAlgorithmName)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::TriggerObjectStandAlone*)o)->addAlgorithmName)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_24964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerObjectStandAlone*)o)->filterLabels)();
  else   (((const ::pat::TriggerObjectStandAlone*)o)->filterLabels)();
}

static  void method_24965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerObjectStandAlone*)o)->conditionNames)();
  else   (((const ::pat::TriggerObjectStandAlone*)o)->conditionNames)();
}

static  void method_24966( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::TriggerObjectStandAlone*)o)->pathNames)());
    else     (((const ::pat::TriggerObjectStandAlone*)o)->pathNames)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::TriggerObjectStandAlone*)o)->pathNames)(*(bool*)arg[0]));
    else     (((const ::pat::TriggerObjectStandAlone*)o)->pathNames)(*(bool*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::TriggerObjectStandAlone*)o)->pathNames)(*(bool*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::pat::TriggerObjectStandAlone*)o)->pathNames)(*(bool*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_24967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::TriggerObjectStandAlone*)o)->algorithmNames)());
    else     (((const ::pat::TriggerObjectStandAlone*)o)->algorithmNames)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::TriggerObjectStandAlone*)o)->algorithmNames)(*(bool*)arg[0]));
    else     (((const ::pat::TriggerObjectStandAlone*)o)->algorithmNames)(*(bool*)arg[0]);
  }
}

static  void method_24968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerObject)((((::pat::TriggerObjectStandAlone*)o)->triggerObject)());
  else   (((::pat::TriggerObjectStandAlone*)o)->triggerObject)();
}

static  void method_24969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->hasFilterLabel)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerObjectStandAlone*)o)->hasFilterLabel)(*(const ::std::string*)arg[0]);
}

static  void method_24970( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->hasConditionName)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerObjectStandAlone*)o)->hasConditionName)(*(const ::std::string*)arg[0]);
}

static  void method_24971( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->hasPathName)(*(const ::std::string*)arg[0]));
    else     (((const ::pat::TriggerObjectStandAlone*)o)->hasPathName)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->hasPathName)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::pat::TriggerObjectStandAlone*)o)->hasPathName)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->hasPathName)(*(const ::std::string*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2]));
    else     (((const ::pat::TriggerObjectStandAlone*)o)->hasPathName)(*(const ::std::string*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2]);
  }
}

static  void method_24972( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->hasAlgorithmName)(*(const ::std::string*)arg[0]));
    else     (((const ::pat::TriggerObjectStandAlone*)o)->hasAlgorithmName)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->hasAlgorithmName)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::pat::TriggerObjectStandAlone*)o)->hasAlgorithmName)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_24973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->hasCollection)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerObjectStandAlone*)o)->hasCollection)(*(const ::std::string*)arg[0]);
}

static  void method_24974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->hasCollection)(*(const ::edm::InputTag*)arg[0]));
  else   (((const ::pat::TriggerObjectStandAlone*)o)->hasCollection)(*(const ::edm::InputTag*)arg[0]);
}

static  void method_24975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->hasPathLastFilterAccepted)());
  else   (((const ::pat::TriggerObjectStandAlone*)o)->hasPathLastFilterAccepted)();
}

static  void method_24976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->hasAlgoCondAccepted)());
  else   (((const ::pat::TriggerObjectStandAlone*)o)->hasAlgoCondAccepted)();
}

static  void method_24977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->hasPathL3FilterAccepted)());
  else   (((const ::pat::TriggerObjectStandAlone*)o)->hasPathL3FilterAccepted)();
}

static  void method_24978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->filter)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerObjectStandAlone*)o)->filter)(*(const ::std::string*)arg[0]);
}

static  void method_24979( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->cond)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerObjectStandAlone*)o)->cond)(*(const ::std::string*)arg[0]);
}

static  void method_24980( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->path)(*(const ::std::string*)arg[0]));
    else     (((const ::pat::TriggerObjectStandAlone*)o)->path)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->path)(*(const ::std::string*)arg[0],
      *(unsigned int*)arg[1]));
    else     (((const ::pat::TriggerObjectStandAlone*)o)->path)(*(const ::std::string*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->path)(*(const ::std::string*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned int*)arg[2]));
    else     (((const ::pat::TriggerObjectStandAlone*)o)->path)(*(const ::std::string*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned int*)arg[2]);
  }
}

static  void method_24981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->algo)(*(const ::std::string*)arg[0]));
    else     (((const ::pat::TriggerObjectStandAlone*)o)->algo)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->algo)(*(const ::std::string*)arg[0],
      *(unsigned int*)arg[1]));
    else     (((const ::pat::TriggerObjectStandAlone*)o)->algo)(*(const ::std::string*)arg[0],
      *(unsigned int*)arg[1]);
  }
}

static  void method_24982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerObjectStandAlone*)o)->coll)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerObjectStandAlone*)o)->coll)(*(const ::std::string*)arg[0]);
}

static  void method_24983( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerObjectStandAlone*)o)->packPathNames)(*(const ::edm::TriggerNames*)arg[0]);
}

static  void method_24984( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerObjectStandAlone*)o)->unpackPathNames)(*(const ::edm::TriggerNames*)arg[0]);
}

static void method_newdel_7344( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::TriggerObjectStandAlone >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::TriggerObjectStandAlone >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::TriggerObjectStandAlone >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::TriggerObjectStandAlone >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::TriggerObjectStandAlone >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::TriggerObject")), ::Reflex::BaseOffset< ::pat::TriggerObjectStandAlone,::pat::TriggerObject >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::TriggerObjectStandAlone,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::TriggerObjectStandAlone,::reco::Candidate >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TriggerObjectStandAlone -------------------------------
void __pat__TriggerObjectStandAlone_db_datamem(Reflex::Class*);
void __pat__TriggerObjectStandAlone_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__TriggerObjectStandAlone_datamem_bld(&__pat__TriggerObjectStandAlone_db_datamem);
Reflex::GenreflexMemberBuilder __pat__TriggerObjectStandAlone_funcmem_bld(&__pat__TriggerObjectStandAlone_db_funcmem);
void __pat__TriggerObjectStandAlone_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::TriggerObjectStandAlone"), typeid(::pat::TriggerObjectStandAlone), sizeof(::pat::TriggerObjectStandAlone), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "11")
  .AddBase(type_7357, ::Reflex::BaseOffset< ::pat::TriggerObjectStandAlone, ::pat::TriggerObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11171, type_8913), Reflex::Literal("operator="), operator_24941, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8913), Reflex::Literal("TriggerObjectStandAlone"), constructor_24942, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerObjectStandAlone"), constructor_24953, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8935), Reflex::Literal("TriggerObjectStandAlone"), constructor_24954, 0, "trigObj", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30881), Reflex::Literal("TriggerObjectStandAlone"), constructor_24955, 0, "trigObj", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29992), Reflex::Literal("TriggerObjectStandAlone"), constructor_24956, 0, "leafCand", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28937, type_71), Reflex::Literal("TriggerObjectStandAlone"), constructor_24957, 0, "vec;id=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28939, type_71), Reflex::Literal("TriggerObjectStandAlone"), constructor_24958, 0, "vec;id=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerObjectStandAlone"), destructor_24959, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7344, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__TriggerObjectStandAlone_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__TriggerObjectStandAlone_funcmem_bld);
}

//------Delayed data member builder for class TriggerObjectStandAlone -------------------
void __pat__TriggerObjectStandAlone_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2756, Reflex::Literal("filterLabels_"), OffsetOf(__shadow__::__pat__TriggerObjectStandAlone, filterLabels_), ::Reflex::PRIVATE)
  .AddDataMember(type_2756, Reflex::Literal("pathNames_"), OffsetOf(__shadow__::__pat__TriggerObjectStandAlone, pathNames_), ::Reflex::PRIVATE)
  .AddDataMember(type_2760, Reflex::Literal("pathIndices_"), OffsetOf(__shadow__::__pat__TriggerObjectStandAlone, pathIndices_), ::Reflex::PRIVATE)
  .AddDataMember(type_2761, Reflex::Literal("pathLastFilterAccepted_"), OffsetOf(__shadow__::__pat__TriggerObjectStandAlone, pathLastFilterAccepted_), ::Reflex::PRIVATE)
  .AddDataMember(type_2761, Reflex::Literal("pathL3FilterAccepted_"), OffsetOf(__shadow__::__pat__TriggerObjectStandAlone, pathL3FilterAccepted_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TriggerObjectStandAlone -------------------
void __pat__TriggerObjectStandAlone_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4393), Reflex::Literal("addFilterLabel"), method_24960, 0, "filterLabel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4393), Reflex::Literal("addConditionName"), method_24961, 0, "conditionName", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4393, type_1454, type_1454), Reflex::Literal("addPathName"), method_24962, 0, "pathName;pathLastFilterAccepted=true;pathL3FilterAccepted=true", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4393, type_1454), Reflex::Literal("addAlgorithmName"), method_24963, 0, "algorithmName;algoCondAccepted=true", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26474), Reflex::Literal("filterLabels"), method_24964, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26474), Reflex::Literal("conditionNames"), method_24965, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2756, type_1454, type_1454), Reflex::Literal("pathNames"), method_24966, 0, "pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2756, type_1454), Reflex::Literal("algorithmNames"), method_24967, 0, "algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7357), Reflex::Literal("triggerObject"), method_24968, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_4393), Reflex::Literal("hasFilterLabel"), method_24969, 0, "filterLabel", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_4393), Reflex::Literal("hasConditionName"), method_24970, 0, "conditionName", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_4393, type_1454, type_1454), Reflex::Literal("hasPathName"), method_24971, 0, "pathName;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_4393, type_1454), Reflex::Literal("hasAlgorithmName"), method_24972, 0, "algorithmName;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_4393), Reflex::Literal("hasCollection"), method_24973, 0, "collName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_18397), Reflex::Literal("hasCollection"), method_24974, 0, "collName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasPathLastFilterAccepted"), method_24975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasAlgoCondAccepted"), method_24976, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasPathL3FilterAccepted"), method_24977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_4393), Reflex::Literal("filter"), method_24978, 0, "filterLabel", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_4393), Reflex::Literal("cond"), method_24979, 0, "conditionName", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_4393, type_289, type_289), Reflex::Literal("path"), method_24980, 0, "pathName;pathLastFilterAccepted=0;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_4393, type_289), Reflex::Literal("algo"), method_24981, 0, "algorithmName;algoCondAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_4393), Reflex::Literal("coll"), method_24982, 0, "collName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29483), Reflex::Literal("packPathNames"), method_24983, 0, "names", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29483), Reflex::Literal("unpackPathNames"), method_24984, 0, "names", ::Reflex::PUBLIC);
}
//------Stub functions for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> >,long int,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> >&> -------------------------------
static void destructor_10396(void*, void * o, const std::vector<void*>&, void *) {
(((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>*)o)->::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>::~iterator)();
}
static  void operator_10397( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>*)o)->operator=)(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>*)arg[0]);
  else   (((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>*)o)->operator=)(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>*)arg[0]);
}

static void constructor_10398( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>*)arg[0]);
  else ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>*)arg[0]);
}

static void constructor_10399( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>();
  else ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>();
}

static void method_newdel_2645( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> >,long int,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> >&> -------------------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__long_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_p_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_r__db_datamem(Reflex::Class*);
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__long_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_p_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_r__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__long_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_p_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_r__datamem_bld(&__std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__long_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_p_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_r__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__long_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_p_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_r__funcmem_bld(&__std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__long_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_p_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_r__db_funcmem);
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__long_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_p_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_r__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>"), typeid(::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>), sizeof(::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone>>,*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone>>*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone>>&>")
  .AddTypedef(type_2391, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>::iterator_category"))
  .AddTypedef(type_4346, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>::value_type"))
  .AddTypedef(type_66, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>::difference_type"))
  .AddTypedef(type_10392, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>::pointer"))
  .AddTypedef(type_10394, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator"), destructor_10396, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26363, type_26364), Reflex::Literal("operator="), operator_10397, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26364), Reflex::Literal("iterator"), constructor_10398, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator"), constructor_10399, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2645, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> >,long int,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> >&> -------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__long_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_p_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_r__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> >,long int,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> >&> -------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__long_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_p_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_r__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class TriggerPath -------------------------------
static  void operator_24996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::TriggerPath*)o)->operator=)(*(const ::pat::TriggerPath*)arg[0]);
  else   (((::pat::TriggerPath*)o)->operator=)(*(const ::pat::TriggerPath*)arg[0]);
}

static void constructor_24997( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerPath(*(const ::pat::TriggerPath*)arg[0]);
  else ::new(mem) ::pat::TriggerPath(*(const ::pat::TriggerPath*)arg[0]);
}

static void constructor_24998( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerPath();
  else ::new(mem) ::pat::TriggerPath();
}

static void constructor_24999( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerPath(*(const ::std::string*)arg[0]);
  else ::new(mem) ::pat::TriggerPath(*(const ::std::string*)arg[0]);
}

static void constructor_25000( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 7 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerPath(*(const ::std::string*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned int*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5],
      *(unsigned int*)arg[6]);
  else ::new(mem) ::pat::TriggerPath(*(const ::std::string*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned int*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5],
      *(unsigned int*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerPath(*(const ::std::string*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned int*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5],
      *(unsigned int*)arg[6],
      *(unsigned int*)arg[7]);
  else ::new(mem) ::pat::TriggerPath(*(const ::std::string*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned int*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5],
      *(unsigned int*)arg[6],
      *(unsigned int*)arg[7]);
  }
}

static void destructor_25001(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::TriggerPath*)o)->::pat::TriggerPath::~TriggerPath)();
}
static  void method_25002( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerPath*)o)->setName)(*(const ::std::string*)arg[0]);
}

static  void method_25003( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerPath*)o)->setIndex)(*(unsigned int*)arg[0]);
}

static  void method_25004( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerPath*)o)->setPrescale)(*(unsigned int*)arg[0]);
}

static  void method_25005( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerPath*)o)->setRun)(*(bool*)arg[0]);
}

static  void method_25006( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerPath*)o)->setAccept)(*(bool*)arg[0]);
}

static  void method_25007( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerPath*)o)->setError)(*(bool*)arg[0]);
}

static  void method_25008( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerPath*)o)->setLastActiveFilterSlot)(*(unsigned int*)arg[0]);
}

static  void method_25009( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerPath*)o)->setL3Filters)(*(unsigned int*)arg[0]);
}

static  void method_25010( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerPath*)o)->addModule)(*(const ::std::string*)arg[0]);
}

static  void method_25011( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerPath*)o)->addFilterIndex)(*(const unsigned int*)arg[0]);
}

static  void method_25012( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerPath*)o)->addL1Seed)(*(const ::pat::L1Seed*)arg[0]);
}

static  void method_25013( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerPath*)o)->addL1Seed)(*(bool*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_25014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerPath*)o)->name)();
  else   (((const ::pat::TriggerPath*)o)->name)();
}

static  void method_25015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::pat::TriggerPath*)o)->index)());
  else   (((const ::pat::TriggerPath*)o)->index)();
}

static  void method_25016( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::pat::TriggerPath*)o)->prescale)());
  else   (((const ::pat::TriggerPath*)o)->prescale)();
}

static  void method_25017( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerPath*)o)->wasRun)());
  else   (((const ::pat::TriggerPath*)o)->wasRun)();
}

static  void method_25018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerPath*)o)->wasAccept)());
  else   (((const ::pat::TriggerPath*)o)->wasAccept)();
}

static  void method_25019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerPath*)o)->wasError)());
  else   (((const ::pat::TriggerPath*)o)->wasError)();
}

static  void method_25020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::pat::TriggerPath*)o)->lastActiveFilterSlot)());
  else   (((const ::pat::TriggerPath*)o)->lastActiveFilterSlot)();
}

static  void method_25021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::pat::TriggerPath*)o)->l3Filters)());
  else   (((const ::pat::TriggerPath*)o)->l3Filters)();
}

static  void method_25022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerPath*)o)->xTrigger)());
  else   (((const ::pat::TriggerPath*)o)->xTrigger)();
}

static  void method_25023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerPath*)o)->modules)();
  else   (((const ::pat::TriggerPath*)o)->modules)();
}

static  void method_25024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerPath*)o)->filterIndices)();
  else   (((const ::pat::TriggerPath*)o)->filterIndices)();
}

static  void method_25025( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::TriggerPath*)o)->indexModule)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerPath*)o)->indexModule)(*(const ::std::string*)arg[0]);
}

static  void method_25026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerPath*)o)->l1Seeds)();
  else   (((const ::pat::TriggerPath*)o)->l1Seeds)();
}

static  void method_25027( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::TriggerPath*)o)->l1Seeds)(*(const bool*)arg[0]));
  else   (((const ::pat::TriggerPath*)o)->l1Seeds)(*(const bool*)arg[0]);
}

static  void method_25028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::TriggerPath*)o)->acceptedL1Seeds)());
  else   (((const ::pat::TriggerPath*)o)->acceptedL1Seeds)();
}

static  void method_25029( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::TriggerPath*)o)->failedL1Seeds)());
  else   (((const ::pat::TriggerPath*)o)->failedL1Seeds)();
}

static void method_newdel_7348( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::TriggerPath >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::TriggerPath >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::TriggerPath >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::TriggerPath >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::TriggerPath >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TriggerPath -------------------------------
void __pat__TriggerPath_db_datamem(Reflex::Class*);
void __pat__TriggerPath_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__TriggerPath_datamem_bld(&__pat__TriggerPath_db_datamem);
Reflex::GenreflexMemberBuilder __pat__TriggerPath_funcmem_bld(&__pat__TriggerPath_db_funcmem);
void __pat__TriggerPath_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::TriggerPath"), typeid(::pat::TriggerPath), sizeof(::pat::TriggerPath), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11234, type_8891), Reflex::Literal("operator="), operator_24996, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8891), Reflex::Literal("TriggerPath"), constructor_24997, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerPath"), constructor_24998, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4393), Reflex::Literal("TriggerPath"), constructor_24999, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4393, type_289, type_289, type_1454, type_1454, type_1454, type_289, type_289), Reflex::Literal("TriggerPath"), constructor_25000, 0, "name;index;prescale;run;accept;error;lastActiveFilterSlot;l3Filters=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerPath"), destructor_25001, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7348, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__TriggerPath_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__TriggerPath_funcmem_bld);
}

//------Delayed data member builder for class TriggerPath -------------------
void __pat__TriggerPath_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2329, Reflex::Literal("name_"), OffsetOf(__shadow__::__pat__TriggerPath, name_), ::Reflex::PRIVATE)
  .AddDataMember(type_289, Reflex::Literal("index_"), OffsetOf(__shadow__::__pat__TriggerPath, index_), ::Reflex::PRIVATE)
  .AddDataMember(type_289, Reflex::Literal("prescale_"), OffsetOf(__shadow__::__pat__TriggerPath, prescale_), ::Reflex::PRIVATE)
  .AddDataMember(type_1454, Reflex::Literal("run_"), OffsetOf(__shadow__::__pat__TriggerPath, run_), ::Reflex::PRIVATE)
  .AddDataMember(type_1454, Reflex::Literal("accept_"), OffsetOf(__shadow__::__pat__TriggerPath, accept_), ::Reflex::PRIVATE)
  .AddDataMember(type_1454, Reflex::Literal("error_"), OffsetOf(__shadow__::__pat__TriggerPath, error_), ::Reflex::PRIVATE)
  .AddDataMember(type_2756, Reflex::Literal("modules_"), OffsetOf(__shadow__::__pat__TriggerPath, modules_), ::Reflex::PRIVATE)
  .AddDataMember(type_2753, Reflex::Literal("filterIndices_"), OffsetOf(__shadow__::__pat__TriggerPath, filterIndices_), ::Reflex::PRIVATE)
  .AddDataMember(type_289, Reflex::Literal("lastActiveFilterSlot_"), OffsetOf(__shadow__::__pat__TriggerPath, lastActiveFilterSlot_), ::Reflex::PRIVATE)
  .AddDataMember(type_289, Reflex::Literal("l3Filters_"), OffsetOf(__shadow__::__pat__TriggerPath, l3Filters_), ::Reflex::PRIVATE)
  .AddDataMember(type_7372, Reflex::Literal("l1Seeds_"), OffsetOf(__shadow__::__pat__TriggerPath, l1Seeds_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TriggerPath -------------------
void __pat__TriggerPath_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4393), Reflex::Literal("setName"), method_25002, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_289), Reflex::Literal("setIndex"), method_25003, 0, "index", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_289), Reflex::Literal("setPrescale"), method_25004, 0, "prescale", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1454), Reflex::Literal("setRun"), method_25005, 0, "run", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1454), Reflex::Literal("setAccept"), method_25006, 0, "accept", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1454), Reflex::Literal("setError"), method_25007, 0, "error", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_289), Reflex::Literal("setLastActiveFilterSlot"), method_25008, 0, "lastActiveFilterSlot", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_289), Reflex::Literal("setL3Filters"), method_25009, 0, "l3Filters", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4393), Reflex::Literal("addModule"), method_25010, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_289c), Reflex::Literal("addFilterIndex"), method_25011, 0, "index", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_30882), Reflex::Literal("addL1Seed"), method_25012, 0, "seed", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1454, type_4393), Reflex::Literal("addL1Seed"), method_25013, 0, "decision;expression", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4393), Reflex::Literal("name"), method_25014, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("index"), method_25015, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("prescale"), method_25016, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("wasRun"), method_25017, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("wasAccept"), method_25018, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("wasError"), method_25019, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("lastActiveFilterSlot"), method_25020, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("l3Filters"), method_25021, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("xTrigger"), method_25022, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26474), Reflex::Literal("modules"), method_25023, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20074), Reflex::Literal("filterIndices"), method_25024, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71, type_4393), Reflex::Literal("indexModule"), method_25025, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30883), Reflex::Literal("l1Seeds"), method_25026, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2756, type_1454c), Reflex::Literal("l1Seeds"), method_25027, 0, "decision", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2756), Reflex::Literal("acceptedL1Seeds"), method_25028, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2756), Reflex::Literal("failedL1Seeds"), method_25029, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> >,long int,edm::Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> >&> -------------------------------
static void destructor_10407(void*, void * o, const std::vector<void*>&, void *) {
(((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>*)o)->::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>::~iterator)();
}
static  void operator_10408( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>*)o)->operator=)(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>*)arg[0]);
  else   (((::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>*)o)->operator=)(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>*)arg[0]);
}

static void constructor_10409( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>*)arg[0]);
  else ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>(*(const ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>*)arg[0]);
}

static void constructor_10410( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>();
  else ::new(mem) ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>();
}

static void method_newdel_2646( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> >,long int,edm::Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> >&> -------------------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__long_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_p_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_r__db_datamem(Reflex::Class*);
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__long_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_p_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_r__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__long_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_p_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_r__datamem_bld(&__std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__long_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_p_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_r__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__long_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_p_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_r__funcmem_bld(&__std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__long_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_p_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_r__db_funcmem);
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__long_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_p_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_r__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>"), typeid(::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>), sizeof(::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath>>,*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath>>*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath>>&>")
  .AddTypedef(type_2391, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>::iterator_category"))
  .AddTypedef(type_4347, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>::value_type"))
  .AddTypedef(type_66, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>::difference_type"))
  .AddTypedef(type_10403, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>::pointer"))
  .AddTypedef(type_10405, Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator"), destructor_10407, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26365, type_26366), Reflex::Literal("operator="), operator_10408, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26366), Reflex::Literal("iterator"), constructor_10409, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator"), constructor_10410, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2646, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> >,long int,edm::Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> >&> -------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__long_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_p_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_r__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> >,long int,edm::Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> >&> -------------------
void __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__long_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_p_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_r__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<pat::TriggerObject,std::allocator<pat::TriggerObject> > -------------------------------
static void constructor_11055( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerObject>();
  else ::new(mem) ::std::vector<pat::TriggerObject>();
}

static void constructor_11056( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerObject>(*(const ::std::allocator<pat::TriggerObject>*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerObject>(*(const ::std::allocator<pat::TriggerObject>*)arg[0]);
}

static void constructor_11057( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerObject>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerObject>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerObject>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerObject*)arg[1]);
  else ::new(mem) ::std::vector<pat::TriggerObject>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerObject*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerObject>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerObject*)arg[1],
      *(const ::std::allocator<pat::TriggerObject>*)arg[2]);
  else ::new(mem) ::std::vector<pat::TriggerObject>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerObject*)arg[1],
      *(const ::std::allocator<pat::TriggerObject>*)arg[2]);
  }
}

static void constructor_11058( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerObject>(*(const ::std::vector<pat::TriggerObject>*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerObject>(*(const ::std::vector<pat::TriggerObject>*)arg[0]);
}

static void destructor_11059(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::TriggerObject>*)o)->::std::vector<pat::TriggerObject>::~vector)();
}
static  void operator_11060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerObject>*)o)->operator=)(*(const ::std::vector<pat::TriggerObject>*)arg[0]);
  else   (((::std::vector<pat::TriggerObject>*)o)->operator=)(*(const ::std::vector<pat::TriggerObject>*)arg[0]);
}

static  void method_11061( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerObject>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::TriggerObject*)arg[1]);
}

static  void method_11062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> >)((((::std::vector<pat::TriggerObject>*)o)->begin)());
  else   (((::std::vector<pat::TriggerObject>*)o)->begin)();
}

static  void method_11063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >)((((const ::std::vector<pat::TriggerObject>*)o)->begin)());
  else   (((const ::std::vector<pat::TriggerObject>*)o)->begin)();
}

static  void method_11064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> >)((((::std::vector<pat::TriggerObject>*)o)->end)());
  else   (((::std::vector<pat::TriggerObject>*)o)->end)();
}

static  void method_11065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >)((((const ::std::vector<pat::TriggerObject>*)o)->end)());
  else   (((const ::std::vector<pat::TriggerObject>*)o)->end)();
}

static  void method_11070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerObject>*)o)->size)());
  else   (((const ::std::vector<pat::TriggerObject>*)o)->size)();
}

static  void method_11071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerObject>*)o)->max_size)());
  else   (((const ::std::vector<pat::TriggerObject>*)o)->max_size)();
}

static  void method_11072( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::TriggerObject>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::TriggerObject>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::TriggerObject*)arg[1]);
  }
}

static  void method_11073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerObject>*)o)->capacity)());
  else   (((const ::std::vector<pat::TriggerObject>*)o)->capacity)();
}

static  void method_11074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::TriggerObject>*)o)->empty)());
  else   (((const ::std::vector<pat::TriggerObject>*)o)->empty)();
}

static  void method_11075( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerObject>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_11076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::TriggerObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::TriggerObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_11079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerObject>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::TriggerObject>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11080( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerObject>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::TriggerObject>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerObject>*)o)->front)();
  else   (((::std::vector<pat::TriggerObject>*)o)->front)();
}

static  void method_11082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerObject>*)o)->front)();
  else   (((const ::std::vector<pat::TriggerObject>*)o)->front)();
}

static  void method_11083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerObject>*)o)->back)();
  else   (((::std::vector<pat::TriggerObject>*)o)->back)();
}

static  void method_11084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerObject>*)o)->back)();
  else   (((const ::std::vector<pat::TriggerObject>*)o)->back)();
}

static  void method_11085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::TriggerObject>*)o)->data)());
  else   (((::std::vector<pat::TriggerObject>*)o)->data)();
}

static  void method_11086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::TriggerObject>*)o)->data)());
  else   (((const ::std::vector<pat::TriggerObject>*)o)->data)();
}

static  void method_11087( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerObject>*)o)->push_back)(*(const ::pat::TriggerObject*)arg[0]);
}

static  void method_11088( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::TriggerObject>*)o)->pop_back)();
}

static  void method_11089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> >)((((::std::vector<pat::TriggerObject>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> >*)arg[0],
    *(const ::pat::TriggerObject*)arg[1]));
  else   (((::std::vector<pat::TriggerObject>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> >*)arg[0],
    *(const ::pat::TriggerObject*)arg[1]);
}

static  void method_11090( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerObject>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::TriggerObject*)arg[2]);
}

static  void method_11091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> >)((((::std::vector<pat::TriggerObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> >*)arg[0]));
  else   (((::std::vector<pat::TriggerObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> >*)arg[0]);
}

static  void method_11092( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> >)((((::std::vector<pat::TriggerObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> >*)arg[1]));
  else   (((::std::vector<pat::TriggerObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::TriggerObject*,std::vector<pat::TriggerObject> >*)arg[1]);
}

static  void method_11093( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerObject>*)o)->swap)(*(::std::vector<pat::TriggerObject>*)arg[0]);
}

static  void method_11094( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::TriggerObject>*)o)->clear)();
}

static void method_newdel_2747( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerObject> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerObject> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerObject> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerObject> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerObject> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::TriggerObject,std::allocator<pat::TriggerObject> >")), ::Reflex::BaseOffset< ::std::vector<pat::TriggerObject>,::std::_Vector_base<pat::TriggerObject,std::allocator<pat::TriggerObject> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::TriggerObject> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::TriggerObject> >::Generate();
}

//------Dictionary for class vector<pat::TriggerObject,std::allocator<pat::TriggerObject> > -------------------------------
void __std__vector_pat__TriggerObject__db_datamem(Reflex::Class*);
void __std__vector_pat__TriggerObject__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__TriggerObject__datamem_bld(&__std__vector_pat__TriggerObject__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__TriggerObject__funcmem_bld(&__std__vector_pat__TriggerObject__db_funcmem);
void __std__vector_pat__TriggerObject__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::TriggerObject>"), typeid(::std::vector<pat::TriggerObject>), sizeof(::std::vector<pat::TriggerObject>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2290, ::Reflex::BaseOffset< ::std::vector<pat::TriggerObject>, ::std::_Vector_base<pat::TriggerObject,std::allocator<pat::TriggerObject> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7357, Reflex::Literal("std::vector<pat::TriggerObject>::_Alloc_value_type"))
  .AddTypedef(type_2290, Reflex::Literal("std::vector<pat::TriggerObject>::_Base"))
  .AddTypedef(type_2942, Reflex::Literal("std::vector<pat::TriggerObject>::_Tp_alloc_type"))
  .AddTypedef(type_6708, Reflex::Literal("std::vector<pat::TriggerObject>::_Alloc_traits"))
  .AddTypedef(type_7357, Reflex::Literal("std::vector<pat::TriggerObject>::value_type"))
  .AddTypedef(type_8063, Reflex::Literal("std::vector<pat::TriggerObject>::pointer"))
  .AddTypedef(type_8933, Reflex::Literal("std::vector<pat::TriggerObject>::const_pointer"))
  .AddTypedef(type_11045, Reflex::Literal("std::vector<pat::TriggerObject>::reference"))
  .AddTypedef(type_8935, Reflex::Literal("std::vector<pat::TriggerObject>::const_reference"))
  .AddTypedef(type_6591, Reflex::Literal("std::vector<pat::TriggerObject>::iterator"))
  .AddTypedef(type_6579, Reflex::Literal("std::vector<pat::TriggerObject>::const_iterator"))
  .AddTypedef(type_3118, Reflex::Literal("std::vector<pat::TriggerObject>::const_reverse_iterator"))
  .AddTypedef(type_3119, Reflex::Literal("std::vector<pat::TriggerObject>::reverse_iterator"))
  .AddTypedef(type_2926, Reflex::Literal("std::vector<pat::TriggerObject>::size_type"))
  .AddTypedef(type_2844, Reflex::Literal("std::vector<pat::TriggerObject>::difference_type"))
  .AddTypedef(type_2942, Reflex::Literal("std::vector<pat::TriggerObject>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_11055, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25589), Reflex::Literal("vector"), constructor_11056, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2926, type_8935, type_25589), Reflex::Literal("vector"), constructor_11057, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15881), Reflex::Literal("vector"), constructor_11058, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_11059, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2747, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__TriggerObject__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::TriggerObject,std::allocator<pat::TriggerObject> > -------------------
void __std__vector_pat__TriggerObject__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::TriggerObject,std::allocator<pat::TriggerObject> > -------------------
void __std__vector_pat__TriggerObject__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26461, type_15881), Reflex::Literal("operator="), operator_11060, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926, type_8935), Reflex::Literal("assign"), method_11061, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6591), Reflex::Literal("begin"), method_11062, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6579), Reflex::Literal("begin"), method_11063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6591), Reflex::Literal("end"), method_11064, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6579), Reflex::Literal("end"), method_11065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("size"), method_11070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("max_size"), method_11071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926, type_7357), Reflex::Literal("resize"), method_11072, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("capacity"), method_11073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_11074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926), Reflex::Literal("reserve"), method_11075, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11045, type_2926), Reflex::Literal("operator[]"), operator_11076, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8935, type_2926), Reflex::Literal("operator[]"), operator_11077, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11045, type_2926), Reflex::Literal("at"), method_11079, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8935, type_2926), Reflex::Literal("at"), method_11080, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11045), Reflex::Literal("front"), method_11081, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8935), Reflex::Literal("front"), method_11082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11045), Reflex::Literal("back"), method_11083, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8935), Reflex::Literal("back"), method_11084, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8063), Reflex::Literal("data"), method_11085, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8933), Reflex::Literal("data"), method_11086, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_8935), Reflex::Literal("push_back"), method_11087, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("pop_back"), method_11088, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6591, type_6591, type_8935), Reflex::Literal("insert"), method_11089, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_6591, type_2926, type_8935), Reflex::Literal("insert"), method_11090, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6591, type_6591), Reflex::Literal("erase"), method_11091, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6591, type_6591, type_6591), Reflex::Literal("erase"), method_11092, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_26461), Reflex::Literal("swap"), method_11093, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_11094, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------------------
static void destructor_19070(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Association<std::vector<pat::TriggerObject> >*)o)->::edm::Association<std::vector<pat::TriggerObject> >::~Association)();
}
static void constructor_19071( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<std::vector<pat::TriggerObject> >(*(const ::edm::Association<std::vector<pat::TriggerObject> >*)arg[0]);
  else ::new(mem) ::edm::Association<std::vector<pat::TriggerObject> >(*(const ::edm::Association<std::vector<pat::TriggerObject> >*)arg[0]);
}

static void constructor_19072( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<std::vector<pat::TriggerObject> >();
  else ::new(mem) ::edm::Association<std::vector<pat::TriggerObject> >();
}

static  void method_19073( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >)((((const ::edm::Association<std::vector<pat::TriggerObject> >*)o)->get)(*(::size_t*)arg[0]));
  else   (((const ::edm::Association<std::vector<pat::TriggerObject> >*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_19074( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >)((((const ::edm::Association<std::vector<pat::TriggerObject> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::Association<std::vector<pat::TriggerObject> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_19075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<std::vector<pat::TriggerObject> >*)o)->operator+=)(*(const ::edm::Association<std::vector<pat::TriggerObject> >*)arg[0]);
  else   (((::edm::Association<std::vector<pat::TriggerObject> >*)o)->operator+=)(*(const ::edm::Association<std::vector<pat::TriggerObject> >*)arg[0]);
}

static  void method_19076( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<std::vector<pat::TriggerObject> >*)o)->setRef)(*(const ::edm::RefProd<std::vector<pat::TriggerObject> >*)arg[0]);
}

static  void method_19077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<std::vector<pat::TriggerObject> >*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::Association<std::vector<pat::TriggerObject> >*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_19078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::Association<std::vector<pat::TriggerObject> >*)o)->size)());
  else   (((const ::edm::Association<std::vector<pat::TriggerObject> >*)o)->size)();
}

static  void method_19079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<std::vector<pat::TriggerObject> >*)o)->empty)());
  else   (((const ::edm::Association<std::vector<pat::TriggerObject> >*)o)->empty)();
}

static  void method_19080( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::Association<std::vector<pat::TriggerObject> >*)o)->clear)();
}

static  void method_19081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefProd<std::vector<pat::TriggerObject> >)((((const ::edm::Association<std::vector<pat::TriggerObject> >*)o)->ref)());
  else   (((const ::edm::Association<std::vector<pat::TriggerObject> >*)o)->ref)();
}

static  void method_19082( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<std::vector<pat::TriggerObject> >*)o)->swap)(*(::edm::Association<std::vector<pat::TriggerObject> >*)arg[0]);
}

static  void operator_19083( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<std::vector<pat::TriggerObject> >*)o)->operator=)(*(const ::edm::Association<std::vector<pat::TriggerObject> >*)arg[0]);
  else   (((::edm::Association<std::vector<pat::TriggerObject> >*)o)->operator=)(*(const ::edm::Association<std::vector<pat::TriggerObject> >*)arg[0]);
}

static  void method_19084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Association<std::vector<pat::TriggerObject> >*)o)->ids)();
  else   (((const ::edm::Association<std::vector<pat::TriggerObject> >*)o)->ids)();
}

static  void method_19085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Association<std::vector<pat::TriggerObject> >*)o)->Class_Version)());
  else   (((::edm::Association<std::vector<pat::TriggerObject> >*)o)->Class_Version)();
}

static void method_newdel_4338( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<pat::TriggerObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<pat::TriggerObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<pat::TriggerObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<pat::TriggerObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<pat::TriggerObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<int>")), ::Reflex::BaseOffset< ::edm::Association<std::vector<pat::TriggerObject> >,::edm::ValueMap<int> >::Get(),::Reflex::PRIVATE), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------------------
void __edm__Association_std__vector_pat__TriggerObject_s__db_datamem(Reflex::Class*);
void __edm__Association_std__vector_pat__TriggerObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Association_std__vector_pat__TriggerObject_s__datamem_bld(&__edm__Association_std__vector_pat__TriggerObject_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Association_std__vector_pat__TriggerObject_s__funcmem_bld(&__edm__Association_std__vector_pat__TriggerObject_s__db_funcmem);
void __edm__Association_std__vector_pat__TriggerObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Association<std::vector<pat::TriggerObject> >"), typeid(::edm::Association<std::vector<pat::TriggerObject> >), sizeof(::edm::Association<std::vector<pat::TriggerObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Association<std::vector<pat::TriggerObject> >::Class_Version())
  .AddBase(type_4152, ::Reflex::BaseOffset< ::edm::Association<std::vector<pat::TriggerObject> >, ::edm::ValueMap<int> >::Get(), ::Reflex::PRIVATE)
  .AddTypedef(type_71, Reflex::Literal("edm::Association<std::vector<pat::TriggerObject> >::index"))
  .AddTypedef(type_4152, Reflex::Literal("edm::Association<std::vector<pat::TriggerObject> >::base"))
  .AddTypedef(type_289, Reflex::Literal("edm::Association<std::vector<pat::TriggerObject> >::offset"))
  .AddTypedef(type_4303, Reflex::Literal("edm::Association<std::vector<pat::TriggerObject> >::refprod_type"))
  .AddTypedef(type_4344, Reflex::Literal("edm::Association<std::vector<pat::TriggerObject> >::reference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Association"), destructor_19070, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29444), Reflex::Literal("Association"), constructor_19071, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Association"), constructor_19072, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4338, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Association_std__vector_pat__TriggerObject_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Association_std__vector_pat__TriggerObject_s__funcmem_bld);
}

//------Delayed data member builder for class Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------
void __edm__Association_std__vector_pat__TriggerObject_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4303, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__Association_std__vector_pat__TriggerObject_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------
void __edm__Association_std__vector_pat__TriggerObject_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4344, type_1924), Reflex::Literal("get"), method_19073, 0, "rawIdx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4344, type_4341, type_1924), Reflex::Literal("get"), method_19074, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29573, type_29444), Reflex::Literal("operator+="), operator_19075, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29535), Reflex::Literal("setRef"), method_19076, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_4341), Reflex::Literal("contains"), method_19077, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1924), Reflex::Literal("size"), method_19078, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_19079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_19080, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4303), Reflex::Literal("ref"), method_19081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29573), Reflex::Literal("swap"), method_19082, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29573, type_29444), Reflex::Literal("operator="), operator_19083, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26470), Reflex::Literal("ids"), method_19084, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_19085, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > -------------------------------
static void destructor_10820(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::~pair)();
}
static  void operator_10821( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)arg[0]);
}

static void constructor_10822( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >(*(const ::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >(*(const ::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)arg[0]);
}

static void constructor_10823( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >();
  else ::new(mem) ::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >();
}

static void constructor_10824( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)arg[1]);
}

static void method_newdel_2707( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > -------------------------------
void __std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__datamem_bld(&__std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__funcmem_bld(&__std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__db_funcmem);
void __std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >"), typeid(::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >), sizeof(::std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_2328, Reflex::Literal("std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::first_type"))
  .AddTypedef(type_4304, Reflex::Literal("std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_10820, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26446, type_26447), Reflex::Literal("operator="), operator_10821, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26447), Reflex::Literal("pair"), constructor_10822, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_10823, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8978, type_26448), Reflex::Literal("pair"), constructor_10824, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2707, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > -------------------
void __std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2328, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_4304, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > -------------------
void __std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<pat::TriggerAlgorithm,std::allocator<pat::TriggerAlgorithm> > -------------------------------
static void constructor_10929( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerAlgorithm>();
  else ::new(mem) ::std::vector<pat::TriggerAlgorithm>();
}

static void constructor_10930( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerAlgorithm>(*(const ::std::allocator<pat::TriggerAlgorithm>*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerAlgorithm>(*(const ::std::allocator<pat::TriggerAlgorithm>*)arg[0]);
}

static void constructor_10931( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerAlgorithm>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerAlgorithm>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerAlgorithm>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerAlgorithm*)arg[1]);
  else ::new(mem) ::std::vector<pat::TriggerAlgorithm>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerAlgorithm*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerAlgorithm>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerAlgorithm*)arg[1],
      *(const ::std::allocator<pat::TriggerAlgorithm>*)arg[2]);
  else ::new(mem) ::std::vector<pat::TriggerAlgorithm>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerAlgorithm*)arg[1],
      *(const ::std::allocator<pat::TriggerAlgorithm>*)arg[2]);
  }
}

static void constructor_10932( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerAlgorithm>(*(const ::std::vector<pat::TriggerAlgorithm>*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerAlgorithm>(*(const ::std::vector<pat::TriggerAlgorithm>*)arg[0]);
}

static void destructor_10933(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::TriggerAlgorithm>*)o)->::std::vector<pat::TriggerAlgorithm>::~vector)();
}
static  void operator_10934( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerAlgorithm>*)o)->operator=)(*(const ::std::vector<pat::TriggerAlgorithm>*)arg[0]);
  else   (((::std::vector<pat::TriggerAlgorithm>*)o)->operator=)(*(const ::std::vector<pat::TriggerAlgorithm>*)arg[0]);
}

static  void method_10935( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerAlgorithm>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::TriggerAlgorithm*)arg[1]);
}

static  void method_10936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >)((((::std::vector<pat::TriggerAlgorithm>*)o)->begin)());
  else   (((::std::vector<pat::TriggerAlgorithm>*)o)->begin)();
}

static  void method_10937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >)((((const ::std::vector<pat::TriggerAlgorithm>*)o)->begin)());
  else   (((const ::std::vector<pat::TriggerAlgorithm>*)o)->begin)();
}

static  void method_10938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >)((((::std::vector<pat::TriggerAlgorithm>*)o)->end)());
  else   (((::std::vector<pat::TriggerAlgorithm>*)o)->end)();
}

static  void method_10939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >)((((const ::std::vector<pat::TriggerAlgorithm>*)o)->end)());
  else   (((const ::std::vector<pat::TriggerAlgorithm>*)o)->end)();
}

static  void method_10944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerAlgorithm>*)o)->size)());
  else   (((const ::std::vector<pat::TriggerAlgorithm>*)o)->size)();
}

static  void method_10945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerAlgorithm>*)o)->max_size)());
  else   (((const ::std::vector<pat::TriggerAlgorithm>*)o)->max_size)();
}

static  void method_10946( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::TriggerAlgorithm>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::TriggerAlgorithm>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::TriggerAlgorithm*)arg[1]);
  }
}

static  void method_10947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerAlgorithm>*)o)->capacity)());
  else   (((const ::std::vector<pat::TriggerAlgorithm>*)o)->capacity)();
}

static  void method_10948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::TriggerAlgorithm>*)o)->empty)());
  else   (((const ::std::vector<pat::TriggerAlgorithm>*)o)->empty)();
}

static  void method_10949( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerAlgorithm>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10950( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerAlgorithm>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::TriggerAlgorithm>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerAlgorithm>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::TriggerAlgorithm>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerAlgorithm>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::TriggerAlgorithm>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10954( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerAlgorithm>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::TriggerAlgorithm>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerAlgorithm>*)o)->front)();
  else   (((::std::vector<pat::TriggerAlgorithm>*)o)->front)();
}

static  void method_10956( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerAlgorithm>*)o)->front)();
  else   (((const ::std::vector<pat::TriggerAlgorithm>*)o)->front)();
}

static  void method_10957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerAlgorithm>*)o)->back)();
  else   (((::std::vector<pat::TriggerAlgorithm>*)o)->back)();
}

static  void method_10958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerAlgorithm>*)o)->back)();
  else   (((const ::std::vector<pat::TriggerAlgorithm>*)o)->back)();
}

static  void method_10959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::TriggerAlgorithm>*)o)->data)());
  else   (((::std::vector<pat::TriggerAlgorithm>*)o)->data)();
}

static  void method_10960( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::TriggerAlgorithm>*)o)->data)());
  else   (((const ::std::vector<pat::TriggerAlgorithm>*)o)->data)();
}

static  void method_10961( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerAlgorithm>*)o)->push_back)(*(const ::pat::TriggerAlgorithm*)arg[0]);
}

static  void method_10962( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::TriggerAlgorithm>*)o)->pop_back)();
}

static  void method_10963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >)((((::std::vector<pat::TriggerAlgorithm>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)arg[0],
    *(const ::pat::TriggerAlgorithm*)arg[1]));
  else   (((::std::vector<pat::TriggerAlgorithm>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)arg[0],
    *(const ::pat::TriggerAlgorithm*)arg[1]);
}

static  void method_10964( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerAlgorithm>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::TriggerAlgorithm*)arg[2]);
}

static  void method_10965( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >)((((::std::vector<pat::TriggerAlgorithm>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)arg[0]));
  else   (((::std::vector<pat::TriggerAlgorithm>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)arg[0]);
}

static  void method_10966( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >)((((::std::vector<pat::TriggerAlgorithm>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)arg[1]));
  else   (((::std::vector<pat::TriggerAlgorithm>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)arg[1]);
}

static  void method_10967( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerAlgorithm>*)o)->swap)(*(::std::vector<pat::TriggerAlgorithm>*)arg[0]);
}

static  void method_10968( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::TriggerAlgorithm>*)o)->clear)();
}

static void method_newdel_2745( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerAlgorithm> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerAlgorithm> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerAlgorithm> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerAlgorithm> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerAlgorithm> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::TriggerAlgorithm,std::allocator<pat::TriggerAlgorithm> >")), ::Reflex::BaseOffset< ::std::vector<pat::TriggerAlgorithm>,::std::_Vector_base<pat::TriggerAlgorithm,std::allocator<pat::TriggerAlgorithm> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::TriggerAlgorithm> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::TriggerAlgorithm> >::Generate();
}

//------Dictionary for class vector<pat::TriggerAlgorithm,std::allocator<pat::TriggerAlgorithm> > -------------------------------
void __std__vector_pat__TriggerAlgorithm__db_datamem(Reflex::Class*);
void __std__vector_pat__TriggerAlgorithm__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__TriggerAlgorithm__datamem_bld(&__std__vector_pat__TriggerAlgorithm__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__TriggerAlgorithm__funcmem_bld(&__std__vector_pat__TriggerAlgorithm__db_funcmem);
void __std__vector_pat__TriggerAlgorithm__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::TriggerAlgorithm>"), typeid(::std::vector<pat::TriggerAlgorithm>), sizeof(::std::vector<pat::TriggerAlgorithm>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2286, ::Reflex::BaseOffset< ::std::vector<pat::TriggerAlgorithm>, ::std::_Vector_base<pat::TriggerAlgorithm,std::allocator<pat::TriggerAlgorithm> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7368, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::_Alloc_value_type"))
  .AddTypedef(type_2286, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::_Base"))
  .AddTypedef(type_2940, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::_Tp_alloc_type"))
  .AddTypedef(type_6704, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::_Alloc_traits"))
  .AddTypedef(type_7368, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::value_type"))
  .AddTypedef(type_7989, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::pointer"))
  .AddTypedef(type_8856, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::const_pointer"))
  .AddTypedef(type_10919, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::reference"))
  .AddTypedef(type_8858, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::const_reference"))
  .AddTypedef(type_6586, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::iterator"))
  .AddTypedef(type_6572, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::const_iterator"))
  .AddTypedef(type_3108, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::const_reverse_iterator"))
  .AddTypedef(type_3109, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::reverse_iterator"))
  .AddTypedef(type_2926, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::size_type"))
  .AddTypedef(type_2844, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::difference_type"))
  .AddTypedef(type_2940, Reflex::Literal("std::vector<pat::TriggerAlgorithm>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10929, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25537), Reflex::Literal("vector"), constructor_10930, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2926, type_8858, type_25537), Reflex::Literal("vector"), constructor_10931, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15857), Reflex::Literal("vector"), constructor_10932, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10933, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2745, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__TriggerAlgorithm__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::TriggerAlgorithm,std::allocator<pat::TriggerAlgorithm> > -------------------
void __std__vector_pat__TriggerAlgorithm__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::TriggerAlgorithm,std::allocator<pat::TriggerAlgorithm> > -------------------
void __std__vector_pat__TriggerAlgorithm__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26459, type_15857), Reflex::Literal("operator="), operator_10934, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926, type_8858), Reflex::Literal("assign"), method_10935, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6586), Reflex::Literal("begin"), method_10936, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6572), Reflex::Literal("begin"), method_10937, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6586), Reflex::Literal("end"), method_10938, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6572), Reflex::Literal("end"), method_10939, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("size"), method_10944, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("max_size"), method_10945, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926, type_7368), Reflex::Literal("resize"), method_10946, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("capacity"), method_10947, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_10948, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926), Reflex::Literal("reserve"), method_10949, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10919, type_2926), Reflex::Literal("operator[]"), operator_10950, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8858, type_2926), Reflex::Literal("operator[]"), operator_10951, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10919, type_2926), Reflex::Literal("at"), method_10953, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8858, type_2926), Reflex::Literal("at"), method_10954, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10919), Reflex::Literal("front"), method_10955, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8858), Reflex::Literal("front"), method_10956, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10919), Reflex::Literal("back"), method_10957, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8858), Reflex::Literal("back"), method_10958, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7989), Reflex::Literal("data"), method_10959, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8856), Reflex::Literal("data"), method_10960, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_8858), Reflex::Literal("push_back"), method_10961, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("pop_back"), method_10962, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6586, type_6586, type_8858), Reflex::Literal("insert"), method_10963, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_6586, type_2926, type_8858), Reflex::Literal("insert"), method_10964, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6586, type_6586), Reflex::Literal("erase"), method_10965, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6586, type_6586, type_6586), Reflex::Literal("erase"), method_10966, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_26459), Reflex::Literal("swap"), method_10967, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_10968, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<pat::TriggerCondition,std::allocator<pat::TriggerCondition> > -------------------------------
static void constructor_10992( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerCondition>();
  else ::new(mem) ::std::vector<pat::TriggerCondition>();
}

static void constructor_10993( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerCondition>(*(const ::std::allocator<pat::TriggerCondition>*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerCondition>(*(const ::std::allocator<pat::TriggerCondition>*)arg[0]);
}

static void constructor_10994( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerCondition>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerCondition>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerCondition>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerCondition*)arg[1]);
  else ::new(mem) ::std::vector<pat::TriggerCondition>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerCondition*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerCondition>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerCondition*)arg[1],
      *(const ::std::allocator<pat::TriggerCondition>*)arg[2]);
  else ::new(mem) ::std::vector<pat::TriggerCondition>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerCondition*)arg[1],
      *(const ::std::allocator<pat::TriggerCondition>*)arg[2]);
  }
}

static void constructor_10995( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerCondition>(*(const ::std::vector<pat::TriggerCondition>*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerCondition>(*(const ::std::vector<pat::TriggerCondition>*)arg[0]);
}

static void destructor_10996(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::TriggerCondition>*)o)->::std::vector<pat::TriggerCondition>::~vector)();
}
static  void operator_10997( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerCondition>*)o)->operator=)(*(const ::std::vector<pat::TriggerCondition>*)arg[0]);
  else   (((::std::vector<pat::TriggerCondition>*)o)->operator=)(*(const ::std::vector<pat::TriggerCondition>*)arg[0]);
}

static  void method_10998( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerCondition>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::TriggerCondition*)arg[1]);
}

static  void method_10999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> >)((((::std::vector<pat::TriggerCondition>*)o)->begin)());
  else   (((::std::vector<pat::TriggerCondition>*)o)->begin)();
}

static  void method_11000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >)((((const ::std::vector<pat::TriggerCondition>*)o)->begin)());
  else   (((const ::std::vector<pat::TriggerCondition>*)o)->begin)();
}

static  void method_11001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> >)((((::std::vector<pat::TriggerCondition>*)o)->end)());
  else   (((::std::vector<pat::TriggerCondition>*)o)->end)();
}

static  void method_11002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >)((((const ::std::vector<pat::TriggerCondition>*)o)->end)());
  else   (((const ::std::vector<pat::TriggerCondition>*)o)->end)();
}

static  void method_11007( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerCondition>*)o)->size)());
  else   (((const ::std::vector<pat::TriggerCondition>*)o)->size)();
}

static  void method_11008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerCondition>*)o)->max_size)());
  else   (((const ::std::vector<pat::TriggerCondition>*)o)->max_size)();
}

static  void method_11009( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::TriggerCondition>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::TriggerCondition>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::TriggerCondition*)arg[1]);
  }
}

static  void method_11010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerCondition>*)o)->capacity)());
  else   (((const ::std::vector<pat::TriggerCondition>*)o)->capacity)();
}

static  void method_11011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::TriggerCondition>*)o)->empty)());
  else   (((const ::std::vector<pat::TriggerCondition>*)o)->empty)();
}

static  void method_11012( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerCondition>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_11013( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerCondition>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::TriggerCondition>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11014( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerCondition>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::TriggerCondition>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_11016( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerCondition>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::TriggerCondition>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11017( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerCondition>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::TriggerCondition>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerCondition>*)o)->front)();
  else   (((::std::vector<pat::TriggerCondition>*)o)->front)();
}

static  void method_11019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerCondition>*)o)->front)();
  else   (((const ::std::vector<pat::TriggerCondition>*)o)->front)();
}

static  void method_11020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerCondition>*)o)->back)();
  else   (((::std::vector<pat::TriggerCondition>*)o)->back)();
}

static  void method_11021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerCondition>*)o)->back)();
  else   (((const ::std::vector<pat::TriggerCondition>*)o)->back)();
}

static  void method_11022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::TriggerCondition>*)o)->data)());
  else   (((::std::vector<pat::TriggerCondition>*)o)->data)();
}

static  void method_11023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::TriggerCondition>*)o)->data)());
  else   (((const ::std::vector<pat::TriggerCondition>*)o)->data)();
}

static  void method_11024( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerCondition>*)o)->push_back)(*(const ::pat::TriggerCondition*)arg[0]);
}

static  void method_11025( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::TriggerCondition>*)o)->pop_back)();
}

static  void method_11026( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> >)((((::std::vector<pat::TriggerCondition>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)arg[0],
    *(const ::pat::TriggerCondition*)arg[1]));
  else   (((::std::vector<pat::TriggerCondition>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)arg[0],
    *(const ::pat::TriggerCondition*)arg[1]);
}

static  void method_11027( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerCondition>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::TriggerCondition*)arg[2]);
}

static  void method_11028( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> >)((((::std::vector<pat::TriggerCondition>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)arg[0]));
  else   (((::std::vector<pat::TriggerCondition>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)arg[0]);
}

static  void method_11029( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> >)((((::std::vector<pat::TriggerCondition>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)arg[1]));
  else   (((::std::vector<pat::TriggerCondition>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)arg[1]);
}

static  void method_11030( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerCondition>*)o)->swap)(*(::std::vector<pat::TriggerCondition>*)arg[0]);
}

static  void method_11031( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::TriggerCondition>*)o)->clear)();
}

static void method_newdel_2746( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerCondition> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerCondition> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerCondition> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerCondition> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerCondition> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::TriggerCondition,std::allocator<pat::TriggerCondition> >")), ::Reflex::BaseOffset< ::std::vector<pat::TriggerCondition>,::std::_Vector_base<pat::TriggerCondition,std::allocator<pat::TriggerCondition> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x25( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::TriggerCondition> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::TriggerCondition> >::Generate();
}

//------Dictionary for class vector<pat::TriggerCondition,std::allocator<pat::TriggerCondition> > -------------------------------
void __std__vector_pat__TriggerCondition__db_datamem(Reflex::Class*);
void __std__vector_pat__TriggerCondition__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__TriggerCondition__datamem_bld(&__std__vector_pat__TriggerCondition__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__TriggerCondition__funcmem_bld(&__std__vector_pat__TriggerCondition__db_funcmem);
void __std__vector_pat__TriggerCondition__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::TriggerCondition>"), typeid(::std::vector<pat::TriggerCondition>), sizeof(::std::vector<pat::TriggerCondition>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2285, ::Reflex::BaseOffset< ::std::vector<pat::TriggerCondition>, ::std::_Vector_base<pat::TriggerCondition,std::allocator<pat::TriggerCondition> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7332, Reflex::Literal("std::vector<pat::TriggerCondition>::_Alloc_value_type"))
  .AddTypedef(type_2285, Reflex::Literal("std::vector<pat::TriggerCondition>::_Base"))
  .AddTypedef(type_2941, Reflex::Literal("std::vector<pat::TriggerCondition>::_Tp_alloc_type"))
  .AddTypedef(type_6703, Reflex::Literal("std::vector<pat::TriggerCondition>::_Alloc_traits"))
  .AddTypedef(type_7332, Reflex::Literal("std::vector<pat::TriggerCondition>::value_type"))
  .AddTypedef(type_7970, Reflex::Literal("std::vector<pat::TriggerCondition>::pointer"))
  .AddTypedef(type_8867, Reflex::Literal("std::vector<pat::TriggerCondition>::const_pointer"))
  .AddTypedef(type_10982, Reflex::Literal("std::vector<pat::TriggerCondition>::reference"))
  .AddTypedef(type_8869, Reflex::Literal("std::vector<pat::TriggerCondition>::const_reference"))
  .AddTypedef(type_6585, Reflex::Literal("std::vector<pat::TriggerCondition>::iterator"))
  .AddTypedef(type_6573, Reflex::Literal("std::vector<pat::TriggerCondition>::const_iterator"))
  .AddTypedef(type_3106, Reflex::Literal("std::vector<pat::TriggerCondition>::const_reverse_iterator"))
  .AddTypedef(type_3107, Reflex::Literal("std::vector<pat::TriggerCondition>::reverse_iterator"))
  .AddTypedef(type_2926, Reflex::Literal("std::vector<pat::TriggerCondition>::size_type"))
  .AddTypedef(type_2844, Reflex::Literal("std::vector<pat::TriggerCondition>::difference_type"))
  .AddTypedef(type_2941, Reflex::Literal("std::vector<pat::TriggerCondition>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10992, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25524), Reflex::Literal("vector"), constructor_10993, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2926, type_8869, type_25524), Reflex::Literal("vector"), constructor_10994, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15845), Reflex::Literal("vector"), constructor_10995, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10996, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2746, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x25, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__TriggerCondition__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::TriggerCondition,std::allocator<pat::TriggerCondition> > -------------------
void __std__vector_pat__TriggerCondition__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::TriggerCondition,std::allocator<pat::TriggerCondition> > -------------------
void __std__vector_pat__TriggerCondition__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26460, type_15845), Reflex::Literal("operator="), operator_10997, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926, type_8869), Reflex::Literal("assign"), method_10998, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6585), Reflex::Literal("begin"), method_10999, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6573), Reflex::Literal("begin"), method_11000, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6585), Reflex::Literal("end"), method_11001, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6573), Reflex::Literal("end"), method_11002, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("size"), method_11007, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("max_size"), method_11008, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926, type_7332), Reflex::Literal("resize"), method_11009, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("capacity"), method_11010, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_11011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926), Reflex::Literal("reserve"), method_11012, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10982, type_2926), Reflex::Literal("operator[]"), operator_11013, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8869, type_2926), Reflex::Literal("operator[]"), operator_11014, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10982, type_2926), Reflex::Literal("at"), method_11016, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8869, type_2926), Reflex::Literal("at"), method_11017, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10982), Reflex::Literal("front"), method_11018, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8869), Reflex::Literal("front"), method_11019, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10982), Reflex::Literal("back"), method_11020, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8869), Reflex::Literal("back"), method_11021, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7970), Reflex::Literal("data"), method_11022, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8867), Reflex::Literal("data"), method_11023, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_8869), Reflex::Literal("push_back"), method_11024, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("pop_back"), method_11025, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6585, type_6585, type_8869), Reflex::Literal("insert"), method_11026, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_6585, type_2926, type_8869), Reflex::Literal("insert"), method_11027, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6585, type_6585), Reflex::Literal("erase"), method_11028, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6585, type_6585, type_6585), Reflex::Literal("erase"), method_11029, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_26460), Reflex::Literal("swap"), method_11030, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_11031, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<pat::TriggerFilter,std::allocator<pat::TriggerFilter> > -------------------------------
static void constructor_11118( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerFilter>();
  else ::new(mem) ::std::vector<pat::TriggerFilter>();
}

static void constructor_11119( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerFilter>(*(const ::std::allocator<pat::TriggerFilter>*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerFilter>(*(const ::std::allocator<pat::TriggerFilter>*)arg[0]);
}

static void constructor_11120( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerFilter>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerFilter>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerFilter>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerFilter*)arg[1]);
  else ::new(mem) ::std::vector<pat::TriggerFilter>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerFilter*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerFilter>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerFilter*)arg[1],
      *(const ::std::allocator<pat::TriggerFilter>*)arg[2]);
  else ::new(mem) ::std::vector<pat::TriggerFilter>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerFilter*)arg[1],
      *(const ::std::allocator<pat::TriggerFilter>*)arg[2]);
  }
}

static void constructor_11121( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerFilter>(*(const ::std::vector<pat::TriggerFilter>*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerFilter>(*(const ::std::vector<pat::TriggerFilter>*)arg[0]);
}

static void destructor_11122(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::TriggerFilter>*)o)->::std::vector<pat::TriggerFilter>::~vector)();
}
static  void operator_11123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerFilter>*)o)->operator=)(*(const ::std::vector<pat::TriggerFilter>*)arg[0]);
  else   (((::std::vector<pat::TriggerFilter>*)o)->operator=)(*(const ::std::vector<pat::TriggerFilter>*)arg[0]);
}

static  void method_11124( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerFilter>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::TriggerFilter*)arg[1]);
}

static  void method_11125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> >)((((::std::vector<pat::TriggerFilter>*)o)->begin)());
  else   (((::std::vector<pat::TriggerFilter>*)o)->begin)();
}

static  void method_11126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >)((((const ::std::vector<pat::TriggerFilter>*)o)->begin)());
  else   (((const ::std::vector<pat::TriggerFilter>*)o)->begin)();
}

static  void method_11127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> >)((((::std::vector<pat::TriggerFilter>*)o)->end)());
  else   (((::std::vector<pat::TriggerFilter>*)o)->end)();
}

static  void method_11128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >)((((const ::std::vector<pat::TriggerFilter>*)o)->end)());
  else   (((const ::std::vector<pat::TriggerFilter>*)o)->end)();
}

static  void method_11133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerFilter>*)o)->size)());
  else   (((const ::std::vector<pat::TriggerFilter>*)o)->size)();
}

static  void method_11134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerFilter>*)o)->max_size)());
  else   (((const ::std::vector<pat::TriggerFilter>*)o)->max_size)();
}

static  void method_11135( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::TriggerFilter>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::TriggerFilter>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::TriggerFilter*)arg[1]);
  }
}

static  void method_11136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerFilter>*)o)->capacity)());
  else   (((const ::std::vector<pat::TriggerFilter>*)o)->capacity)();
}

static  void method_11137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::TriggerFilter>*)o)->empty)());
  else   (((const ::std::vector<pat::TriggerFilter>*)o)->empty)();
}

static  void method_11138( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerFilter>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_11139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerFilter>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::TriggerFilter>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11140( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerFilter>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::TriggerFilter>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_11142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerFilter>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::TriggerFilter>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerFilter>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::TriggerFilter>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerFilter>*)o)->front)();
  else   (((::std::vector<pat::TriggerFilter>*)o)->front)();
}

static  void method_11145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerFilter>*)o)->front)();
  else   (((const ::std::vector<pat::TriggerFilter>*)o)->front)();
}

static  void method_11146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerFilter>*)o)->back)();
  else   (((::std::vector<pat::TriggerFilter>*)o)->back)();
}

static  void method_11147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerFilter>*)o)->back)();
  else   (((const ::std::vector<pat::TriggerFilter>*)o)->back)();
}

static  void method_11148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::TriggerFilter>*)o)->data)());
  else   (((::std::vector<pat::TriggerFilter>*)o)->data)();
}

static  void method_11149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::TriggerFilter>*)o)->data)());
  else   (((const ::std::vector<pat::TriggerFilter>*)o)->data)();
}

static  void method_11150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerFilter>*)o)->push_back)(*(const ::pat::TriggerFilter*)arg[0]);
}

static  void method_11151( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::TriggerFilter>*)o)->pop_back)();
}

static  void method_11152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> >)((((::std::vector<pat::TriggerFilter>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)arg[0],
    *(const ::pat::TriggerFilter*)arg[1]));
  else   (((::std::vector<pat::TriggerFilter>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)arg[0],
    *(const ::pat::TriggerFilter*)arg[1]);
}

static  void method_11153( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerFilter>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::TriggerFilter*)arg[2]);
}

static  void method_11154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> >)((((::std::vector<pat::TriggerFilter>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)arg[0]));
  else   (((::std::vector<pat::TriggerFilter>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)arg[0]);
}

static  void method_11155( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> >)((((::std::vector<pat::TriggerFilter>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)arg[1]));
  else   (((::std::vector<pat::TriggerFilter>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)arg[1]);
}

static  void method_11156( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerFilter>*)o)->swap)(*(::std::vector<pat::TriggerFilter>*)arg[0]);
}

static  void method_11157( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::TriggerFilter>*)o)->clear)();
}

static void method_newdel_2748( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerFilter> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerFilter> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerFilter> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerFilter> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerFilter> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::TriggerFilter,std::allocator<pat::TriggerFilter> >")), ::Reflex::BaseOffset< ::std::vector<pat::TriggerFilter>,::std::_Vector_base<pat::TriggerFilter,std::allocator<pat::TriggerFilter> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::TriggerFilter> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::TriggerFilter> >::Generate();
}

//------Dictionary for class vector<pat::TriggerFilter,std::allocator<pat::TriggerFilter> > -------------------------------
void __std__vector_pat__TriggerFilter__db_datamem(Reflex::Class*);
void __std__vector_pat__TriggerFilter__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__TriggerFilter__datamem_bld(&__std__vector_pat__TriggerFilter__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__TriggerFilter__funcmem_bld(&__std__vector_pat__TriggerFilter__db_funcmem);
void __std__vector_pat__TriggerFilter__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::TriggerFilter>"), typeid(::std::vector<pat::TriggerFilter>), sizeof(::std::vector<pat::TriggerFilter>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2282, ::Reflex::BaseOffset< ::std::vector<pat::TriggerFilter>, ::std::_Vector_base<pat::TriggerFilter,std::allocator<pat::TriggerFilter> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7359, Reflex::Literal("std::vector<pat::TriggerFilter>::_Alloc_value_type"))
  .AddTypedef(type_2282, Reflex::Literal("std::vector<pat::TriggerFilter>::_Base"))
  .AddTypedef(type_2943, Reflex::Literal("std::vector<pat::TriggerFilter>::_Tp_alloc_type"))
  .AddTypedef(type_6700, Reflex::Literal("std::vector<pat::TriggerFilter>::_Alloc_traits"))
  .AddTypedef(type_7359, Reflex::Literal("std::vector<pat::TriggerFilter>::value_type"))
  .AddTypedef(type_7913, Reflex::Literal("std::vector<pat::TriggerFilter>::pointer"))
  .AddTypedef(type_8900, Reflex::Literal("std::vector<pat::TriggerFilter>::const_pointer"))
  .AddTypedef(type_11108, Reflex::Literal("std::vector<pat::TriggerFilter>::reference"))
  .AddTypedef(type_8902, Reflex::Literal("std::vector<pat::TriggerFilter>::const_reference"))
  .AddTypedef(type_6582, Reflex::Literal("std::vector<pat::TriggerFilter>::iterator"))
  .AddTypedef(type_6576, Reflex::Literal("std::vector<pat::TriggerFilter>::const_iterator"))
  .AddTypedef(type_3100, Reflex::Literal("std::vector<pat::TriggerFilter>::const_reverse_iterator"))
  .AddTypedef(type_3101, Reflex::Literal("std::vector<pat::TriggerFilter>::reverse_iterator"))
  .AddTypedef(type_2926, Reflex::Literal("std::vector<pat::TriggerFilter>::size_type"))
  .AddTypedef(type_2844, Reflex::Literal("std::vector<pat::TriggerFilter>::difference_type"))
  .AddTypedef(type_2943, Reflex::Literal("std::vector<pat::TriggerFilter>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_11118, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25485), Reflex::Literal("vector"), constructor_11119, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2926, type_8902, type_25485), Reflex::Literal("vector"), constructor_11120, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15821), Reflex::Literal("vector"), constructor_11121, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_11122, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2748, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__TriggerFilter__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::TriggerFilter,std::allocator<pat::TriggerFilter> > -------------------
void __std__vector_pat__TriggerFilter__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::TriggerFilter,std::allocator<pat::TriggerFilter> > -------------------
void __std__vector_pat__TriggerFilter__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26462, type_15821), Reflex::Literal("operator="), operator_11123, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926, type_8902), Reflex::Literal("assign"), method_11124, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6582), Reflex::Literal("begin"), method_11125, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6576), Reflex::Literal("begin"), method_11126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6582), Reflex::Literal("end"), method_11127, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6576), Reflex::Literal("end"), method_11128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("size"), method_11133, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("max_size"), method_11134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926, type_7359), Reflex::Literal("resize"), method_11135, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("capacity"), method_11136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_11137, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926), Reflex::Literal("reserve"), method_11138, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11108, type_2926), Reflex::Literal("operator[]"), operator_11139, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8902, type_2926), Reflex::Literal("operator[]"), operator_11140, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11108, type_2926), Reflex::Literal("at"), method_11142, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8902, type_2926), Reflex::Literal("at"), method_11143, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11108), Reflex::Literal("front"), method_11144, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8902), Reflex::Literal("front"), method_11145, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11108), Reflex::Literal("back"), method_11146, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8902), Reflex::Literal("back"), method_11147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7913), Reflex::Literal("data"), method_11148, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8900), Reflex::Literal("data"), method_11149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_8902), Reflex::Literal("push_back"), method_11150, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("pop_back"), method_11151, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6582, type_6582, type_8902), Reflex::Literal("insert"), method_11152, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_6582, type_2926, type_8902), Reflex::Literal("insert"), method_11153, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6582, type_6582), Reflex::Literal("erase"), method_11154, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6582, type_6582, type_6582), Reflex::Literal("erase"), method_11155, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_26462), Reflex::Literal("swap"), method_11156, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_11157, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<pat::TriggerObjectStandAlone,std::allocator<pat::TriggerObjectStandAlone> > -------------------------------
static void constructor_11181( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerObjectStandAlone>();
  else ::new(mem) ::std::vector<pat::TriggerObjectStandAlone>();
}

static void constructor_11182( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerObjectStandAlone>(*(const ::std::allocator<pat::TriggerObjectStandAlone>*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerObjectStandAlone>(*(const ::std::allocator<pat::TriggerObjectStandAlone>*)arg[0]);
}

static void constructor_11183( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerObjectStandAlone>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerObjectStandAlone>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerObjectStandAlone>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerObjectStandAlone*)arg[1]);
  else ::new(mem) ::std::vector<pat::TriggerObjectStandAlone>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerObjectStandAlone*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerObjectStandAlone>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerObjectStandAlone*)arg[1],
      *(const ::std::allocator<pat::TriggerObjectStandAlone>*)arg[2]);
  else ::new(mem) ::std::vector<pat::TriggerObjectStandAlone>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerObjectStandAlone*)arg[1],
      *(const ::std::allocator<pat::TriggerObjectStandAlone>*)arg[2]);
  }
}

static void constructor_11184( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerObjectStandAlone>(*(const ::std::vector<pat::TriggerObjectStandAlone>*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerObjectStandAlone>(*(const ::std::vector<pat::TriggerObjectStandAlone>*)arg[0]);
}

static void destructor_11185(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::TriggerObjectStandAlone>*)o)->::std::vector<pat::TriggerObjectStandAlone>::~vector)();
}
static  void operator_11186( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerObjectStandAlone>*)o)->operator=)(*(const ::std::vector<pat::TriggerObjectStandAlone>*)arg[0]);
  else   (((::std::vector<pat::TriggerObjectStandAlone>*)o)->operator=)(*(const ::std::vector<pat::TriggerObjectStandAlone>*)arg[0]);
}

static  void method_11187( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerObjectStandAlone>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::TriggerObjectStandAlone*)arg[1]);
}

static  void method_11188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >)((((::std::vector<pat::TriggerObjectStandAlone>*)o)->begin)());
  else   (((::std::vector<pat::TriggerObjectStandAlone>*)o)->begin)();
}

static  void method_11189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >)((((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->begin)());
  else   (((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->begin)();
}

static  void method_11190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >)((((::std::vector<pat::TriggerObjectStandAlone>*)o)->end)());
  else   (((::std::vector<pat::TriggerObjectStandAlone>*)o)->end)();
}

static  void method_11191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >)((((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->end)());
  else   (((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->end)();
}

static  void method_11196( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->size)());
  else   (((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->size)();
}

static  void method_11197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->max_size)());
  else   (((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->max_size)();
}

static  void method_11198( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::TriggerObjectStandAlone>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::TriggerObjectStandAlone>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::TriggerObjectStandAlone*)arg[1]);
  }
}

static  void method_11199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->capacity)());
  else   (((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->capacity)();
}

static  void method_11200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->empty)());
  else   (((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->empty)();
}

static  void method_11201( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerObjectStandAlone>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_11202( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerObjectStandAlone>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::TriggerObjectStandAlone>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11203( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_11205( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerObjectStandAlone>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::TriggerObjectStandAlone>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11206( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerObjectStandAlone>*)o)->front)();
  else   (((::std::vector<pat::TriggerObjectStandAlone>*)o)->front)();
}

static  void method_11208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->front)();
  else   (((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->front)();
}

static  void method_11209( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerObjectStandAlone>*)o)->back)();
  else   (((::std::vector<pat::TriggerObjectStandAlone>*)o)->back)();
}

static  void method_11210( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->back)();
  else   (((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->back)();
}

static  void method_11211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::TriggerObjectStandAlone>*)o)->data)());
  else   (((::std::vector<pat::TriggerObjectStandAlone>*)o)->data)();
}

static  void method_11212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->data)());
  else   (((const ::std::vector<pat::TriggerObjectStandAlone>*)o)->data)();
}

static  void method_11213( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerObjectStandAlone>*)o)->push_back)(*(const ::pat::TriggerObjectStandAlone*)arg[0]);
}

static  void method_11214( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::TriggerObjectStandAlone>*)o)->pop_back)();
}

static  void method_11215( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >)((((::std::vector<pat::TriggerObjectStandAlone>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
    *(const ::pat::TriggerObjectStandAlone*)arg[1]));
  else   (((::std::vector<pat::TriggerObjectStandAlone>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
    *(const ::pat::TriggerObjectStandAlone*)arg[1]);
}

static  void method_11216( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerObjectStandAlone>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::TriggerObjectStandAlone*)arg[2]);
}

static  void method_11217( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >)((((::std::vector<pat::TriggerObjectStandAlone>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)arg[0]));
  else   (((::std::vector<pat::TriggerObjectStandAlone>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void method_11218( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >)((((::std::vector<pat::TriggerObjectStandAlone>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)arg[1]));
  else   (((::std::vector<pat::TriggerObjectStandAlone>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)arg[1]);
}

static  void method_11219( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerObjectStandAlone>*)o)->swap)(*(::std::vector<pat::TriggerObjectStandAlone>*)arg[0]);
}

static  void method_11220( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::TriggerObjectStandAlone>*)o)->clear)();
}

static void method_newdel_2749( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerObjectStandAlone> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerObjectStandAlone> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerObjectStandAlone> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerObjectStandAlone> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerObjectStandAlone> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::TriggerObjectStandAlone,std::allocator<pat::TriggerObjectStandAlone> >")), ::Reflex::BaseOffset< ::std::vector<pat::TriggerObjectStandAlone>,::std::_Vector_base<pat::TriggerObjectStandAlone,std::allocator<pat::TriggerObjectStandAlone> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x31( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::TriggerObjectStandAlone> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::TriggerObjectStandAlone> >::Generate();
}

//------Dictionary for class vector<pat::TriggerObjectStandAlone,std::allocator<pat::TriggerObjectStandAlone> > -------------------------------
void __std__vector_pat__TriggerObjectStandAlone__db_datamem(Reflex::Class*);
void __std__vector_pat__TriggerObjectStandAlone__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__TriggerObjectStandAlone__datamem_bld(&__std__vector_pat__TriggerObjectStandAlone__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__TriggerObjectStandAlone__funcmem_bld(&__std__vector_pat__TriggerObjectStandAlone__db_funcmem);
void __std__vector_pat__TriggerObjectStandAlone__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>"), typeid(::std::vector<pat::TriggerObjectStandAlone>), sizeof(::std::vector<pat::TriggerObjectStandAlone>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2288, ::Reflex::BaseOffset< ::std::vector<pat::TriggerObjectStandAlone>, ::std::_Vector_base<pat::TriggerObjectStandAlone,std::allocator<pat::TriggerObjectStandAlone> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7344, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::_Alloc_value_type"))
  .AddTypedef(type_2288, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::_Base"))
  .AddTypedef(type_2944, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::_Tp_alloc_type"))
  .AddTypedef(type_6706, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::_Alloc_traits"))
  .AddTypedef(type_7344, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::value_type"))
  .AddTypedef(type_8026, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::pointer"))
  .AddTypedef(type_8911, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::const_pointer"))
  .AddTypedef(type_11171, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::reference"))
  .AddTypedef(type_8913, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::const_reference"))
  .AddTypedef(type_6588, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::iterator"))
  .AddTypedef(type_6577, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::const_iterator"))
  .AddTypedef(type_3112, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::const_reverse_iterator"))
  .AddTypedef(type_3113, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::reverse_iterator"))
  .AddTypedef(type_2926, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::size_type"))
  .AddTypedef(type_2844, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::difference_type"))
  .AddTypedef(type_2944, Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_11181, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25563), Reflex::Literal("vector"), constructor_11182, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2926, type_8913, type_25563), Reflex::Literal("vector"), constructor_11183, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15869), Reflex::Literal("vector"), constructor_11184, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_11185, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2749, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x31, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__TriggerObjectStandAlone__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::TriggerObjectStandAlone,std::allocator<pat::TriggerObjectStandAlone> > -------------------
void __std__vector_pat__TriggerObjectStandAlone__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::TriggerObjectStandAlone,std::allocator<pat::TriggerObjectStandAlone> > -------------------
void __std__vector_pat__TriggerObjectStandAlone__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26463, type_15869), Reflex::Literal("operator="), operator_11186, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926, type_8913), Reflex::Literal("assign"), method_11187, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6588), Reflex::Literal("begin"), method_11188, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6577), Reflex::Literal("begin"), method_11189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6588), Reflex::Literal("end"), method_11190, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6577), Reflex::Literal("end"), method_11191, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("size"), method_11196, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("max_size"), method_11197, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926, type_7344), Reflex::Literal("resize"), method_11198, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("capacity"), method_11199, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_11200, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926), Reflex::Literal("reserve"), method_11201, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11171, type_2926), Reflex::Literal("operator[]"), operator_11202, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8913, type_2926), Reflex::Literal("operator[]"), operator_11203, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11171, type_2926), Reflex::Literal("at"), method_11205, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8913, type_2926), Reflex::Literal("at"), method_11206, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11171), Reflex::Literal("front"), method_11207, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8913), Reflex::Literal("front"), method_11208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11171), Reflex::Literal("back"), method_11209, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8913), Reflex::Literal("back"), method_11210, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8026), Reflex::Literal("data"), method_11211, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8911), Reflex::Literal("data"), method_11212, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_8913), Reflex::Literal("push_back"), method_11213, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("pop_back"), method_11214, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6588, type_6588, type_8913), Reflex::Literal("insert"), method_11215, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_6588, type_2926, type_8913), Reflex::Literal("insert"), method_11216, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6588, type_6588), Reflex::Literal("erase"), method_11217, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6588, type_6588, type_6588), Reflex::Literal("erase"), method_11218, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_26463), Reflex::Literal("swap"), method_11219, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_11220, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<pat::TriggerPath,std::allocator<pat::TriggerPath> > -------------------------------
static void constructor_11244( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerPath>();
  else ::new(mem) ::std::vector<pat::TriggerPath>();
}

static void constructor_11245( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerPath>(*(const ::std::allocator<pat::TriggerPath>*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerPath>(*(const ::std::allocator<pat::TriggerPath>*)arg[0]);
}

static void constructor_11246( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerPath>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerPath>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerPath>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerPath*)arg[1]);
  else ::new(mem) ::std::vector<pat::TriggerPath>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerPath*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerPath>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerPath*)arg[1],
      *(const ::std::allocator<pat::TriggerPath>*)arg[2]);
  else ::new(mem) ::std::vector<pat::TriggerPath>(*(::std::size_t*)arg[0],
      *(const ::pat::TriggerPath*)arg[1],
      *(const ::std::allocator<pat::TriggerPath>*)arg[2]);
  }
}

static void constructor_11247( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::TriggerPath>(*(const ::std::vector<pat::TriggerPath>*)arg[0]);
  else ::new(mem) ::std::vector<pat::TriggerPath>(*(const ::std::vector<pat::TriggerPath>*)arg[0]);
}

static void destructor_11248(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::TriggerPath>*)o)->::std::vector<pat::TriggerPath>::~vector)();
}
static  void operator_11249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerPath>*)o)->operator=)(*(const ::std::vector<pat::TriggerPath>*)arg[0]);
  else   (((::std::vector<pat::TriggerPath>*)o)->operator=)(*(const ::std::vector<pat::TriggerPath>*)arg[0]);
}

static  void method_11250( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerPath>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::TriggerPath*)arg[1]);
}

static  void method_11251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> >)((((::std::vector<pat::TriggerPath>*)o)->begin)());
  else   (((::std::vector<pat::TriggerPath>*)o)->begin)();
}

static  void method_11252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >)((((const ::std::vector<pat::TriggerPath>*)o)->begin)());
  else   (((const ::std::vector<pat::TriggerPath>*)o)->begin)();
}

static  void method_11253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> >)((((::std::vector<pat::TriggerPath>*)o)->end)());
  else   (((::std::vector<pat::TriggerPath>*)o)->end)();
}

static  void method_11254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >)((((const ::std::vector<pat::TriggerPath>*)o)->end)());
  else   (((const ::std::vector<pat::TriggerPath>*)o)->end)();
}

static  void method_11259( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerPath>*)o)->size)());
  else   (((const ::std::vector<pat::TriggerPath>*)o)->size)();
}

static  void method_11260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerPath>*)o)->max_size)());
  else   (((const ::std::vector<pat::TriggerPath>*)o)->max_size)();
}

static  void method_11261( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::TriggerPath>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::TriggerPath>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::TriggerPath*)arg[1]);
  }
}

static  void method_11262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::TriggerPath>*)o)->capacity)());
  else   (((const ::std::vector<pat::TriggerPath>*)o)->capacity)();
}

static  void method_11263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::TriggerPath>*)o)->empty)());
  else   (((const ::std::vector<pat::TriggerPath>*)o)->empty)();
}

static  void method_11264( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerPath>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_11265( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerPath>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::TriggerPath>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11266( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerPath>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::TriggerPath>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_11268( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerPath>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::TriggerPath>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerPath>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::TriggerPath>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerPath>*)o)->front)();
  else   (((::std::vector<pat::TriggerPath>*)o)->front)();
}

static  void method_11271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerPath>*)o)->front)();
  else   (((const ::std::vector<pat::TriggerPath>*)o)->front)();
}

static  void method_11272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::TriggerPath>*)o)->back)();
  else   (((::std::vector<pat::TriggerPath>*)o)->back)();
}

static  void method_11273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::TriggerPath>*)o)->back)();
  else   (((const ::std::vector<pat::TriggerPath>*)o)->back)();
}

static  void method_11274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::TriggerPath>*)o)->data)());
  else   (((::std::vector<pat::TriggerPath>*)o)->data)();
}

static  void method_11275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::TriggerPath>*)o)->data)());
  else   (((const ::std::vector<pat::TriggerPath>*)o)->data)();
}

static  void method_11276( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerPath>*)o)->push_back)(*(const ::pat::TriggerPath*)arg[0]);
}

static  void method_11277( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::TriggerPath>*)o)->pop_back)();
}

static  void method_11278( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> >)((((::std::vector<pat::TriggerPath>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> >*)arg[0],
    *(const ::pat::TriggerPath*)arg[1]));
  else   (((::std::vector<pat::TriggerPath>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> >*)arg[0],
    *(const ::pat::TriggerPath*)arg[1]);
}

static  void method_11279( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerPath>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::TriggerPath*)arg[2]);
}

static  void method_11280( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> >)((((::std::vector<pat::TriggerPath>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> >*)arg[0]));
  else   (((::std::vector<pat::TriggerPath>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> >*)arg[0]);
}

static  void method_11281( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> >)((((::std::vector<pat::TriggerPath>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> >*)arg[1]));
  else   (((::std::vector<pat::TriggerPath>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::TriggerPath*,std::vector<pat::TriggerPath> >*)arg[1]);
}

static  void method_11282( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::TriggerPath>*)o)->swap)(*(::std::vector<pat::TriggerPath>*)arg[0]);
}

static  void method_11283( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::TriggerPath>*)o)->clear)();
}

static void method_newdel_2750( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerPath> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerPath> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerPath> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerPath> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::TriggerPath> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::TriggerPath,std::allocator<pat::TriggerPath> >")), ::Reflex::BaseOffset< ::std::vector<pat::TriggerPath>,::std::_Vector_base<pat::TriggerPath,std::allocator<pat::TriggerPath> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x34( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::TriggerPath> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::TriggerPath> >::Generate();
}

//------Dictionary for class vector<pat::TriggerPath,std::allocator<pat::TriggerPath> > -------------------------------
void __std__vector_pat__TriggerPath__db_datamem(Reflex::Class*);
void __std__vector_pat__TriggerPath__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__TriggerPath__datamem_bld(&__std__vector_pat__TriggerPath__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__TriggerPath__funcmem_bld(&__std__vector_pat__TriggerPath__db_funcmem);
void __std__vector_pat__TriggerPath__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::TriggerPath>"), typeid(::std::vector<pat::TriggerPath>), sizeof(::std::vector<pat::TriggerPath>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2283, ::Reflex::BaseOffset< ::std::vector<pat::TriggerPath>, ::std::_Vector_base<pat::TriggerPath,std::allocator<pat::TriggerPath> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7348, Reflex::Literal("std::vector<pat::TriggerPath>::_Alloc_value_type"))
  .AddTypedef(type_2283, Reflex::Literal("std::vector<pat::TriggerPath>::_Base"))
  .AddTypedef(type_2945, Reflex::Literal("std::vector<pat::TriggerPath>::_Tp_alloc_type"))
  .AddTypedef(type_6701, Reflex::Literal("std::vector<pat::TriggerPath>::_Alloc_traits"))
  .AddTypedef(type_7348, Reflex::Literal("std::vector<pat::TriggerPath>::value_type"))
  .AddTypedef(type_7932, Reflex::Literal("std::vector<pat::TriggerPath>::pointer"))
  .AddTypedef(type_8889, Reflex::Literal("std::vector<pat::TriggerPath>::const_pointer"))
  .AddTypedef(type_11234, Reflex::Literal("std::vector<pat::TriggerPath>::reference"))
  .AddTypedef(type_8891, Reflex::Literal("std::vector<pat::TriggerPath>::const_reference"))
  .AddTypedef(type_6583, Reflex::Literal("std::vector<pat::TriggerPath>::iterator"))
  .AddTypedef(type_6575, Reflex::Literal("std::vector<pat::TriggerPath>::const_iterator"))
  .AddTypedef(type_3102, Reflex::Literal("std::vector<pat::TriggerPath>::const_reverse_iterator"))
  .AddTypedef(type_3103, Reflex::Literal("std::vector<pat::TriggerPath>::reverse_iterator"))
  .AddTypedef(type_2926, Reflex::Literal("std::vector<pat::TriggerPath>::size_type"))
  .AddTypedef(type_2844, Reflex::Literal("std::vector<pat::TriggerPath>::difference_type"))
  .AddTypedef(type_2945, Reflex::Literal("std::vector<pat::TriggerPath>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_11244, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25498), Reflex::Literal("vector"), constructor_11245, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2926, type_8891, type_25498), Reflex::Literal("vector"), constructor_11246, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15833), Reflex::Literal("vector"), constructor_11247, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_11248, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2750, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x34, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__TriggerPath__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::TriggerPath,std::allocator<pat::TriggerPath> > -------------------
void __std__vector_pat__TriggerPath__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::TriggerPath,std::allocator<pat::TriggerPath> > -------------------
void __std__vector_pat__TriggerPath__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26464, type_15833), Reflex::Literal("operator="), operator_11249, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926, type_8891), Reflex::Literal("assign"), method_11250, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6583), Reflex::Literal("begin"), method_11251, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6575), Reflex::Literal("begin"), method_11252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6583), Reflex::Literal("end"), method_11253, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6575), Reflex::Literal("end"), method_11254, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("size"), method_11259, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("max_size"), method_11260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926, type_7348), Reflex::Literal("resize"), method_11261, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("capacity"), method_11262, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_11263, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926), Reflex::Literal("reserve"), method_11264, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11234, type_2926), Reflex::Literal("operator[]"), operator_11265, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8891, type_2926), Reflex::Literal("operator[]"), operator_11266, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11234, type_2926), Reflex::Literal("at"), method_11268, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8891, type_2926), Reflex::Literal("at"), method_11269, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11234), Reflex::Literal("front"), method_11270, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8891), Reflex::Literal("front"), method_11271, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11234), Reflex::Literal("back"), method_11272, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8891), Reflex::Literal("back"), method_11273, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7932), Reflex::Literal("data"), method_11274, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8889), Reflex::Literal("data"), method_11275, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_8891), Reflex::Literal("push_back"), method_11276, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("pop_back"), method_11277, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6583, type_6583, type_8891), Reflex::Literal("insert"), method_11278, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_6583, type_2926, type_8891), Reflex::Literal("insert"), method_11279, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6583, type_6583), Reflex::Literal("erase"), method_11280, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6583, type_6583, type_6583), Reflex::Literal("erase"), method_11281, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_26464), Reflex::Literal("swap"), method_11282, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_11283, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > > > -------------------------------
static void destructor_13533(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::~map)();
}
static void constructor_13534( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >();
  else ::new(mem) ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >();
}

static void constructor_13535( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[1]);
  else ::new(mem) ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[1]);
  }
}

static void constructor_13536( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >(*(const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >(*(const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)arg[0]);
}

static  void operator_13537( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)arg[0]);
  else   (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)arg[0]);
}

static  void method_13538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >)((((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->get_allocator)());
  else   (((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->get_allocator)();
}

static  void method_13539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >)((((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->begin)());
  else   (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->begin)();
}

static  void method_13540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >)((((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->begin)());
  else   (((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->begin)();
}

static  void method_13541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >)((((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->end)());
  else   (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->end)();
}

static  void method_13542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >)((((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->end)());
  else   (((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->end)();
}

static  void method_13547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->empty)());
  else   (((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->empty)();
}

static  void method_13548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->size)());
  else   (((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->size)();
}

static  void method_13549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->max_size)());
  else   (((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->max_size)();
}

static  void operator_13550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13551( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >,bool>)((((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)arg[0]);
}

static  void method_13554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >)((((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)arg[1]));
  else   (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)arg[1]);
}

static  void method_13555( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0]);
}

static  void method_13556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13557( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[1]);
}

static  void method_13558( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->swap)(*(::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)arg[0]);
}

static  void method_13559( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->clear)();
}

static  void method_13560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->key_comp)());
  else   (((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->key_comp)();
}

static  void method_13562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >)((((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >)((((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13565( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >)((((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13566( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >)((((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >)((((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13568( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >)((((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13569( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >)((((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13570( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >)((((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_2868( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x36( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::Generate();
  else ::Reflex::Proxy< ::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::Generate();
}

//------Dictionary for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > > > -------------------------------
void __std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__db_datamem(Reflex::Class*);
void __std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__datamem_bld(&__std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__funcmem_bld(&__std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__db_funcmem);
void __std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >"), typeid(::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >), sizeof(::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2328, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::key_type"))
  .AddTypedef(type_4304, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::mapped_type"))
  .AddTypedef(type_2719, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::value_type"))
  .AddTypedef(type_2439, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::key_compare"))
  .AddTypedef(type_2959, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::allocator_type"))
  .AddTypedef(type_2719, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::_Alloc_value_type"))
  .AddTypedef(type_2959, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::_Pair_alloc_type"))
  .AddTypedef(type_2483, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::_Rep_type"))
  .AddTypedef(type_9888, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::pointer"))
  .AddTypedef(type_9890, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::const_pointer"))
  .AddTypedef(type_9892, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::reference"))
  .AddTypedef(type_9894, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::const_reference"))
  .AddTypedef(type_2819, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::iterator"))
  .AddTypedef(type_2928, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::const_iterator"))
  .AddTypedef(type_2926, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::size_type"))
  .AddTypedef(type_2844, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::difference_type"))
  .AddTypedef(type_3099, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::reverse_iterator"))
  .AddTypedef(type_3098, Reflex::Literal("std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_13533, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_13534, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26205, type_26290), Reflex::Literal("map"), constructor_13535, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26605), Reflex::Literal("map"), constructor_13536, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2868, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x36, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > > > -------------------
void __std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2483, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > > > -------------------
void __std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26606, type_26605), Reflex::Literal("operator="), operator_13537, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2959), Reflex::Literal("get_allocator"), method_13538, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2819), Reflex::Literal("begin"), method_13539, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2928), Reflex::Literal("begin"), method_13540, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2819), Reflex::Literal("end"), method_13541, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2928), Reflex::Literal("end"), method_13542, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_13547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("size"), method_13548, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("max_size"), method_13549, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26607, type_8978), Reflex::Literal("operator[]"), operator_13550, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26607, type_8978), Reflex::Literal("at"), method_13551, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26448, type_8978), Reflex::Literal("at"), method_13552, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2721, type_9894), Reflex::Literal("insert"), method_13553, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2819, type_2819, type_9894), Reflex::Literal("insert"), method_13554, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2819), Reflex::Literal("erase"), method_13555, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926, type_8978), Reflex::Literal("erase"), method_13556, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2819, type_2819), Reflex::Literal("erase"), method_13557, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_26606), Reflex::Literal("swap"), method_13558, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_13559, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2439), Reflex::Literal("key_comp"), method_13560, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2819, type_8978), Reflex::Literal("find"), method_13562, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2928, type_8978), Reflex::Literal("find"), method_13563, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926, type_8978), Reflex::Literal("count"), method_13564, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2819, type_8978), Reflex::Literal("lower_bound"), method_13565, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2928, type_8978), Reflex::Literal("lower_bound"), method_13566, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2819, type_8978), Reflex::Literal("upper_bound"), method_13567, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2928, type_8978), Reflex::Literal("upper_bound"), method_13568, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2720, type_8978), Reflex::Literal("equal_range"), method_13569, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2718, type_8978), Reflex::Literal("equal_range"), method_13570, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PackedTriggerPrescales -------------------------------
static  void operator_24895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::PackedTriggerPrescales*)o)->operator=)(*(const ::pat::PackedTriggerPrescales*)arg[0]);
  else   (((::pat::PackedTriggerPrescales*)o)->operator=)(*(const ::pat::PackedTriggerPrescales*)arg[0]);
}

static void constructor_24896( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PackedTriggerPrescales(*(const ::pat::PackedTriggerPrescales*)arg[0]);
  else ::new(mem) ::pat::PackedTriggerPrescales(*(const ::pat::PackedTriggerPrescales*)arg[0]);
}

static void constructor_24897( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PackedTriggerPrescales();
  else ::new(mem) ::pat::PackedTriggerPrescales();
}

static void constructor_24898( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PackedTriggerPrescales(*(const ::edm::Handle<edm::TriggerResults>*)arg[0]);
  else ::new(mem) ::pat::PackedTriggerPrescales(*(const ::edm::Handle<edm::TriggerResults>*)arg[0]);
}

static void destructor_24899(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::PackedTriggerPrescales*)o)->::pat::PackedTriggerPrescales::~PackedTriggerPrescales)();
}
static  void method_24900( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PackedTriggerPrescales*)o)->getPrescaleForIndex)(*(int*)arg[0]));
  else   (((const ::pat::PackedTriggerPrescales*)o)->getPrescaleForIndex)(*(int*)arg[0]);
}

static  void method_24901( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (int)((((const ::pat::PackedTriggerPrescales*)o)->getPrescaleForName)(*(const ::std::string*)arg[0]));
    else     (((const ::pat::PackedTriggerPrescales*)o)->getPrescaleForName)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (int)((((const ::pat::PackedTriggerPrescales*)o)->getPrescaleForName)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::pat::PackedTriggerPrescales*)o)->getPrescaleForName)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_24902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PackedTriggerPrescales*)o)->triggerResults)();
  else   (((const ::pat::PackedTriggerPrescales*)o)->triggerResults)();
}

static  void method_24903( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedTriggerPrescales*)o)->setTriggerNames)(*(const ::edm::TriggerNames*)arg[0]);
}

static  void method_24904( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedTriggerPrescales*)o)->addPrescaledTrigger)(*(int*)arg[0],
    *(int*)arg[1]);
}

static void method_newdel_7330( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::PackedTriggerPrescales >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::PackedTriggerPrescales >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::PackedTriggerPrescales >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::PackedTriggerPrescales >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::PackedTriggerPrescales >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

void read___pat__PackedTriggerPrescales_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  const edm::TriggerNames* &triggerNames_ = *(const edm::TriggerNames**)(target + OffsetOf(__shadow__::__pat__PackedTriggerPrescales, triggerNames_));

  if( oldObj ) {}
  //--- User's code ---
    triggerNames_ = 0; 
  
}

//------Dictionary for class PackedTriggerPrescales -------------------------------
void __pat__PackedTriggerPrescales_db_datamem(Reflex::Class*);
void __pat__PackedTriggerPrescales_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__PackedTriggerPrescales_datamem_bld(&__pat__PackedTriggerPrescales_db_datamem);
Reflex::GenreflexMemberBuilder __pat__PackedTriggerPrescales_funcmem_bld(&__pat__PackedTriggerPrescales_db_funcmem);
void __pat__PackedTriggerPrescales_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(1);
  rule = &readrules[0];
  rule->fSourceClass = "pat::PackedTriggerPrescales";
  rule->fTarget      = "triggerNames_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__PackedTriggerPrescales_0);
  rule->fCode        = "\n    triggerNames_ = 0; \n  ";
  rule->fVersion     = "[1-]";


  ::Reflex::ClassBuilder(Reflex::Literal("pat::PackedTriggerPrescales"), typeid(::pat::PackedTriggerPrescales), sizeof(::pat::PackedTriggerPrescales), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddProperty("ioread", readrules )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30878, type_30879), Reflex::Literal("operator="), operator_24895, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30879), Reflex::Literal("PackedTriggerPrescales"), constructor_24896, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PackedTriggerPrescales"), constructor_24897, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30880), Reflex::Literal("PackedTriggerPrescales"), constructor_24898, 0, "handle", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PackedTriggerPrescales"), destructor_24899, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7330, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__PackedTriggerPrescales_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__PackedTriggerPrescales_funcmem_bld);
}

//------Delayed data member builder for class PackedTriggerPrescales -------------------
void __pat__PackedTriggerPrescales_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2755, Reflex::Literal("prescaleValues_"), OffsetOf(__shadow__::__pat__PackedTriggerPrescales, prescaleValues_), ::Reflex::PROTECTED)
  .AddDataMember(type_4286, Reflex::Literal("triggerResults_"), OffsetOf(__shadow__::__pat__PackedTriggerPrescales, triggerResults_), ::Reflex::PROTECTED)
  .AddDataMember(type_30877, Reflex::Literal("triggerNames_"), OffsetOf(__shadow__::__pat__PackedTriggerPrescales, triggerNames_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class PackedTriggerPrescales -------------------
void __pat__PackedTriggerPrescales_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71, type_71), Reflex::Literal("getPrescaleForIndex"), method_24900, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71, type_4393, type_1454), Reflex::Literal("getPrescaleForName"), method_24901, 0, "name;prefixOnly=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29570), Reflex::Literal("triggerResults"), method_24902, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29483), Reflex::Literal("setTriggerNames"), method_24903, 0, "names", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_71, type_71), Reflex::Literal("addPrescaledTrigger"), method_24904, 0, "index;prescale", ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<pat::PackedTriggerPrescales> -------------------------------
static void constructor_17884( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<pat::PackedTriggerPrescales>();
  else ::new(mem) ::edm::Wrapper<pat::PackedTriggerPrescales>();
}

static void constructor_17885( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<pat::PackedTriggerPrescales>(*(::std::auto_ptr<pat::PackedTriggerPrescales>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<pat::PackedTriggerPrescales>(*(::std::auto_ptr<pat::PackedTriggerPrescales>*)arg[0]);
}

static void destructor_17886(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->::edm::Wrapper<pat::PackedTriggerPrescales>::~Wrapper)();
}
static  void method_17887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->product)());
  else   (((const ::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->product)();
}

static  void operator_17888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->operator->)());
  else   (((const ::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->operator->)();
}

static  void method_17889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->productTypeInfo)();
}

static  void method_17890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->typeInfo)();
  else   (((::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->typeInfo)();
}

static void constructor_17891( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<pat::PackedTriggerPrescales>((::pat::PackedTriggerPrescales*)arg[0]);
  else ::new(mem) ::edm::Wrapper<pat::PackedTriggerPrescales>((::pat::PackedTriggerPrescales*)arg[0]);
}

static  void method_17892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->getInterface)());
  else   (((::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->getInterface)();
}

static  void method_17893( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17894( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17895( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->dynamicTypeInfo)();
}

static  void method_17897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->isPresent)();
}

static  void method_17898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<pat::PackedTriggerPrescales>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4130( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<pat::PackedTriggerPrescales> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<pat::PackedTriggerPrescales> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<pat::PackedTriggerPrescales> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<pat::PackedTriggerPrescales> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<pat::PackedTriggerPrescales> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<pat::PackedTriggerPrescales> -------------------------------
void __edm__Wrapper_pat__PackedTriggerPrescales__db_datamem(Reflex::Class*);
void __edm__Wrapper_pat__PackedTriggerPrescales__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_pat__PackedTriggerPrescales__datamem_bld(&__edm__Wrapper_pat__PackedTriggerPrescales__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_pat__PackedTriggerPrescales__funcmem_bld(&__edm__Wrapper_pat__PackedTriggerPrescales__db_funcmem);
void __edm__Wrapper_pat__PackedTriggerPrescales__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<pat::PackedTriggerPrescales>"), typeid(::edm::Wrapper<pat::PackedTriggerPrescales>), sizeof(::edm::Wrapper<pat::PackedTriggerPrescales>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7330, Reflex::Literal("edm::Wrapper<pat::PackedTriggerPrescales>::value_type"))
  .AddTypedef(type_7330, Reflex::Literal("edm::Wrapper<pat::PackedTriggerPrescales>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17884, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521), Reflex::Literal("Wrapper"), constructor_17885, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17886, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29236), Reflex::Literal("Wrapper"), constructor_17891, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4130, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_pat__PackedTriggerPrescales__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_pat__PackedTriggerPrescales__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<pat::PackedTriggerPrescales> -------------------
void __edm__Wrapper_pat__PackedTriggerPrescales__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_pat__PackedTriggerPrescales_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7330, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_pat__PackedTriggerPrescales_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<pat::PackedTriggerPrescales> -------------------
void __edm__Wrapper_pat__PackedTriggerPrescales__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29235), Reflex::Literal("product"), method_17887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29235), Reflex::Literal("operator->"), operator_17888, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_17889, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_17890, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29237), Reflex::Literal("getInterface"), method_17892, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_17893, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_17894, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_17895, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_17896, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_17897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_17898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TriggerEvent -------------------------------
static  void operator_25052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::TriggerEvent*)o)->operator=)(*(const ::pat::TriggerEvent*)arg[0]);
  else   (((::pat::TriggerEvent*)o)->operator=)(*(const ::pat::TriggerEvent*)arg[0]);
}

static void constructor_25053( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerEvent(*(const ::pat::TriggerEvent*)arg[0]);
  else ::new(mem) ::pat::TriggerEvent(*(const ::pat::TriggerEvent*)arg[0]);
}

static void constructor_25054( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerEvent();
  else ::new(mem) ::pat::TriggerEvent();
}

static void constructor_25055( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0]);
  else ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  else ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4]);
  else ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4]);
  }
}

static void constructor_25056( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  else ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4]);
  else ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5]);
  else ::new(mem) ::pat::TriggerEvent(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5]);
  }
}

static void destructor_25057(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::TriggerEvent*)o)->::pat::TriggerEvent::~TriggerEvent)();
}
static  void method_25058( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setNameL1Menu)(*(const ::std::string*)arg[0]);
}

static  void method_25059( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setNameHltTable)(*(const ::std::string*)arg[0]);
}

static  void method_25060( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setRun)(*(bool*)arg[0]);
}

static  void method_25061( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setAccept)(*(bool*)arg[0]);
}

static  void method_25062( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setError)(*(bool*)arg[0]);
}

static  void method_25063( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setPhysDecl)(*(bool*)arg[0]);
}

static  void method_25064( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setLhcFill)(*(::uint32_t*)arg[0]);
}

static  void method_25065( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setBeamMode)(*(::uint16_t*)arg[0]);
}

static  void method_25066( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setBeamMomentum)(*(::uint16_t*)arg[0]);
}

static  void method_25067( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setIntensityBeam1)(*(::uint32_t*)arg[0]);
}

static  void method_25068( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setIntensityBeam2)(*(::uint32_t*)arg[0]);
}

static  void method_25069( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setBstMasterStatus)(*(::uint16_t*)arg[0]);
}

static  void method_25070( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setTurnCount)(*(::uint32_t*)arg[0]);
}

static  void method_25071( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setBCurrentStart)(*(float*)arg[0]);
}

static  void method_25072( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setBCurrentStop)(*(float*)arg[0]);
}

static  void method_25073( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setBCurrentAvg)(*(float*)arg[0]);
}

static  void method_25074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerEvent*)o)->nameL1Menu)();
  else   (((const ::pat::TriggerEvent*)o)->nameL1Menu)();
}

static  void method_25075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::TriggerEvent*)o)->nameHltTable)();
  else   (((const ::pat::TriggerEvent*)o)->nameHltTable)();
}

static  void method_25076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerEvent*)o)->wasRun)());
  else   (((const ::pat::TriggerEvent*)o)->wasRun)();
}

static  void method_25077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerEvent*)o)->wasAccept)());
  else   (((const ::pat::TriggerEvent*)o)->wasAccept)();
}

static  void method_25078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerEvent*)o)->wasError)());
  else   (((const ::pat::TriggerEvent*)o)->wasError)();
}

static  void method_25079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerEvent*)o)->wasPhysDecl)());
  else   (((const ::pat::TriggerEvent*)o)->wasPhysDecl)();
}

static  void method_25080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::pat::TriggerEvent*)o)->lhcFill)());
  else   (((const ::pat::TriggerEvent*)o)->lhcFill)();
}

static  void method_25081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint16_t)((((const ::pat::TriggerEvent*)o)->beamMode)());
  else   (((const ::pat::TriggerEvent*)o)->beamMode)();
}

static  void method_25082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint16_t)((((const ::pat::TriggerEvent*)o)->beamMomentum)());
  else   (((const ::pat::TriggerEvent*)o)->beamMomentum)();
}

static  void method_25083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::pat::TriggerEvent*)o)->intensityBeam1)());
  else   (((const ::pat::TriggerEvent*)o)->intensityBeam1)();
}

static  void method_25084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::pat::TriggerEvent*)o)->intensityBeam2)());
  else   (((const ::pat::TriggerEvent*)o)->intensityBeam2)();
}

static  void method_25085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint16_t)((((const ::pat::TriggerEvent*)o)->bstMasterStatus)());
  else   (((const ::pat::TriggerEvent*)o)->bstMasterStatus)();
}

static  void method_25086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::pat::TriggerEvent*)o)->turnCount)());
  else   (((const ::pat::TriggerEvent*)o)->turnCount)();
}

static  void method_25087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::TriggerEvent*)o)->bCurrentStart)());
  else   (((const ::pat::TriggerEvent*)o)->bCurrentStart)();
}

static  void method_25088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::TriggerEvent*)o)->bCurrentStop)());
  else   (((const ::pat::TriggerEvent*)o)->bCurrentStop)();
}

static  void method_25089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::TriggerEvent*)o)->bCurrentAvg)());
  else   (((const ::pat::TriggerEvent*)o)->bCurrentAvg)();
}

static  void method_25090( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setAlgorithms)(*(const ::edm::Handle<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
}

static  void method_25091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerEvent*)o)->algorithms)());
  else   (((const ::pat::TriggerEvent*)o)->algorithms)();
}

static  void method_25092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerAlgorithmRefVector)((((const ::pat::TriggerEvent*)o)->algorithmRefs)());
  else   (((const ::pat::TriggerEvent*)o)->algorithmRefs)();
}

static  void method_25093( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerEvent*)o)->algorithm)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->algorithm)(*(const ::std::string*)arg[0]);
}

static  void method_25094( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerAlgorithmRef)((((const ::pat::TriggerEvent*)o)->algorithmRef)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->algorithmRef)(*(const ::std::string*)arg[0]);
}

static  void method_25095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::string)((((const ::pat::TriggerEvent*)o)->nameAlgorithm)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::TriggerEvent*)o)->nameAlgorithm)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::string)((((const ::pat::TriggerEvent*)o)->nameAlgorithm)(*(const unsigned int*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::TriggerEvent*)o)->nameAlgorithm)(*(const unsigned int*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_25096( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::pat::TriggerEvent*)o)->indexAlgorithm)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->indexAlgorithm)(*(const ::std::string*)arg[0]);
}

static  void method_25097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerAlgorithmRefVector)((((const ::pat::TriggerEvent*)o)->acceptedAlgorithms)());
  else   (((const ::pat::TriggerEvent*)o)->acceptedAlgorithms)();
}

static  void method_25098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerAlgorithmRefVector)((((const ::pat::TriggerEvent*)o)->acceptedAlgorithmsGtl)());
  else   (((const ::pat::TriggerEvent*)o)->acceptedAlgorithmsGtl)();
}

static  void method_25099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerAlgorithmRefVector)((((const ::pat::TriggerEvent*)o)->techAlgorithms)());
  else   (((const ::pat::TriggerEvent*)o)->techAlgorithms)();
}

static  void method_25100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerAlgorithmRefVector)((((const ::pat::TriggerEvent*)o)->acceptedTechAlgorithms)());
  else   (((const ::pat::TriggerEvent*)o)->acceptedTechAlgorithms)();
}

static  void method_25101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerAlgorithmRefVector)((((const ::pat::TriggerEvent*)o)->acceptedTechAlgorithmsGtl)());
  else   (((const ::pat::TriggerEvent*)o)->acceptedTechAlgorithmsGtl)();
}

static  void method_25102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerAlgorithmRefVector)((((const ::pat::TriggerEvent*)o)->physAlgorithms)());
  else   (((const ::pat::TriggerEvent*)o)->physAlgorithms)();
}

static  void method_25103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerAlgorithmRefVector)((((const ::pat::TriggerEvent*)o)->acceptedPhysAlgorithms)());
  else   (((const ::pat::TriggerEvent*)o)->acceptedPhysAlgorithms)();
}

static  void method_25104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerAlgorithmRefVector)((((const ::pat::TriggerEvent*)o)->acceptedPhysAlgorithmsGtl)());
  else   (((const ::pat::TriggerEvent*)o)->acceptedPhysAlgorithmsGtl)();
}

static  void method_25105( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setConditions)(*(const ::edm::Handle<std::vector<pat::TriggerCondition> >*)arg[0]);
}

static  void method_25106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerEvent*)o)->conditions)());
  else   (((const ::pat::TriggerEvent*)o)->conditions)();
}

static  void method_25107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerConditionRefVector)((((const ::pat::TriggerEvent*)o)->conditionRefs)());
  else   (((const ::pat::TriggerEvent*)o)->conditionRefs)();
}

static  void method_25108( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerEvent*)o)->condition)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->condition)(*(const ::std::string*)arg[0]);
}

static  void method_25109( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerConditionRef)((((const ::pat::TriggerEvent*)o)->conditionRef)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->conditionRef)(*(const ::std::string*)arg[0]);
}

static  void method_25110( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::pat::TriggerEvent*)o)->indexCondition)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->indexCondition)(*(const ::std::string*)arg[0]);
}

static  void method_25111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerConditionRefVector)((((const ::pat::TriggerEvent*)o)->acceptedConditions)());
  else   (((const ::pat::TriggerEvent*)o)->acceptedConditions)();
}

static  void method_25112( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setPaths)(*(const ::edm::Handle<std::vector<pat::TriggerPath> >*)arg[0]);
}

static  void method_25113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerEvent*)o)->paths)());
  else   (((const ::pat::TriggerEvent*)o)->paths)();
}

static  void method_25114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerPathRefVector)((((const ::pat::TriggerEvent*)o)->pathRefs)());
  else   (((const ::pat::TriggerEvent*)o)->pathRefs)();
}

static  void method_25115( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerEvent*)o)->path)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->path)(*(const ::std::string*)arg[0]);
}

static  void method_25116( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerPathRef)((((const ::pat::TriggerEvent*)o)->pathRef)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->pathRef)(*(const ::std::string*)arg[0]);
}

static  void method_25117( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::pat::TriggerEvent*)o)->indexPath)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->indexPath)(*(const ::std::string*)arg[0]);
}

static  void method_25118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerPathRefVector)((((const ::pat::TriggerEvent*)o)->acceptedPaths)());
  else   (((const ::pat::TriggerEvent*)o)->acceptedPaths)();
}

static  void method_25119( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setFilters)(*(const ::edm::Handle<std::vector<pat::TriggerFilter> >*)arg[0]);
}

static  void method_25120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerEvent*)o)->filters)());
  else   (((const ::pat::TriggerEvent*)o)->filters)();
}

static  void method_25121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerFilterRefVector)((((const ::pat::TriggerEvent*)o)->filterRefs)());
  else   (((const ::pat::TriggerEvent*)o)->filterRefs)();
}

static  void method_25122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerEvent*)o)->filter)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->filter)(*(const ::std::string*)arg[0]);
}

static  void method_25123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerFilterRef)((((const ::pat::TriggerEvent*)o)->filterRef)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->filterRef)(*(const ::std::string*)arg[0]);
}

static  void method_25124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::pat::TriggerEvent*)o)->indexFilter)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->indexFilter)(*(const ::std::string*)arg[0]);
}

static  void method_25125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerFilterRefVector)((((const ::pat::TriggerEvent*)o)->acceptedFilters)());
  else   (((const ::pat::TriggerEvent*)o)->acceptedFilters)();
}

static  void method_25126( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::TriggerEvent*)o)->setObjects)(*(const ::edm::Handle<std::vector<pat::TriggerObject> >*)arg[0]);
}

static  void method_25127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerEvent*)o)->objects)());
  else   (((const ::pat::TriggerEvent*)o)->objects)();
}

static  void method_25128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerObjectRefVector)((((const ::pat::TriggerEvent*)o)->objectRefs)());
  else   (((const ::pat::TriggerEvent*)o)->objectRefs)();
}

static  void method_25129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerObjectRefVector)((((const ::pat::TriggerEvent*)o)->objects)(*(::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->objects)(*(::trigger::TriggerObjectType*)arg[0]);
}

static  void method_25130( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerObjectRefVector)((((const ::pat::TriggerEvent*)o)->objects)(*(int*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->objects)(*(int*)arg[0]);
}

static  void method_25131( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerConditionRefVector)((((const ::pat::TriggerEvent*)o)->algorithmConditions)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->algorithmConditions)(*(const ::std::string*)arg[0]);
}

static  void method_25132( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerEvent*)o)->conditionInAlgorithm)(*(const ::pat::TriggerConditionRef*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::pat::TriggerEvent*)o)->conditionInAlgorithm)(*(const ::pat::TriggerConditionRef*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_25133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerAlgorithmRefVector)((((const ::pat::TriggerEvent*)o)->conditionAlgorithms)(*(const ::pat::TriggerConditionRef*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->conditionAlgorithms)(*(const ::pat::TriggerConditionRef*)arg[0]);
}

static  void method_25134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::TriggerEvent*)o)->conditionCollections)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->conditionCollections)(*(const ::std::string*)arg[0]);
}

static  void method_25135( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerObjectRefVector)((((const ::pat::TriggerEvent*)o)->conditionObjects)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->conditionObjects)(*(const ::std::string*)arg[0]);
}

static  void method_25136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerEvent*)o)->objectInCondition)(*(const ::pat::TriggerObjectRef*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::pat::TriggerEvent*)o)->objectInCondition)(*(const ::pat::TriggerObjectRef*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_25137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerConditionRefVector)((((const ::pat::TriggerEvent*)o)->objectConditions)(*(const ::pat::TriggerObjectRef*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->objectConditions)(*(const ::pat::TriggerObjectRef*)arg[0]);
}

static  void method_25138( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerObjectRefVector)((((const ::pat::TriggerEvent*)o)->algorithmObjects)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->algorithmObjects)(*(const ::std::string*)arg[0]);
}

static  void method_25139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerEvent*)o)->objectInAlgorithm)(*(const ::pat::TriggerObjectRef*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::pat::TriggerEvent*)o)->objectInAlgorithm)(*(const ::pat::TriggerObjectRef*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_25140( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerAlgorithmRefVector)((((const ::pat::TriggerEvent*)o)->objectAlgorithms)(*(const ::pat::TriggerObjectRef*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->objectAlgorithms)(*(const ::pat::TriggerObjectRef*)arg[0]);
}

static  void method_25141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (pat::TriggerFilterRefVector)((((const ::pat::TriggerEvent*)o)->pathModules)(*(const ::std::string*)arg[0]));
    else     (((const ::pat::TriggerEvent*)o)->pathModules)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (pat::TriggerFilterRefVector)((((const ::pat::TriggerEvent*)o)->pathModules)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::pat::TriggerEvent*)o)->pathModules)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_25142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (pat::TriggerFilterRefVector)((((const ::pat::TriggerEvent*)o)->pathFilters)(*(const ::std::string*)arg[0]));
    else     (((const ::pat::TriggerEvent*)o)->pathFilters)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (pat::TriggerFilterRefVector)((((const ::pat::TriggerEvent*)o)->pathFilters)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::pat::TriggerEvent*)o)->pathFilters)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_25143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerEvent*)o)->filterInPath)(*(const ::pat::TriggerFilterRef*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::pat::TriggerEvent*)o)->filterInPath)(*(const ::pat::TriggerFilterRef*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerEvent*)o)->filterInPath)(*(const ::pat::TriggerFilterRef*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]));
    else     (((const ::pat::TriggerEvent*)o)->filterInPath)(*(const ::pat::TriggerFilterRef*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]);
  }
}

static  void method_25144( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (pat::TriggerPathRefVector)((((const ::pat::TriggerEvent*)o)->filterPaths)(*(const ::pat::TriggerFilterRef*)arg[0]));
    else     (((const ::pat::TriggerEvent*)o)->filterPaths)(*(const ::pat::TriggerFilterRef*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (pat::TriggerPathRefVector)((((const ::pat::TriggerEvent*)o)->filterPaths)(*(const ::pat::TriggerFilterRef*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::pat::TriggerEvent*)o)->filterPaths)(*(const ::pat::TriggerFilterRef*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_25145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::TriggerEvent*)o)->filterCollections)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->filterCollections)(*(const ::std::string*)arg[0]);
}

static  void method_25146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (pat::TriggerObjectRefVector)((((const ::pat::TriggerEvent*)o)->filterObjects)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->filterObjects)(*(const ::std::string*)arg[0]);
}

static  void method_25147( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerEvent*)o)->objectInFilter)(*(const ::pat::TriggerObjectRef*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::pat::TriggerEvent*)o)->objectInFilter)(*(const ::pat::TriggerObjectRef*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_25148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (pat::TriggerFilterRefVector)((((const ::pat::TriggerEvent*)o)->objectFilters)(*(const ::pat::TriggerObjectRef*)arg[0]));
    else     (((const ::pat::TriggerEvent*)o)->objectFilters)(*(const ::pat::TriggerObjectRef*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (pat::TriggerFilterRefVector)((((const ::pat::TriggerEvent*)o)->objectFilters)(*(const ::pat::TriggerObjectRef*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::pat::TriggerEvent*)o)->objectFilters)(*(const ::pat::TriggerObjectRef*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_25149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (pat::TriggerObjectRefVector)((((const ::pat::TriggerEvent*)o)->pathObjects)(*(const ::std::string*)arg[0]));
    else     (((const ::pat::TriggerEvent*)o)->pathObjects)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (pat::TriggerObjectRefVector)((((const ::pat::TriggerEvent*)o)->pathObjects)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::pat::TriggerEvent*)o)->pathObjects)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_25150( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerEvent*)o)->objectInPath)(*(const ::pat::TriggerObjectRef*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::pat::TriggerEvent*)o)->objectInPath)(*(const ::pat::TriggerObjectRef*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::TriggerEvent*)o)->objectInPath)(*(const ::pat::TriggerObjectRef*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]));
    else     (((const ::pat::TriggerEvent*)o)->objectInPath)(*(const ::pat::TriggerObjectRef*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]);
  }
}

static  void method_25151( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (pat::TriggerPathRefVector)((((const ::pat::TriggerEvent*)o)->objectPaths)(*(const ::pat::TriggerObjectRef*)arg[0]));
    else     (((const ::pat::TriggerEvent*)o)->objectPaths)(*(const ::pat::TriggerObjectRef*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (pat::TriggerPathRefVector)((((const ::pat::TriggerEvent*)o)->objectPaths)(*(const ::pat::TriggerObjectRef*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::pat::TriggerEvent*)o)->objectPaths)(*(const ::pat::TriggerObjectRef*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_25152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::pat::TriggerEvent*)o)->addObjectMatchResult)(*(const ::pat::TriggerObjectMatchRefProd*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::pat::TriggerEvent*)o)->addObjectMatchResult)(*(const ::pat::TriggerObjectMatchRefProd*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_25153( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::pat::TriggerEvent*)o)->addObjectMatchResult)(*(const ::edm::Handle<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::pat::TriggerEvent*)o)->addObjectMatchResult)(*(const ::edm::Handle<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_25154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::pat::TriggerEvent*)o)->addObjectMatchResult)(*(const ::edm::OrphanHandle<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::pat::TriggerEvent*)o)->addObjectMatchResult)(*(const ::edm::OrphanHandle<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_25155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::TriggerEvent*)o)->triggerMatchers)());
  else   (((const ::pat::TriggerEvent*)o)->triggerMatchers)();
}

static  void method_25156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerEvent*)o)->triggerObjectMatchResults)());
  else   (((const ::pat::TriggerEvent*)o)->triggerObjectMatchResults)();
}

static  void method_25157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::TriggerEvent*)o)->triggerObjectMatchResult)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::TriggerEvent*)o)->triggerObjectMatchResult)(*(const ::std::string*)arg[0]);
}

static void method_newdel_7350( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::TriggerEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::TriggerEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::TriggerEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::TriggerEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::TriggerEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TriggerEvent -------------------------------
void __pat__TriggerEvent_db_datamem(Reflex::Class*);
void __pat__TriggerEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__TriggerEvent_datamem_bld(&__pat__TriggerEvent_db_datamem);
Reflex::GenreflexMemberBuilder __pat__TriggerEvent_funcmem_bld(&__pat__TriggerEvent_db_funcmem);
void __pat__TriggerEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::TriggerEvent"), typeid(::pat::TriggerEvent), sizeof(::pat::TriggerEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30884, type_30885), Reflex::Literal("operator="), operator_25052, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30885), Reflex::Literal("TriggerEvent"), constructor_25053, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerEvent"), constructor_25054, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4393, type_1454, type_1454, type_1454, type_1454), Reflex::Literal("TriggerEvent"), constructor_25055, 0, "nameHltTable;run=true;accept=true;error=false;physDecl=true", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4393, type_4393, type_1454, type_1454, type_1454, type_1454), Reflex::Literal("TriggerEvent"), constructor_25056, 0, "nameL1Menu;nameHltTable;run=true;accept=true;error=false;physDecl=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerEvent"), destructor_25057, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7350, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__TriggerEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__TriggerEvent_funcmem_bld);
}

//------Delayed data member builder for class TriggerEvent -------------------
void __pat__TriggerEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2329, Reflex::Literal("nameL1Menu_"), OffsetOf(__shadow__::__pat__TriggerEvent, nameL1Menu_), ::Reflex::PRIVATE)
  .AddDataMember(type_2329, Reflex::Literal("nameHltTable_"), OffsetOf(__shadow__::__pat__TriggerEvent, nameHltTable_), ::Reflex::PRIVATE)
  .AddDataMember(type_1454, Reflex::Literal("run_"), OffsetOf(__shadow__::__pat__TriggerEvent, run_), ::Reflex::PRIVATE)
  .AddDataMember(type_1454, Reflex::Literal("accept_"), OffsetOf(__shadow__::__pat__TriggerEvent, accept_), ::Reflex::PRIVATE)
  .AddDataMember(type_1454, Reflex::Literal("error_"), OffsetOf(__shadow__::__pat__TriggerEvent, error_), ::Reflex::PRIVATE)
  .AddDataMember(type_1454, Reflex::Literal("physDecl_"), OffsetOf(__shadow__::__pat__TriggerEvent, physDecl_), ::Reflex::PRIVATE)
  .AddDataMember(type_1418, Reflex::Literal("lhcFill_"), OffsetOf(__shadow__::__pat__TriggerEvent, lhcFill_), ::Reflex::PRIVATE)
  .AddDataMember(type_1624, Reflex::Literal("beamMode_"), OffsetOf(__shadow__::__pat__TriggerEvent, beamMode_), ::Reflex::PRIVATE)
  .AddDataMember(type_1624, Reflex::Literal("beamMomentum_"), OffsetOf(__shadow__::__pat__TriggerEvent, beamMomentum_), ::Reflex::PRIVATE)
  .AddDataMember(type_1418, Reflex::Literal("intensityBeam1_"), OffsetOf(__shadow__::__pat__TriggerEvent, intensityBeam1_), ::Reflex::PRIVATE)
  .AddDataMember(type_1418, Reflex::Literal("intensityBeam2_"), OffsetOf(__shadow__::__pat__TriggerEvent, intensityBeam2_), ::Reflex::PRIVATE)
  .AddDataMember(type_1624, Reflex::Literal("bstMasterStatus_"), OffsetOf(__shadow__::__pat__TriggerEvent, bstMasterStatus_), ::Reflex::PRIVATE)
  .AddDataMember(type_1418, Reflex::Literal("turnCount_"), OffsetOf(__shadow__::__pat__TriggerEvent, turnCount_), ::Reflex::PRIVATE)
  .AddDataMember(type_782, Reflex::Literal("bCurrentStart_"), OffsetOf(__shadow__::__pat__TriggerEvent, bCurrentStart_), ::Reflex::PRIVATE)
  .AddDataMember(type_782, Reflex::Literal("bCurrentStop_"), OffsetOf(__shadow__::__pat__TriggerEvent, bCurrentStop_), ::Reflex::PRIVATE)
  .AddDataMember(type_782, Reflex::Literal("bCurrentAvg_"), OffsetOf(__shadow__::__pat__TriggerEvent, bCurrentAvg_), ::Reflex::PRIVATE)
  .AddDataMember(type_7362, Reflex::Literal("algorithms_"), OffsetOf(__shadow__::__pat__TriggerEvent, algorithms_), ::Reflex::PRIVATE)
  .AddDataMember(type_7360, Reflex::Literal("conditions_"), OffsetOf(__shadow__::__pat__TriggerEvent, conditions_), ::Reflex::PRIVATE)
  .AddDataMember(type_7339, Reflex::Literal("paths_"), OffsetOf(__shadow__::__pat__TriggerEvent, paths_), ::Reflex::PRIVATE)
  .AddDataMember(type_7373, Reflex::Literal("filters_"), OffsetOf(__shadow__::__pat__TriggerEvent, filters_), ::Reflex::PRIVATE)
  .AddDataMember(type_7356, Reflex::Literal("objects_"), OffsetOf(__shadow__::__pat__TriggerEvent, objects_), ::Reflex::PRIVATE)
  .AddDataMember(type_7370, Reflex::Literal("objectMatchResults_"), OffsetOf(__shadow__::__pat__TriggerEvent, objectMatchResults_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TriggerEvent -------------------
void __pat__TriggerEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4393), Reflex::Literal("setNameL1Menu"), method_25058, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4393), Reflex::Literal("setNameHltTable"), method_25059, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1454), Reflex::Literal("setRun"), method_25060, 0, "run", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1454), Reflex::Literal("setAccept"), method_25061, 0, "accept", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1454), Reflex::Literal("setError"), method_25062, 0, "error", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1454), Reflex::Literal("setPhysDecl"), method_25063, 0, "physDecl", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1418), Reflex::Literal("setLhcFill"), method_25064, 0, "lhcFill", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1624), Reflex::Literal("setBeamMode"), method_25065, 0, "beamMode", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1624), Reflex::Literal("setBeamMomentum"), method_25066, 0, "beamMomentum", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1418), Reflex::Literal("setIntensityBeam1"), method_25067, 0, "intensityBeam1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1418), Reflex::Literal("setIntensityBeam2"), method_25068, 0, "intensityBeam2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1624), Reflex::Literal("setBstMasterStatus"), method_25069, 0, "bstMasterStatus", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_1418), Reflex::Literal("setTurnCount"), method_25070, 0, "turnCount", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_782), Reflex::Literal("setBCurrentStart"), method_25071, 0, "bCurrentStart", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_782), Reflex::Literal("setBCurrentStop"), method_25072, 0, "bCurrentStop", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_782), Reflex::Literal("setBCurrentAvg"), method_25073, 0, "bCurrentAvg", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4393), Reflex::Literal("nameL1Menu"), method_25074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4393), Reflex::Literal("nameHltTable"), method_25075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("wasRun"), method_25076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("wasAccept"), method_25077, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("wasError"), method_25078, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("wasPhysDecl"), method_25079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1418), Reflex::Literal("lhcFill"), method_25080, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1624), Reflex::Literal("beamMode"), method_25081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1624), Reflex::Literal("beamMomentum"), method_25082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1418), Reflex::Literal("intensityBeam1"), method_25083, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1418), Reflex::Literal("intensityBeam2"), method_25084, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1624), Reflex::Literal("bstMasterStatus"), method_25085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1418), Reflex::Literal("turnCount"), method_25086, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_782), Reflex::Literal("bCurrentStart"), method_25087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_782), Reflex::Literal("bCurrentStop"), method_25088, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_782), Reflex::Literal("bCurrentAvg"), method_25089, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29549), Reflex::Literal("setAlgorithms"), method_25090, 0, "handleTriggerAlgorithms", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30886), Reflex::Literal("algorithms"), method_25091, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7340c), Reflex::Literal("algorithmRefs"), method_25092, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8856, type_4393), Reflex::Literal("algorithm"), method_25093, 0, "nameAlgorithm", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7349c, type_4393), Reflex::Literal("algorithmRef"), method_25094, 0, "nameAlgorithm", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2329, type_289c, type_1454c), Reflex::Literal("nameAlgorithm"), method_25095, 0, "bitAlgorithm;techAlgorithm=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289, type_4393), Reflex::Literal("indexAlgorithm"), method_25096, 0, "nameAlgorithm", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7340), Reflex::Literal("acceptedAlgorithms"), method_25097, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7340), Reflex::Literal("acceptedAlgorithmsGtl"), method_25098, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7340), Reflex::Literal("techAlgorithms"), method_25099, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7340), Reflex::Literal("acceptedTechAlgorithms"), method_25100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7340), Reflex::Literal("acceptedTechAlgorithmsGtl"), method_25101, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7340), Reflex::Literal("physAlgorithms"), method_25102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7340), Reflex::Literal("acceptedPhysAlgorithms"), method_25103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7340), Reflex::Literal("acceptedPhysAlgorithmsGtl"), method_25104, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29546), Reflex::Literal("setConditions"), method_25105, 0, "handleTriggerConditions", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30889), Reflex::Literal("conditions"), method_25106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7355c), Reflex::Literal("conditionRefs"), method_25107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8867, type_4393), Reflex::Literal("condition"), method_25108, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7342c, type_4393), Reflex::Literal("conditionRef"), method_25109, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289, type_4393), Reflex::Literal("indexCondition"), method_25110, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7355), Reflex::Literal("acceptedConditions"), method_25111, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29543), Reflex::Literal("setPaths"), method_25112, 0, "handleTriggerPaths", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30892), Reflex::Literal("paths"), method_25113, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7367c), Reflex::Literal("pathRefs"), method_25114, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8889, type_4393), Reflex::Literal("path"), method_25115, 0, "namePath", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7329c, type_4393), Reflex::Literal("pathRef"), method_25116, 0, "namePath", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289, type_4393), Reflex::Literal("indexPath"), method_25117, 0, "namePath", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7367), Reflex::Literal("acceptedPaths"), method_25118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29540), Reflex::Literal("setFilters"), method_25119, 0, "handleTriggerFilters", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30895), Reflex::Literal("filters"), method_25120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7369c), Reflex::Literal("filterRefs"), method_25121, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8900, type_4393), Reflex::Literal("filter"), method_25122, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7333c, type_4393), Reflex::Literal("filterRef"), method_25123, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289, type_4393), Reflex::Literal("indexFilter"), method_25124, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7369), Reflex::Literal("acceptedFilters"), method_25125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29536), Reflex::Literal("setObjects"), method_25126, 0, "handleTriggerObjects", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30898), Reflex::Literal("objects"), method_25127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7363c), Reflex::Literal("objectRefs"), method_25128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7363, type_7391), Reflex::Literal("objects"), method_25129, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7363, type_71), Reflex::Literal("objects"), method_25130, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7355, type_4393), Reflex::Literal("algorithmConditions"), method_25131, 0, "nameAlgorithm", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_30900, type_4393), Reflex::Literal("conditionInAlgorithm"), method_25132, 0, "conditionRef;nameAlgorithm", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7340, type_30900), Reflex::Literal("conditionAlgorithms"), method_25133, 0, "conditionRef", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2756, type_4393), Reflex::Literal("conditionCollections"), method_25134, 0, "nameAlgorithm", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7363, type_4393), Reflex::Literal("conditionObjects"), method_25135, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_30901, type_4393), Reflex::Literal("objectInCondition"), method_25136, 0, "objectRef;nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7355, type_30901), Reflex::Literal("objectConditions"), method_25137, 0, "objectRef", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7363, type_4393), Reflex::Literal("algorithmObjects"), method_25138, 0, "nameAlgorithm", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_30901, type_4393), Reflex::Literal("objectInAlgorithm"), method_25139, 0, "objectRef;nameAlgorithm", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7340, type_30901), Reflex::Literal("objectAlgorithms"), method_25140, 0, "objectRef", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7369, type_4393, type_1454), Reflex::Literal("pathModules"), method_25141, 0, "namePath;all=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7369, type_4393, type_1454), Reflex::Literal("pathFilters"), method_25142, 0, "namePath;firing=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_30902, type_4393, type_1454), Reflex::Literal("filterInPath"), method_25143, 0, "filterRef;namePath;firing=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7367, type_30902, type_1454), Reflex::Literal("filterPaths"), method_25144, 0, "filterRef;firing=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2756, type_4393), Reflex::Literal("filterCollections"), method_25145, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7363, type_4393), Reflex::Literal("filterObjects"), method_25146, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_30901, type_4393), Reflex::Literal("objectInFilter"), method_25147, 0, "objectRef;labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7369, type_30901, type_1454), Reflex::Literal("objectFilters"), method_25148, 0, "objectRef;firing=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7363, type_4393, type_1454), Reflex::Literal("pathObjects"), method_25149, 0, "namePath;firing=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_30901, type_4393, type_1454), Reflex::Literal("objectInPath"), method_25150, 0, "objectRef;namePath;firing=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7367, type_30901, type_1454), Reflex::Literal("objectPaths"), method_25151, 0, "objectRef;firing=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_30903, type_4393), Reflex::Literal("addObjectMatchResult"), method_25152, 0, "trigMatches;labelMatcher", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_29537, type_4393), Reflex::Literal("addObjectMatchResult"), method_25153, 0, "trigMatches;labelMatcher", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_29471, type_4393), Reflex::Literal("addObjectMatchResult"), method_25154, 0, "trigMatches;labelMatcher", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2756), Reflex::Literal("triggerMatchers"), method_25155, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30904), Reflex::Literal("triggerObjectMatchResults"), method_25156, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30905, type_4393), Reflex::Literal("triggerObjectMatchResult"), method_25157, 0, "labelMatcher", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<pat::TriggerEvent> -------------------------------
static void constructor_17905( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<pat::TriggerEvent>();
  else ::new(mem) ::edm::Wrapper<pat::TriggerEvent>();
}

static void constructor_17906( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<pat::TriggerEvent>(*(::std::auto_ptr<pat::TriggerEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<pat::TriggerEvent>(*(::std::auto_ptr<pat::TriggerEvent>*)arg[0]);
}

static void destructor_17907(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<pat::TriggerEvent>*)o)->::edm::Wrapper<pat::TriggerEvent>::~Wrapper)();
}
static  void method_17908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<pat::TriggerEvent>*)o)->product)());
  else   (((const ::edm::Wrapper<pat::TriggerEvent>*)o)->product)();
}

static  void operator_17909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<pat::TriggerEvent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<pat::TriggerEvent>*)o)->operator->)();
}

static  void method_17910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<pat::TriggerEvent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<pat::TriggerEvent>*)o)->productTypeInfo)();
}

static  void method_17911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<pat::TriggerEvent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<pat::TriggerEvent>*)o)->typeInfo)();
}

static void constructor_17912( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<pat::TriggerEvent>((::pat::TriggerEvent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<pat::TriggerEvent>((::pat::TriggerEvent*)arg[0]);
}

static  void method_17913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<pat::TriggerEvent>*)o)->getInterface)());
  else   (((::edm::Wrapper<pat::TriggerEvent>*)o)->getInterface)();
}

static  void method_17914( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<pat::TriggerEvent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17915( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<pat::TriggerEvent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17916( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<pat::TriggerEvent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<pat::TriggerEvent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<pat::TriggerEvent>*)o)->dynamicTypeInfo)();
}

static  void method_17918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<pat::TriggerEvent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<pat::TriggerEvent>*)o)->isPresent)();
}

static  void method_17919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<pat::TriggerEvent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<pat::TriggerEvent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4131( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<pat::TriggerEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<pat::TriggerEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<pat::TriggerEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<pat::TriggerEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<pat::TriggerEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<pat::TriggerEvent> -------------------------------
void __edm__Wrapper_pat__TriggerEvent__db_datamem(Reflex::Class*);
void __edm__Wrapper_pat__TriggerEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_pat__TriggerEvent__datamem_bld(&__edm__Wrapper_pat__TriggerEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_pat__TriggerEvent__funcmem_bld(&__edm__Wrapper_pat__TriggerEvent__db_funcmem);
void __edm__Wrapper_pat__TriggerEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<pat::TriggerEvent>"), typeid(::edm::Wrapper<pat::TriggerEvent>), sizeof(::edm::Wrapper<pat::TriggerEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7350, Reflex::Literal("edm::Wrapper<pat::TriggerEvent>::value_type"))
  .AddTypedef(type_7350, Reflex::Literal("edm::Wrapper<pat::TriggerEvent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17905, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2522), Reflex::Literal("Wrapper"), constructor_17906, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17907, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29241), Reflex::Literal("Wrapper"), constructor_17912, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4131, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_pat__TriggerEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_pat__TriggerEvent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<pat::TriggerEvent> -------------------
void __edm__Wrapper_pat__TriggerEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_pat__TriggerEvent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7350, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_pat__TriggerEvent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<pat::TriggerEvent> -------------------
void __edm__Wrapper_pat__TriggerEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29240), Reflex::Literal("product"), method_17908, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29240), Reflex::Literal("operator->"), operator_17909, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_17910, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_17911, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29242), Reflex::Literal("getInterface"), method_17913, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_17914, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_17915, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_17916, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_17917, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_17918, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_17919, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > -------------------------------
static void constructor_17947( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >();
}

static void constructor_17948( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >(*(::std::auto_ptr<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >(*(::std::auto_ptr<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
}

static void destructor_17949(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >::~Wrapper)();
}
static  void method_17950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->product)();
}

static  void operator_17951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->operator->)();
}

static  void method_17952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->productTypeInfo)();
}

static  void method_17953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->typeInfo)();
}

static void constructor_17954( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >((::std::vector<pat::TriggerAlgorithm>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >((::std::vector<pat::TriggerAlgorithm>*)arg[0]);
}

static  void method_17955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->getInterface)();
}

static  void method_17956( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17957( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17958( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->dynamicTypeInfo)();
}

static  void method_17960( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->isPresent)();
}

static  void method_17961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4133( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerAlgorithm> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > -------------------------------
void __edm__Wrapper_std__vector_pat__TriggerAlgorithm_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__TriggerAlgorithm_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__TriggerAlgorithm_s__datamem_bld(&__edm__Wrapper_std__vector_pat__TriggerAlgorithm_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__TriggerAlgorithm_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__TriggerAlgorithm_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__TriggerAlgorithm_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerAlgorithm> >"), typeid(::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >), sizeof(::edm::Wrapper<std::vector<pat::TriggerAlgorithm> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2745, Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerAlgorithm> >::value_type"))
  .AddTypedef(type_2745, Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerAlgorithm> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17947, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2525), Reflex::Literal("Wrapper"), constructor_17948, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17949, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29250), Reflex::Literal("Wrapper"), constructor_17954, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4133, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__TriggerAlgorithm_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__TriggerAlgorithm_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > -------------------
void __edm__Wrapper_std__vector_pat__TriggerAlgorithm_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__TriggerAlgorithm_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2745, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__TriggerAlgorithm_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > -------------------
void __edm__Wrapper_std__vector_pat__TriggerAlgorithm_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29213), Reflex::Literal("product"), method_17950, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29213), Reflex::Literal("operator->"), operator_17951, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_17952, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_17953, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29251), Reflex::Literal("getInterface"), method_17955, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_17956, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_17957, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_17958, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_17959, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_17960, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_17961, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > -------------------------------
static void constructor_17989( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerCondition> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerCondition> >();
}

static void constructor_17990( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerCondition> >(*(::std::auto_ptr<std::vector<pat::TriggerCondition> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerCondition> >(*(::std::auto_ptr<std::vector<pat::TriggerCondition> >*)arg[0]);
}

static void destructor_17991(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->::edm::Wrapper<std::vector<pat::TriggerCondition> >::~Wrapper)();
}
static  void method_17992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->product)();
}

static  void operator_17993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->operator->)();
}

static  void method_17994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->productTypeInfo)();
}

static  void method_17995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->typeInfo)();
}

static void constructor_17996( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerCondition> >((::std::vector<pat::TriggerCondition>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerCondition> >((::std::vector<pat::TriggerCondition>*)arg[0]);
}

static  void method_17997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->getInterface)();
}

static  void method_17998( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17999( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18000( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->dynamicTypeInfo)();
}

static  void method_18002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->isPresent)();
}

static  void method_18003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerCondition> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4135( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerCondition> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerCondition> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerCondition> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerCondition> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerCondition> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > -------------------------------
void __edm__Wrapper_std__vector_pat__TriggerCondition_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__TriggerCondition_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__TriggerCondition_s__datamem_bld(&__edm__Wrapper_std__vector_pat__TriggerCondition_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__TriggerCondition_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__TriggerCondition_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__TriggerCondition_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerCondition> >"), typeid(::edm::Wrapper<std::vector<pat::TriggerCondition> >), sizeof(::edm::Wrapper<std::vector<pat::TriggerCondition> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2746, Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerCondition> >::value_type"))
  .AddTypedef(type_2746, Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerCondition> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17989, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2528), Reflex::Literal("Wrapper"), constructor_17990, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17991, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29259), Reflex::Literal("Wrapper"), constructor_17996, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4135, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__TriggerCondition_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__TriggerCondition_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > -------------------
void __edm__Wrapper_std__vector_pat__TriggerCondition_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__TriggerCondition_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2746, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__TriggerCondition_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > -------------------
void __edm__Wrapper_std__vector_pat__TriggerCondition_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29218), Reflex::Literal("product"), method_17992, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29218), Reflex::Literal("operator->"), operator_17993, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_17994, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_17995, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29260), Reflex::Literal("getInterface"), method_17997, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_17998, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_17999, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_18000, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_18001, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_18002, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_18003, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > -------------------------------
static void constructor_18031( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerPath> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerPath> >();
}

static void constructor_18032( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerPath> >(*(::std::auto_ptr<std::vector<pat::TriggerPath> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerPath> >(*(::std::auto_ptr<std::vector<pat::TriggerPath> >*)arg[0]);
}

static void destructor_18033(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->::edm::Wrapper<std::vector<pat::TriggerPath> >::~Wrapper)();
}
static  void method_18034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->product)();
}

static  void operator_18035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->operator->)();
}

static  void method_18036( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->productTypeInfo)();
}

static  void method_18037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->typeInfo)();
}

static void constructor_18038( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerPath> >((::std::vector<pat::TriggerPath>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerPath> >((::std::vector<pat::TriggerPath>*)arg[0]);
}

static  void method_18039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->getInterface)();
}

static  void method_18040( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18041( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18042( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->dynamicTypeInfo)();
}

static  void method_18044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->isPresent)();
}

static  void method_18045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerPath> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4137( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerPath> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerPath> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerPath> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerPath> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerPath> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > -------------------------------
void __edm__Wrapper_std__vector_pat__TriggerPath_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__TriggerPath_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__TriggerPath_s__datamem_bld(&__edm__Wrapper_std__vector_pat__TriggerPath_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__TriggerPath_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__TriggerPath_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__TriggerPath_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerPath> >"), typeid(::edm::Wrapper<std::vector<pat::TriggerPath> >), sizeof(::edm::Wrapper<std::vector<pat::TriggerPath> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2750, Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerPath> >::value_type"))
  .AddTypedef(type_2750, Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerPath> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18031, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2531), Reflex::Literal("Wrapper"), constructor_18032, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18033, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29268), Reflex::Literal("Wrapper"), constructor_18038, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4137, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__TriggerPath_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__TriggerPath_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > -------------------
void __edm__Wrapper_std__vector_pat__TriggerPath_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__TriggerPath_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2750, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__TriggerPath_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > -------------------
void __edm__Wrapper_std__vector_pat__TriggerPath_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29222), Reflex::Literal("product"), method_18034, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29222), Reflex::Literal("operator->"), operator_18035, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_18036, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_18037, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29269), Reflex::Literal("getInterface"), method_18039, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_18040, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_18041, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_18042, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_18043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_18044, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_18045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > -------------------------------
static void constructor_18073( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerFilter> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerFilter> >();
}

static void constructor_18074( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerFilter> >(*(::std::auto_ptr<std::vector<pat::TriggerFilter> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerFilter> >(*(::std::auto_ptr<std::vector<pat::TriggerFilter> >*)arg[0]);
}

static void destructor_18075(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->::edm::Wrapper<std::vector<pat::TriggerFilter> >::~Wrapper)();
}
static  void method_18076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->product)();
}

static  void operator_18077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->operator->)();
}

static  void method_18078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->productTypeInfo)();
}

static  void method_18079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->typeInfo)();
}

static void constructor_18080( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerFilter> >((::std::vector<pat::TriggerFilter>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerFilter> >((::std::vector<pat::TriggerFilter>*)arg[0]);
}

static  void method_18081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->getInterface)();
}

static  void method_18082( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18083( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18084( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->dynamicTypeInfo)();
}

static  void method_18086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->isPresent)();
}

static  void method_18087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerFilter> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4139( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerFilter> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerFilter> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerFilter> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerFilter> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerFilter> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > -------------------------------
void __edm__Wrapper_std__vector_pat__TriggerFilter_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__TriggerFilter_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__TriggerFilter_s__datamem_bld(&__edm__Wrapper_std__vector_pat__TriggerFilter_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__TriggerFilter_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__TriggerFilter_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__TriggerFilter_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerFilter> >"), typeid(::edm::Wrapper<std::vector<pat::TriggerFilter> >), sizeof(::edm::Wrapper<std::vector<pat::TriggerFilter> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2748, Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerFilter> >::value_type"))
  .AddTypedef(type_2748, Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerFilter> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18073, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2534), Reflex::Literal("Wrapper"), constructor_18074, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18075, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29277), Reflex::Literal("Wrapper"), constructor_18080, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4139, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__TriggerFilter_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__TriggerFilter_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > -------------------
void __edm__Wrapper_std__vector_pat__TriggerFilter_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__TriggerFilter_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2748, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__TriggerFilter_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > -------------------
void __edm__Wrapper_std__vector_pat__TriggerFilter_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29226), Reflex::Literal("product"), method_18076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29226), Reflex::Literal("operator->"), operator_18077, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_18078, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_18079, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29278), Reflex::Literal("getInterface"), method_18081, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_18082, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_18083, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_18084, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_18085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_18086, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_18087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Association<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------------------
static void destructor_19044(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->::edm::Association<std::vector<pat::TriggerObjectStandAlone> >::~Association)();
}
static void constructor_19045( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >(*(const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
  else ::new(mem) ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >(*(const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static void constructor_19046( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >();
  else ::new(mem) ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >();
}

static  void method_19047( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >)((((const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->get)(*(::size_t*)arg[0]));
  else   (((const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_19048( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >)((((const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_19049( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->operator+=)(*(const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
  else   (((::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->operator+=)(*(const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void method_19050( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->setRef)(*(const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void method_19051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_19052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->size)());
  else   (((const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->size)();
}

static  void method_19053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->empty)());
  else   (((const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->empty)();
}

static  void method_19054( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->clear)();
}

static  void method_19055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >)((((const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->ref)());
  else   (((const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->ref)();
}

static  void method_19056( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->swap)(*(::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void operator_19057( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->operator=)(*(const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
  else   (((::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->operator=)(*(const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void method_19058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->ids)();
  else   (((const ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->ids)();
}

static  void method_19059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->Class_Version)());
  else   (((::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)o)->Class_Version)();
}

static void method_newdel_4337( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<pat::TriggerObjectStandAlone> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<pat::TriggerObjectStandAlone> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<pat::TriggerObjectStandAlone> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<pat::TriggerObjectStandAlone> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<pat::TriggerObjectStandAlone> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x46( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<int>")), ::Reflex::BaseOffset< ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >,::edm::ValueMap<int> >::Get(),::Reflex::PRIVATE), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Association<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------------------
void __edm__Association_std__vector_pat__TriggerObjectStandAlone_s__db_datamem(Reflex::Class*);
void __edm__Association_std__vector_pat__TriggerObjectStandAlone_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Association_std__vector_pat__TriggerObjectStandAlone_s__datamem_bld(&__edm__Association_std__vector_pat__TriggerObjectStandAlone_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Association_std__vector_pat__TriggerObjectStandAlone_s__funcmem_bld(&__edm__Association_std__vector_pat__TriggerObjectStandAlone_s__db_funcmem);
void __edm__Association_std__vector_pat__TriggerObjectStandAlone_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Association<std::vector<pat::TriggerObjectStandAlone> >"), typeid(::edm::Association<std::vector<pat::TriggerObjectStandAlone> >), sizeof(::edm::Association<std::vector<pat::TriggerObjectStandAlone> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >::Class_Version())
  .AddBase(type_4152, ::Reflex::BaseOffset< ::edm::Association<std::vector<pat::TriggerObjectStandAlone> >, ::edm::ValueMap<int> >::Get(), ::Reflex::PRIVATE)
  .AddTypedef(type_71, Reflex::Literal("edm::Association<std::vector<pat::TriggerObjectStandAlone> >::index"))
  .AddTypedef(type_4152, Reflex::Literal("edm::Association<std::vector<pat::TriggerObjectStandAlone> >::base"))
  .AddTypedef(type_289, Reflex::Literal("edm::Association<std::vector<pat::TriggerObjectStandAlone> >::offset"))
  .AddTypedef(type_4302, Reflex::Literal("edm::Association<std::vector<pat::TriggerObjectStandAlone> >::refprod_type"))
  .AddTypedef(type_4346, Reflex::Literal("edm::Association<std::vector<pat::TriggerObjectStandAlone> >::reference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Association"), destructor_19044, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29571), Reflex::Literal("Association"), constructor_19045, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Association"), constructor_19046, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4337, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x46, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Association_std__vector_pat__TriggerObjectStandAlone_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Association_std__vector_pat__TriggerObjectStandAlone_s__funcmem_bld);
}

//------Delayed data member builder for class Association<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------
void __edm__Association_std__vector_pat__TriggerObjectStandAlone_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4302, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__Association_std__vector_pat__TriggerObjectStandAlone_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Association<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------
void __edm__Association_std__vector_pat__TriggerObjectStandAlone_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4346, type_1924), Reflex::Literal("get"), method_19047, 0, "rawIdx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4346, type_4341, type_1924), Reflex::Literal("get"), method_19048, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29572, type_29571), Reflex::Literal("operator+="), operator_19049, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29530), Reflex::Literal("setRef"), method_19050, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_4341), Reflex::Literal("contains"), method_19051, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1924), Reflex::Literal("size"), method_19052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_19053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_19054, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4302), Reflex::Literal("ref"), method_19055, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29572), Reflex::Literal("swap"), method_19056, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29572, type_29571), Reflex::Literal("operator="), operator_19057, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26470), Reflex::Literal("ids"), method_19058, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_19059, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > > -------------------------------
static void constructor_18094( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >();
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >();
}

static void constructor_18095( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >(*(::std::auto_ptr<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >(*(::std::auto_ptr<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)arg[0]);
}

static void destructor_18096(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >::~Wrapper)();
}
static  void method_18097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->product)();
}

static  void operator_18098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->operator->)();
}

static  void method_18099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->productTypeInfo)();
}

static  void method_18100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->typeInfo)();
}

static void constructor_18101( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >((::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >((::edm::Association<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void method_18102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->getInterface)();
}

static  void method_18103( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18104( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18105( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->dynamicTypeInfo)();
}

static  void method_18107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->isPresent)();
}

static  void method_18108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4140( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > > -------------------------------
void __edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s__datamem_bld(&__edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s__funcmem_bld(&__edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s__db_funcmem);
void __edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >"), typeid(::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >), sizeof(::edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4337, Reflex::Literal("edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >::value_type"))
  .AddTypedef(type_4337, Reflex::Literal("edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18094, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2535), Reflex::Literal("Wrapper"), constructor_18095, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18096, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29282), Reflex::Literal("Wrapper"), constructor_18101, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4140, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > > -------------------
void __edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4337, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > > -------------------
void __edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29281), Reflex::Literal("product"), method_18097, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29281), Reflex::Literal("operator->"), operator_18098, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_18099, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_18100, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29283), Reflex::Literal("getInterface"), method_18102, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_18103, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_18104, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_18105, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_18106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_18107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_18108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------------------
static void constructor_18136( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >();
}

static void constructor_18137( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >(*(::std::auto_ptr<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >(*(::std::auto_ptr<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static void destructor_18138(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >::~Wrapper)();
}
static  void method_18139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->product)();
}

static  void operator_18140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->operator->)();
}

static  void method_18141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->productTypeInfo)();
}

static  void method_18142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->typeInfo)();
}

static void constructor_18143( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >((::std::vector<pat::TriggerObjectStandAlone>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >((::std::vector<pat::TriggerObjectStandAlone>*)arg[0]);
}

static  void method_18144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->getInterface)();
}

static  void method_18145( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18146( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18147( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->dynamicTypeInfo)();
}

static  void method_18149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->isPresent)();
}

static  void method_18150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4142( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------------------
void __edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s__datamem_bld(&__edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >"), typeid(::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >), sizeof(::edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2749, Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >::value_type"))
  .AddTypedef(type_2749, Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18136, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2541), Reflex::Literal("Wrapper"), constructor_18137, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18138, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29291), Reflex::Literal("Wrapper"), constructor_18143, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4142, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------
void __edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2749, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------
void __edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29230), Reflex::Literal("product"), method_18139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29230), Reflex::Literal("operator->"), operator_18140, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_18141, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_18142, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29292), Reflex::Literal("getInterface"), method_18144, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_18145, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_18146, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_18147, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_18148, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_18149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_18150, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > > > > -------------------------------
static void constructor_18157( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >();
  else ::new(mem) ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >();
}

static void constructor_18158( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >(*(::std::auto_ptr<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >(*(::std::auto_ptr<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0]);
}

static void destructor_18159(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::~Wrapper)();
}
static  void method_18160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->product)();
}

static  void operator_18161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator->)();
}

static  void method_18162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->productTypeInfo)();
}

static  void method_18163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->typeInfo)();
}

static void constructor_18164( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >((::std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >*)arg[0]);
}

static  void method_18165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->getInterface)();
}

static  void method_18166( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18167( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18168( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->dynamicTypeInfo)();
}

static  void method_18170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->isPresent)();
}

static  void method_18171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4143( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > > > > -------------------------------
void __edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__datamem_bld(&__edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__funcmem_bld(&__edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__db_funcmem);
void __edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >"), typeid(::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >), sizeof(::edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2868, Reflex::Literal("edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::value_type"))
  .AddTypedef(type_2868, Reflex::Literal("edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18157, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2542), Reflex::Literal("Wrapper"), constructor_18158, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18159, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29296), Reflex::Literal("Wrapper"), constructor_18164, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4143, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > > > > -------------------
void __edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2868, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > > > > -------------------
void __edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29295), Reflex::Literal("product"), method_18160, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29295), Reflex::Literal("operator->"), operator_18161, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_18162, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_18163, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29297), Reflex::Literal("getInterface"), method_18165, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_18166, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_18167, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_18168, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_18169, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_18170, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_18171, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > -------------------------------
static void constructor_18178( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >();
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >();
}

static void constructor_18179( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >(*(::std::auto_ptr<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >(*(::std::auto_ptr<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0]);
}

static void destructor_18180(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >::~Wrapper)();
}
static  void method_18181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->product)();
}

static  void operator_18182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->operator->)();
}

static  void method_18183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->productTypeInfo)();
}

static  void method_18184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->typeInfo)();
}

static void constructor_18185( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >((::edm::Association<std::vector<pat::TriggerObject> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >((::edm::Association<std::vector<pat::TriggerObject> >*)arg[0]);
}

static  void method_18186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->getInterface)();
}

static  void method_18187( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18188( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18189( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->dynamicTypeInfo)();
}

static  void method_18191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->isPresent)();
}

static  void method_18192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4144( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > -------------------------------
void __edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s__datamem_bld(&__edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s__funcmem_bld(&__edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s__db_funcmem);
void __edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >"), typeid(::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >), sizeof(::edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4338, Reflex::Literal("edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >::value_type"))
  .AddTypedef(type_4338, Reflex::Literal("edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18178, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2543), Reflex::Literal("Wrapper"), constructor_18179, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18180, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29301), Reflex::Literal("Wrapper"), constructor_18185, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4144, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > -------------------
void __edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4338, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > -------------------
void __edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29300), Reflex::Literal("product"), method_18181, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29300), Reflex::Literal("operator->"), operator_18182, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_18183, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_18184, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29302), Reflex::Literal("getInterface"), method_18186, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_18187, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_18188, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_18189, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_18190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_18191, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_18192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------------------
static void constructor_18220( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerObject> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerObject> >();
}

static void constructor_18221( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerObject> >(*(::std::auto_ptr<std::vector<pat::TriggerObject> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerObject> >(*(::std::auto_ptr<std::vector<pat::TriggerObject> >*)arg[0]);
}

static void destructor_18222(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->::edm::Wrapper<std::vector<pat::TriggerObject> >::~Wrapper)();
}
static  void method_18223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->product)();
}

static  void operator_18224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->operator->)();
}

static  void method_18225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->productTypeInfo)();
}

static  void method_18226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->typeInfo)();
}

static void constructor_18227( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerObject> >((::std::vector<pat::TriggerObject>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::TriggerObject> >((::std::vector<pat::TriggerObject>*)arg[0]);
}

static  void method_18228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->getInterface)();
}

static  void method_18229( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18230( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18231( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->dynamicTypeInfo)();
}

static  void method_18233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->isPresent)();
}

static  void method_18234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::TriggerObject> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4146( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::TriggerObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------------------
void __edm__Wrapper_std__vector_pat__TriggerObject_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__TriggerObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__TriggerObject_s__datamem_bld(&__edm__Wrapper_std__vector_pat__TriggerObject_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__TriggerObject_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__TriggerObject_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__TriggerObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerObject> >"), typeid(::edm::Wrapper<std::vector<pat::TriggerObject> >), sizeof(::edm::Wrapper<std::vector<pat::TriggerObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2747, Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerObject> >::value_type"))
  .AddTypedef(type_2747, Reflex::Literal("edm::Wrapper<std::vector<pat::TriggerObject> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18220, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2546), Reflex::Literal("Wrapper"), constructor_18221, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18222, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29310), Reflex::Literal("Wrapper"), constructor_18227, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4146, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__TriggerObject_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__TriggerObject_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------
void __edm__Wrapper_std__vector_pat__TriggerObject_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__TriggerObject_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2747, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__TriggerObject_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------
void __edm__Wrapper_std__vector_pat__TriggerObject_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29233), Reflex::Literal("product"), method_18223, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29233), Reflex::Literal("operator->"), operator_18224, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_18225, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_18226, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29311), Reflex::Literal("getInterface"), method_18228, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_18229, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_18230, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_18231, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_18232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_18233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_18234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > -------------------------------
static  void operator_18790( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->operator=)(*(const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0]);
  else   (((::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->operator=)(*(const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0]);
}

static void constructor_18791( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >(*(const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >(*(const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0]);
}

static void constructor_18792( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >();
  else ::new(mem) ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >();
}

static void constructor_18793( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >(*(const ::edm::Handle<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >(*(const ::edm::Handle<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0]);
}

static void constructor_18794( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >(*(const ::edm::OrphanHandle<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >(*(const ::edm::OrphanHandle<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0]);
}

static void constructor_18795( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >((const ::edm::Association<std::vector<pat::TriggerObject> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >((const ::edm::Association<std::vector<pat::TriggerObject> >*)arg[0]);
}

static void constructor_18796( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >(*(const ::edm::TestHandle<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >(*(const ::edm::TestHandle<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0]);
}

static void constructor_18797( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_18798(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >::~RefProd)();
}
static  void operator_18799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->operator*)();
  else   (((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->operator*)();
}

static  void operator_18800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->operator->)());
  else   (((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->operator->)();
}

static  void method_18801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->get)());
  else   (((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->get)();
}

static  void method_18802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->product)());
  else   (((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->product)();
}

static  void method_18803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->refCore)();
  else   (((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->refCore)();
}

static  void method_18804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->isNull)());
  else   (((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->isNull)();
}

static  void method_18805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->isNonnull)();
}

static  void operator_18806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->operator!)());
  else   (((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->operator!)();
}

static  void method_18807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->id)());
  else   (((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->id)();
}

static  void method_18808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->productGetter)());
  else   (((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->productGetter)();
}

static  void method_18809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->hasCache)());
  else   (((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->hasCache)();
}

static  void method_18810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->hasProductCache)();
}

static  void method_18811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->isAvailable)();
}

static  void method_18812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->isTransient)());
  else   (((const ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->isTransient)();
}

static  void method_18813( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->swap)(*(::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)arg[0]);
}

static  void method_18814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->Class_Version)());
  else   (((::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >*)o)->Class_Version)();
}

static void method_newdel_4304( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > -------------------------------
void __edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s__db_datamem(Reflex::Class*);
void __edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s__datamem_bld(&__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s__funcmem_bld(&__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s__db_funcmem);
void __edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >"), typeid(::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >), sizeof(::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >::Class_Version())
  .AddTypedef(type_4338, Reflex::Literal("edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >::product_type"))
  .AddTypedef(type_4338, Reflex::Literal("edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26607, type_26448), Reflex::Literal("operator="), operator_18790, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26448), Reflex::Literal("RefProd"), constructor_18791, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_18792, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29537), Reflex::Literal("RefProd"), constructor_18793, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29471), Reflex::Literal("RefProd"), constructor_18794, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29300), Reflex::Literal("RefProd"), constructor_18795, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29443), Reflex::Literal("RefProd"), constructor_18796, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_19013), Reflex::Literal("RefProd"), constructor_18797, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_18798, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4304, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > -------------------
void __edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4286, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > -------------------
void __edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29444), Reflex::Literal("operator*"), operator_18799, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29300), Reflex::Literal("operator->"), operator_18800, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29300), Reflex::Literal("get"), method_18801, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29300), Reflex::Literal("product"), method_18802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17508), Reflex::Literal("refCore"), method_18803, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_18804, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_18805, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_18806, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_18807, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_18808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasCache"), method_18809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_18810, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_18811, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_18812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_26607), Reflex::Literal("swap"), method_18813, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_18814, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> > -------------------------------
static  void operator_19332( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static void constructor_19333( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static void constructor_19334( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >();
}

static void constructor_19335( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::Handle<std::vector<pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::Handle<std::vector<pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::Handle<std::vector<pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::Handle<std::vector<pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19336( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19337( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19338( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >((const ::std::vector<pat::TriggerPath>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >((const ::std::vector<pat::TriggerPath>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >((const ::std::vector<pat::TriggerPath>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >((const ::std::vector<pat::TriggerPath>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19339( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::TestHandle<std::vector<pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::TestHandle<std::vector<pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::TestHandle<std::vector<pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::TestHandle<std::vector<pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19340( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_19341( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::TriggerPath*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::TriggerPath>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::TriggerPath*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::TriggerPath>*)arg[3]);
}

static void constructor_19342( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_19343( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::RefProd<std::vector<pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::RefProd<std::vector<pat::TriggerPath> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_19344(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::~Ref)();
}
static  void operator_19345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator*)();
}

static  void operator_19346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator->)();
}

static  void method_19347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->get)();
}

static  void method_19348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isNull)();
}

static  void method_19349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isNonnull)();
}

static  void operator_19350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator!)();
}

static  void method_19351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->id)();
}

static  void method_19352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->productGetter)();
}

static  void method_19353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->product)();
}

static  void method_19354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->key)();
}

static  void method_19355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->index)();
}

static  void method_19356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->hasProductCache)();
}

static  void method_19357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isAvailable)();
}

static  void method_19358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isTransient)();
}

static  void method_19359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->refCore)();
}

static  void method_19360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->Class_Version)();
}

static void constructor_19361( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_4347( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> > -------------------------------
void __edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__datamem_bld(&__edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__funcmem_bld(&__edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_funcmem);
void __edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >"), typeid(::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >), sizeof(::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::Class_Version())
  .AddTypedef(type_7348, Reflex::Literal("edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::T"))
  .AddTypedef(type_15828, Reflex::Literal("edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::F"))
  .AddTypedef(type_17534, Reflex::Literal("edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::VF"))
  .AddTypedef(type_17533, Reflex::Literal("edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::VBF"))
  .AddTypedef(type_2750, Reflex::Literal("edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::product_type"))
  .AddTypedef(type_7348, Reflex::Literal("edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::value_type"))
  .AddTypedef(type_7348c, Reflex::Literal("edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::element_type"))
  .AddTypedef(type_15828, Reflex::Literal("edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::finder_type"))
  .AddTypedef(type_289, Reflex::Literal("edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::argument_type"))
  .AddTypedef(type_289, Reflex::Literal("edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10405, type_29221), Reflex::Literal("operator="), operator_19332, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29221), Reflex::Literal("Ref"), constructor_19333, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_19334, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29543, type_289, type_1454), Reflex::Literal("Ref"), constructor_19335, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29477, type_289, type_1454), Reflex::Literal("Ref"), constructor_19336, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29220, type_289, type_1454), Reflex::Literal("Ref"), constructor_19337, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29222, type_289, type_1454), Reflex::Literal("Ref"), constructor_19338, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29450, type_289, type_1454), Reflex::Literal("Ref"), constructor_19339, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_289, type_19013), Reflex::Literal("Ref"), constructor_19340, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_8889, type_289, type_29222), Reflex::Literal("Ref"), constructor_19341, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634), Reflex::Literal("Ref"), constructor_19342, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29542, type_289), Reflex::Literal("Ref"), constructor_19343, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_19344, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17508, type_8924), Reflex::Literal("Ref"), constructor_19361, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4347, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> > -------------------
void __edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4367, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> > -------------------
void __edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8891), Reflex::Literal("operator*"), operator_19345, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8889), Reflex::Literal("operator->"), operator_19346, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8889), Reflex::Literal("get"), method_19347, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_19348, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_19349, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_19350, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_19351, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_19352, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29222), Reflex::Literal("product"), method_19353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("key"), method_19354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("index"), method_19355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_19356, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_19357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_19358, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17508), Reflex::Literal("refCore"), method_19359, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_19360, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > -------------------------------
static void destructor_17809(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::~RefVector)();
}
static void constructor_17810( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >();
}

static void constructor_17811( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static void constructor_17812( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_17813( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void operator_17814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >)((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_17815( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >)((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->refVector)();
}

static  void method_17817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->empty)();
}

static  void method_17818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->size)();
}

static  void method_17819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->capacity)();
}

static  void method_17820( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_17821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >)((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->begin)();
}

static  void method_17822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >)((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->end)();
}

static  void method_17823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->id)();
}

static  void method_17824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->productGetter)();
}

static  void method_17825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isNull)();
}

static  void method_17826( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isNonnull)();
}

static  void operator_17827( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator!)();
}

static  void method_17828( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->product)();
}

static  void method_17829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isAvailable)();
}

static  void method_17830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isTransient)();
}

static  void method_17831( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >)((((::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void method_17832( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->clear)();
}

static  void method_17833( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void operator_17834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void method_17835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->hasProductCache)();
}

static  void method_17836( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_17837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->Class_Version)();
}

static void method_newdel_4056( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > -------------------------------
void __edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__datamem_bld(&__edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__funcmem_bld(&__edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_funcmem);
void __edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >"), typeid(::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >), sizeof(::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::Class_Version())
  .AddTypedef(type_2749, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::collection_type"))
  .AddTypedef(type_7344, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::member_type"))
  .AddTypedef(type_15864, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::finder_type"))
  .AddTypedef(type_4019, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::iterator"))
  .AddTypedef(type_4019, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::const_iterator"))
  .AddTypedef(type_4346, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::value_type"))
  .AddTypedef(type_4346c, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::const_reference"))
  .AddTypedef(type_4346c, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::reference"))
  .AddTypedef(type_289, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::key_type"))
  .AddTypedef(type_2753, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::KeyVec"))
  .AddTypedef(type_2926, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::size_type"))
  .AddTypedef(type_4296, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_17809, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_17810, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29228), Reflex::Literal("RefVector"), constructor_17811, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634), Reflex::Literal("RefVector"), constructor_17812, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4056, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > -------------------
void __edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4296, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > -------------------
void __edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29229), Reflex::Literal("push_back"), method_17813, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4346c, type_2926), Reflex::Literal("operator[]"), operator_17814, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4346c, type_2926), Reflex::Literal("at"), method_17815, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29212), Reflex::Literal("refVector"), method_17816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_17817, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("size"), method_17818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("capacity"), method_17819, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926), Reflex::Literal("reserve"), method_17820, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4019), Reflex::Literal("begin"), method_17821, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4019), Reflex::Literal("end"), method_17822, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_17823, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_17824, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_17825, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_17826, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_17827, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29230), Reflex::Literal("product"), method_17828, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_17829, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_17830, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4019, type_28980), Reflex::Literal("erase"), method_17831, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_17832, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29231), Reflex::Literal("swap"), method_17833, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29231, type_29228), Reflex::Literal("operator="), operator_17834, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_17835, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_29215), Reflex::Literal("fillView"), method_17836, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_17837, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> > -------------------------------
static  void operator_19248( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static void constructor_19249( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static void constructor_19250( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >();
}

static void constructor_19251( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::Handle<std::vector<pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::Handle<std::vector<pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::Handle<std::vector<pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::Handle<std::vector<pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19252( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19253( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19254( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >((const ::std::vector<pat::TriggerFilter>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >((const ::std::vector<pat::TriggerFilter>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >((const ::std::vector<pat::TriggerFilter>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >((const ::std::vector<pat::TriggerFilter>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19255( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::TestHandle<std::vector<pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::TestHandle<std::vector<pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::TestHandle<std::vector<pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::TestHandle<std::vector<pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19256( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_19257( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::TriggerFilter*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::TriggerFilter>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::TriggerFilter*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::TriggerFilter>*)arg[3]);
}

static void constructor_19258( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_19259( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_19260(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::~Ref)();
}
static  void operator_19261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator*)();
}

static  void operator_19262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator->)();
}

static  void method_19263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->get)();
}

static  void method_19264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isNull)();
}

static  void method_19265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isNonnull)();
}

static  void operator_19266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator!)();
}

static  void method_19267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->id)();
}

static  void method_19268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->productGetter)();
}

static  void method_19269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->product)();
}

static  void method_19270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->key)();
}

static  void method_19271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->index)();
}

static  void method_19272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->hasProductCache)();
}

static  void method_19273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isAvailable)();
}

static  void method_19274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isTransient)();
}

static  void method_19275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->refCore)();
}

static  void method_19276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->Class_Version)();
}

static void constructor_19277( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_4345( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> > -------------------------------
void __edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__datamem_bld(&__edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__funcmem_bld(&__edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_funcmem);
void __edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >"), typeid(::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >), sizeof(::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::Class_Version())
  .AddTypedef(type_7359, Reflex::Literal("edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::T"))
  .AddTypedef(type_15816, Reflex::Literal("edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::F"))
  .AddTypedef(type_17532, Reflex::Literal("edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::VF"))
  .AddTypedef(type_17531, Reflex::Literal("edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::VBF"))
  .AddTypedef(type_2748, Reflex::Literal("edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::product_type"))
  .AddTypedef(type_7359, Reflex::Literal("edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::value_type"))
  .AddTypedef(type_7359c, Reflex::Literal("edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::element_type"))
  .AddTypedef(type_15816, Reflex::Literal("edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::finder_type"))
  .AddTypedef(type_289, Reflex::Literal("edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::argument_type"))
  .AddTypedef(type_289, Reflex::Literal("edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10383, type_29225), Reflex::Literal("operator="), operator_19248, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29225), Reflex::Literal("Ref"), constructor_19249, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_19250, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29540, type_289, type_1454), Reflex::Literal("Ref"), constructor_19251, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29475, type_289, type_1454), Reflex::Literal("Ref"), constructor_19252, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29224, type_289, type_1454), Reflex::Literal("Ref"), constructor_19253, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29226, type_289, type_1454), Reflex::Literal("Ref"), constructor_19254, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29448, type_289, type_1454), Reflex::Literal("Ref"), constructor_19255, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_289, type_19013), Reflex::Literal("Ref"), constructor_19256, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_8900, type_289, type_29226), Reflex::Literal("Ref"), constructor_19257, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634), Reflex::Literal("Ref"), constructor_19258, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29539, type_289), Reflex::Literal("Ref"), constructor_19259, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_19260, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17508, type_8924), Reflex::Literal("Ref"), constructor_19277, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4345, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> > -------------------
void __edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4367, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> > -------------------
void __edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8902), Reflex::Literal("operator*"), operator_19261, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8900), Reflex::Literal("operator->"), operator_19262, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8900), Reflex::Literal("get"), method_19263, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_19264, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_19265, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_19266, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_19267, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_19268, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29226), Reflex::Literal("product"), method_19269, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("key"), method_19270, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("index"), method_19271, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_19272, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_19273, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_19274, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17508), Reflex::Literal("refCore"), method_19275, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_19276, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVectorIterator<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> > -------------------------------
static void destructor_17335(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::~RefVectorIterator)();
}
static  void operator_17336( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static void constructor_17337( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static void constructor_17338( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >();
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >();
}

static void constructor_17339( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::RefCore*)arg[0],
      *(const ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >*)arg[1]);
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::RefCore*)arg[0],
      *(const ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >*)arg[1]);
}

static  void operator_17340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator*)());
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator*)();
}

static  void operator_17341( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator->)());
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator->)();
}

static  void operator_17343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator++)();
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator++)();
}

static  void operator_17344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator--)();
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator--)();
}

static  void operator_17345( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17346( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17347( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >)((((::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_17348( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >)((((::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_17349( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17350( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17351( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::ptrdiff_t)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator-)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator-)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static  void operator_17352( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator==)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator==)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static  void operator_17353( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator!=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator!=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static  void operator_17354( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator<)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator<)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static  void operator_17355( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator>)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator>)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static  void operator_17356( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator<=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator<=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static  void operator_17357( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator>=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator>=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static void method_newdel_4017( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x57( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&>")), ::Reflex::BaseOffset< ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefVectorIterator<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> > -------------------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_datamem(Reflex::Class*);
void __edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__datamem_bld(&__edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__funcmem_bld(&__edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_funcmem);
void __edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >"), typeid(::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >), sizeof(::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2646, ::Reflex::BaseOffset< ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >, ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4347, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::value_type"))
  .AddTypedef(type_4347c, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::const_reference"))
  .AddTypedef(type_4347c, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::reference"))
  .AddTypedef(type_289, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::key_type"))
  .AddTypedef(type_2844, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::difference"))
  .AddTypedef(type_6578, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::keyIter"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVectorIterator"), destructor_17335, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28973, type_28974), Reflex::Literal("operator="), operator_17336, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28974), Reflex::Literal("RefVectorIterator"), constructor_17337, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVectorIterator"), constructor_17338, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17508, type_28968), Reflex::Literal("RefVectorIterator"), constructor_17339, 0, "product;it", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4017, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x57, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__funcmem_bld);
}

//------Delayed data member builder for class RefVectorIterator<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> > -------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4286, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_, product_), ::Reflex::PRIVATE)
  .AddDataMember(type_6578, Reflex::Literal("iter_"), OffsetOf(__shadow__::__edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_, iter_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVectorIterator<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> > -------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4347c), Reflex::Literal("operator*"), operator_17340, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4347c, type_2844), Reflex::Literal("operator[]"), operator_17341, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2529), Reflex::Literal("operator->"), operator_17342, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28973), Reflex::Literal("operator++"), operator_17343, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28973), Reflex::Literal("operator--"), operator_17344, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28973, type_2844), Reflex::Literal("operator+="), operator_17345, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28973, type_2844), Reflex::Literal("operator-="), operator_17346, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4017, type_71), Reflex::Literal("operator++"), operator_17347, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4017, type_71), Reflex::Literal("operator--"), operator_17348, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4017, type_2844), Reflex::Literal("operator+"), operator_17349, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4017, type_2844), Reflex::Literal("operator-"), operator_17350, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2844, type_28974), Reflex::Literal("operator-"), operator_17351, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28974), Reflex::Literal("operator=="), operator_17352, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28974), Reflex::Literal("operator!="), operator_17353, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28974), Reflex::Literal("operator<"), operator_17354, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28974), Reflex::Literal("operator>"), operator_17355, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28974), Reflex::Literal("operator<="), operator_17356, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28974), Reflex::Literal("operator>="), operator_17357, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class RefVectorIterator<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> > -------------------------------
static void destructor_17273(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::~RefVectorIterator)();
}
static  void operator_17274( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static void constructor_17275( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static void constructor_17276( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >();
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >();
}

static void constructor_17277( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::RefCore*)arg[0],
      *(const ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >*)arg[1]);
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::RefCore*)arg[0],
      *(const ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >*)arg[1]);
}

static  void operator_17278( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator*)());
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator*)();
}

static  void operator_17279( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator->)());
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator->)();
}

static  void operator_17281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator++)();
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator++)();
}

static  void operator_17282( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator--)();
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator--)();
}

static  void operator_17283( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17285( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >)((((::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_17286( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >)((((::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_17287( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17288( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17289( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::ptrdiff_t)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator-)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator-)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static  void operator_17290( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator==)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator==)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static  void operator_17291( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator!=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator!=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static  void operator_17292( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator<)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator<)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static  void operator_17293( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator>)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator>)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static  void operator_17294( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator<=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator<=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static  void operator_17295( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator>=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator>=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static void method_newdel_4015( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x59( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&>")), ::Reflex::BaseOffset< ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefVectorIterator<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> > -------------------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_datamem(Reflex::Class*);
void __edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__datamem_bld(&__edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__funcmem_bld(&__edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_funcmem);
void __edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >"), typeid(::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >), sizeof(::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2641, ::Reflex::BaseOffset< ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >, ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4342, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::value_type"))
  .AddTypedef(type_4342c, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::const_reference"))
  .AddTypedef(type_4342c, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::reference"))
  .AddTypedef(type_289, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::key_type"))
  .AddTypedef(type_2844, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::difference"))
  .AddTypedef(type_6578, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::keyIter"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVectorIterator"), destructor_17273, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28966, type_28967), Reflex::Literal("operator="), operator_17274, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28967), Reflex::Literal("RefVectorIterator"), constructor_17275, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVectorIterator"), constructor_17276, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17508, type_28968), Reflex::Literal("RefVectorIterator"), constructor_17277, 0, "product;it", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4015, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x59, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__funcmem_bld);
}

//------Delayed data member builder for class RefVectorIterator<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> > -------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4286, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_, product_), ::Reflex::PRIVATE)
  .AddDataMember(type_6578, Reflex::Literal("iter_"), OffsetOf(__shadow__::__edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_, iter_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVectorIterator<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> > -------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4342c), Reflex::Literal("operator*"), operator_17278, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4342c, type_2844), Reflex::Literal("operator[]"), operator_17279, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2523), Reflex::Literal("operator->"), operator_17280, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28966), Reflex::Literal("operator++"), operator_17281, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28966), Reflex::Literal("operator--"), operator_17282, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28966, type_2844), Reflex::Literal("operator+="), operator_17283, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28966, type_2844), Reflex::Literal("operator-="), operator_17284, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4015, type_71), Reflex::Literal("operator++"), operator_17285, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4015, type_71), Reflex::Literal("operator--"), operator_17286, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4015, type_2844), Reflex::Literal("operator+"), operator_17287, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4015, type_2844), Reflex::Literal("operator-"), operator_17288, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2844, type_28967), Reflex::Literal("operator-"), operator_17289, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28967), Reflex::Literal("operator=="), operator_17290, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28967), Reflex::Literal("operator!="), operator_17291, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28967), Reflex::Literal("operator<"), operator_17292, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28967), Reflex::Literal("operator>"), operator_17293, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28967), Reflex::Literal("operator<="), operator_17294, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28967), Reflex::Literal("operator>="), operator_17295, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class RefProd<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > -------------------------------
static  void operator_18848( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::TriggerPath> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::TriggerPath> >*)arg[0]);
}

static void constructor_18849( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerPath> >(*(const ::edm::RefProd<std::vector<pat::TriggerPath> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerPath> >(*(const ::edm::RefProd<std::vector<pat::TriggerPath> >*)arg[0]);
}

static void constructor_18850( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerPath> >();
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerPath> >();
}

static void constructor_18851( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerPath> >(*(const ::edm::Handle<std::vector<pat::TriggerPath> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerPath> >(*(const ::edm::Handle<std::vector<pat::TriggerPath> >*)arg[0]);
}

static void constructor_18852( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerPath> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerPath> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerPath> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerPath> >*)arg[0]);
}

static void constructor_18853( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerPath> >((const ::std::vector<pat::TriggerPath>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerPath> >((const ::std::vector<pat::TriggerPath>*)arg[0]);
}

static void constructor_18854( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerPath> >(*(const ::edm::TestHandle<std::vector<pat::TriggerPath> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerPath> >(*(const ::edm::TestHandle<std::vector<pat::TriggerPath> >*)arg[0]);
}

static void constructor_18855( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerPath> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerPath> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_18856(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->::edm::RefProd<std::vector<pat::TriggerPath> >::~RefProd)();
}
static  void operator_18857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->operator*)();
}

static  void operator_18858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->operator->)();
}

static  void method_18859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->get)();
}

static  void method_18860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->product)();
}

static  void method_18861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->refCore)();
}

static  void method_18862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->isNull)();
}

static  void method_18863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->isNonnull)();
}

static  void operator_18864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->operator!)();
}

static  void method_18865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->id)();
}

static  void method_18866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->productGetter)();
}

static  void method_18867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->hasCache)();
}

static  void method_18868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->hasProductCache)();
}

static  void method_18869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->isAvailable)();
}

static  void method_18870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->isTransient)();
}

static  void method_18871( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->swap)(*(::edm::RefProd<std::vector<pat::TriggerPath> >*)arg[0]);
}

static  void method_18872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<pat::TriggerPath> >*)o)->Class_Version)();
}

static void method_newdel_4306( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerPath> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerPath> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerPath> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerPath> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerPath> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > -------------------------------
void __edm__RefProd_std__vector_pat__TriggerPath_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_pat__TriggerPath_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__TriggerPath_s__datamem_bld(&__edm__RefProd_std__vector_pat__TriggerPath_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__TriggerPath_s__funcmem_bld(&__edm__RefProd_std__vector_pat__TriggerPath_s__db_funcmem);
void __edm__RefProd_std__vector_pat__TriggerPath_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::TriggerPath> >"), typeid(::edm::RefProd<std::vector<pat::TriggerPath> >), sizeof(::edm::RefProd<std::vector<pat::TriggerPath> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<pat::TriggerPath> >::Class_Version())
  .AddTypedef(type_2750, Reflex::Literal("edm::RefProd<std::vector<pat::TriggerPath> >::product_type"))
  .AddTypedef(type_2750, Reflex::Literal("edm::RefProd<std::vector<pat::TriggerPath> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29541, type_29542), Reflex::Literal("operator="), operator_18848, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29542), Reflex::Literal("RefProd"), constructor_18849, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_18850, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29543), Reflex::Literal("RefProd"), constructor_18851, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29477), Reflex::Literal("RefProd"), constructor_18852, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29222), Reflex::Literal("RefProd"), constructor_18853, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29450), Reflex::Literal("RefProd"), constructor_18854, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_19013), Reflex::Literal("RefProd"), constructor_18855, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_18856, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4306, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_pat__TriggerPath_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_pat__TriggerPath_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > -------------------
void __edm__RefProd_std__vector_pat__TriggerPath_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4286, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_pat__TriggerPath_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > -------------------
void __edm__RefProd_std__vector_pat__TriggerPath_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15833), Reflex::Literal("operator*"), operator_18857, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29222), Reflex::Literal("operator->"), operator_18858, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29222), Reflex::Literal("get"), method_18859, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29222), Reflex::Literal("product"), method_18860, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17508), Reflex::Literal("refCore"), method_18861, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_18862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_18863, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_18864, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_18865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_18866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasCache"), method_18867, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_18868, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_18869, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_18870, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29541), Reflex::Literal("swap"), method_18871, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_18872, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> > -------------------------------
static void destructor_17641(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::~RefVector)();
}
static void constructor_17642( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >();
}

static void constructor_17643( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static void constructor_17644( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_17645( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static  void operator_17646( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >)((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_17647( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >)((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->refVector)();
}

static  void method_17649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->empty)();
}

static  void method_17650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->size)();
}

static  void method_17651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->capacity)();
}

static  void method_17652( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_17653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >)((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->begin)();
}

static  void method_17654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >)((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->end)();
}

static  void method_17655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->id)();
}

static  void method_17656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->productGetter)();
}

static  void method_17657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isNull)();
}

static  void method_17658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isNonnull)();
}

static  void operator_17659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator!)();
}

static  void method_17660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->product)();
}

static  void method_17661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isAvailable)();
}

static  void method_17662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isTransient)();
}

static  void method_17663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >)((((::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static  void method_17664( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->clear)();
}

static  void method_17665( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static  void operator_17666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static  void method_17667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->hasProductCache)();
}

static  void method_17668( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_17669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->Class_Version)();
}

static void method_newdel_4052( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> > -------------------------------
void __edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__datamem_bld(&__edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__funcmem_bld(&__edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_funcmem);
void __edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >"), typeid(::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >), sizeof(::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::Class_Version())
  .AddTypedef(type_2745, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::collection_type"))
  .AddTypedef(type_7368, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::member_type"))
  .AddTypedef(type_15852, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::finder_type"))
  .AddTypedef(type_4015, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::iterator"))
  .AddTypedef(type_4015, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::const_iterator"))
  .AddTypedef(type_4342, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::value_type"))
  .AddTypedef(type_4342c, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::const_reference"))
  .AddTypedef(type_4342c, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::reference"))
  .AddTypedef(type_289, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::key_type"))
  .AddTypedef(type_2753, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::KeyVec"))
  .AddTypedef(type_2926, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::size_type"))
  .AddTypedef(type_4296, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_17641, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_17642, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29210), Reflex::Literal("RefVector"), constructor_17643, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634), Reflex::Literal("RefVector"), constructor_17644, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4052, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> > -------------------
void __edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4296, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> > -------------------
void __edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29211), Reflex::Literal("push_back"), method_17645, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4342c, type_2926), Reflex::Literal("operator[]"), operator_17646, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4342c, type_2926), Reflex::Literal("at"), method_17647, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29212), Reflex::Literal("refVector"), method_17648, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_17649, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("size"), method_17650, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("capacity"), method_17651, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926), Reflex::Literal("reserve"), method_17652, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4015), Reflex::Literal("begin"), method_17653, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4015), Reflex::Literal("end"), method_17654, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_17655, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_17656, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_17657, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_17658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_17659, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29213), Reflex::Literal("product"), method_17660, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_17661, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_17662, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4015, type_28967), Reflex::Literal("erase"), method_17663, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_17664, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29214), Reflex::Literal("swap"), method_17665, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29214, type_29210), Reflex::Literal("operator="), operator_17666, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_17667, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_29215), Reflex::Literal("fillView"), method_17668, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_17669, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > -------------------------------
static  void operator_19206( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static void constructor_19207( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static void constructor_19208( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >();
}

static void constructor_19209( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::Handle<std::vector<pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::Handle<std::vector<pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::Handle<std::vector<pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::Handle<std::vector<pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19210( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19211( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19212( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >((const ::std::vector<pat::TriggerObject>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >((const ::std::vector<pat::TriggerObject>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >((const ::std::vector<pat::TriggerObject>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >((const ::std::vector<pat::TriggerObject>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19213( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::TestHandle<std::vector<pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::TestHandle<std::vector<pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::TestHandle<std::vector<pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::TestHandle<std::vector<pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19214( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_19215( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::TriggerObject*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::TriggerObject>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::TriggerObject*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::TriggerObject>*)arg[3]);
}

static void constructor_19216( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_19217( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::RefProd<std::vector<pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::RefProd<std::vector<pat::TriggerObject> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_19218(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::~Ref)();
}
static  void operator_19219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator*)();
}

static  void operator_19220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator->)();
}

static  void method_19221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->get)();
}

static  void method_19222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isNull)();
}

static  void method_19223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isNonnull)();
}

static  void operator_19224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator!)();
}

static  void method_19225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->id)();
}

static  void method_19226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->productGetter)();
}

static  void method_19227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->product)();
}

static  void method_19228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->key)();
}

static  void method_19229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->index)();
}

static  void method_19230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->hasProductCache)();
}

static  void method_19231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isAvailable)();
}

static  void method_19232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isTransient)();
}

static  void method_19233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->refCore)();
}

static  void method_19234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->Class_Version)();
}

static void constructor_19235( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_4344( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > -------------------------------
void __edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__datamem_bld(&__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__funcmem_bld(&__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_funcmem);
void __edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >"), typeid(::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >), sizeof(::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::Class_Version())
  .AddTypedef(type_7357, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::T"))
  .AddTypedef(type_15876, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::F"))
  .AddTypedef(type_17542, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::VF"))
  .AddTypedef(type_17541, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::VBF"))
  .AddTypedef(type_2747, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::product_type"))
  .AddTypedef(type_7357, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::value_type"))
  .AddTypedef(type_7357c, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::element_type"))
  .AddTypedef(type_15876, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::finder_type"))
  .AddTypedef(type_289, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::argument_type"))
  .AddTypedef(type_289, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10372, type_26451), Reflex::Literal("operator="), operator_19206, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26451), Reflex::Literal("Ref"), constructor_19207, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_19208, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29536, type_289, type_1454), Reflex::Literal("Ref"), constructor_19209, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29473, type_289, type_1454), Reflex::Literal("Ref"), constructor_19210, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29232, type_289, type_1454), Reflex::Literal("Ref"), constructor_19211, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29233, type_289, type_1454), Reflex::Literal("Ref"), constructor_19212, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29446, type_289, type_1454), Reflex::Literal("Ref"), constructor_19213, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_289, type_19013), Reflex::Literal("Ref"), constructor_19214, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_8933, type_289, type_29233), Reflex::Literal("Ref"), constructor_19215, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634), Reflex::Literal("Ref"), constructor_19216, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29535, type_289), Reflex::Literal("Ref"), constructor_19217, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_19218, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17508, type_8924), Reflex::Literal("Ref"), constructor_19235, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4344, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > -------------------
void __edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4367, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > -------------------
void __edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8935), Reflex::Literal("operator*"), operator_19219, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8933), Reflex::Literal("operator->"), operator_19220, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8933), Reflex::Literal("get"), method_19221, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_19222, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_19223, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_19224, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_19225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_19226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29233), Reflex::Literal("product"), method_19227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("key"), method_19228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("index"), method_19229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_19230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_19231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_19232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17508), Reflex::Literal("refCore"), method_19233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_19234, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> > -------------------------------
static  void operator_19164( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static void constructor_19165( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static void constructor_19166( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >();
}

static void constructor_19167( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::Handle<std::vector<pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::Handle<std::vector<pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::Handle<std::vector<pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::Handle<std::vector<pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19168( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19169( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19170( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >((const ::std::vector<pat::TriggerCondition>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >((const ::std::vector<pat::TriggerCondition>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >((const ::std::vector<pat::TriggerCondition>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >((const ::std::vector<pat::TriggerCondition>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19171( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::TestHandle<std::vector<pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::TestHandle<std::vector<pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::TestHandle<std::vector<pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::TestHandle<std::vector<pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19172( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_19173( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::TriggerCondition*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::TriggerCondition>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::TriggerCondition*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::TriggerCondition>*)arg[3]);
}

static void constructor_19174( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_19175( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_19176(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::~Ref)();
}
static  void operator_19177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator*)();
}

static  void operator_19178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator->)();
}

static  void method_19179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->get)();
}

static  void method_19180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isNull)();
}

static  void method_19181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isNonnull)();
}

static  void operator_19182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator!)();
}

static  void method_19183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->id)();
}

static  void method_19184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->productGetter)();
}

static  void method_19185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->product)();
}

static  void method_19186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->key)();
}

static  void method_19187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->index)();
}

static  void method_19188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->hasProductCache)();
}

static  void method_19189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isAvailable)();
}

static  void method_19190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isTransient)();
}

static  void method_19191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->refCore)();
}

static  void method_19192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->Class_Version)();
}

static void constructor_19193( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_4343( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> > -------------------------------
void __edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__datamem_bld(&__edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__funcmem_bld(&__edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_funcmem);
void __edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >"), typeid(::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >), sizeof(::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::Class_Version())
  .AddTypedef(type_7332, Reflex::Literal("edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::T"))
  .AddTypedef(type_15840, Reflex::Literal("edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::F"))
  .AddTypedef(type_17536, Reflex::Literal("edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::VF"))
  .AddTypedef(type_17535, Reflex::Literal("edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::VBF"))
  .AddTypedef(type_2746, Reflex::Literal("edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::product_type"))
  .AddTypedef(type_7332, Reflex::Literal("edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::value_type"))
  .AddTypedef(type_7332c, Reflex::Literal("edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::element_type"))
  .AddTypedef(type_15840, Reflex::Literal("edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::finder_type"))
  .AddTypedef(type_289, Reflex::Literal("edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::argument_type"))
  .AddTypedef(type_289, Reflex::Literal("edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10361, type_29217), Reflex::Literal("operator="), operator_19164, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29217), Reflex::Literal("Ref"), constructor_19165, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_19166, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29546, type_289, type_1454), Reflex::Literal("Ref"), constructor_19167, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29479, type_289, type_1454), Reflex::Literal("Ref"), constructor_19168, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29216, type_289, type_1454), Reflex::Literal("Ref"), constructor_19169, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29218, type_289, type_1454), Reflex::Literal("Ref"), constructor_19170, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29452, type_289, type_1454), Reflex::Literal("Ref"), constructor_19171, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_289, type_19013), Reflex::Literal("Ref"), constructor_19172, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_8867, type_289, type_29218), Reflex::Literal("Ref"), constructor_19173, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634), Reflex::Literal("Ref"), constructor_19174, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29545, type_289), Reflex::Literal("Ref"), constructor_19175, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_19176, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17508, type_8924), Reflex::Literal("Ref"), constructor_19193, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4343, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> > -------------------
void __edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4367, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> > -------------------
void __edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8869), Reflex::Literal("operator*"), operator_19177, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8867), Reflex::Literal("operator->"), operator_19178, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8867), Reflex::Literal("get"), method_19179, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_19180, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_19181, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_19182, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_19183, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_19184, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29218), Reflex::Literal("product"), method_19185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("key"), method_19186, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("index"), method_19187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_19188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_19189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_19190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17508), Reflex::Literal("refCore"), method_19191, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_19192, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------------------
static  void operator_18732( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static void constructor_18733( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >(*(const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >(*(const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static void constructor_18734( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >();
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >();
}

static void constructor_18735( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >(*(const ::edm::Handle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >(*(const ::edm::Handle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static void constructor_18736( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static void constructor_18737( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >((const ::std::vector<pat::TriggerObjectStandAlone>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >((const ::std::vector<pat::TriggerObjectStandAlone>*)arg[0]);
}

static void constructor_18738( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >(*(const ::edm::TestHandle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >(*(const ::edm::TestHandle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static void constructor_18739( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_18740(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >::~RefProd)();
}
static  void operator_18741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->operator*)();
}

static  void operator_18742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->operator->)();
}

static  void method_18743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->get)();
}

static  void method_18744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->product)();
}

static  void method_18745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->refCore)();
}

static  void method_18746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->isNull)();
}

static  void method_18747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->isNonnull)();
}

static  void operator_18748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->operator!)();
}

static  void method_18749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->id)();
}

static  void method_18750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->productGetter)();
}

static  void method_18751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->hasCache)();
}

static  void method_18752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->hasProductCache)();
}

static  void method_18753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->isAvailable)();
}

static  void method_18754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->isTransient)();
}

static  void method_18755( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->swap)(*(::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void method_18756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)o)->Class_Version)();
}

static void method_newdel_4302( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------------------
void __edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s__datamem_bld(&__edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s__funcmem_bld(&__edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s__db_funcmem);
void __edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >"), typeid(::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >), sizeof(::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >::Class_Version())
  .AddTypedef(type_2749, Reflex::Literal("edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >::product_type"))
  .AddTypedef(type_2749, Reflex::Literal("edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29529, type_29530), Reflex::Literal("operator="), operator_18732, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29530), Reflex::Literal("RefProd"), constructor_18733, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_18734, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29531), Reflex::Literal("RefProd"), constructor_18735, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29532), Reflex::Literal("RefProd"), constructor_18736, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29230), Reflex::Literal("RefProd"), constructor_18737, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29533), Reflex::Literal("RefProd"), constructor_18738, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_19013), Reflex::Literal("RefProd"), constructor_18739, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_18740, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4302, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------
void __edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4286, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------
void __edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15869), Reflex::Literal("operator*"), operator_18741, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29230), Reflex::Literal("operator->"), operator_18742, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29230), Reflex::Literal("get"), method_18743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29230), Reflex::Literal("product"), method_18744, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17508), Reflex::Literal("refCore"), method_18745, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_18746, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_18747, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_18748, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_18749, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_18750, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasCache"), method_18751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_18752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_18753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_18754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29529), Reflex::Literal("swap"), method_18755, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_18756, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> > -------------------------------
static  void operator_19122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static void constructor_19123( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0]);
}

static void constructor_19124( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >();
}

static void constructor_19125( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::Handle<std::vector<pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::Handle<std::vector<pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::Handle<std::vector<pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::Handle<std::vector<pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19126( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19127( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19128( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >((const ::std::vector<pat::TriggerAlgorithm>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >((const ::std::vector<pat::TriggerAlgorithm>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >((const ::std::vector<pat::TriggerAlgorithm>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >((const ::std::vector<pat::TriggerAlgorithm>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19129( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::TestHandle<std::vector<pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::TestHandle<std::vector<pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::TestHandle<std::vector<pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::TestHandle<std::vector<pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19130( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_19131( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::TriggerAlgorithm*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::TriggerAlgorithm>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::TriggerAlgorithm*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::TriggerAlgorithm>*)arg[3]);
}

static void constructor_19132( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_19133( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_19134(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::~Ref)();
}
static  void operator_19135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator*)();
}

static  void operator_19136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator->)();
}

static  void method_19137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->get)();
}

static  void method_19138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isNull)();
}

static  void method_19139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isNonnull)();
}

static  void operator_19140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->operator!)();
}

static  void method_19141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->id)();
}

static  void method_19142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->productGetter)();
}

static  void method_19143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->product)();
}

static  void method_19144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->key)();
}

static  void method_19145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->index)();
}

static  void method_19146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->hasProductCache)();
}

static  void method_19147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isAvailable)();
}

static  void method_19148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->isTransient)();
}

static  void method_19149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->refCore)();
}

static  void method_19150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*)o)->Class_Version)();
}

static void constructor_19151( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_4342( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> > -------------------------------
void __edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__datamem_bld(&__edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__funcmem_bld(&__edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_funcmem);
void __edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >"), typeid(::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >), sizeof(::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::Class_Version())
  .AddTypedef(type_7368, Reflex::Literal("edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::T"))
  .AddTypedef(type_15852, Reflex::Literal("edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::F"))
  .AddTypedef(type_17538, Reflex::Literal("edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::VF"))
  .AddTypedef(type_17537, Reflex::Literal("edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::VBF"))
  .AddTypedef(type_2745, Reflex::Literal("edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::product_type"))
  .AddTypedef(type_7368, Reflex::Literal("edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::value_type"))
  .AddTypedef(type_7368c, Reflex::Literal("edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::element_type"))
  .AddTypedef(type_15852, Reflex::Literal("edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::finder_type"))
  .AddTypedef(type_289, Reflex::Literal("edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::argument_type"))
  .AddTypedef(type_289, Reflex::Literal("edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10350, type_29211), Reflex::Literal("operator="), operator_19122, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29211), Reflex::Literal("Ref"), constructor_19123, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_19124, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29549, type_289, type_1454), Reflex::Literal("Ref"), constructor_19125, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29481, type_289, type_1454), Reflex::Literal("Ref"), constructor_19126, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29210, type_289, type_1454), Reflex::Literal("Ref"), constructor_19127, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29213, type_289, type_1454), Reflex::Literal("Ref"), constructor_19128, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29454, type_289, type_1454), Reflex::Literal("Ref"), constructor_19129, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_289, type_19013), Reflex::Literal("Ref"), constructor_19130, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_8856, type_289, type_29213), Reflex::Literal("Ref"), constructor_19131, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634), Reflex::Literal("Ref"), constructor_19132, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29548, type_289), Reflex::Literal("Ref"), constructor_19133, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_19134, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17508, type_8924), Reflex::Literal("Ref"), constructor_19151, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4342, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> > -------------------
void __edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4367, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> >, pat::TriggerAlgorithm> > -------------------
void __edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8858), Reflex::Literal("operator*"), operator_19135, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8856), Reflex::Literal("operator->"), operator_19136, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8856), Reflex::Literal("get"), method_19137, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_19138, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_19139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_19140, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_19141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_19142, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29213), Reflex::Literal("product"), method_19143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("key"), method_19144, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("index"), method_19145, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_19146, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_19147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_19148, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17508), Reflex::Literal("refCore"), method_19149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_19150, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVectorIterator<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> > -------------------------------
static void destructor_17304(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::~RefVectorIterator)();
}
static  void operator_17305( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static void constructor_17306( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static void constructor_17307( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >();
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >();
}

static void constructor_17308( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::RefCore*)arg[0],
      *(const ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >*)arg[1]);
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::RefCore*)arg[0],
      *(const ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >*)arg[1]);
}

static  void operator_17309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator*)());
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator*)();
}

static  void operator_17310( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator->)());
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator->)();
}

static  void operator_17312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator++)();
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator++)();
}

static  void operator_17313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator--)();
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator--)();
}

static  void operator_17314( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17316( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >)((((::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_17317( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >)((((::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_17318( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17319( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17320( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::ptrdiff_t)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator-)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator-)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static  void operator_17321( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator==)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator==)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static  void operator_17322( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator!=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator!=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static  void operator_17323( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator<)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator<)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static  void operator_17324( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator>)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator>)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static  void operator_17325( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator<=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator<=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static  void operator_17326( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator>=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator>=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static void method_newdel_4016( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x67( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&>")), ::Reflex::BaseOffset< ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefVectorIterator<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> > -------------------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_datamem(Reflex::Class*);
void __edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__datamem_bld(&__edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__funcmem_bld(&__edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_funcmem);
void __edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >"), typeid(::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >), sizeof(::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2642, ::Reflex::BaseOffset< ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >, ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4343, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::value_type"))
  .AddTypedef(type_4343c, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::const_reference"))
  .AddTypedef(type_4343c, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::reference"))
  .AddTypedef(type_289, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::key_type"))
  .AddTypedef(type_2844, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::difference"))
  .AddTypedef(type_6578, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::keyIter"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVectorIterator"), destructor_17304, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28970, type_28971), Reflex::Literal("operator="), operator_17305, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28971), Reflex::Literal("RefVectorIterator"), constructor_17306, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVectorIterator"), constructor_17307, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17508, type_28968), Reflex::Literal("RefVectorIterator"), constructor_17308, 0, "product;it", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4016, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x67, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__funcmem_bld);
}

//------Delayed data member builder for class RefVectorIterator<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> > -------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4286, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_, product_), ::Reflex::PRIVATE)
  .AddDataMember(type_6578, Reflex::Literal("iter_"), OffsetOf(__shadow__::__edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_, iter_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVectorIterator<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> > -------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4343c), Reflex::Literal("operator*"), operator_17309, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4343c, type_2844), Reflex::Literal("operator[]"), operator_17310, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2526), Reflex::Literal("operator->"), operator_17311, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28970), Reflex::Literal("operator++"), operator_17312, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28970), Reflex::Literal("operator--"), operator_17313, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28970, type_2844), Reflex::Literal("operator+="), operator_17314, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28970, type_2844), Reflex::Literal("operator-="), operator_17315, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4016, type_71), Reflex::Literal("operator++"), operator_17316, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4016, type_71), Reflex::Literal("operator--"), operator_17317, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4016, type_2844), Reflex::Literal("operator+"), operator_17318, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4016, type_2844), Reflex::Literal("operator-"), operator_17319, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2844, type_28971), Reflex::Literal("operator-"), operator_17320, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28971), Reflex::Literal("operator=="), operator_17321, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28971), Reflex::Literal("operator!="), operator_17322, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28971), Reflex::Literal("operator<"), operator_17323, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28971), Reflex::Literal("operator>"), operator_17324, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28971), Reflex::Literal("operator<="), operator_17325, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28971), Reflex::Literal("operator>="), operator_17326, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class pair<bool,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
static void destructor_10838(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<bool,std::basic_string<char> >*)o)->::std::pair<bool,std::basic_string<char> >::~pair)();
}
static  void operator_10839( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<bool,std::basic_string<char> >*)o)->operator=)(*(const ::std::pair<bool,std::basic_string<char> >*)arg[0]);
  else   (((::std::pair<bool,std::basic_string<char> >*)o)->operator=)(*(const ::std::pair<bool,std::basic_string<char> >*)arg[0]);
}

static void constructor_10840( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<bool,std::basic_string<char> >(*(const ::std::pair<bool,std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::pair<bool,std::basic_string<char> >(*(const ::std::pair<bool,std::basic_string<char> >*)arg[0]);
}

static void constructor_10841( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<bool,std::basic_string<char> >();
  else ::new(mem) ::std::pair<bool,std::basic_string<char> >();
}

static void constructor_10842( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<bool,std::basic_string<char> >(*(const bool*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::std::pair<bool,std::basic_string<char> >(*(const bool*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
}

static void method_newdel_2722( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<bool,std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<bool,std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<bool,std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<bool,std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<bool,std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<bool,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
void __std__pair_bool_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__pair_bool_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_bool_std__basic_string_char_s__datamem_bld(&__std__pair_bool_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_bool_std__basic_string_char_s__funcmem_bld(&__std__pair_bool_std__basic_string_char_s__db_funcmem);
void __std__pair_bool_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<bool,std::basic_string<char> >"), typeid(::std::pair<bool,std::basic_string<char> >), sizeof(::std::pair<bool,std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1454, Reflex::Literal("std::pair<bool,std::basic_string<char> >::first_type"))
  .AddTypedef(type_2328, Reflex::Literal("std::pair<bool,std::basic_string<char> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_10838, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11802, type_8880), Reflex::Literal("operator="), operator_10839, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8880), Reflex::Literal("pair"), constructor_10840, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_10841, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14138, type_8978), Reflex::Literal("pair"), constructor_10842, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2722, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_bool_std__basic_string_char_s__datamem_bld);
}

//------Delayed data member builder for class pair<bool,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_bool_std__basic_string_char_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_bool_std__basic_string_char_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2328, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_bool_std__basic_string_char_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<bool,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_bool_std__basic_string_char_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RefVectorIterator<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> > -------------------------------
static void destructor_17366(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::~RefVectorIterator)();
}
static  void operator_17367( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static void constructor_17368( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static void constructor_17369( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >();
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >();
}

static void constructor_17370( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::RefCore*)arg[0],
      *(const ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >*)arg[1]);
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::RefCore*)arg[0],
      *(const ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >*)arg[1]);
}

static  void operator_17371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator*)());
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator*)();
}

static  void operator_17372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator->)());
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator->)();
}

static  void operator_17374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator++)();
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator++)();
}

static  void operator_17375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator--)();
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator--)();
}

static  void operator_17376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17377( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17378( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >)((((::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_17379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >)((((::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_17380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17381( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17382( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::ptrdiff_t)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator-)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator-)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static  void operator_17383( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator==)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator==)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static  void operator_17384( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator!=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator!=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static  void operator_17385( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator<)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator<)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static  void operator_17386( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator>)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator>)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static  void operator_17387( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator<=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator<=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static  void operator_17388( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator>=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator>=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static void method_newdel_4018( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x70( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&>")), ::Reflex::BaseOffset< ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefVectorIterator<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> > -------------------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_datamem(Reflex::Class*);
void __edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__datamem_bld(&__edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__funcmem_bld(&__edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_funcmem);
void __edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >"), typeid(::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >), sizeof(::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2644, ::Reflex::BaseOffset< ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >, ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4345, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::value_type"))
  .AddTypedef(type_4345c, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::const_reference"))
  .AddTypedef(type_4345c, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::reference"))
  .AddTypedef(type_289, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::key_type"))
  .AddTypedef(type_2844, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::difference"))
  .AddTypedef(type_6578, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::keyIter"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVectorIterator"), destructor_17366, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28976, type_28977), Reflex::Literal("operator="), operator_17367, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28977), Reflex::Literal("RefVectorIterator"), constructor_17368, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVectorIterator"), constructor_17369, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17508, type_28968), Reflex::Literal("RefVectorIterator"), constructor_17370, 0, "product;it", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4018, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x70, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__funcmem_bld);
}

//------Delayed data member builder for class RefVectorIterator<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> > -------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4286, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_, product_), ::Reflex::PRIVATE)
  .AddDataMember(type_6578, Reflex::Literal("iter_"), OffsetOf(__shadow__::__edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_, iter_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVectorIterator<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> > -------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4345c), Reflex::Literal("operator*"), operator_17371, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4345c, type_2844), Reflex::Literal("operator[]"), operator_17372, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2532), Reflex::Literal("operator->"), operator_17373, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28976), Reflex::Literal("operator++"), operator_17374, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28976), Reflex::Literal("operator--"), operator_17375, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28976, type_2844), Reflex::Literal("operator+="), operator_17376, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28976, type_2844), Reflex::Literal("operator-="), operator_17377, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4018, type_71), Reflex::Literal("operator++"), operator_17378, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4018, type_71), Reflex::Literal("operator--"), operator_17379, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4018, type_2844), Reflex::Literal("operator+"), operator_17380, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4018, type_2844), Reflex::Literal("operator-"), operator_17381, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2844, type_28977), Reflex::Literal("operator-"), operator_17382, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28977), Reflex::Literal("operator=="), operator_17383, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28977), Reflex::Literal("operator!="), operator_17384, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28977), Reflex::Literal("operator<"), operator_17385, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28977), Reflex::Literal("operator>"), operator_17386, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28977), Reflex::Literal("operator<="), operator_17387, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28977), Reflex::Literal("operator>="), operator_17388, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > -------------------------------
static  void operator_19290( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static void constructor_19291( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static void constructor_19292( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >();
}

static void constructor_19293( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::Handle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::Handle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::Handle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::Handle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19294( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19295( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19296( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >((const ::std::vector<pat::TriggerObjectStandAlone>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >((const ::std::vector<pat::TriggerObjectStandAlone>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >((const ::std::vector<pat::TriggerObjectStandAlone>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >((const ::std::vector<pat::TriggerObjectStandAlone>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19297( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::TestHandle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::TestHandle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::TestHandle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::TestHandle<std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19298( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_19299( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::TriggerObjectStandAlone*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::TriggerObjectStandAlone>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::TriggerObjectStandAlone*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::TriggerObjectStandAlone>*)arg[3]);
}

static void constructor_19300( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_19301( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_19302(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::~Ref)();
}
static  void operator_19303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator*)();
}

static  void operator_19304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator->)();
}

static  void method_19305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->get)();
}

static  void method_19306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isNull)();
}

static  void method_19307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isNonnull)();
}

static  void operator_19308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator!)();
}

static  void method_19309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->id)();
}

static  void method_19310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->productGetter)();
}

static  void method_19311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->product)();
}

static  void method_19312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->key)();
}

static  void method_19313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->index)();
}

static  void method_19314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->hasProductCache)();
}

static  void method_19315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isAvailable)();
}

static  void method_19316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->isTransient)();
}

static  void method_19317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->refCore)();
}

static  void method_19318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->Class_Version)();
}

static void constructor_19319( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_4346( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > -------------------------------
void __edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__datamem_bld(&__edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__funcmem_bld(&__edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_funcmem);
void __edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >"), typeid(::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >), sizeof(::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::Class_Version())
  .AddTypedef(type_7344, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::T"))
  .AddTypedef(type_15864, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::F"))
  .AddTypedef(type_17540, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::VF"))
  .AddTypedef(type_17539, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::VBF"))
  .AddTypedef(type_2749, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::product_type"))
  .AddTypedef(type_7344, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::value_type"))
  .AddTypedef(type_7344c, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::element_type"))
  .AddTypedef(type_15864, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::finder_type"))
  .AddTypedef(type_289, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::argument_type"))
  .AddTypedef(type_289, Reflex::Literal("edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10394, type_29229), Reflex::Literal("operator="), operator_19290, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29229), Reflex::Literal("Ref"), constructor_19291, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_19292, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29531, type_289, type_1454), Reflex::Literal("Ref"), constructor_19293, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29532, type_289, type_1454), Reflex::Literal("Ref"), constructor_19294, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29228, type_289, type_1454), Reflex::Literal("Ref"), constructor_19295, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29230, type_289, type_1454), Reflex::Literal("Ref"), constructor_19296, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29533, type_289, type_1454), Reflex::Literal("Ref"), constructor_19297, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_289, type_19013), Reflex::Literal("Ref"), constructor_19298, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_8911, type_289, type_29230), Reflex::Literal("Ref"), constructor_19299, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634), Reflex::Literal("Ref"), constructor_19300, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29530, type_289), Reflex::Literal("Ref"), constructor_19301, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_19302, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17508, type_8924), Reflex::Literal("Ref"), constructor_19319, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4346, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > -------------------
void __edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4367, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > -------------------
void __edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8913), Reflex::Literal("operator*"), operator_19303, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8911), Reflex::Literal("operator->"), operator_19304, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8911), Reflex::Literal("get"), method_19305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_19306, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_19307, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_19308, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_19309, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_19310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29230), Reflex::Literal("product"), method_19311, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("key"), method_19312, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_289), Reflex::Literal("index"), method_19313, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_19314, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_19315, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_19316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17508), Reflex::Literal("refCore"), method_19317, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_19318, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> > -------------------------------
static void destructor_17683(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::~RefVector)();
}
static void constructor_17684( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >();
}

static void constructor_17685( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static void constructor_17686( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_17687( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static  void operator_17688( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >)((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_17689( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >)((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->refVector)();
}

static  void method_17691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->empty)();
}

static  void method_17692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->size)();
}

static  void method_17693( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->capacity)();
}

static  void method_17694( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_17695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >)((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->begin)();
}

static  void method_17696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >)((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->end)();
}

static  void method_17697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->id)();
}

static  void method_17698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->productGetter)();
}

static  void method_17699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isNull)();
}

static  void method_17700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isNonnull)();
}

static  void operator_17701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator!)();
}

static  void method_17702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->product)();
}

static  void method_17703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isAvailable)();
}

static  void method_17704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->isTransient)();
}

static  void method_17705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >)((((::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static  void method_17706( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->clear)();
}

static  void method_17707( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static  void operator_17708( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)arg[0]);
}

static  void method_17709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->hasProductCache)();
}

static  void method_17710( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_17711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*)o)->Class_Version)();
}

static void method_newdel_4053( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> > -------------------------------
void __edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__datamem_bld(&__edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__funcmem_bld(&__edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_funcmem);
void __edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >"), typeid(::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >), sizeof(::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::Class_Version())
  .AddTypedef(type_2746, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::collection_type"))
  .AddTypedef(type_7332, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::member_type"))
  .AddTypedef(type_15840, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::finder_type"))
  .AddTypedef(type_4016, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::iterator"))
  .AddTypedef(type_4016, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::const_iterator"))
  .AddTypedef(type_4343, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::value_type"))
  .AddTypedef(type_4343c, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::const_reference"))
  .AddTypedef(type_4343c, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::reference"))
  .AddTypedef(type_289, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::key_type"))
  .AddTypedef(type_2753, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::KeyVec"))
  .AddTypedef(type_2926, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::size_type"))
  .AddTypedef(type_4296, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_17683, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_17684, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29216), Reflex::Literal("RefVector"), constructor_17685, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634), Reflex::Literal("RefVector"), constructor_17686, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4053, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> > -------------------
void __edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4296, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> >, pat::TriggerCondition> > -------------------
void __edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29217), Reflex::Literal("push_back"), method_17687, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4343c, type_2926), Reflex::Literal("operator[]"), operator_17688, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4343c, type_2926), Reflex::Literal("at"), method_17689, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29212), Reflex::Literal("refVector"), method_17690, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_17691, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("size"), method_17692, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("capacity"), method_17693, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926), Reflex::Literal("reserve"), method_17694, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4016), Reflex::Literal("begin"), method_17695, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4016), Reflex::Literal("end"), method_17696, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_17697, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_17698, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_17699, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_17700, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_17701, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29218), Reflex::Literal("product"), method_17702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_17703, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_17704, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4016, type_28971), Reflex::Literal("erase"), method_17705, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_17706, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29219), Reflex::Literal("swap"), method_17707, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29219, type_29216), Reflex::Literal("operator="), operator_17708, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_17709, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_29215), Reflex::Literal("fillView"), method_17710, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_17711, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------------------
static  void operator_18761( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::TriggerObject> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::TriggerObject> >*)arg[0]);
}

static void constructor_18762( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObject> >(*(const ::edm::RefProd<std::vector<pat::TriggerObject> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObject> >(*(const ::edm::RefProd<std::vector<pat::TriggerObject> >*)arg[0]);
}

static void constructor_18763( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObject> >();
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObject> >();
}

static void constructor_18764( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObject> >(*(const ::edm::Handle<std::vector<pat::TriggerObject> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObject> >(*(const ::edm::Handle<std::vector<pat::TriggerObject> >*)arg[0]);
}

static void constructor_18765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObject> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerObject> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObject> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerObject> >*)arg[0]);
}

static void constructor_18766( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObject> >((const ::std::vector<pat::TriggerObject>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObject> >((const ::std::vector<pat::TriggerObject>*)arg[0]);
}

static void constructor_18767( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObject> >(*(const ::edm::TestHandle<std::vector<pat::TriggerObject> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObject> >(*(const ::edm::TestHandle<std::vector<pat::TriggerObject> >*)arg[0]);
}

static void constructor_18768( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObject> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerObject> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_18769(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->::edm::RefProd<std::vector<pat::TriggerObject> >::~RefProd)();
}
static  void operator_18770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->operator*)();
}

static  void operator_18771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->operator->)();
}

static  void method_18772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->get)();
}

static  void method_18773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->product)();
}

static  void method_18774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->refCore)();
}

static  void method_18775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->isNull)();
}

static  void method_18776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->isNonnull)();
}

static  void operator_18777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->operator!)();
}

static  void method_18778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->id)();
}

static  void method_18779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->productGetter)();
}

static  void method_18780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->hasCache)();
}

static  void method_18781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->hasProductCache)();
}

static  void method_18782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->isAvailable)();
}

static  void method_18783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->isTransient)();
}

static  void method_18784( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->swap)(*(::edm::RefProd<std::vector<pat::TriggerObject> >*)arg[0]);
}

static  void method_18785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<pat::TriggerObject> >*)o)->Class_Version)();
}

static void method_newdel_4303( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------------------
void __edm__RefProd_std__vector_pat__TriggerObject_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_pat__TriggerObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__TriggerObject_s__datamem_bld(&__edm__RefProd_std__vector_pat__TriggerObject_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__TriggerObject_s__funcmem_bld(&__edm__RefProd_std__vector_pat__TriggerObject_s__db_funcmem);
void __edm__RefProd_std__vector_pat__TriggerObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::TriggerObject> >"), typeid(::edm::RefProd<std::vector<pat::TriggerObject> >), sizeof(::edm::RefProd<std::vector<pat::TriggerObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<pat::TriggerObject> >::Class_Version())
  .AddTypedef(type_2747, Reflex::Literal("edm::RefProd<std::vector<pat::TriggerObject> >::product_type"))
  .AddTypedef(type_2747, Reflex::Literal("edm::RefProd<std::vector<pat::TriggerObject> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29534, type_29535), Reflex::Literal("operator="), operator_18761, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29535), Reflex::Literal("RefProd"), constructor_18762, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_18763, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29536), Reflex::Literal("RefProd"), constructor_18764, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29473), Reflex::Literal("RefProd"), constructor_18765, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29233), Reflex::Literal("RefProd"), constructor_18766, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29446), Reflex::Literal("RefProd"), constructor_18767, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_19013), Reflex::Literal("RefProd"), constructor_18768, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_18769, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4303, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_pat__TriggerObject_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_pat__TriggerObject_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------
void __edm__RefProd_std__vector_pat__TriggerObject_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4286, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_pat__TriggerObject_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------
void __edm__RefProd_std__vector_pat__TriggerObject_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15881), Reflex::Literal("operator*"), operator_18770, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29233), Reflex::Literal("operator->"), operator_18771, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29233), Reflex::Literal("get"), method_18772, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29233), Reflex::Literal("product"), method_18773, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17508), Reflex::Literal("refCore"), method_18774, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_18775, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_18776, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_18777, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_18778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_18779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasCache"), method_18780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_18781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_18782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_18783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29534), Reflex::Literal("swap"), method_18784, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_18785, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > -------------------------------
static  void operator_18877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)arg[0]);
}

static void constructor_18878( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerCondition> >(*(const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerCondition> >(*(const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)arg[0]);
}

static void constructor_18879( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerCondition> >();
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerCondition> >();
}

static void constructor_18880( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerCondition> >(*(const ::edm::Handle<std::vector<pat::TriggerCondition> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerCondition> >(*(const ::edm::Handle<std::vector<pat::TriggerCondition> >*)arg[0]);
}

static void constructor_18881( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerCondition> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerCondition> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerCondition> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerCondition> >*)arg[0]);
}

static void constructor_18882( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerCondition> >((const ::std::vector<pat::TriggerCondition>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerCondition> >((const ::std::vector<pat::TriggerCondition>*)arg[0]);
}

static void constructor_18883( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerCondition> >(*(const ::edm::TestHandle<std::vector<pat::TriggerCondition> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerCondition> >(*(const ::edm::TestHandle<std::vector<pat::TriggerCondition> >*)arg[0]);
}

static void constructor_18884( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerCondition> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerCondition> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_18885(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->::edm::RefProd<std::vector<pat::TriggerCondition> >::~RefProd)();
}
static  void operator_18886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->operator*)();
}

static  void operator_18887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->operator->)();
}

static  void method_18888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->get)();
}

static  void method_18889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->product)();
}

static  void method_18890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->refCore)();
}

static  void method_18891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->isNull)();
}

static  void method_18892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->isNonnull)();
}

static  void operator_18893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->operator!)();
}

static  void method_18894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->id)();
}

static  void method_18895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->productGetter)();
}

static  void method_18896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->hasCache)();
}

static  void method_18897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->hasProductCache)();
}

static  void method_18898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->isAvailable)();
}

static  void method_18899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->isTransient)();
}

static  void method_18900( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->swap)(*(::edm::RefProd<std::vector<pat::TriggerCondition> >*)arg[0]);
}

static  void method_18901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<pat::TriggerCondition> >*)o)->Class_Version)();
}

static void method_newdel_4307( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerCondition> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerCondition> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerCondition> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerCondition> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerCondition> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > -------------------------------
void __edm__RefProd_std__vector_pat__TriggerCondition_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_pat__TriggerCondition_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__TriggerCondition_s__datamem_bld(&__edm__RefProd_std__vector_pat__TriggerCondition_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__TriggerCondition_s__funcmem_bld(&__edm__RefProd_std__vector_pat__TriggerCondition_s__db_funcmem);
void __edm__RefProd_std__vector_pat__TriggerCondition_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::TriggerCondition> >"), typeid(::edm::RefProd<std::vector<pat::TriggerCondition> >), sizeof(::edm::RefProd<std::vector<pat::TriggerCondition> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<pat::TriggerCondition> >::Class_Version())
  .AddTypedef(type_2746, Reflex::Literal("edm::RefProd<std::vector<pat::TriggerCondition> >::product_type"))
  .AddTypedef(type_2746, Reflex::Literal("edm::RefProd<std::vector<pat::TriggerCondition> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29544, type_29545), Reflex::Literal("operator="), operator_18877, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29545), Reflex::Literal("RefProd"), constructor_18878, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_18879, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29546), Reflex::Literal("RefProd"), constructor_18880, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29479), Reflex::Literal("RefProd"), constructor_18881, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29218), Reflex::Literal("RefProd"), constructor_18882, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29452), Reflex::Literal("RefProd"), constructor_18883, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_19013), Reflex::Literal("RefProd"), constructor_18884, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_18885, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4307, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_pat__TriggerCondition_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_pat__TriggerCondition_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > -------------------
void __edm__RefProd_std__vector_pat__TriggerCondition_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4286, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_pat__TriggerCondition_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > -------------------
void __edm__RefProd_std__vector_pat__TriggerCondition_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15845), Reflex::Literal("operator*"), operator_18886, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29218), Reflex::Literal("operator->"), operator_18887, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29218), Reflex::Literal("get"), method_18888, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29218), Reflex::Literal("product"), method_18889, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17508), Reflex::Literal("refCore"), method_18890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_18891, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_18892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_18893, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_18894, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_18895, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasCache"), method_18896, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_18897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_18898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_18899, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29544), Reflex::Literal("swap"), method_18900, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_18901, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > -------------------------------
static  void operator_18906( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
}

static void constructor_18907( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >(*(const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >(*(const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
}

static void constructor_18908( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >();
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >();
}

static void constructor_18909( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >(*(const ::edm::Handle<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >(*(const ::edm::Handle<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
}

static void constructor_18910( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
}

static void constructor_18911( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >((const ::std::vector<pat::TriggerAlgorithm>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >((const ::std::vector<pat::TriggerAlgorithm>*)arg[0]);
}

static void constructor_18912( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >(*(const ::edm::TestHandle<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >(*(const ::edm::TestHandle<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
}

static void constructor_18913( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_18914(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->::edm::RefProd<std::vector<pat::TriggerAlgorithm> >::~RefProd)();
}
static  void operator_18915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->operator*)();
}

static  void operator_18916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->operator->)();
}

static  void method_18917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->get)();
}

static  void method_18918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->product)();
}

static  void method_18919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->refCore)();
}

static  void method_18920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->isNull)();
}

static  void method_18921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->isNonnull)();
}

static  void operator_18922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->operator!)();
}

static  void method_18923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->id)();
}

static  void method_18924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->productGetter)();
}

static  void method_18925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->hasCache)();
}

static  void method_18926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->hasProductCache)();
}

static  void method_18927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->isAvailable)();
}

static  void method_18928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->isTransient)();
}

static  void method_18929( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->swap)(*(::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
}

static  void method_18930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)o)->Class_Version)();
}

static void method_newdel_4308( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerAlgorithm> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerAlgorithm> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerAlgorithm> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerAlgorithm> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerAlgorithm> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > -------------------------------
void __edm__RefProd_std__vector_pat__TriggerAlgorithm_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_pat__TriggerAlgorithm_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__TriggerAlgorithm_s__datamem_bld(&__edm__RefProd_std__vector_pat__TriggerAlgorithm_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__TriggerAlgorithm_s__funcmem_bld(&__edm__RefProd_std__vector_pat__TriggerAlgorithm_s__db_funcmem);
void __edm__RefProd_std__vector_pat__TriggerAlgorithm_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::TriggerAlgorithm> >"), typeid(::edm::RefProd<std::vector<pat::TriggerAlgorithm> >), sizeof(::edm::RefProd<std::vector<pat::TriggerAlgorithm> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<pat::TriggerAlgorithm> >::Class_Version())
  .AddTypedef(type_2745, Reflex::Literal("edm::RefProd<std::vector<pat::TriggerAlgorithm> >::product_type"))
  .AddTypedef(type_2745, Reflex::Literal("edm::RefProd<std::vector<pat::TriggerAlgorithm> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29547, type_29548), Reflex::Literal("operator="), operator_18906, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29548), Reflex::Literal("RefProd"), constructor_18907, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_18908, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29549), Reflex::Literal("RefProd"), constructor_18909, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29481), Reflex::Literal("RefProd"), constructor_18910, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29213), Reflex::Literal("RefProd"), constructor_18911, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29454), Reflex::Literal("RefProd"), constructor_18912, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_19013), Reflex::Literal("RefProd"), constructor_18913, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_18914, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4308, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_pat__TriggerAlgorithm_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_pat__TriggerAlgorithm_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > -------------------
void __edm__RefProd_std__vector_pat__TriggerAlgorithm_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4286, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_pat__TriggerAlgorithm_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > -------------------
void __edm__RefProd_std__vector_pat__TriggerAlgorithm_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15857), Reflex::Literal("operator*"), operator_18915, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29213), Reflex::Literal("operator->"), operator_18916, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29213), Reflex::Literal("get"), method_18917, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29213), Reflex::Literal("product"), method_18918, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17508), Reflex::Literal("refCore"), method_18919, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_18920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_18921, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_18922, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_18923, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_18924, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasCache"), method_18925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_18926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_18927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_18928, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29547), Reflex::Literal("swap"), method_18929, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_18930, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > -------------------------------
static void destructor_17851(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::~RefVector)();
}
static void constructor_17852( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >();
}

static void constructor_17853( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static void constructor_17854( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_17855( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static  void operator_17856( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >)((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_17857( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >)((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->refVector)();
}

static  void method_17859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->empty)();
}

static  void method_17860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->size)();
}

static  void method_17861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->capacity)();
}

static  void method_17862( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_17863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >)((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->begin)();
}

static  void method_17864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >)((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->end)();
}

static  void method_17865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->id)();
}

static  void method_17866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->productGetter)();
}

static  void method_17867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isNull)();
}

static  void method_17868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isNonnull)();
}

static  void operator_17869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator!)();
}

static  void method_17870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->product)();
}

static  void method_17871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isAvailable)();
}

static  void method_17872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->isTransient)();
}

static  void method_17873( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >)((((::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static  void method_17874( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->clear)();
}

static  void method_17875( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static  void operator_17876( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static  void method_17877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->hasProductCache)();
}

static  void method_17878( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_17879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->Class_Version)();
}

static void method_newdel_4057( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > -------------------------------
void __edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__datamem_bld(&__edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__funcmem_bld(&__edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_funcmem);
void __edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >"), typeid(::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >), sizeof(::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::Class_Version())
  .AddTypedef(type_2747, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::collection_type"))
  .AddTypedef(type_7357, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::member_type"))
  .AddTypedef(type_15876, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::finder_type"))
  .AddTypedef(type_4020, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::iterator"))
  .AddTypedef(type_4020, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::const_iterator"))
  .AddTypedef(type_4344, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::value_type"))
  .AddTypedef(type_4344c, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::const_reference"))
  .AddTypedef(type_4344c, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::reference"))
  .AddTypedef(type_289, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::key_type"))
  .AddTypedef(type_2753, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::KeyVec"))
  .AddTypedef(type_2926, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::size_type"))
  .AddTypedef(type_4296, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_17851, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_17852, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29232), Reflex::Literal("RefVector"), constructor_17853, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634), Reflex::Literal("RefVector"), constructor_17854, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4057, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > -------------------
void __edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4296, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > -------------------
void __edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_26451), Reflex::Literal("push_back"), method_17855, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4344c, type_2926), Reflex::Literal("operator[]"), operator_17856, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4344c, type_2926), Reflex::Literal("at"), method_17857, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29212), Reflex::Literal("refVector"), method_17858, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_17859, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("size"), method_17860, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("capacity"), method_17861, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926), Reflex::Literal("reserve"), method_17862, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4020), Reflex::Literal("begin"), method_17863, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4020), Reflex::Literal("end"), method_17864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_17865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_17866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_17867, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_17868, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_17869, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29233), Reflex::Literal("product"), method_17870, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_17871, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_17872, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4020, type_28983), Reflex::Literal("erase"), method_17873, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_17874, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29234), Reflex::Literal("swap"), method_17875, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29234, type_29232), Reflex::Literal("operator="), operator_17876, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_17877, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_29215), Reflex::Literal("fillView"), method_17878, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_17879, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVectorIterator<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > -------------------------------
static void destructor_17397(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::~RefVectorIterator)();
}
static  void operator_17398( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static void constructor_17399( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static void constructor_17400( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >();
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >();
}

static void constructor_17401( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::RefCore*)arg[0],
      *(const ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >*)arg[1]);
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >(*(const ::edm::RefCore*)arg[0],
      *(const ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >*)arg[1]);
}

static  void operator_17402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator*)());
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator*)();
}

static  void operator_17403( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator->)());
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator->)();
}

static  void operator_17405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator++)();
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator++)();
}

static  void operator_17406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator--)();
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator--)();
}

static  void operator_17407( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17408( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17409( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >)((((::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_17410( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >)((((::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_17411( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17412( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17413( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::ptrdiff_t)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator-)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator-)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void operator_17414( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator==)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator==)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void operator_17415( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator!=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator!=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void operator_17416( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator<)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator<)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void operator_17417( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator>)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator>)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void operator_17418( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator<=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator<=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void operator_17419( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator>=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)o)->operator>=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static void method_newdel_4019( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x78( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&>")), ::Reflex::BaseOffset< ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefVectorIterator<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > -------------------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_datamem(Reflex::Class*);
void __edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__datamem_bld(&__edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__funcmem_bld(&__edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_funcmem);
void __edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >"), typeid(::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >), sizeof(::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2645, ::Reflex::BaseOffset< ::edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >, ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4346, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::value_type"))
  .AddTypedef(type_4346c, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::const_reference"))
  .AddTypedef(type_4346c, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::reference"))
  .AddTypedef(type_289, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::key_type"))
  .AddTypedef(type_2844, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::difference"))
  .AddTypedef(type_6578, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >::keyIter"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVectorIterator"), destructor_17397, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28979, type_28980), Reflex::Literal("operator="), operator_17398, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28980), Reflex::Literal("RefVectorIterator"), constructor_17399, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVectorIterator"), constructor_17400, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17508, type_28968), Reflex::Literal("RefVectorIterator"), constructor_17401, 0, "product;it", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4019, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x78, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__funcmem_bld);
}

//------Delayed data member builder for class RefVectorIterator<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > -------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4286, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_, product_), ::Reflex::PRIVATE)
  .AddDataMember(type_6578, Reflex::Literal("iter_"), OffsetOf(__shadow__::__edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_, iter_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVectorIterator<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > -------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4346c), Reflex::Literal("operator*"), operator_17402, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4346c, type_2844), Reflex::Literal("operator[]"), operator_17403, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2539), Reflex::Literal("operator->"), operator_17404, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28979), Reflex::Literal("operator++"), operator_17405, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28979), Reflex::Literal("operator--"), operator_17406, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28979, type_2844), Reflex::Literal("operator+="), operator_17407, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28979, type_2844), Reflex::Literal("operator-="), operator_17408, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4019, type_71), Reflex::Literal("operator++"), operator_17409, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4019, type_71), Reflex::Literal("operator--"), operator_17410, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4019, type_2844), Reflex::Literal("operator+"), operator_17411, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4019, type_2844), Reflex::Literal("operator-"), operator_17412, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2844, type_28980), Reflex::Literal("operator-"), operator_17413, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28980), Reflex::Literal("operator=="), operator_17414, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28980), Reflex::Literal("operator!="), operator_17415, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28980), Reflex::Literal("operator<"), operator_17416, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28980), Reflex::Literal("operator>"), operator_17417, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28980), Reflex::Literal("operator<="), operator_17418, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28980), Reflex::Literal("operator>="), operator_17419, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class RefVectorIterator<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > -------------------------------
static void destructor_17428(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::~RefVectorIterator)();
}
static  void operator_17429( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static void constructor_17430( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static void constructor_17431( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >();
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >();
}

static void constructor_17432( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::RefCore*)arg[0],
      *(const ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >*)arg[1]);
  else ::new(mem) ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >(*(const ::edm::RefCore*)arg[0],
      *(const ::__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >*)arg[1]);
}

static  void operator_17433( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator*)());
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator*)();
}

static  void operator_17434( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator->)());
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator->)();
}

static  void operator_17436( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator++)();
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator++)();
}

static  void operator_17437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator--)();
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator--)();
}

static  void operator_17438( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17439( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17440( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >)((((::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_17441( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >)((((::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_17442( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_17444( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::ptrdiff_t)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator-)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator-)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static  void operator_17445( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator==)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator==)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static  void operator_17446( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator!=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator!=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static  void operator_17447( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator<)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator<)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static  void operator_17448( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator>)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator>)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static  void operator_17449( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator<=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator<=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static  void operator_17450( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator>=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]));
  else   (((const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)o)->operator>=)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static void method_newdel_4020( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x80( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&>")), ::Reflex::BaseOffset< ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefVectorIterator<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > -------------------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_datamem(Reflex::Class*);
void __edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__datamem_bld(&__edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__funcmem_bld(&__edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_funcmem);
void __edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >"), typeid(::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >), sizeof(::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2643, ::Reflex::BaseOffset< ::edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >, ::std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4344, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::value_type"))
  .AddTypedef(type_4344c, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::const_reference"))
  .AddTypedef(type_4344c, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::reference"))
  .AddTypedef(type_289, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::key_type"))
  .AddTypedef(type_2844, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::difference"))
  .AddTypedef(type_6578, Reflex::Literal("edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >::keyIter"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVectorIterator"), destructor_17428, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28982, type_28983), Reflex::Literal("operator="), operator_17429, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28983), Reflex::Literal("RefVectorIterator"), constructor_17430, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVectorIterator"), constructor_17431, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17508, type_28968), Reflex::Literal("RefVectorIterator"), constructor_17432, 0, "product;it", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4020, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x80, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__funcmem_bld);
}

//------Delayed data member builder for class RefVectorIterator<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > -------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4286, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_, product_), ::Reflex::PRIVATE)
  .AddDataMember(type_6578, Reflex::Literal("iter_"), OffsetOf(__shadow__::__edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_, iter_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVectorIterator<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > -------------------
void __edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4344c), Reflex::Literal("operator*"), operator_17433, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4344c, type_2844), Reflex::Literal("operator[]"), operator_17434, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2544), Reflex::Literal("operator->"), operator_17435, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28982), Reflex::Literal("operator++"), operator_17436, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28982), Reflex::Literal("operator--"), operator_17437, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28982, type_2844), Reflex::Literal("operator+="), operator_17438, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28982, type_2844), Reflex::Literal("operator-="), operator_17439, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4020, type_71), Reflex::Literal("operator++"), operator_17440, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4020, type_71), Reflex::Literal("operator--"), operator_17441, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4020, type_2844), Reflex::Literal("operator+"), operator_17442, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4020, type_2844), Reflex::Literal("operator-"), operator_17443, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2844, type_28983), Reflex::Literal("operator-"), operator_17444, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28983), Reflex::Literal("operator=="), operator_17445, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28983), Reflex::Literal("operator!="), operator_17446, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28983), Reflex::Literal("operator<"), operator_17447, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28983), Reflex::Literal("operator>"), operator_17448, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28983), Reflex::Literal("operator<="), operator_17449, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_28983), Reflex::Literal("operator>="), operator_17450, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class RefVector<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> > -------------------------------
static void destructor_17725(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::~RefVector)();
}
static void constructor_17726( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >();
}

static void constructor_17727( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static void constructor_17728( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_17729( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static  void operator_17730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >)((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_17731( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >)((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->refVector)();
}

static  void method_17733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->empty)();
}

static  void method_17734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->size)();
}

static  void method_17735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->capacity)();
}

static  void method_17736( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_17737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >)((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->begin)();
}

static  void method_17738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >)((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->end)();
}

static  void method_17739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->id)();
}

static  void method_17740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->productGetter)();
}

static  void method_17741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isNull)();
}

static  void method_17742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isNonnull)();
}

static  void operator_17743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator!)();
}

static  void method_17744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->product)();
}

static  void method_17745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isAvailable)();
}

static  void method_17746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->isTransient)();
}

static  void method_17747( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >)((((::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static  void method_17748( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->clear)();
}

static  void method_17749( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static  void operator_17750( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)arg[0]);
}

static  void method_17751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->hasProductCache)();
}

static  void method_17752( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_17753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*)o)->Class_Version)();
}

static void method_newdel_4054( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> > -------------------------------
void __edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__datamem_bld(&__edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__funcmem_bld(&__edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_funcmem);
void __edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >"), typeid(::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >), sizeof(::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::Class_Version())
  .AddTypedef(type_2750, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::collection_type"))
  .AddTypedef(type_7348, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::member_type"))
  .AddTypedef(type_15828, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::finder_type"))
  .AddTypedef(type_4017, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::iterator"))
  .AddTypedef(type_4017, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::const_iterator"))
  .AddTypedef(type_4347, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::value_type"))
  .AddTypedef(type_4347c, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::const_reference"))
  .AddTypedef(type_4347c, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::reference"))
  .AddTypedef(type_289, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::key_type"))
  .AddTypedef(type_2753, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::KeyVec"))
  .AddTypedef(type_2926, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::size_type"))
  .AddTypedef(type_4296, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_17725, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_17726, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29220), Reflex::Literal("RefVector"), constructor_17727, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634), Reflex::Literal("RefVector"), constructor_17728, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4054, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> > -------------------
void __edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4296, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> >, pat::TriggerPath> > -------------------
void __edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29221), Reflex::Literal("push_back"), method_17729, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4347c, type_2926), Reflex::Literal("operator[]"), operator_17730, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4347c, type_2926), Reflex::Literal("at"), method_17731, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29212), Reflex::Literal("refVector"), method_17732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_17733, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("size"), method_17734, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("capacity"), method_17735, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926), Reflex::Literal("reserve"), method_17736, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4017), Reflex::Literal("begin"), method_17737, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4017), Reflex::Literal("end"), method_17738, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_17739, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_17740, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_17741, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_17742, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_17743, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29222), Reflex::Literal("product"), method_17744, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_17745, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_17746, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4017, type_28974), Reflex::Literal("erase"), method_17747, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_17748, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29223), Reflex::Literal("swap"), method_17749, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29223, type_29220), Reflex::Literal("operator="), operator_17750, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_17751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_29215), Reflex::Literal("fillView"), method_17752, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_17753, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> > -------------------------------
static void destructor_17767(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::~RefVector)();
}
static void constructor_17768( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >();
}

static void constructor_17769( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static void constructor_17770( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_17771( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static  void operator_17772( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >)((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_17773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >)((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->refVector)();
}

static  void method_17775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->empty)();
}

static  void method_17776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->size)();
}

static  void method_17777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->capacity)();
}

static  void method_17778( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_17779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >)((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->begin)();
}

static  void method_17780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >)((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->end)();
}

static  void method_17781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->id)();
}

static  void method_17782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->productGetter)();
}

static  void method_17783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isNull)();
}

static  void method_17784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isNonnull)();
}

static  void operator_17785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator!)();
}

static  void method_17786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->product)();
}

static  void method_17787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isAvailable)();
}

static  void method_17788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->isTransient)();
}

static  void method_17789( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >)((((::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static  void method_17790( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->clear)();
}

static  void method_17791( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static  void operator_17792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)arg[0]);
}

static  void method_17793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->hasProductCache)();
}

static  void method_17794( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_17795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*)o)->Class_Version)();
}

static void method_newdel_4055( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> > -------------------------------
void __edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__datamem_bld(&__edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__funcmem_bld(&__edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_funcmem);
void __edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >"), typeid(::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >), sizeof(::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::Class_Version())
  .AddTypedef(type_2748, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::collection_type"))
  .AddTypedef(type_7359, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::member_type"))
  .AddTypedef(type_15816, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::finder_type"))
  .AddTypedef(type_4018, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::iterator"))
  .AddTypedef(type_4018, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::const_iterator"))
  .AddTypedef(type_4345, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::value_type"))
  .AddTypedef(type_4345c, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::const_reference"))
  .AddTypedef(type_4345c, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::reference"))
  .AddTypedef(type_289, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::key_type"))
  .AddTypedef(type_2753, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::KeyVec"))
  .AddTypedef(type_2926, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::size_type"))
  .AddTypedef(type_4296, Reflex::Literal("edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_17767, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_17768, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29224), Reflex::Literal("RefVector"), constructor_17769, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634), Reflex::Literal("RefVector"), constructor_17770, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4055, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> > -------------------
void __edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4296, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> >, pat::TriggerFilter> > -------------------
void __edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29225), Reflex::Literal("push_back"), method_17771, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4345c, type_2926), Reflex::Literal("operator[]"), operator_17772, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4345c, type_2926), Reflex::Literal("at"), method_17773, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29212), Reflex::Literal("refVector"), method_17774, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_17775, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("size"), method_17776, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("capacity"), method_17777, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926), Reflex::Literal("reserve"), method_17778, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4018), Reflex::Literal("begin"), method_17779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4018), Reflex::Literal("end"), method_17780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_17781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_17782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_17783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_17784, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_17785, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29226), Reflex::Literal("product"), method_17786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_17787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_17788, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4018, type_28977), Reflex::Literal("erase"), method_17789, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_17790, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29227), Reflex::Literal("swap"), method_17791, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29227, type_29224), Reflex::Literal("operator="), operator_17792, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_17793, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_29215), Reflex::Literal("fillView"), method_17794, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_17795, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > -------------------------------
static  void operator_18819( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)arg[0]);
}

static void constructor_18820( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerFilter> >(*(const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerFilter> >(*(const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)arg[0]);
}

static void constructor_18821( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerFilter> >();
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerFilter> >();
}

static void constructor_18822( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerFilter> >(*(const ::edm::Handle<std::vector<pat::TriggerFilter> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerFilter> >(*(const ::edm::Handle<std::vector<pat::TriggerFilter> >*)arg[0]);
}

static void constructor_18823( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerFilter> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerFilter> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerFilter> >(*(const ::edm::OrphanHandle<std::vector<pat::TriggerFilter> >*)arg[0]);
}

static void constructor_18824( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerFilter> >((const ::std::vector<pat::TriggerFilter>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerFilter> >((const ::std::vector<pat::TriggerFilter>*)arg[0]);
}

static void constructor_18825( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerFilter> >(*(const ::edm::TestHandle<std::vector<pat::TriggerFilter> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerFilter> >(*(const ::edm::TestHandle<std::vector<pat::TriggerFilter> >*)arg[0]);
}

static void constructor_18826( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::TriggerFilter> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::TriggerFilter> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_18827(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->::edm::RefProd<std::vector<pat::TriggerFilter> >::~RefProd)();
}
static  void operator_18828( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->operator*)();
}

static  void operator_18829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->operator->)();
}

static  void method_18830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->get)();
}

static  void method_18831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->product)();
}

static  void method_18832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->refCore)();
}

static  void method_18833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->isNull)();
}

static  void method_18834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->isNonnull)();
}

static  void operator_18835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->operator!)();
}

static  void method_18836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->id)();
}

static  void method_18837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->productGetter)();
}

static  void method_18838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->hasCache)();
}

static  void method_18839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->hasProductCache)();
}

static  void method_18840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->isAvailable)();
}

static  void method_18841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->isTransient)();
}

static  void method_18842( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->swap)(*(::edm::RefProd<std::vector<pat::TriggerFilter> >*)arg[0]);
}

static  void method_18843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<pat::TriggerFilter> >*)o)->Class_Version)();
}

static void method_newdel_4305( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerFilter> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerFilter> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerFilter> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerFilter> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::TriggerFilter> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > -------------------------------
void __edm__RefProd_std__vector_pat__TriggerFilter_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_pat__TriggerFilter_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__TriggerFilter_s__datamem_bld(&__edm__RefProd_std__vector_pat__TriggerFilter_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__TriggerFilter_s__funcmem_bld(&__edm__RefProd_std__vector_pat__TriggerFilter_s__db_funcmem);
void __edm__RefProd_std__vector_pat__TriggerFilter_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::TriggerFilter> >"), typeid(::edm::RefProd<std::vector<pat::TriggerFilter> >), sizeof(::edm::RefProd<std::vector<pat::TriggerFilter> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<pat::TriggerFilter> >::Class_Version())
  .AddTypedef(type_2748, Reflex::Literal("edm::RefProd<std::vector<pat::TriggerFilter> >::product_type"))
  .AddTypedef(type_2748, Reflex::Literal("edm::RefProd<std::vector<pat::TriggerFilter> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29538, type_29539), Reflex::Literal("operator="), operator_18819, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29539), Reflex::Literal("RefProd"), constructor_18820, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_18821, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29540), Reflex::Literal("RefProd"), constructor_18822, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29475), Reflex::Literal("RefProd"), constructor_18823, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29226), Reflex::Literal("RefProd"), constructor_18824, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29448), Reflex::Literal("RefProd"), constructor_18825, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15634, type_19013), Reflex::Literal("RefProd"), constructor_18826, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_18827, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4305, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_pat__TriggerFilter_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_pat__TriggerFilter_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > -------------------
void __edm__RefProd_std__vector_pat__TriggerFilter_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4286, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_pat__TriggerFilter_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > -------------------
void __edm__RefProd_std__vector_pat__TriggerFilter_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15821), Reflex::Literal("operator*"), operator_18828, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29226), Reflex::Literal("operator->"), operator_18829, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29226), Reflex::Literal("get"), method_18830, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29226), Reflex::Literal("product"), method_18831, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17508), Reflex::Literal("refCore"), method_18832, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNull"), method_18833, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isNonnull"), method_18834, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("operator!"), operator_18835, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_18836, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_18837, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasCache"), method_18838, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_18839, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_18840, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isTransient"), method_18841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29538), Reflex::Literal("swap"), method_18842, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_18843, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > -------------------------------
static void destructor_21835(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >::~__normal_iterator)();
}
static  void operator_21836( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)arg[0]);
}

static void constructor_21837( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)arg[0]);
}

static void constructor_21838( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >();
}

static void constructor_21839( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >(*(const ::pat::TriggerAlgorithm* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >(*(const ::pat::TriggerAlgorithm* const*)arg[0]);
}

static  void operator_21840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator*)();
}

static  void operator_21841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator->)();
}

static  void operator_21842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator++)();
}

static  void operator_21843( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >)((((::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_21844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator--)();
}

static  void operator_21845( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >)((((::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_21846( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21847( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21848( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >)((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21849( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >)((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_21851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >*)o)->base)();
}

static void method_newdel_6572( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2339, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >::__traits_type"))
  .AddTypedef(type_8856, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >::iterator_type"))
  .AddTypedef(type_2391, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >::iterator_category"))
  .AddTypedef(type_7368, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >::value_type"))
  .AddTypedef(type_2844, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >::difference_type"))
  .AddTypedef(type_8858, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >::reference"))
  .AddTypedef(type_8856, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_21835, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30211, type_30212), Reflex::Literal("operator="), operator_21836, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30212), Reflex::Literal("__normal_iterator"), constructor_21837, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_21838, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30213), Reflex::Literal("__normal_iterator"), constructor_21839, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6572, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8856, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8858), Reflex::Literal("operator*"), operator_21840, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8856), Reflex::Literal("operator->"), operator_21841, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30211), Reflex::Literal("operator++"), operator_21842, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6572, type_71), Reflex::Literal("operator++"), operator_21843, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30211), Reflex::Literal("operator--"), operator_21844, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6572, type_71), Reflex::Literal("operator--"), operator_21845, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8858, type_30214), Reflex::Literal("operator[]"), operator_21846, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30211, type_30214), Reflex::Literal("operator+="), operator_21847, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6572, type_30214), Reflex::Literal("operator+"), operator_21848, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30211, type_30214), Reflex::Literal("operator-="), operator_21849, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6572, type_30214), Reflex::Literal("operator-"), operator_21850, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30213), Reflex::Literal("base"), method_21851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > -------------------------------
static void destructor_21860(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >::~__normal_iterator)();
}
static  void operator_21861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)arg[0]);
}

static void constructor_21862( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)arg[0]);
}

static void constructor_21863( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >();
}

static void constructor_21864( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >(*(const ::pat::TriggerCondition* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >(*(const ::pat::TriggerCondition* const*)arg[0]);
}

static  void operator_21865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator*)();
}

static  void operator_21866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator->)();
}

static  void operator_21867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator++)();
}

static  void operator_21868( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >)((((::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_21869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator--)();
}

static  void operator_21870( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >)((((::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_21871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21872( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21873( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >)((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21874( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21875( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >)((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_21876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >*)o)->base)();
}

static void method_newdel_6573( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2340, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >::__traits_type"))
  .AddTypedef(type_8867, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >::iterator_type"))
  .AddTypedef(type_2391, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >::iterator_category"))
  .AddTypedef(type_7332, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >::value_type"))
  .AddTypedef(type_2844, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >::difference_type"))
  .AddTypedef(type_8869, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >::reference"))
  .AddTypedef(type_8867, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_21860, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30215, type_30216), Reflex::Literal("operator="), operator_21861, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30216), Reflex::Literal("__normal_iterator"), constructor_21862, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_21863, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30217), Reflex::Literal("__normal_iterator"), constructor_21864, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6573, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8867, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8869), Reflex::Literal("operator*"), operator_21865, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8867), Reflex::Literal("operator->"), operator_21866, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30215), Reflex::Literal("operator++"), operator_21867, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6573, type_71), Reflex::Literal("operator++"), operator_21868, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30215), Reflex::Literal("operator--"), operator_21869, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6573, type_71), Reflex::Literal("operator--"), operator_21870, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8869, type_30214), Reflex::Literal("operator[]"), operator_21871, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30215, type_30214), Reflex::Literal("operator+="), operator_21872, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6573, type_30214), Reflex::Literal("operator+"), operator_21873, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30215, type_30214), Reflex::Literal("operator-="), operator_21874, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6573, type_30214), Reflex::Literal("operator-"), operator_21875, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30217), Reflex::Literal("base"), method_21876, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------------------
static void destructor_22010(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >::~__normal_iterator)();
}
static  void operator_22011( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)arg[0]);
}

static void constructor_22012( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)arg[0]);
}

static void constructor_22013( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >();
}

static void constructor_22014( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >(*(const ::pat::TriggerObject* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >(*(const ::pat::TriggerObject* const*)arg[0]);
}

static  void operator_22015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator*)();
}

static  void operator_22016( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator->)();
}

static  void operator_22017( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator++)();
}

static  void operator_22018( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >)((((::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_22019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator--)();
}

static  void operator_22020( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >)((((::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_22021( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_22022( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_22023( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >)((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_22024( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_22025( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >)((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_22026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >*)o)->base)();
}

static void method_newdel_6579( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2346, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >::__traits_type"))
  .AddTypedef(type_8933, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >::iterator_type"))
  .AddTypedef(type_2391, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >::iterator_category"))
  .AddTypedef(type_7357, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >::value_type"))
  .AddTypedef(type_2844, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >::difference_type"))
  .AddTypedef(type_8935, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >::reference"))
  .AddTypedef(type_8933, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_22010, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30232, type_30233), Reflex::Literal("operator="), operator_22011, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30233), Reflex::Literal("__normal_iterator"), constructor_22012, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_22013, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30234), Reflex::Literal("__normal_iterator"), constructor_22014, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6579, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8933, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8935), Reflex::Literal("operator*"), operator_22015, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8933), Reflex::Literal("operator->"), operator_22016, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30232), Reflex::Literal("operator++"), operator_22017, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6579, type_71), Reflex::Literal("operator++"), operator_22018, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30232), Reflex::Literal("operator--"), operator_22019, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6579, type_71), Reflex::Literal("operator--"), operator_22020, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8935, type_30214), Reflex::Literal("operator[]"), operator_22021, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30232, type_30214), Reflex::Literal("operator+="), operator_22022, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6579, type_30214), Reflex::Literal("operator+"), operator_22023, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30232, type_30214), Reflex::Literal("operator-="), operator_22024, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6579, type_30214), Reflex::Literal("operator-"), operator_22025, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30234), Reflex::Literal("base"), method_22026, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > -------------------------------
static void destructor_21935(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >::~__normal_iterator)();
}
static  void operator_21936( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)arg[0]);
}

static void constructor_21937( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)arg[0]);
}

static void constructor_21938( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >();
}

static void constructor_21939( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >(*(const ::pat::TriggerFilter* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >(*(const ::pat::TriggerFilter* const*)arg[0]);
}

static  void operator_21940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator*)();
}

static  void operator_21941( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator->)();
}

static  void operator_21942( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator++)();
}

static  void operator_21943( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >)((((::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_21944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator--)();
}

static  void operator_21945( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >)((((::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_21946( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21947( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21948( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >)((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21950( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >)((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_21951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >*)o)->base)();
}

static void method_newdel_6576( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2343, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >::__traits_type"))
  .AddTypedef(type_8900, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >::iterator_type"))
  .AddTypedef(type_2391, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >::iterator_category"))
  .AddTypedef(type_7359, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >::value_type"))
  .AddTypedef(type_2844, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >::difference_type"))
  .AddTypedef(type_8902, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >::reference"))
  .AddTypedef(type_8900, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_21935, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30224, type_30225), Reflex::Literal("operator="), operator_21936, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30225), Reflex::Literal("__normal_iterator"), constructor_21937, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_21938, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30226), Reflex::Literal("__normal_iterator"), constructor_21939, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6576, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8900, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8902), Reflex::Literal("operator*"), operator_21940, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8900), Reflex::Literal("operator->"), operator_21941, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30224), Reflex::Literal("operator++"), operator_21942, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6576, type_71), Reflex::Literal("operator++"), operator_21943, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30224), Reflex::Literal("operator--"), operator_21944, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6576, type_71), Reflex::Literal("operator--"), operator_21945, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8902, type_30214), Reflex::Literal("operator[]"), operator_21946, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30224, type_30214), Reflex::Literal("operator+="), operator_21947, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6576, type_30214), Reflex::Literal("operator+"), operator_21948, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30224, type_30214), Reflex::Literal("operator-="), operator_21949, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6576, type_30214), Reflex::Literal("operator-"), operator_21950, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30226), Reflex::Literal("base"), method_21951, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------------------
static void destructor_21960(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >::~__normal_iterator)();
}
static  void operator_21961( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static void constructor_21962( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static void constructor_21963( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >();
}

static void constructor_21964( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >(*(const ::pat::TriggerObjectStandAlone* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >(*(const ::pat::TriggerObjectStandAlone* const*)arg[0]);
}

static  void operator_21965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator*)();
}

static  void operator_21966( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator->)();
}

static  void operator_21967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator++)();
}

static  void operator_21968( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >)((((::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_21969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator--)();
}

static  void operator_21970( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >)((((::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_21971( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21972( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >)((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >)((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_21976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >*)o)->base)();
}

static void method_newdel_6577( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2344, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >::__traits_type"))
  .AddTypedef(type_8911, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >::iterator_type"))
  .AddTypedef(type_2391, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >::iterator_category"))
  .AddTypedef(type_7344, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >::value_type"))
  .AddTypedef(type_2844, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >::difference_type"))
  .AddTypedef(type_8913, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >::reference"))
  .AddTypedef(type_8911, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_21960, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30227, type_30228), Reflex::Literal("operator="), operator_21961, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30228), Reflex::Literal("__normal_iterator"), constructor_21962, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_21963, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30229), Reflex::Literal("__normal_iterator"), constructor_21964, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6577, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8911, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8913), Reflex::Literal("operator*"), operator_21965, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8911), Reflex::Literal("operator->"), operator_21966, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30227), Reflex::Literal("operator++"), operator_21967, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6577, type_71), Reflex::Literal("operator++"), operator_21968, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30227), Reflex::Literal("operator--"), operator_21969, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6577, type_71), Reflex::Literal("operator--"), operator_21970, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8913, type_30214), Reflex::Literal("operator[]"), operator_21971, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30227, type_30214), Reflex::Literal("operator+="), operator_21972, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6577, type_30214), Reflex::Literal("operator+"), operator_21973, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30227, type_30214), Reflex::Literal("operator-="), operator_21974, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6577, type_30214), Reflex::Literal("operator-"), operator_21975, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30229), Reflex::Literal("base"), method_21976, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > -------------------------------
static void destructor_21910(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >::~__normal_iterator)();
}
static  void operator_21911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)arg[0]);
}

static void constructor_21912( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >(*(const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)arg[0]);
}

static void constructor_21913( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >();
}

static void constructor_21914( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >(*(const ::pat::TriggerPath* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >(*(const ::pat::TriggerPath* const*)arg[0]);
}

static  void operator_21915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator*)();
}

static  void operator_21916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator->)();
}

static  void operator_21917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator++)();
}

static  void operator_21918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >)((((::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_21919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator--)();
}

static  void operator_21920( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >)((((::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_21921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21923( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >)((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >)((((const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_21926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >*)o)->base)();
}

static void method_newdel_6575( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2342, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >::__traits_type"))
  .AddTypedef(type_8889, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >::iterator_type"))
  .AddTypedef(type_2391, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >::iterator_category"))
  .AddTypedef(type_7348, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >::value_type"))
  .AddTypedef(type_2844, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >::difference_type"))
  .AddTypedef(type_8891, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >::reference"))
  .AddTypedef(type_8889, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_21910, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30221, type_30222), Reflex::Literal("operator="), operator_21911, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30222), Reflex::Literal("__normal_iterator"), constructor_21912, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_21913, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30223), Reflex::Literal("__normal_iterator"), constructor_21914, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6575, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8889, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8891), Reflex::Literal("operator*"), operator_21915, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8889), Reflex::Literal("operator->"), operator_21916, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30221), Reflex::Literal("operator++"), operator_21917, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6575, type_71), Reflex::Literal("operator++"), operator_21918, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30221), Reflex::Literal("operator--"), operator_21919, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6575, type_71), Reflex::Literal("operator--"), operator_21920, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8891, type_30214), Reflex::Literal("operator[]"), operator_21921, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30221, type_30214), Reflex::Literal("operator+="), operator_21922, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6575, type_30214), Reflex::Literal("operator+"), operator_21923, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30221, type_30214), Reflex::Literal("operator-="), operator_21924, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6575, type_30214), Reflex::Literal("operator-"), operator_21925, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30223), Reflex::Literal("base"), method_21926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class _Rb_tree_const_iterator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > > -------------------------------
static void destructor_13814(void*, void * o, const std::vector<void*>&, void *) {
(((::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::~_Rb_tree_const_iterator)();
}
static  void operator_13815( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator=)(*(const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0]);
  else   (((::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator=)(*(const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0]);
}

static void constructor_13816( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >(*(const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0]);
  else ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >(*(const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0]);
}

static void constructor_13817( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >();
  else ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >();
}

static void constructor_13818( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >((const ::std::_Rb_tree_node<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0]);
  else ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >((const ::std::_Rb_tree_node<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0]);
}

static void constructor_13819( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >(*(const ::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0]);
  else ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >(*(const ::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0]);
}

static  void method_13820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >)((((const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->_M_const_cast)());
  else   (((const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->_M_const_cast)();
}

static  void operator_13821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator*)();
  else   (((const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator*)();
}

static  void operator_13822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator->)());
  else   (((const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator->)();
}

static  void operator_13823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator++)();
  else   (((::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator++)();
}

static  void operator_13824( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >)((((::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator++)(*(int*)arg[0]));
  else   (((::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_13825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator--)();
  else   (((::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator--)();
}

static  void operator_13826( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >)((((::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator--)(*(int*)arg[0]));
  else   (((::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_13827( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator==)(*(const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0]));
  else   (((const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator==)(*(const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0]);
}

static  void operator_13828( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator!=)(*(const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0]));
  else   (((const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)o)->operator!=)(*(const ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >*)arg[0]);
}

static void method_newdel_2928( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Rb_tree_const_iterator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > > -------------------------------
void __std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__db_datamem(Reflex::Class*);
void __std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__datamem_bld(&__std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__funcmem_bld(&__std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__db_funcmem);
void __std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >"), typeid(::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >), sizeof(::std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_2719, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::value_type"))
  .AddTypedef(type_9894, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::reference"))
  .AddTypedef(type_9890, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::pointer"))
  .AddTypedef(type_2819, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::iterator"))
  .AddTypedef(type_2448, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::iterator_category"))
  .AddTypedef(type_2844, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::difference_type"))
  .AddTypedef(type_9666, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::_Base_ptr"))
  .AddTypedef(type_9898, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > >::_Link_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Rb_tree_const_iterator"), destructor_13814, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26656, type_26657), Reflex::Literal("operator="), operator_13815, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26657), Reflex::Literal("_Rb_tree_const_iterator"), constructor_13816, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Rb_tree_const_iterator"), constructor_13817, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9898), Reflex::Literal("_Rb_tree_const_iterator"), constructor_13818, 0, "__x", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26658), Reflex::Literal("_Rb_tree_const_iterator"), constructor_13819, 0, "__it", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2928, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class _Rb_tree_const_iterator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > > -------------------
void __std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9666, Reflex::Literal("_M_node"), OffsetOf(__shadow__::__std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s_, _M_node), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Rb_tree_const_iterator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::RefProd<edm::Association<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > > > -------------------
void __std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2819), Reflex::Literal("_M_const_cast"), method_13820, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9894), Reflex::Literal("operator*"), operator_13821, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9890), Reflex::Literal("operator->"), operator_13822, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26656), Reflex::Literal("operator++"), operator_13823, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2928, type_71), Reflex::Literal("operator++"), operator_13824, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26656), Reflex::Literal("operator--"), operator_13825, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2928, type_71), Reflex::Literal("operator--"), operator_13826, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_26657), Reflex::Literal("operator=="), operator_13827, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_26657), Reflex::Literal("operator!="), operator_13828, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > -------------------------------
static void destructor_10829(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::~pair)();
}
static  void operator_10830( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
}

static void constructor_10831( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
}

static void constructor_10832( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >();
  else ::new(mem) ::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >();
}

static void constructor_10833( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[1]);
}

static void method_newdel_2713( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > -------------------------------
void __std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__datamem_bld(&__std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__funcmem_bld(&__std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_funcmem);
void __std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >"), typeid(::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >), sizeof(::std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("o_name"), "std::pair<std::string, pat::TriggerObjectRef>")
  .AddTypedef(type_2328, Reflex::Literal("std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::first_type"))
  .AddTypedef(type_4344, Reflex::Literal("std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_10829, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26449, type_26450), Reflex::Literal("operator="), operator_10830, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26450), Reflex::Literal("pair"), constructor_10831, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_10832, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8978, type_26451), Reflex::Literal("pair"), constructor_10833, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2713, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > -------------------
void __std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2328, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_4344, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > -------------------
void __std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
static void constructor_11812( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<bool,std::basic_string<char> > >();
  else ::new(mem) ::std::vector<std::pair<bool,std::basic_string<char> > >();
}

static void constructor_11813( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<bool,std::basic_string<char> > >(*(const ::std::allocator<std::pair<bool,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<bool,std::basic_string<char> > >(*(const ::std::allocator<std::pair<bool,std::basic_string<char> > >*)arg[0]);
}

static void constructor_11814( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<bool,std::basic_string<char> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<bool,std::basic_string<char> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<bool,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<bool,std::basic_string<char> >*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<bool,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<bool,std::basic_string<char> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<bool,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<bool,std::basic_string<char> >*)arg[1],
      *(const ::std::allocator<std::pair<bool,std::basic_string<char> > >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<bool,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<bool,std::basic_string<char> >*)arg[1],
      *(const ::std::allocator<std::pair<bool,std::basic_string<char> > >*)arg[2]);
  }
}

static void constructor_11815( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<bool,std::basic_string<char> > >(*(const ::std::vector<std::pair<bool,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<bool,std::basic_string<char> > >(*(const ::std::vector<std::pair<bool,std::basic_string<char> > >*)arg[0]);
}

static void destructor_11816(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->::std::vector<std::pair<bool,std::basic_string<char> > >::~vector)();
}
static  void operator_11817( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->operator=)(*(const ::std::vector<std::pair<bool,std::basic_string<char> > >*)arg[0]);
  else   (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->operator=)(*(const ::std::vector<std::pair<bool,std::basic_string<char> > >*)arg[0]);
}

static  void method_11818( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<bool,std::basic_string<char> >*)arg[1]);
}

static  void method_11819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >)((((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->begin)());
  else   (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->begin)();
}

static  void method_11820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >)((((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->begin)());
  else   (((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->begin)();
}

static  void method_11821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >)((((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->end)());
  else   (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->end)();
}

static  void method_11822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >)((((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->end)());
  else   (((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->end)();
}

static  void method_11827( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->size)());
  else   (((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->size)();
}

static  void method_11828( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->max_size)();
}

static  void method_11829( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<bool,std::basic_string<char> >*)arg[1]);
  }
}

static  void method_11830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->capacity)();
}

static  void method_11831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->empty)());
  else   (((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->empty)();
}

static  void method_11832( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_11833( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_11836( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11837( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->front)();
  else   (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->front)();
}

static  void method_11839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->front)();
  else   (((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->front)();
}

static  void method_11840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->back)();
  else   (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->back)();
}

static  void method_11841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->back)();
  else   (((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->back)();
}

static  void method_11842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->data)());
  else   (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->data)();
}

static  void method_11843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->data)());
  else   (((const ::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->data)();
}

static  void method_11844( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->push_back)(*(const ::std::pair<bool,std::basic_string<char> >*)arg[0]);
}

static  void method_11845( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->pop_back)();
}

static  void method_11846( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >)((((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)arg[0],
    *(const ::std::pair<bool,std::basic_string<char> >*)arg[1]));
  else   (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)arg[0],
    *(const ::std::pair<bool,std::basic_string<char> >*)arg[1]);
}

static  void method_11847( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<bool,std::basic_string<char> >*)arg[2]);
}

static  void method_11848( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >)((((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)arg[0]));
  else   (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)arg[0]);
}

static  void method_11849( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >)((((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)arg[1]));
  else   (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)arg[1]);
}

static  void method_11850( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->swap)(*(::std::vector<std::pair<bool,std::basic_string<char> > >*)arg[0]);
}

static  void method_11851( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<bool,std::basic_string<char> > >*)o)->clear)();
}

static void method_newdel_2759( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<bool,std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<bool,std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<bool,std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<bool,std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<bool,std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x93( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<bool,std::basic_string<char> >,std::allocator<std::pair<bool,std::basic_string<char> > > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<bool,std::basic_string<char> > >,::std::_Vector_base<std::pair<bool,std::basic_string<char> >,std::allocator<std::pair<bool,std::basic_string<char> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x94( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<bool,std::basic_string<char> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<bool,std::basic_string<char> > > >::Generate();
}

//------Dictionary for class vector<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
void __std__vector_std__pair_bool_std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_bool_std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_bool_std__basic_string_char_s_s__datamem_bld(&__std__vector_std__pair_bool_std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_bool_std__basic_string_char_s_s__funcmem_bld(&__std__vector_std__pair_bool_std__basic_string_char_s_s__db_funcmem);
void __std__vector_std__pair_bool_std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >"), typeid(::std::vector<std::pair<bool,std::basic_string<char> > >), sizeof(::std::vector<std::pair<bool,std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "std::vector<pat::L1Seed>")
  .AddBase(type_2284, ::Reflex::BaseOffset< ::std::vector<std::pair<bool,std::basic_string<char> > >, ::std::_Vector_base<std::pair<bool,std::basic_string<char> >,std::allocator<std::pair<bool,std::basic_string<char> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2722, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::_Alloc_value_type"))
  .AddTypedef(type_2284, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::_Base"))
  .AddTypedef(type_2961, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::_Tp_alloc_type"))
  .AddTypedef(type_6702, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::_Alloc_traits"))
  .AddTypedef(type_2722, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::value_type"))
  .AddTypedef(type_7951, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::pointer"))
  .AddTypedef(type_8878, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::const_pointer"))
  .AddTypedef(type_11802, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::reference"))
  .AddTypedef(type_8880, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::const_reference"))
  .AddTypedef(type_6584, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::iterator"))
  .AddTypedef(type_6574, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::const_iterator"))
  .AddTypedef(type_3104, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::const_reverse_iterator"))
  .AddTypedef(type_3105, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::reverse_iterator"))
  .AddTypedef(type_2926, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::size_type"))
  .AddTypedef(type_2844, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::difference_type"))
  .AddTypedef(type_2961, Reflex::Literal("std::vector<std::pair<bool,std::basic_string<char> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_11812, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25511), Reflex::Literal("vector"), constructor_11813, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2926, type_8880, type_25511), Reflex::Literal("vector"), constructor_11814, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26482), Reflex::Literal("vector"), constructor_11815, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_11816, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2759, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x93, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x94, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_bool_std__basic_string_char_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__vector_std__pair_bool_std__basic_string_char_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__vector_std__pair_bool_std__basic_string_char_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26483, type_26482), Reflex::Literal("operator="), operator_11817, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926, type_8880), Reflex::Literal("assign"), method_11818, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6584), Reflex::Literal("begin"), method_11819, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6574), Reflex::Literal("begin"), method_11820, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6584), Reflex::Literal("end"), method_11821, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6574), Reflex::Literal("end"), method_11822, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("size"), method_11827, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("max_size"), method_11828, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926, type_2722), Reflex::Literal("resize"), method_11829, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("capacity"), method_11830, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_11831, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2926), Reflex::Literal("reserve"), method_11832, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11802, type_2926), Reflex::Literal("operator[]"), operator_11833, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8880, type_2926), Reflex::Literal("operator[]"), operator_11834, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11802, type_2926), Reflex::Literal("at"), method_11836, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8880, type_2926), Reflex::Literal("at"), method_11837, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11802), Reflex::Literal("front"), method_11838, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8880), Reflex::Literal("front"), method_11839, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11802), Reflex::Literal("back"), method_11840, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8880), Reflex::Literal("back"), method_11841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7951), Reflex::Literal("data"), method_11842, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8878), Reflex::Literal("data"), method_11843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_8880), Reflex::Literal("push_back"), method_11844, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("pop_back"), method_11845, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6584, type_6584, type_8880), Reflex::Literal("insert"), method_11846, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_6584, type_2926, type_8880), Reflex::Literal("insert"), method_11847, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6584, type_6584), Reflex::Literal("erase"), method_11848, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6584, type_6584, type_6584), Reflex::Literal("erase"), method_11849, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_26483), Reflex::Literal("swap"), method_11850, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_11851, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > > > -------------------------------
static void destructor_13417(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::~map)();
}
static void constructor_13418( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >();
  else ::new(mem) ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >();
}

static void constructor_13419( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >*)arg[1]);
  else ::new(mem) ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >*)arg[1]);
  }
}

static void constructor_13420( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
}

static  void operator_13421( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
  else   (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
}

static  void method_13422( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >)((((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->get_allocator)());
  else   (((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->get_allocator)();
}

static  void method_13423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >)((((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->begin)());
  else   (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->begin)();
}

static  void method_13424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >)((((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->begin)());
  else   (((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->begin)();
}

static  void method_13425( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >)((((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->end)());
  else   (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->end)();
}

static  void method_13426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >)((((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->end)());
  else   (((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->end)();
}

static  void method_13431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->empty)());
  else   (((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->empty)();
}

static  void method_13432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->size)());
  else   (((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->size)();
}

static  void method_13433( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->max_size)());
  else   (((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->max_size)();
}

static  void operator_13434( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13435( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13436( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13437( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >,bool>)((((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
}

static  void method_13438( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >)((((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[1]));
  else   (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[1]);
}

static  void method_13439( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >*)arg[0]);
}

static  void method_13440( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13441( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >*)arg[1]);
}

static  void method_13442( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->swap)(*(::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
}

static  void method_13443( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->clear)();
}

static  void method_13444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->key_comp)());
  else   (((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->key_comp)();
}

static  void method_13446( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >)((((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13447( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >)((((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13448( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13449( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >)((((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13450( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >)((((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13451( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >)((((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13452( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >)((((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13453( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > > >)((((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > > >)((((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_2866( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x96( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::Generate();
  else ::Reflex::Proxy< ::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::Generate();
}

//------Dictionary for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > > > -------------------------------
void __std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_datamem(Reflex::Class*);
void __std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__datamem_bld(&__std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__funcmem_bld(&__std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_funcmem);
void __std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >"), typeid(::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >), sizeof(::std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "std::map<std::string, pat::TriggerObjectRef>")
  .AddTypedef(type_2328, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::key_type"))
  .AddTypedef(type_4344, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::mapped_type"))
  .AddTypedef(type_2709, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::value_type"))
  .AddTypedef(type_2439, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::key_compare"))
  .AddTypedef(type_2952, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::allocator_type"))
  .AddTypedef(type_2709, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::_Alloc_value_type"))
  .AddTypedef(type_2952, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::_Pair_alloc_type"))
  .AddTypedef(type_2481, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::_Rep_type"))
  .AddTypedef(type_9670, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::pointer"))
  .AddTypedef(type_9672, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::const_pointer"))
  .AddTypedef(type_9674, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::reference"))
  .AddTypedef(type_9676, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::const_reference"))
  .AddTypedef(type_2820, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::iterator"))
  .AddTypedef(type_2929, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::const_iterator"))
  .AddTypedef(type_2926, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::size_type"))
  .AddTypedef(type_2844, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::difference_type"))
  .AddTypedef(type_3093, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::reverse_iterator"))
  .AddTypedef(type_3092, Reflex::Literal("std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_13417, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_13418, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26205, type_26276), Reflex::Literal("map"), constructor_13419, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26601), Reflex::Literal("map"), constructor_13420, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2866, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x96, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__funcmem_bld);
}

//------Delayed data member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > > > -------------------
void __std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2481, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > > > -------------------
void __std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26602, type_26601), Reflex::Literal("operator="), operator_13421, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2952), Reflex::Literal("get_allocator"), method_13422, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2820), Reflex::Literal("begin"), method_13423, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2929), Reflex::Literal("begin"), method_13424, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2820), Reflex::Literal("end"), method_13425, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2929), Reflex::Literal("end"), method_13426, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("empty"), method_13431, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("size"), method_13432, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926), Reflex::Literal("max_size"), method_13433, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10372, type_8978), Reflex::Literal("operator[]"), operator_13434, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10372, type_8978), Reflex::Literal("at"), method_13435, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26451, type_8978), Reflex::Literal("at"), method_13436, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2711, type_9676), Reflex::Literal("insert"), method_13437, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2820, type_2820, type_9676), Reflex::Literal("insert"), method_13438, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2820), Reflex::Literal("erase"), method_13439, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926, type_8978), Reflex::Literal("erase"), method_13440, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_2820, type_2820), Reflex::Literal("erase"), method_13441, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_26602), Reflex::Literal("swap"), method_13442, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601), Reflex::Literal("clear"), method_13443, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2439), Reflex::Literal("key_comp"), method_13444, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2820, type_8978), Reflex::Literal("find"), method_13446, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2929, type_8978), Reflex::Literal("find"), method_13447, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2926, type_8978), Reflex::Literal("count"), method_13448, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2820, type_8978), Reflex::Literal("lower_bound"), method_13449, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2929, type_8978), Reflex::Literal("lower_bound"), method_13450, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2820, type_8978), Reflex::Literal("upper_bound"), method_13451, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2929, type_8978), Reflex::Literal("upper_bound"), method_13452, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2710, type_8978), Reflex::Literal("equal_range"), method_13453, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2708, type_8978), Reflex::Literal("equal_range"), method_13454, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > > -------------------------------
static void constructor_17926( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >();
}

static void constructor_17927( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >(*(::std::auto_ptr<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >(*(::std::auto_ptr<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)arg[0]);
}

static void destructor_17928(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >::~Wrapper)();
}
static  void method_17929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->product)();
}

static  void operator_17930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->operator->)();
}

static  void method_17931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->productTypeInfo)();
}

static  void method_17932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->typeInfo)();
}

static void constructor_17933( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >((::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >((::edm::RefProd<std::vector<pat::TriggerAlgorithm> >*)arg[0]);
}

static  void method_17934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->getInterface)();
}

static  void method_17935( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17936( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17937( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->dynamicTypeInfo)();
}

static  void method_17939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->isPresent)();
}

static  void method_17940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4132( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > > -------------------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s__datamem_bld(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s__funcmem_bld(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s__db_funcmem);
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >"), typeid(::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >), sizeof(::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::TriggerAlgorithmRefProd >")
  .AddTypedef(type_4308, Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >::value_type"))
  .AddTypedef(type_4308, Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17926, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2524), Reflex::Literal("Wrapper"), constructor_17927, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17928, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29246), Reflex::Literal("Wrapper"), constructor_17933, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4132, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > > -------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4308, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm, std::allocator<pat::TriggerAlgorithm> > > > -------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29245), Reflex::Literal("product"), method_17929, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29245), Reflex::Literal("operator->"), operator_17930, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_17931, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_17932, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29247), Reflex::Literal("getInterface"), method_17934, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_17935, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_17936, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_17937, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_17938, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_17939, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_17940, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefProd<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > > -------------------------------
static void constructor_17968( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >();
}

static void constructor_17969( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >(*(::std::auto_ptr<edm::RefProd<std::vector<pat::TriggerCondition> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >(*(::std::auto_ptr<edm::RefProd<std::vector<pat::TriggerCondition> > >*)arg[0]);
}

static void destructor_17970(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >::~Wrapper)();
}
static  void method_17971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->product)();
}

static  void operator_17972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->operator->)();
}

static  void method_17973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->productTypeInfo)();
}

static  void method_17974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->typeInfo)();
}

static void constructor_17975( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >((::edm::RefProd<std::vector<pat::TriggerCondition> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >((::edm::RefProd<std::vector<pat::TriggerCondition> >*)arg[0]);
}

static  void method_17976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->getInterface)();
}

static  void method_17977( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17978( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17979( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->dynamicTypeInfo)();
}

static  void method_17981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->isPresent)();
}

static  void method_17982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4134( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefProd<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > > -------------------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s__datamem_bld(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s__funcmem_bld(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s__db_funcmem);
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >"), typeid(::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >), sizeof(::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::TriggerConditionRefProd >")
  .AddTypedef(type_4307, Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >::value_type"))
  .AddTypedef(type_4307, Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17968, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2527), Reflex::Literal("Wrapper"), constructor_17969, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17970, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29255), Reflex::Literal("Wrapper"), constructor_17975, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4134, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefProd<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > > -------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4307, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefProd<std::vector<pat::TriggerCondition, std::allocator<pat::TriggerCondition> > > > -------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29254), Reflex::Literal("product"), method_17971, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29254), Reflex::Literal("operator->"), operator_17972, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_17973, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_17974, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29256), Reflex::Literal("getInterface"), method_17976, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_17977, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_17978, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_17979, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_17980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_17981, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_17982, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefProd<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > > -------------------------------
static void constructor_18010( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >();
}

static void constructor_18011( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >(*(::std::auto_ptr<edm::RefProd<std::vector<pat::TriggerPath> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >(*(::std::auto_ptr<edm::RefProd<std::vector<pat::TriggerPath> > >*)arg[0]);
}

static void destructor_18012(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >::~Wrapper)();
}
static  void method_18013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->product)();
}

static  void operator_18014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->operator->)();
}

static  void method_18015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->productTypeInfo)();
}

static  void method_18016( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->typeInfo)();
}

static void constructor_18017( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >((::edm::RefProd<std::vector<pat::TriggerPath> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >((::edm::RefProd<std::vector<pat::TriggerPath> >*)arg[0]);
}

static  void method_18018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->getInterface)();
}

static  void method_18019( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18020( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18021( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->dynamicTypeInfo)();
}

static  void method_18023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->isPresent)();
}

static  void method_18024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4136( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefProd<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > > -------------------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s__datamem_bld(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s__funcmem_bld(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s__db_funcmem);
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >"), typeid(::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >), sizeof(::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::TriggerPathRefProd >")
  .AddTypedef(type_4306, Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >::value_type"))
  .AddTypedef(type_4306, Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18010, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2530), Reflex::Literal("Wrapper"), constructor_18011, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18012, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29264), Reflex::Literal("Wrapper"), constructor_18017, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4136, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefProd<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > > -------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4306, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefProd<std::vector<pat::TriggerPath, std::allocator<pat::TriggerPath> > > > -------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29263), Reflex::Literal("product"), method_18013, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29263), Reflex::Literal("operator->"), operator_18014, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_18015, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_18016, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29265), Reflex::Literal("getInterface"), method_18018, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_18019, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_18020, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_18021, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_18022, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_18023, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_18024, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefProd<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > > -------------------------------
static void constructor_18052( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >();
}

static void constructor_18053( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >(*(::std::auto_ptr<edm::RefProd<std::vector<pat::TriggerFilter> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >(*(::std::auto_ptr<edm::RefProd<std::vector<pat::TriggerFilter> > >*)arg[0]);
}

static void destructor_18054(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >::~Wrapper)();
}
static  void method_18055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->product)();
}

static  void operator_18056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->operator->)();
}

static  void method_18057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->productTypeInfo)();
}

static  void method_18058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->typeInfo)();
}

static void constructor_18059( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >((::edm::RefProd<std::vector<pat::TriggerFilter> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >((::edm::RefProd<std::vector<pat::TriggerFilter> >*)arg[0]);
}

static  void method_18060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->getInterface)();
}

static  void method_18061( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18062( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18063( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->dynamicTypeInfo)();
}

static  void method_18065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->isPresent)();
}

static  void method_18066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4138( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefProd<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > > -------------------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s__datamem_bld(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s__funcmem_bld(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s__db_funcmem);
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >"), typeid(::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >), sizeof(::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::TriggerFilterRefProd >")
  .AddTypedef(type_4305, Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >::value_type"))
  .AddTypedef(type_4305, Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18052, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2533), Reflex::Literal("Wrapper"), constructor_18053, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18054, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29273), Reflex::Literal("Wrapper"), constructor_18059, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4138, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefProd<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > > -------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4305, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefProd<std::vector<pat::TriggerFilter, std::allocator<pat::TriggerFilter> > > > -------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29272), Reflex::Literal("product"), method_18055, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29272), Reflex::Literal("operator->"), operator_18056, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_18057, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_18058, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29274), Reflex::Literal("getInterface"), method_18060, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_18061, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_18062, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_18063, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_18064, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_18065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_18066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > > -------------------------------
static void constructor_18115( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >();
}

static void constructor_18116( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >(*(::std::auto_ptr<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >(*(::std::auto_ptr<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)arg[0]);
}

static void destructor_18117(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >::~Wrapper)();
}
static  void method_18118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->product)();
}

static  void operator_18119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->operator->)();
}

static  void method_18120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->productTypeInfo)();
}

static  void method_18121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->typeInfo)();
}

static void constructor_18122( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >((::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >((::edm::RefProd<std::vector<pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void method_18123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->getInterface)();
}

static  void method_18124( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18125( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18126( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->dynamicTypeInfo)();
}

static  void method_18128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->isPresent)();
}

static  void method_18129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4141( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > > -------------------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s__datamem_bld(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s__funcmem_bld(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s__db_funcmem);
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >"), typeid(::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >), sizeof(::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::TriggerObjectStandAloneRefProd>")
  .AddTypedef(type_4302, Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >::value_type"))
  .AddTypedef(type_4302, Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18115, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2540), Reflex::Literal("Wrapper"), constructor_18116, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18117, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29287), Reflex::Literal("Wrapper"), constructor_18122, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4141, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > > -------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4302, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> > > > -------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29286), Reflex::Literal("product"), method_18118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29286), Reflex::Literal("operator->"), operator_18119, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_18120, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_18121, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29288), Reflex::Literal("getInterface"), method_18123, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_18124, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_18125, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_18126, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_18127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_18128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_18129, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefProd<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > -------------------------------
static void constructor_18199( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >();
}

static void constructor_18200( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >(*(::std::auto_ptr<edm::RefProd<std::vector<pat::TriggerObject> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >(*(::std::auto_ptr<edm::RefProd<std::vector<pat::TriggerObject> > >*)arg[0]);
}

static void destructor_18201(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >::~Wrapper)();
}
static  void method_18202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->product)();
}

static  void operator_18203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->operator->)();
}

static  void method_18204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->productTypeInfo)();
}

static  void method_18205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->typeInfo)();
}

static void constructor_18206( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >((::edm::RefProd<std::vector<pat::TriggerObject> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >((::edm::RefProd<std::vector<pat::TriggerObject> >*)arg[0]);
}

static  void method_18207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->getInterface)();
}

static  void method_18208( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18209( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18210( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->dynamicTypeInfo)();
}

static  void method_18212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->isPresent)();
}

static  void method_18213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4145( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefProd<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > -------------------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s__datamem_bld(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s__funcmem_bld(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s__db_funcmem);
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >"), typeid(::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >), sizeof(::edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::TriggerObjectRefProd>")
  .AddTypedef(type_4303, Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >::value_type"))
  .AddTypedef(type_4303, Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18199, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2545), Reflex::Literal("Wrapper"), constructor_18200, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18201, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29306), Reflex::Literal("Wrapper"), constructor_18206, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4145, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefProd<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > -------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1454, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4303, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefProd<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> > > > -------------------
void __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29305), Reflex::Literal("product"), method_18202, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29305), Reflex::Literal("operator->"), operator_18203, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("productTypeInfo"), method_18204, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("typeInfo"), method_18205, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29307), Reflex::Literal("getInterface"), method_18207, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15634, type_26466, type_28869), Reflex::Literal("fillView"), method_18208, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_281, type_9167), Reflex::Literal("setPtr"), method_18209, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_15648, type_26467, type_26466), Reflex::Literal("fillPtrVector"), method_18210, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo"), method_18211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isPresent"), method_18212, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15648), Reflex::Literal("dynamicTypeInfo_"), method_18213, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >*,std::vector<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > -------------------------------
static void destructor_21885(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >::~__normal_iterator)();
}
static  void operator_21886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)arg[0]);
}

static void constructor_21887( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >(*(const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >(*(const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)arg[0]);
}

static void constructor_21888( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >();
}

static void constructor_21889( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >(*(const ::std::pair<bool,std::basic_string<char> >* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >(*(const ::std::pair<bool,std::basic_string<char> >* const*)arg[0]);
}

static  void operator_21890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator*)();
}

static  void operator_21891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator->)();
}

static  void operator_21892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator++)();
}

static  void operator_21893( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >)((((::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_21894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator--)();
}

static  void operator_21895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >)((((::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_21896( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21897( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21898( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >)((((const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21899( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_21900( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >)((((const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_21901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >*)o)->base)();
}

static void method_newdel_6574( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >*,std::vector<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > -------------------------------
void ____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s__datamem_bld(&____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s__funcmem_bld(&____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >"), typeid(::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >), sizeof(::__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "std::vector<pat::L1Seed>::const_iterator")
  .AddTypedef(type_2341, Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >::__traits_type"))
  .AddTypedef(type_8878, Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >::iterator_type"))
  .AddTypedef(type_2391, Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >::iterator_category"))
  .AddTypedef(type_2722, Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >::value_type"))
  .AddTypedef(type_2844, Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >::difference_type"))
  .AddTypedef(type_8880, Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >::reference"))
  .AddTypedef(type_8878, Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_21885, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30218, type_30219), Reflex::Literal("operator="), operator_21886, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30219), Reflex::Literal("__normal_iterator"), constructor_21887, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_21888, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30220), Reflex::Literal("__normal_iterator"), constructor_21889, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6574, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >*,std::vector<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > -------------------
void ____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8878, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >*,std::vector<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > -------------------
void ____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8880), Reflex::Literal("operator*"), operator_21890, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8878), Reflex::Literal("operator->"), operator_21891, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30218), Reflex::Literal("operator++"), operator_21892, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6574, type_71), Reflex::Literal("operator++"), operator_21893, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30218), Reflex::Literal("operator--"), operator_21894, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6574, type_71), Reflex::Literal("operator--"), operator_21895, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8880, type_30214), Reflex::Literal("operator[]"), operator_21896, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30218, type_30214), Reflex::Literal("operator+="), operator_21897, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6574, type_30214), Reflex::Literal("operator+"), operator_21898, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30218, type_30214), Reflex::Literal("operator-="), operator_21899, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6574, type_30214), Reflex::Literal("operator-"), operator_21900, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30220), Reflex::Literal("base"), method_21901, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > > -------------------------------
static  void operator_29337( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)arg[0]);
}

static void constructor_29338( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)arg[0]);
}

static void constructor_29339( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >();
}

static void constructor_29340( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >(*(const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >(*(const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void method_29341( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)arg[0]);
}

static void destructor_29342(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::~RefHolder)();
}
static  void method_29343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->clone)();
}

static  void method_29344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->id)();
}

static  void method_29345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->key)();
}

static  void method_29346( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_29347( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_29348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->getRef)();
}

static  void method_29349( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void method_29350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->makeVectorHolder)();
}

static  void method_29351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->productGetter)();
}

static  void method_29352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->hasProductCache)();
}

static  void method_29353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->product)();
}

static  void method_29354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->isAvailable)();
}

static  void method_29355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->Class_Version)();
}

static void method_newdel_18281( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x105( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<pat::TriggerObjectStandAloneRef>")
  .AddBase(type_10254, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33422, type_33423), Reflex::Literal("operator="), operator_29337, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33423), Reflex::Literal("RefHolder"), constructor_29338, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_29339, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29229), Reflex::Literal("RefHolder"), constructor_29340, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_29342, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_18281, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x105, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4346, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_33422), Reflex::Literal("swap"), method_29341, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16859), Reflex::Literal("clone"), method_29343, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_29344, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1924), Reflex::Literal("key"), method_29345, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_31203), Reflex::Literal("isEqualTo"), method_29346, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_16861, type_8988), Reflex::Literal("fillRefIfMyTypeMatches"), method_29347, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29229), Reflex::Literal("getRef"), method_29348, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_29229), Reflex::Literal("setRef"), method_29349, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2536), Reflex::Literal("makeVectorHolder"), method_29350, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_29351, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_29352, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3434), Reflex::Literal("product"), method_29353, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_29354, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_29355, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > -------------------------------
static  void operator_29358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
}

static void constructor_29359( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
}

static void constructor_29360( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >();
}

static void constructor_29361( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static  void method_29362( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
}

static void destructor_29363(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::~RefHolder)();
}
static  void method_29364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->clone)();
}

static  void method_29365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->id)();
}

static  void method_29366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->key)();
}

static  void method_29367( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_29368( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_29369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->getRef)();
}

static  void method_29370( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static  void method_29371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->makeVectorHolder)();
}

static  void method_29372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->productGetter)();
}

static  void method_29373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->hasProductCache)();
}

static  void method_29374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->product)();
}

static  void method_29375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->isAvailable)();
}

static  void method_29376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->Class_Version)();
}

static void method_newdel_18282( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x107( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<pat::TriggerObjectRef>")
  .AddBase(type_10254, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33424, type_33425), Reflex::Literal("operator="), operator_29358, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33425), Reflex::Literal("RefHolder"), constructor_29359, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_29360, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26451), Reflex::Literal("RefHolder"), constructor_29361, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_29363, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_18282, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x107, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4344, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_33424), Reflex::Literal("swap"), method_29362, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16859), Reflex::Literal("clone"), method_29364, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_29365, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1924), Reflex::Literal("key"), method_29366, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_31203), Reflex::Literal("isEqualTo"), method_29367, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_16861, type_8988), Reflex::Literal("fillRefIfMyTypeMatches"), method_29368, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26451), Reflex::Literal("getRef"), method_29369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_26451), Reflex::Literal("setRef"), method_29370, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2536), Reflex::Literal("makeVectorHolder"), method_29371, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_29372, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_29373, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3434), Reflex::Literal("product"), method_29374, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_29375, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_29376, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > > -------------------------------
static void constructor_29393( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >();
}

static void constructor_29394( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)arg[0]);
}

static void constructor_29395( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >(*(const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >(*(const ::edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*)arg[0]);
}

static  void operator_29396( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)arg[0]);
}

static  void method_29397( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)arg[0]);
}

static void destructor_29398(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::~Holder)();
}
static  void method_29399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->clone)();
}

static  void method_29400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->getPtr)();
}

static  void method_29401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->id)();
}

static  void method_29402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->key)();
}

static  void method_29403( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_29404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->getRef)();
}

static  void method_29405( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_29406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->holder)();
}

static  void method_29407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->makeVectorHolder)();
}

static  void method_29408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->makeVectorBaseHolder)();
}

static  void method_29409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->productGetter)();
}

static  void method_29410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->hasProductCache)();
}

static  void method_29411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->product)();
}

static  void method_29412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->isAvailable)();
}

static  void method_29413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >*)o)->Class_Version)();
}

static void method_newdel_18288( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x109( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Candidate,pat::TriggerObjectStandAloneRef>")
  .AddBase(type_18280, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_29393, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33432), Reflex::Literal("Holder"), constructor_29394, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29229), Reflex::Literal("Holder"), constructor_29395, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_29398, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_18288, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x109, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4346, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone, std::allocator<pat::TriggerObjectStandAlone> >, pat::TriggerObjectStandAlone> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33433, type_33432), Reflex::Literal("operator="), operator_29396, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_33433), Reflex::Literal("swap"), method_29397, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29550), Reflex::Literal("clone"), method_29399, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29555), Reflex::Literal("getPtr"), method_29400, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_29401, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1924), Reflex::Literal("key"), method_29402, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_33421), Reflex::Literal("isEqualTo"), method_29403, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29229), Reflex::Literal("getRef"), method_29404, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_16861, type_8988), Reflex::Literal("fillRefIfMyTypeMatches"), method_29405, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2538), Reflex::Literal("holder"), method_29406, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2537), Reflex::Literal("makeVectorHolder"), method_29407, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2536), Reflex::Literal("makeVectorBaseHolder"), method_29408, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_29409, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_29410, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3434), Reflex::Literal("product"), method_29411, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_29412, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_29413, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > -------------------------------
static void constructor_29415( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >();
}

static void constructor_29416( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
}

static void constructor_29417( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >(*(const ::edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*)arg[0]);
}

static  void operator_29418( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
}

static  void method_29419( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)arg[0]);
}

static void destructor_29420(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::~Holder)();
}
static  void method_29421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->clone)();
}

static  void method_29422( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->getPtr)();
}

static  void method_29423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->id)();
}

static  void method_29424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->key)();
}

static  void method_29425( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_29426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->getRef)();
}

static  void method_29427( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_29428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->holder)();
}

static  void method_29429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->makeVectorHolder)();
}

static  void method_29430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->makeVectorBaseHolder)();
}

static  void method_29431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->productGetter)();
}

static  void method_29432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->hasProductCache)();
}

static  void method_29433( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->product)();
}

static  void method_29434( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->isAvailable)();
}

static  void method_29435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >*)o)->Class_Version)();
}

static void method_newdel_18289( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x111( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Candidate,pat::TriggerObjectRef>")
  .AddBase(type_18280, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_29415, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33434), Reflex::Literal("Holder"), constructor_29416, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26451), Reflex::Literal("Holder"), constructor_29417, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_29420, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_18289, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x111, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4344, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject, edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject, std::allocator<pat::TriggerObject> >, pat::TriggerObject> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33435, type_33434), Reflex::Literal("operator="), operator_29418, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_33435), Reflex::Literal("swap"), method_29419, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29550), Reflex::Literal("clone"), method_29421, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29555), Reflex::Literal("getPtr"), method_29422, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("id"), method_29423, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1924), Reflex::Literal("key"), method_29424, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_33421), Reflex::Literal("isEqualTo"), method_29425, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26451), Reflex::Literal("getRef"), method_29426, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_16861, type_8988), Reflex::Literal("fillRefIfMyTypeMatches"), method_29427, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2538), Reflex::Literal("holder"), method_29428, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2537), Reflex::Literal("makeVectorHolder"), method_29429, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2536), Reflex::Literal("makeVectorBaseHolder"), method_29430, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("productGetter"), method_29431, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("hasProductCache"), method_29432, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3434), Reflex::Literal("product"), method_29433, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454), Reflex::Literal("isAvailable"), method_29434, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_217), Reflex::Literal("Class_Version"), method_29435, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __pat__TriggerAlgorithm_dict(); 
      __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__long_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_p_edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s_r__dict(); 
      __pat__TriggerCondition_dict(); 
      __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__long_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_p_edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s_r__dict(); 
      __pat__TriggerObject_dict(); 
      __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__long_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_p_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_r__dict(); 
      __pat__TriggerFilter_dict(); 
      __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__long_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_p_edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s_r__dict(); 
      __pat__TriggerObjectStandAlone_dict(); 
      __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__long_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_p_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_r__dict(); 
      __pat__TriggerPath_dict(); 
      __std__iterator_std__random_access_iterator_tag_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__long_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_p_edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s_r__dict(); 
      __std__vector_pat__TriggerObject__dict(); 
      __edm__Association_std__vector_pat__TriggerObject_s__dict(); 
      __std__pair_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__dict(); 
      __std__vector_pat__TriggerAlgorithm__dict(); 
      __std__vector_pat__TriggerCondition__dict(); 
      __std__vector_pat__TriggerFilter__dict(); 
      __std__vector_pat__TriggerObjectStandAlone__dict(); 
      __std__vector_pat__TriggerPath__dict(); 
      __std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s__dict(); 
      __pat__PackedTriggerPrescales_dict(); 
      __edm__Wrapper_pat__PackedTriggerPrescales__dict(); 
      __pat__TriggerEvent_dict(); 
      __edm__Wrapper_pat__TriggerEvent__dict(); 
      __edm__Wrapper_std__vector_pat__TriggerAlgorithm_s__dict(); 
      __edm__Wrapper_std__vector_pat__TriggerCondition_s__dict(); 
      __edm__Wrapper_std__vector_pat__TriggerPath_s__dict(); 
      __edm__Wrapper_std__vector_pat__TriggerFilter_s__dict(); 
      __edm__Association_std__vector_pat__TriggerObjectStandAlone_s__dict(); 
      __edm__Wrapper_edm__Association_std__vector_pat__TriggerObjectStandAlone_s_s__dict(); 
      __edm__Wrapper_std__vector_pat__TriggerObjectStandAlone_s__dict(); 
      __edm__Wrapper_std__map_std__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__dict(); 
      __edm__Wrapper_edm__Association_std__vector_pat__TriggerObject_s_s__dict(); 
      __edm__Wrapper_std__vector_pat__TriggerObject_s__dict(); 
      __edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s__dict(); 
      __edm__Ref_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__dict(); 
      __edm__RefVector_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__dict(); 
      __edm__Ref_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__dict(); 
      __edm__RefVectorIterator_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__dict(); 
      __edm__RefVectorIterator_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__dict(); 
      __edm__RefProd_std__vector_pat__TriggerPath_s__dict(); 
      __edm__RefVector_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__dict(); 
      __edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__dict(); 
      __edm__Ref_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__dict(); 
      __edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s__dict(); 
      __edm__Ref_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerAlgorithm__pat__TriggerAlgorithm_s__dict(); 
      __edm__RefVectorIterator_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__dict(); 
      __std__pair_bool_std__basic_string_char_s__dict(); 
      __edm__RefVectorIterator_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__dict(); 
      __edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__dict(); 
      __edm__RefVector_std__vector_pat__TriggerCondition__pat__TriggerCondition_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerCondition__pat__TriggerCondition_s__dict(); 
      __edm__RefProd_std__vector_pat__TriggerObject_s__dict(); 
      __edm__RefProd_std__vector_pat__TriggerCondition_s__dict(); 
      __edm__RefProd_std__vector_pat__TriggerAlgorithm_s__dict(); 
      __edm__RefVector_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__dict(); 
      __edm__RefVectorIterator_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s__dict(); 
      __edm__RefVectorIterator_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s__dict(); 
      __edm__RefVector_std__vector_pat__TriggerPath__pat__TriggerPath_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerPath__pat__TriggerPath_s__dict(); 
      __edm__RefVector_std__vector_pat__TriggerFilter__pat__TriggerFilter_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerFilter__pat__TriggerFilter_s__dict(); 
      __edm__RefProd_std__vector_pat__TriggerFilter_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__TriggerAlgorithmp_std__vector_pat__TriggerAlgorithm_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__TriggerConditionp_std__vector_pat__TriggerCondition_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__TriggerObjectp_std__vector_pat__TriggerObject_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__TriggerFilterp_std__vector_pat__TriggerFilter_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__TriggerObjectStandAlonep_std__vector_pat__TriggerObjectStandAlone_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__TriggerPathp_std__vector_pat__TriggerPath_s__dict(); 
      __std___Rb_tree_const_iterator_std__pair_constsstd__basic_string_char__edm__RefProd_edm__Association_std__vector_pat__TriggerObject_s_s_s_s__dict(); 
      __std__pair_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__dict(); 
      __std__vector_std__pair_bool_std__basic_string_char_s_s__dict(); 
      __std__map_std__basic_string_char__edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__dict(); 
      __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerAlgorithm_s_s__dict(); 
      __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerCondition_s_s__dict(); 
      __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerPath_s_s__dict(); 
      __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerFilter_s_s__dict(); 
      __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObjectStandAlone_s_s__dict(); 
      __edm__Wrapper_edm__RefProd_std__vector_pat__TriggerObject_s_s__dict(); 
      ____gnu_cxx____normal_iterator_constsstd__pair_bool_std__basic_string_char_s_p_std__vector_std__pair_bool_std__basic_string_char_s_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObjectStandAlone__pat__TriggerObjectStandAlone_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__TriggerObject__pat__TriggerObject_edm__refhelper__FindUsingAdvance_std__vector_pat__TriggerObject__pat__TriggerObject_s_s__dict(); 
    }
    ~Dictionaries() {
      type_7368.Unload(); // class pat::TriggerAlgorithm 
      type_2641.Unload(); // class std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >,long,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >*,edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> >&> 
      type_7332.Unload(); // class pat::TriggerCondition 
      type_2642.Unload(); // class std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >,long,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >*,edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> >&> 
      type_7357.Unload(); // class pat::TriggerObject 
      type_2643.Unload(); // class std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >,long,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >*,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> >&> 
      type_7359.Unload(); // class pat::TriggerFilter 
      type_2644.Unload(); // class std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >,long,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >*,edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> >&> 
      type_7344.Unload(); // class pat::TriggerObjectStandAlone 
      type_2645.Unload(); // class std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >,long,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >*,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> >&> 
      type_7348.Unload(); // class pat::TriggerPath 
      type_2646.Unload(); // class std::iterator<std::random_access_iterator_tag,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >,long,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >*,edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> >&> 
      type_2747.Unload(); // class std::vector<pat::TriggerObject> 
      type_4338.Unload(); // class edm::Association<std::vector<pat::TriggerObject> > 
      type_2707.Unload(); // class std::pair<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > 
      type_2745.Unload(); // class std::vector<pat::TriggerAlgorithm> 
      type_2746.Unload(); // class std::vector<pat::TriggerCondition> 
      type_2748.Unload(); // class std::vector<pat::TriggerFilter> 
      type_2749.Unload(); // class std::vector<pat::TriggerObjectStandAlone> 
      type_2750.Unload(); // class std::vector<pat::TriggerPath> 
      type_2868.Unload(); // class std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > 
      type_7330.Unload(); // class pat::PackedTriggerPrescales 
      type_4130.Unload(); // class edm::Wrapper<pat::PackedTriggerPrescales> 
      type_7350.Unload(); // class pat::TriggerEvent 
      type_4131.Unload(); // class edm::Wrapper<pat::TriggerEvent> 
      type_4133.Unload(); // class edm::Wrapper<std::vector<pat::TriggerAlgorithm> > 
      type_4135.Unload(); // class edm::Wrapper<std::vector<pat::TriggerCondition> > 
      type_4137.Unload(); // class edm::Wrapper<std::vector<pat::TriggerPath> > 
      type_4139.Unload(); // class edm::Wrapper<std::vector<pat::TriggerFilter> > 
      type_4337.Unload(); // class edm::Association<std::vector<pat::TriggerObjectStandAlone> > 
      type_4140.Unload(); // class edm::Wrapper<edm::Association<std::vector<pat::TriggerObjectStandAlone> > > 
      type_4142.Unload(); // class edm::Wrapper<std::vector<pat::TriggerObjectStandAlone> > 
      type_4143.Unload(); // class edm::Wrapper<std::map<std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > 
      type_4144.Unload(); // class edm::Wrapper<edm::Association<std::vector<pat::TriggerObject> > > 
      type_4146.Unload(); // class edm::Wrapper<std::vector<pat::TriggerObject> > 
      type_4304.Unload(); // class edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > 
      type_4347.Unload(); // class edm::Ref<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > 
      type_4056.Unload(); // class edm::RefVector<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > 
      type_4345.Unload(); // class edm::Ref<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > 
      type_4017.Unload(); // class edm::RefVectorIterator<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > 
      type_4015.Unload(); // class edm::RefVectorIterator<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > 
      type_4306.Unload(); // class edm::RefProd<std::vector<pat::TriggerPath> > 
      type_4052.Unload(); // class edm::RefVector<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > 
      type_4344.Unload(); // class edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > 
      type_4343.Unload(); // class edm::Ref<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > 
      type_4302.Unload(); // class edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > 
      type_4342.Unload(); // class edm::Ref<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerAlgorithm>,pat::TriggerAlgorithm> > 
      type_4016.Unload(); // class edm::RefVectorIterator<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > 
      type_2722.Unload(); // class std::pair<bool,std::basic_string<char> > 
      type_4018.Unload(); // class edm::RefVectorIterator<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > 
      type_4346.Unload(); // class edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > 
      type_4053.Unload(); // class edm::RefVector<std::vector<pat::TriggerCondition>,pat::TriggerCondition,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerCondition>,pat::TriggerCondition> > 
      type_4303.Unload(); // class edm::RefProd<std::vector<pat::TriggerObject> > 
      type_4307.Unload(); // class edm::RefProd<std::vector<pat::TriggerCondition> > 
      type_4308.Unload(); // class edm::RefProd<std::vector<pat::TriggerAlgorithm> > 
      type_4057.Unload(); // class edm::RefVector<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > 
      type_4019.Unload(); // class edm::RefVectorIterator<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > 
      type_4020.Unload(); // class edm::RefVectorIterator<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > 
      type_4054.Unload(); // class edm::RefVector<std::vector<pat::TriggerPath>,pat::TriggerPath,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerPath>,pat::TriggerPath> > 
      type_4055.Unload(); // class edm::RefVector<std::vector<pat::TriggerFilter>,pat::TriggerFilter,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerFilter>,pat::TriggerFilter> > 
      type_4305.Unload(); // class edm::RefProd<std::vector<pat::TriggerFilter> > 
      type_6572.Unload(); // class __gnu_cxx::__normal_iterator<const pat::TriggerAlgorithm*,std::vector<pat::TriggerAlgorithm> > 
      type_6573.Unload(); // class __gnu_cxx::__normal_iterator<const pat::TriggerCondition*,std::vector<pat::TriggerCondition> > 
      type_6579.Unload(); // class __gnu_cxx::__normal_iterator<const pat::TriggerObject*,std::vector<pat::TriggerObject> > 
      type_6576.Unload(); // class __gnu_cxx::__normal_iterator<const pat::TriggerFilter*,std::vector<pat::TriggerFilter> > 
      type_6577.Unload(); // class __gnu_cxx::__normal_iterator<const pat::TriggerObjectStandAlone*,std::vector<pat::TriggerObjectStandAlone> > 
      type_6575.Unload(); // class __gnu_cxx::__normal_iterator<const pat::TriggerPath*,std::vector<pat::TriggerPath> > 
      type_2928.Unload(); // class std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::RefProd<edm::Association<std::vector<pat::TriggerObject> > > > > 
      type_2713.Unload(); // class std::pair<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > 
      type_2759.Unload(); // class std::vector<std::pair<bool,std::basic_string<char> > > 
      type_2866.Unload(); // class std::map<std::basic_string<char>,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > 
      type_4132.Unload(); // class edm::Wrapper<edm::RefProd<std::vector<pat::TriggerAlgorithm> > > 
      type_4134.Unload(); // class edm::Wrapper<edm::RefProd<std::vector<pat::TriggerCondition> > > 
      type_4136.Unload(); // class edm::Wrapper<edm::RefProd<std::vector<pat::TriggerPath> > > 
      type_4138.Unload(); // class edm::Wrapper<edm::RefProd<std::vector<pat::TriggerFilter> > > 
      type_4141.Unload(); // class edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObjectStandAlone> > > 
      type_4145.Unload(); // class edm::Wrapper<edm::RefProd<std::vector<pat::TriggerObject> > > 
      type_6574.Unload(); // class __gnu_cxx::__normal_iterator<const std::pair<bool,std::basic_string<char> >*,std::vector<std::pair<bool,std::basic_string<char> > > > 
      type_18281.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > > 
      type_18282.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > 
      type_18288.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObjectStandAlone>,pat::TriggerObjectStandAlone> > > 
      type_18289.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::TriggerObject>,pat::TriggerObject,edm::refhelper::FindUsingAdvance<std::vector<pat::TriggerObject>,pat::TriggerObject> > > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
