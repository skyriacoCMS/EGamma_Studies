// Generated at Fri Dec  5 09:57:44 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/PatCandidates/src/classes_user.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("pat") );
  ::Reflex::Type type_64 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_689 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1580 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_232 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_361 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_7778 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Track"));
  ::Reflex::Type type_4840 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCore"));
  ::Reflex::Type type_353 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_7786 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Vertex"));
  ::Reflex::Type type_8862 = ::Reflex::TypeBuilder(Reflex::Literal("pat::UserData"));
  ::Reflex::Type type_492 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_4894 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_4892 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EDProductGetter"));
  ::Reflex::Type type_2520 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_4878 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::UserData>"));
  ::Reflex::Type type_2901 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2902 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_2920 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::UserData*>"));
  ::Reflex::Type type_8866 = ::Reflex::TypeBuilder(Reflex::Literal("pat::UserHolder<reco::Track>"));
  ::Reflex::Type type_692 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::SVector<double,4>"));
  ::Reflex::Type type_8865 = ::Reflex::TypeBuilder(Reflex::Literal("pat::UserHolder<reco::Vertex>"));
  ::Reflex::Type type_1764 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::SVector<double,5>"));
  ::Reflex::Type type_1762 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::SVector<double,3>"));
  ::Reflex::Type type_1760 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::SVector<double,2>"));
  ::Reflex::Type type_3119 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::UserData*>"));
  ::Reflex::Type type_4918 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ClonePolicy<pat::UserData>"));
  ::Reflex::Type type_4841 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolderBase"));
  ::Reflex::Type type_2900 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >"));
  ::Reflex::Type type_4718 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<edm::Ptr<pat::UserData> >"));
  ::Reflex::Type type_3099 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::Ptr<pat::UserData> >"));
  ::Reflex::Type type_8867 = ::Reflex::TypeBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SVector<double,5> >"));
  ::Reflex::Type type_8868 = ::Reflex::TypeBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SVector<double,4> >"));
  ::Reflex::Type type_8869 = ::Reflex::TypeBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SVector<double,3> >"));
  ::Reflex::Type type_8870 = ::Reflex::TypeBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SVector<double,2> >"));
  ::Reflex::Type type_2899 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<edm::ProductID,unsigned int> >"));
  ::Reflex::Type type_4392 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_4711 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >"));
  ::Reflex::Type type_2710 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ValueMap<edm::Ptr<pat::UserData> > >"));
  ::Reflex::Type type_19877 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<edm::Ptr<pat::UserData> >::const_iterator"));
  ::Reflex::Type type_6800 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >"));
  ::Reflex::Type type_8155 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::UserData*> >"));
  ::Reflex::Type type_6804 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >"));
  ::Reflex::Type type_4921 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >"));
  ::Reflex::Type type_19875 = ::Reflex::TypeBuilder(Reflex::Literal("edm::helper::Filler<edm::ValueMap<edm::Ptr<pat::UserData> > >"));
  ::Reflex::Type type_4785 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ValueMap<edm::Ptr<pat::UserData> > >"));
  ::Reflex::Type type_120 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >"));
  ::Reflex::Type type_115 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >"));
  ::Reflex::Type type_107 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >"));
  ::Reflex::Type type_1670 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >"));
  ::Reflex::Type type_2472 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::UserData*,std::allocator<pat::UserData*> >"));
  ::Reflex::Type type_8145 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<edm::Ptr<pat::UserData> > >"));
  ::Reflex::Type type_20916 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::iterator"));
  ::Reflex::Type type_8008 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> >"));
  ::Reflex::Type type_8876 = ::Reflex::TypeBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >"));
  ::Reflex::Type type_8875 = ::Reflex::TypeBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >"));
  ::Reflex::Type type_4712 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >"));
  ::Reflex::Type type_2711 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >"));
  ::Reflex::Type type_20917 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::const_iterator"));
  ::Reflex::Type type_8009 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::UserData* const*,std::vector<pat::UserData*> >"));
  ::Reflex::Type type_8871 = ::Reflex::TypeBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >"));
  ::Reflex::Type type_8872 = ::Reflex::TypeBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >"));
  ::Reflex::Type type_8873 = ::Reflex::TypeBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >"));
  ::Reflex::Type type_8874 = ::Reflex::TypeBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >"));
  ::Reflex::Type type_2462 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ptr<pat::UserData>,std::allocator<edm::Ptr<pat::UserData> > >"));
  ::Reflex::Type type_4786 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >"));
  ::Reflex::Type type_7980 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >"));
  ::Reflex::Type type_3282 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> > >"));
  ::Reflex::Type type_7981 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >"));
  ::Reflex::Type type_6810 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>"));
  ::Reflex::Type type_3281 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::UserData* const*,std::vector<pat::UserData*> > >"));
  ::Reflex::Type type_6816 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>"));
  ::Reflex::Type type_3262 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > > >"));
  ::Reflex::Type type_8877 = ::Reflex::TypeBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >"));
  ::Reflex::Type type_8878 = ::Reflex::TypeBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >"));
  ::Reflex::Type type_3261 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > > >"));
  ::Reflex::Type type_8849 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::UserDataCollection"), type_4921);
  ::Reflex::Type type_20911 = ::Reflex::ReferenceBuilder(type_8862);
  ::Reflex::Type type_8862c = ::Reflex::ConstBuilder(type_8862);
  ::Reflex::Type type_20913 = ::Reflex::ReferenceBuilder(type_8862c);
  ::Reflex::Type type_13571 = ::Reflex::PointerBuilder(type_8862);
  ::Reflex::Type type_492c = ::Reflex::ConstBuilder(type_492);
  ::Reflex::Type type_17769 = ::Reflex::ReferenceBuilder(type_492c);
  ::Reflex::Type type_2521 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2520);
  ::Reflex::Type type_2521c = ::Reflex::ConstBuilder(type_2521);
  ::Reflex::Type type_15463 = ::Reflex::ReferenceBuilder(type_2521c);
  ::Reflex::Type type_689c = ::Reflex::ConstBuilder(type_689);
  ::Reflex::Type type_3866 = ::Reflex::PointerBuilder(type_689c);
  ::Reflex::Type type_12368 = ::Reflex::ReferenceBuilder(type_4878);
  ::Reflex::Type type_4878c = ::Reflex::ConstBuilder(type_4878);
  ::Reflex::Type type_12370 = ::Reflex::ReferenceBuilder(type_4878c);
  ::Reflex::Type type_4894c = ::Reflex::ConstBuilder(type_4894);
  ::Reflex::Type type_17630 = ::Reflex::ReferenceBuilder(type_4894c);
  ::Reflex::Type type_4892c = ::Reflex::ConstBuilder(type_4892);
  ::Reflex::Type type_17720 = ::Reflex::PointerBuilder(type_4892c);
  ::Reflex::Type type_32055 = ::Reflex::PointerBuilder(type_8862c);
  ::Reflex::Type type_4840c = ::Reflex::ConstBuilder(type_4840);
  ::Reflex::Type type_19971 = ::Reflex::ReferenceBuilder(type_4840c);
  ::Reflex::Type type_9492 = ::Reflex::PointerBuilder(type_4878);
  ::Reflex::Type type_12366 = ::Reflex::PointerBuilder(type_4878c);
  ::Reflex::Type type_3086 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_353);
  ::Reflex::Type type_3008 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_64);
  ::Reflex::Type type_3099c = ::Reflex::ConstBuilder(type_3099);
  ::Reflex::Type type_27871 = ::Reflex::ReferenceBuilder(type_3099c);
  ::Reflex::Type type_2900c = ::Reflex::ConstBuilder(type_2900);
  ::Reflex::Type type_28955 = ::Reflex::ReferenceBuilder(type_2900c);
  ::Reflex::Type type_28956 = ::Reflex::ReferenceBuilder(type_2900);
  ::Reflex::Type type_9682 = ::Reflex::PointerBuilder(type_13571);
  ::Reflex::Type type_13571c = ::Reflex::ConstBuilder(type_13571);
  ::Reflex::Type type_13578 = ::Reflex::PointerBuilder(type_13571c);
  ::Reflex::Type type_13580 = ::Reflex::ReferenceBuilder(type_13571);
  ::Reflex::Type type_13582 = ::Reflex::ReferenceBuilder(type_13571c);
  ::Reflex::Type type_3119c = ::Reflex::ConstBuilder(type_3119);
  ::Reflex::Type type_28001 = ::Reflex::ReferenceBuilder(type_3119c);
  ::Reflex::Type type_2920c = ::Reflex::ConstBuilder(type_2920);
  ::Reflex::Type type_28993 = ::Reflex::ReferenceBuilder(type_2920c);
  ::Reflex::Type type_28994 = ::Reflex::ReferenceBuilder(type_2920);
  ::Reflex::Type type_4718c = ::Reflex::ConstBuilder(type_4718);
  ::Reflex::Type type_31955 = ::Reflex::ReferenceBuilder(type_4718c);
  ::Reflex::Type type_31956 = ::Reflex::ReferenceBuilder(type_4718);
  ::Reflex::Type type_2099 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_353);
  ::Reflex::Type type_2899c = ::Reflex::ConstBuilder(type_2899);
  ::Reflex::Type type_28952 = ::Reflex::ReferenceBuilder(type_2899c);
  ::Reflex::Type type_31945 = ::Reflex::PointerBuilder(type_4718c);
  ::Reflex::Type type_31946 = ::Reflex::PointerBuilder(type_4718);
  ::Reflex::Type type_4785c = ::Reflex::ConstBuilder(type_4785);
  ::Reflex::Type type_31947 = ::Reflex::PointerBuilder(type_4785c);
  ::Reflex::Type type_17724 = ::Reflex::ReferenceBuilder(type_2901);
  ::Reflex::Type type_31573 = ::Reflex::ReferenceBuilder(type_4392);
  ::Reflex::Type type_10978 = ::Reflex::ReferenceBuilder(type_3866);
  ::Reflex::Type type_2902c = ::Reflex::ConstBuilder(type_2902);
  ::Reflex::Type type_21244 = ::Reflex::ReferenceBuilder(type_2902c);
  ::Reflex::Type type_33573 = ::Reflex::ReferenceBuilder(type_8865);
  ::Reflex::Type type_8865c = ::Reflex::ConstBuilder(type_8865);
  ::Reflex::Type type_33574 = ::Reflex::ReferenceBuilder(type_8865c);
  ::Reflex::Type type_7786c = ::Reflex::ConstBuilder(type_7786);
  ::Reflex::Type type_12944 = ::Reflex::ReferenceBuilder(type_7786c);
  ::Reflex::Type type_33575 = ::Reflex::PointerBuilder(type_8865);
  ::Reflex::Type type_2520c = ::Reflex::ConstBuilder(type_2520);
  ::Reflex::Type type_10789 = ::Reflex::ReferenceBuilder(type_2520c);
  ::Reflex::Type type_33576 = ::Reflex::ReferenceBuilder(type_8866);
  ::Reflex::Type type_8866c = ::Reflex::ConstBuilder(type_8866);
  ::Reflex::Type type_33577 = ::Reflex::ReferenceBuilder(type_8866c);
  ::Reflex::Type type_7778c = ::Reflex::ConstBuilder(type_7778);
  ::Reflex::Type type_12560 = ::Reflex::ReferenceBuilder(type_7778c);
  ::Reflex::Type type_33578 = ::Reflex::PointerBuilder(type_8866);
  ::Reflex::Type type_33579 = ::Reflex::ReferenceBuilder(type_8867);
  ::Reflex::Type type_8867c = ::Reflex::ConstBuilder(type_8867);
  ::Reflex::Type type_33580 = ::Reflex::ReferenceBuilder(type_8867c);
  ::Reflex::Type type_1764c = ::Reflex::ConstBuilder(type_1764);
  ::Reflex::Type type_22125 = ::Reflex::ReferenceBuilder(type_1764c);
  ::Reflex::Type type_33581 = ::Reflex::PointerBuilder(type_8867);
  ::Reflex::Type type_33582 = ::Reflex::ReferenceBuilder(type_8868);
  ::Reflex::Type type_8868c = ::Reflex::ConstBuilder(type_8868);
  ::Reflex::Type type_33583 = ::Reflex::ReferenceBuilder(type_8868c);
  ::Reflex::Type type_692c = ::Reflex::ConstBuilder(type_692);
  ::Reflex::Type type_21335 = ::Reflex::ReferenceBuilder(type_692c);
  ::Reflex::Type type_33584 = ::Reflex::PointerBuilder(type_8868);
  ::Reflex::Type type_33585 = ::Reflex::ReferenceBuilder(type_8869);
  ::Reflex::Type type_8869c = ::Reflex::ConstBuilder(type_8869);
  ::Reflex::Type type_33586 = ::Reflex::ReferenceBuilder(type_8869c);
  ::Reflex::Type type_1762c = ::Reflex::ConstBuilder(type_1762);
  ::Reflex::Type type_22110 = ::Reflex::ReferenceBuilder(type_1762c);
  ::Reflex::Type type_33587 = ::Reflex::PointerBuilder(type_8869);
  ::Reflex::Type type_33588 = ::Reflex::ReferenceBuilder(type_8870);
  ::Reflex::Type type_8870c = ::Reflex::ConstBuilder(type_8870);
  ::Reflex::Type type_33589 = ::Reflex::ReferenceBuilder(type_8870c);
  ::Reflex::Type type_1760c = ::Reflex::ConstBuilder(type_1760);
  ::Reflex::Type type_22120 = ::Reflex::ReferenceBuilder(type_1760c);
  ::Reflex::Type type_33590 = ::Reflex::PointerBuilder(type_8870);
  ::Reflex::Type type_33591 = ::Reflex::ReferenceBuilder(type_8871);
  ::Reflex::Type type_8871c = ::Reflex::ConstBuilder(type_8871);
  ::Reflex::Type type_33592 = ::Reflex::ReferenceBuilder(type_8871c);
  ::Reflex::Type type_120c = ::Reflex::ConstBuilder(type_120);
  ::Reflex::Type type_17679 = ::Reflex::ReferenceBuilder(type_120c);
  ::Reflex::Type type_33593 = ::Reflex::PointerBuilder(type_8871);
  ::Reflex::Type type_33594 = ::Reflex::ReferenceBuilder(type_8872);
  ::Reflex::Type type_8872c = ::Reflex::ConstBuilder(type_8872);
  ::Reflex::Type type_33595 = ::Reflex::ReferenceBuilder(type_8872c);
  ::Reflex::Type type_115c = ::Reflex::ConstBuilder(type_115);
  ::Reflex::Type type_17654 = ::Reflex::ReferenceBuilder(type_115c);
  ::Reflex::Type type_33596 = ::Reflex::PointerBuilder(type_8872);
  ::Reflex::Type type_33597 = ::Reflex::ReferenceBuilder(type_8873);
  ::Reflex::Type type_8873c = ::Reflex::ConstBuilder(type_8873);
  ::Reflex::Type type_33598 = ::Reflex::ReferenceBuilder(type_8873c);
  ::Reflex::Type type_107c = ::Reflex::ConstBuilder(type_107);
  ::Reflex::Type type_17563 = ::Reflex::ReferenceBuilder(type_107c);
  ::Reflex::Type type_33599 = ::Reflex::PointerBuilder(type_8873);
  ::Reflex::Type type_33600 = ::Reflex::ReferenceBuilder(type_8874);
  ::Reflex::Type type_8874c = ::Reflex::ConstBuilder(type_8874);
  ::Reflex::Type type_33601 = ::Reflex::ReferenceBuilder(type_8874c);
  ::Reflex::Type type_1670c = ::Reflex::ConstBuilder(type_1670);
  ::Reflex::Type type_22109 = ::Reflex::ReferenceBuilder(type_1670c);
  ::Reflex::Type type_33602 = ::Reflex::PointerBuilder(type_8874);
  ::Reflex::Type type_33603 = ::Reflex::ReferenceBuilder(type_8875);
  ::Reflex::Type type_8875c = ::Reflex::ConstBuilder(type_8875);
  ::Reflex::Type type_33604 = ::Reflex::ReferenceBuilder(type_8875c);
  ::Reflex::Type type_6804c = ::Reflex::ConstBuilder(type_6804);
  ::Reflex::Type type_32394 = ::Reflex::ReferenceBuilder(type_6804c);
  ::Reflex::Type type_33605 = ::Reflex::PointerBuilder(type_8875);
  ::Reflex::Type type_33606 = ::Reflex::ReferenceBuilder(type_8876);
  ::Reflex::Type type_8876c = ::Reflex::ConstBuilder(type_8876);
  ::Reflex::Type type_33607 = ::Reflex::ReferenceBuilder(type_8876c);
  ::Reflex::Type type_6800c = ::Reflex::ConstBuilder(type_6800);
  ::Reflex::Type type_32333 = ::Reflex::ReferenceBuilder(type_6800c);
  ::Reflex::Type type_33608 = ::Reflex::PointerBuilder(type_8876);
  ::Reflex::Type type_33609 = ::Reflex::ReferenceBuilder(type_8877);
  ::Reflex::Type type_8877c = ::Reflex::ConstBuilder(type_8877);
  ::Reflex::Type type_33610 = ::Reflex::ReferenceBuilder(type_8877c);
  ::Reflex::Type type_6810c = ::Reflex::ConstBuilder(type_6810);
  ::Reflex::Type type_32435 = ::Reflex::ReferenceBuilder(type_6810c);
  ::Reflex::Type type_33611 = ::Reflex::PointerBuilder(type_8877);
  ::Reflex::Type type_33612 = ::Reflex::ReferenceBuilder(type_8878);
  ::Reflex::Type type_8878c = ::Reflex::ConstBuilder(type_8878);
  ::Reflex::Type type_33613 = ::Reflex::ReferenceBuilder(type_8878c);
  ::Reflex::Type type_6816c = ::Reflex::ConstBuilder(type_6816);
  ::Reflex::Type type_32438 = ::Reflex::ReferenceBuilder(type_6816c);
  ::Reflex::Type type_33614 = ::Reflex::PointerBuilder(type_8878);
  ::Reflex::Type type_4921c = ::Reflex::ConstBuilder(type_4921);
  ::Reflex::Type type_32146 = ::Reflex::ReferenceBuilder(type_4921c);
  ::Reflex::Type type_32147 = ::Reflex::ReferenceBuilder(type_4921);
  ::Reflex::Type type_4842 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::helper_vector"), type_4841);
  ::Reflex::Type type_17725 = ::Reflex::ReferenceBuilder(type_4842);
  ::Reflex::Type type_31950 = ::Reflex::PointerBuilder(type_4921c);
  ::Reflex::Type type_31951 = ::Reflex::PointerBuilder(type_4921);
  ::Reflex::Type type_4786c = ::Reflex::ConstBuilder(type_4786);
  ::Reflex::Type type_31952 = ::Reflex::PointerBuilder(type_4786c);
  ::Reflex::Type type_4712f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::UserDataCollection>"), type_4712);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __pat__UserData
#undef __pat__UserData
#endif
class __pat__UserData {
  public:
  __pat__UserData();
  virtual ~__pat__UserData() throw();
};
#ifdef __edm__Ptr_pat__UserData_
#undef __edm__Ptr_pat__UserData_
#endif
class __edm__Ptr_pat__UserData_ {
  public:
  __edm__Ptr_pat__UserData_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __std__vector_edm__Ptr_pat__UserData_s_
#undef __std__vector_edm__Ptr_pat__UserData_s_
#endif
class __std__vector_edm__Ptr_pat__UserData_s_ : protected ::std::_Vector_base<edm::Ptr<pat::UserData>,std::allocator<edm::Ptr<pat::UserData> > > {
  public:
  __std__vector_edm__Ptr_pat__UserData_s_();
};
#ifdef __std__vector_pat__UserDatap_
#undef __std__vector_pat__UserDatap_
#endif
class __std__vector_pat__UserDatap_ : protected ::std::_Vector_base<pat::UserData*,std::allocator<pat::UserData*> > {
  public:
  __std__vector_pat__UserDatap_();
};
#ifdef __edm__ValueMap_edm__Ptr_pat__UserData_s_
#undef __edm__ValueMap_edm__Ptr_pat__UserData_s_
#endif
class __edm__ValueMap_edm__Ptr_pat__UserData_s_ {
  public:
  __edm__ValueMap_edm__Ptr_pat__UserData_s_();
#ifdef __edm__ValueMap_edm__Ptr_pat__UserData_s___IDComparator
#undef __edm__ValueMap_edm__Ptr_pat__UserData_s___IDComparator
#endif
  struct __edm__ValueMap_edm__Ptr_pat__UserData_s___IDComparator {
    public:
    __edm__ValueMap_edm__Ptr_pat__UserData_s___IDComparator();
  };
  ::std::vector<edm::Ptr<pat::UserData> > values_;
  ::std::vector<std::pair<edm::ProductID,unsigned int> > ids_;
};
#ifdef __edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s_
#undef __edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s_
#endif
class __edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s_ {
  public:
  __edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s_();
  bool present;
  ::edm::ValueMap<edm::Ptr<pat::UserData> > obj;
};
#ifdef __pat__UserHolder_reco__Vertex_
#undef __pat__UserHolder_reco__Vertex_
#endif
class __pat__UserHolder_reco__Vertex_ : public ::pat::UserData {
  public:
  __pat__UserHolder_reco__Vertex_();
  virtual ~__pat__UserHolder_reco__Vertex_() throw();
  ::reco::Vertex obj_;
};
#ifdef __pat__UserHolder_reco__Track_
#undef __pat__UserHolder_reco__Track_
#endif
class __pat__UserHolder_reco__Track_ : public ::pat::UserData {
  public:
  __pat__UserHolder_reco__Track_();
  virtual ~__pat__UserHolder_reco__Track_() throw();
  ::reco::Track obj_;
};
#ifdef __pat__UserHolder_ROOT__Math__SVector_double_5_s_
#undef __pat__UserHolder_ROOT__Math__SVector_double_5_s_
#endif
class __pat__UserHolder_ROOT__Math__SVector_double_5_s_ : public ::pat::UserData {
  public:
  __pat__UserHolder_ROOT__Math__SVector_double_5_s_();
  virtual ~__pat__UserHolder_ROOT__Math__SVector_double_5_s_() throw();
  ::ROOT::Math::SVector<double,5> obj_;
};
#ifdef __pat__UserHolder_ROOT__Math__SVector_double_4_s_
#undef __pat__UserHolder_ROOT__Math__SVector_double_4_s_
#endif
class __pat__UserHolder_ROOT__Math__SVector_double_4_s_ : public ::pat::UserData {
  public:
  __pat__UserHolder_ROOT__Math__SVector_double_4_s_();
  virtual ~__pat__UserHolder_ROOT__Math__SVector_double_4_s_() throw();
  ::ROOT::Math::SVector<double,4> obj_;
};
#ifdef __pat__UserHolder_ROOT__Math__SVector_double_3_s_
#undef __pat__UserHolder_ROOT__Math__SVector_double_3_s_
#endif
class __pat__UserHolder_ROOT__Math__SVector_double_3_s_ : public ::pat::UserData {
  public:
  __pat__UserHolder_ROOT__Math__SVector_double_3_s_();
  virtual ~__pat__UserHolder_ROOT__Math__SVector_double_3_s_() throw();
  ::ROOT::Math::SVector<double,3> obj_;
};
#ifdef __pat__UserHolder_ROOT__Math__SVector_double_2_s_
#undef __pat__UserHolder_ROOT__Math__SVector_double_2_s_
#endif
class __pat__UserHolder_ROOT__Math__SVector_double_2_s_ : public ::pat::UserData {
  public:
  __pat__UserHolder_ROOT__Math__SVector_double_2_s_();
  virtual ~__pat__UserHolder_ROOT__Math__SVector_double_2_s_() throw();
  ::ROOT::Math::SVector<double,2> obj_;
};
#ifdef __pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s_
#undef __pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s_
#endif
class __pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s_ : public ::pat::UserData {
  public:
  __pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s_();
  virtual ~__pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s_() throw();
  ::ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > obj_;
};
#ifdef __pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s_
#undef __pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s_
#endif
class __pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s_ : public ::pat::UserData {
  public:
  __pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s_();
  virtual ~__pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s_() throw();
  ::ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > obj_;
};
#ifdef __pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s_
#undef __pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s_
#endif
class __pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s_ : public ::pat::UserData {
  public:
  __pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s_();
  virtual ~__pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s_() throw();
  ::ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > obj_;
};
#ifdef __pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s_
#undef __pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s_
#endif
class __pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s_ : public ::pat::UserData {
  public:
  __pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s_();
  virtual ~__pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s_() throw();
  ::ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > obj_;
};
#ifdef __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s_
#undef __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s_
#endif
class __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s_ : public ::pat::UserData {
  public:
  __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s_();
  virtual ~__pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s_() throw();
  ::ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > obj_;
};
#ifdef __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s_
#undef __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s_
#endif
class __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s_ : public ::pat::UserData {
  public:
  __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s_();
  virtual ~__pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s_() throw();
  ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > obj_;
};
#ifdef __pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s_
#undef __pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s_
#endif
class __pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s_ : public ::pat::UserData {
  public:
  __pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s_();
  virtual ~__pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s_() throw();
  ::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> obj_;
};
#ifdef __pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s_
#undef __pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s_
#endif
class __pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s_ : public ::pat::UserData {
  public:
  __pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s_();
  virtual ~__pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s_() throw();
  ::ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> obj_;
};
#ifdef __edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_
#undef __edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_
#endif
class __edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_ {
  public:
  __edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_();
  ::std::vector<pat::UserData*> data_;
};
#ifdef __edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s_
#undef __edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s_
#endif
class __edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s_ {
  public:
  __edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s_();
  bool present;
  ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class UserData -------------------------------
static  void operator_27516( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::UserData*)o)->operator=)(*(const ::pat::UserData*)arg[0]);
  else   (((::pat::UserData*)o)->operator=)(*(const ::pat::UserData*)arg[0]);
}

static void destructor_27519(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::UserData*)o)->::pat::UserData::~UserData)();
}
static  void method_27520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserData*)o)->clone)());
  else   (((const ::pat::UserData*)o)->clone)();
}

static  void method_27521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserData*)o)->typeId)();
  else   (((const ::pat::UserData*)o)->typeId)();
}

static  void method_27522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserData*)o)->typeName)();
  else   (((const ::pat::UserData*)o)->typeName)();
}

static  void method_27523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserData*)o)->bareData)());
  else   (((const ::pat::UserData*)o)->bareData)();
}

//------Dictionary for class UserData -------------------------------
void __pat__UserData_db_datamem(Reflex::Class*);
void __pat__UserData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__UserData_datamem_bld(&__pat__UserData_db_datamem);
Reflex::GenreflexMemberBuilder __pat__UserData_funcmem_bld(&__pat__UserData_db_funcmem);
void __pat__UserData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::UserData"), typeid(::pat::UserData), sizeof(::pat::UserData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20911, type_20913), Reflex::Literal("operator="), operator_27516, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UserData"), destructor_27519, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__pat__UserData_funcmem_bld);
}

//------Delayed data member builder for class UserData -------------------
void __pat__UserData_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class UserData -------------------
void __pat__UserData_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13571), Reflex::Literal("clone"), method_27520, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeId"), method_27521, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15463), Reflex::Literal("typeName"), method_27522, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3866), Reflex::Literal("bareData"), method_27523, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Ptr<pat::UserData> -------------------------------
static  void operator_20291( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<pat::UserData>*)o)->operator=)(*(const ::edm::Ptr<pat::UserData>*)arg[0]);
  else   (((::edm::Ptr<pat::UserData>*)o)->operator=)(*(const ::edm::Ptr<pat::UserData>*)arg[0]);
}

static void constructor_20292( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::UserData>(*(const ::edm::Ptr<pat::UserData>*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::UserData>(*(const ::edm::Ptr<pat::UserData>*)arg[0]);
}

static void constructor_20293( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::UserData>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::UserData>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_20294( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::UserData>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::UserData*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::UserData>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::UserData*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_20295( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::UserData>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::UserData>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_20296( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::UserData>();
  else ::new(mem) ::edm::Ptr<pat::UserData>();
}

static void destructor_20297(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<pat::UserData>*)o)->::edm::Ptr<pat::UserData>::~Ptr)();
}
static  void operator_20298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::UserData>*)o)->operator*)();
  else   (((const ::edm::Ptr<pat::UserData>*)o)->operator*)();
}

static  void operator_20299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::UserData>*)o)->operator->)());
  else   (((const ::edm::Ptr<pat::UserData>*)o)->operator->)();
}

static  void method_20300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::UserData>*)o)->get)());
  else   (((const ::edm::Ptr<pat::UserData>*)o)->get)();
}

static  void method_20301( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::UserData>*)o)->isNull)());
  else   (((const ::edm::Ptr<pat::UserData>*)o)->isNull)();
}

static  void method_20302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::UserData>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<pat::UserData>*)o)->isNonnull)();
}

static  void operator_20303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::UserData>*)o)->operator!)());
  else   (((const ::edm::Ptr<pat::UserData>*)o)->operator!)();
}

static  void method_20304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::UserData>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<pat::UserData>*)o)->isAvailable)();
}

static  void method_20305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::UserData>*)o)->isTransient)());
  else   (((const ::edm::Ptr<pat::UserData>*)o)->isTransient)();
}

static  void method_20306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<pat::UserData>*)o)->id)());
  else   (((const ::edm::Ptr<pat::UserData>*)o)->id)();
}

static  void method_20307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::UserData>*)o)->productGetter)());
  else   (((const ::edm::Ptr<pat::UserData>*)o)->productGetter)();
}

static  void method_20308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<pat::UserData>*)o)->key)());
  else   (((const ::edm::Ptr<pat::UserData>*)o)->key)();
}

static  void method_20309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::UserData>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<pat::UserData>*)o)->hasProductCache)();
}

static  void method_20310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::UserData>*)o)->refCore)();
  else   (((const ::edm::Ptr<pat::UserData>*)o)->refCore)();
}

static  void method_20311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::UserData>*)o)->product)());
  else   (((const ::edm::Ptr<pat::UserData>*)o)->product)();
}

static  void method_20312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<pat::UserData>*)o)->Class_Version)());
  else   (((::edm::Ptr<pat::UserData>*)o)->Class_Version)();
}

static void method_newdel_4878( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::UserData> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::UserData> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::UserData> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::UserData> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::UserData> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<pat::UserData> -------------------------------
void __edm__Ptr_pat__UserData__db_datamem(Reflex::Class*);
void __edm__Ptr_pat__UserData__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__UserData__datamem_bld(&__edm__Ptr_pat__UserData__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__UserData__funcmem_bld(&__edm__Ptr_pat__UserData__db_funcmem);
void __edm__Ptr_pat__UserData__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<pat::UserData>"), typeid(::edm::Ptr<pat::UserData>), sizeof(::edm::Ptr<pat::UserData>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<pat::UserData>::Class_Version())
  .AddTypedef(type_353, Reflex::Literal("edm::Ptr<pat::UserData>::key_type"))
  .AddTypedef(type_8862, Reflex::Literal("edm::Ptr<pat::UserData>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12368, type_12370), Reflex::Literal("operator="), operator_20291, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12370), Reflex::Literal("Ptr"), constructor_20292, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17630, type_353, type_17720), Reflex::Literal("Ptr"), constructor_20293, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17630, type_32055, type_353), Reflex::Literal("Ptr"), constructor_20294, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17630), Reflex::Literal("Ptr"), constructor_20295, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_20296, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_20297, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4878, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_pat__UserData__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_pat__UserData__funcmem_bld);
}

//------Delayed data member builder for class Ptr<pat::UserData> -------------------
void __edm__Ptr_pat__UserData__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4840, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_pat__UserData_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_353, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_pat__UserData_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<pat::UserData> -------------------
void __edm__Ptr_pat__UserData__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20913), Reflex::Literal("operator*"), operator_20298, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32055), Reflex::Literal("operator->"), operator_20299, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32055), Reflex::Literal("get"), method_20300, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1580), Reflex::Literal("isNull"), method_20301, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1580), Reflex::Literal("isNonnull"), method_20302, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1580), Reflex::Literal("operator!"), operator_20303, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1580), Reflex::Literal("isAvailable"), method_20304, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1580), Reflex::Literal("isTransient"), method_20305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4894), Reflex::Literal("id"), method_20306, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17720), Reflex::Literal("productGetter"), method_20307, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_353), Reflex::Literal("key"), method_20308, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1580), Reflex::Literal("hasProductCache"), method_20309, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19971), Reflex::Literal("refCore"), method_20310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3866), Reflex::Literal("product"), method_20311, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_232), Reflex::Literal("Class_Version"), method_20312, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<edm::Ptr<pat::UserData>,std::allocator<edm::Ptr<pat::UserData> > > -------------------------------
static void constructor_12379( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<pat::UserData> >();
  else ::new(mem) ::std::vector<edm::Ptr<pat::UserData> >();
}

static void constructor_12380( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<pat::UserData> >(*(const ::std::allocator<edm::Ptr<pat::UserData> >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ptr<pat::UserData> >(*(const ::std::allocator<edm::Ptr<pat::UserData> >*)arg[0]);
}

static void constructor_12381( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<pat::UserData> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ptr<pat::UserData> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<pat::UserData> >(*(::std::size_t*)arg[0],
      *(const ::edm::Ptr<pat::UserData>*)arg[1]);
  else ::new(mem) ::std::vector<edm::Ptr<pat::UserData> >(*(::std::size_t*)arg[0],
      *(const ::edm::Ptr<pat::UserData>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<pat::UserData> >(*(::std::size_t*)arg[0],
      *(const ::edm::Ptr<pat::UserData>*)arg[1],
      *(const ::std::allocator<edm::Ptr<pat::UserData> >*)arg[2]);
  else ::new(mem) ::std::vector<edm::Ptr<pat::UserData> >(*(::std::size_t*)arg[0],
      *(const ::edm::Ptr<pat::UserData>*)arg[1],
      *(const ::std::allocator<edm::Ptr<pat::UserData> >*)arg[2]);
  }
}

static void constructor_12382( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<pat::UserData> >(*(const ::std::vector<edm::Ptr<pat::UserData> >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ptr<pat::UserData> >(*(const ::std::vector<edm::Ptr<pat::UserData> >*)arg[0]);
}

static void destructor_12383(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::Ptr<pat::UserData> >*)o)->::std::vector<edm::Ptr<pat::UserData> >::~vector)();
}
static  void operator_12384( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ptr<pat::UserData> >*)o)->operator=)(*(const ::std::vector<edm::Ptr<pat::UserData> >*)arg[0]);
  else   (((::std::vector<edm::Ptr<pat::UserData> >*)o)->operator=)(*(const ::std::vector<edm::Ptr<pat::UserData> >*)arg[0]);
}

static  void method_12385( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ptr<pat::UserData> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::Ptr<pat::UserData>*)arg[1]);
}

static  void method_12386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >)((((::std::vector<edm::Ptr<pat::UserData> >*)o)->begin)());
  else   (((::std::vector<edm::Ptr<pat::UserData> >*)o)->begin)();
}

static  void method_12387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >)((((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->begin)());
  else   (((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->begin)();
}

static  void method_12388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >)((((::std::vector<edm::Ptr<pat::UserData> >*)o)->end)());
  else   (((::std::vector<edm::Ptr<pat::UserData> >*)o)->end)();
}

static  void method_12389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >)((((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->end)());
  else   (((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->end)();
}

static  void method_12394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->size)());
  else   (((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->size)();
}

static  void method_12395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->max_size)());
  else   (((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->max_size)();
}

static  void method_12396( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::Ptr<pat::UserData> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::Ptr<pat::UserData> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::Ptr<pat::UserData>*)arg[1]);
  }
}

static  void method_12397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->capacity)());
  else   (((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->capacity)();
}

static  void method_12398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->empty)());
  else   (((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->empty)();
}

static  void method_12399( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ptr<pat::UserData> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12400( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ptr<pat::UserData> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ptr<pat::UserData> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12401( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12403( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ptr<pat::UserData> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ptr<pat::UserData> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12404( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ptr<pat::UserData> >*)o)->front)();
  else   (((::std::vector<edm::Ptr<pat::UserData> >*)o)->front)();
}

static  void method_12406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->front)();
  else   (((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->front)();
}

static  void method_12407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ptr<pat::UserData> >*)o)->back)();
  else   (((::std::vector<edm::Ptr<pat::UserData> >*)o)->back)();
}

static  void method_12408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->back)();
  else   (((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->back)();
}

static  void method_12409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::Ptr<pat::UserData> >*)o)->data)());
  else   (((::std::vector<edm::Ptr<pat::UserData> >*)o)->data)();
}

static  void method_12410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->data)());
  else   (((const ::std::vector<edm::Ptr<pat::UserData> >*)o)->data)();
}

static  void method_12411( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ptr<pat::UserData> >*)o)->push_back)(*(const ::edm::Ptr<pat::UserData>*)arg[0]);
}

static  void method_12412( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ptr<pat::UserData> >*)o)->pop_back)();
}

static  void method_12413( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >)((((::std::vector<edm::Ptr<pat::UserData> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >*)arg[0],
    *(const ::edm::Ptr<pat::UserData>*)arg[1]));
  else   (((::std::vector<edm::Ptr<pat::UserData> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >*)arg[0],
    *(const ::edm::Ptr<pat::UserData>*)arg[1]);
}

static  void method_12414( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ptr<pat::UserData> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::Ptr<pat::UserData>*)arg[2]);
}

static  void method_12415( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >)((((::std::vector<edm::Ptr<pat::UserData> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >*)arg[0]));
  else   (((::std::vector<edm::Ptr<pat::UserData> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >*)arg[0]);
}

static  void method_12416( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >)((((::std::vector<edm::Ptr<pat::UserData> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >*)arg[1]));
  else   (((::std::vector<edm::Ptr<pat::UserData> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ptr<pat::UserData>*,std::vector<edm::Ptr<pat::UserData> > >*)arg[1]);
}

static  void method_12417( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ptr<pat::UserData> >*)o)->swap)(*(::std::vector<edm::Ptr<pat::UserData> >*)arg[0]);
}

static  void method_12418( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ptr<pat::UserData> >*)o)->clear)();
}

static void method_newdel_2900( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ptr<pat::UserData> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ptr<pat::UserData> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ptr<pat::UserData> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ptr<pat::UserData> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ptr<pat::UserData> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ptr<pat::UserData>,std::allocator<edm::Ptr<pat::UserData> > >")), ::Reflex::BaseOffset< ::std::vector<edm::Ptr<pat::UserData> >,::std::_Vector_base<edm::Ptr<pat::UserData>,std::allocator<edm::Ptr<pat::UserData> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::Ptr<pat::UserData> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::Ptr<pat::UserData> > >::Generate();
}

//------Dictionary for class vector<edm::Ptr<pat::UserData>,std::allocator<edm::Ptr<pat::UserData> > > -------------------------------
void __std__vector_edm__Ptr_pat__UserData_s__db_datamem(Reflex::Class*);
void __std__vector_edm__Ptr_pat__UserData_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ptr_pat__UserData_s__datamem_bld(&__std__vector_edm__Ptr_pat__UserData_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ptr_pat__UserData_s__funcmem_bld(&__std__vector_edm__Ptr_pat__UserData_s__db_funcmem);
void __std__vector_edm__Ptr_pat__UserData_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >"), typeid(::std::vector<edm::Ptr<pat::UserData> >), sizeof(::std::vector<edm::Ptr<pat::UserData> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2462, ::Reflex::BaseOffset< ::std::vector<edm::Ptr<pat::UserData> >, ::std::_Vector_base<edm::Ptr<pat::UserData>,std::allocator<edm::Ptr<pat::UserData> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4878, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::_Alloc_value_type"))
  .AddTypedef(type_2462, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::_Base"))
  .AddTypedef(type_3099, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::_Tp_alloc_type"))
  .AddTypedef(type_8145, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::_Alloc_traits"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::value_type"))
  .AddTypedef(type_9492, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::pointer"))
  .AddTypedef(type_12366, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::const_pointer"))
  .AddTypedef(type_12368, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::reference"))
  .AddTypedef(type_12370, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::const_reference"))
  .AddTypedef(type_7980, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::iterator"))
  .AddTypedef(type_7981, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::const_iterator"))
  .AddTypedef(type_3261, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::const_reverse_iterator"))
  .AddTypedef(type_3262, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::reverse_iterator"))
  .AddTypedef(type_3086, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::size_type"))
  .AddTypedef(type_3008, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::difference_type"))
  .AddTypedef(type_3099, Reflex::Literal("std::vector<edm::Ptr<pat::UserData> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12379, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27871), Reflex::Literal("vector"), constructor_12380, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3086, type_12370, type_27871), Reflex::Literal("vector"), constructor_12381, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28955), Reflex::Literal("vector"), constructor_12382, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12383, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2900, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__Ptr_pat__UserData_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::Ptr<pat::UserData>,std::allocator<edm::Ptr<pat::UserData> > > -------------------
void __std__vector_edm__Ptr_pat__UserData_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::Ptr<pat::UserData>,std::allocator<edm::Ptr<pat::UserData> > > -------------------
void __std__vector_edm__Ptr_pat__UserData_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28956, type_28955), Reflex::Literal("operator="), operator_12384, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_3086, type_12370), Reflex::Literal("assign"), method_12385, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7980), Reflex::Literal("begin"), method_12386, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7981), Reflex::Literal("begin"), method_12387, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7980), Reflex::Literal("end"), method_12388, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7981), Reflex::Literal("end"), method_12389, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3086), Reflex::Literal("size"), method_12394, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3086), Reflex::Literal("max_size"), method_12395, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_3086, type_4878), Reflex::Literal("resize"), method_12396, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3086), Reflex::Literal("capacity"), method_12397, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1580), Reflex::Literal("empty"), method_12398, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_3086), Reflex::Literal("reserve"), method_12399, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12368, type_3086), Reflex::Literal("operator[]"), operator_12400, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12370, type_3086), Reflex::Literal("operator[]"), operator_12401, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12368, type_3086), Reflex::Literal("at"), method_12403, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12370, type_3086), Reflex::Literal("at"), method_12404, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12368), Reflex::Literal("front"), method_12405, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12370), Reflex::Literal("front"), method_12406, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12368), Reflex::Literal("back"), method_12407, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12370), Reflex::Literal("back"), method_12408, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9492), Reflex::Literal("data"), method_12409, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12366), Reflex::Literal("data"), method_12410, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_12370), Reflex::Literal("push_back"), method_12411, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689), Reflex::Literal("pop_back"), method_12412, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7980, type_7980, type_12370), Reflex::Literal("insert"), method_12413, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_7980, type_3086, type_12370), Reflex::Literal("insert"), method_12414, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7980, type_7980), Reflex::Literal("erase"), method_12415, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7980, type_7980, type_7980), Reflex::Literal("erase"), method_12416, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_28956), Reflex::Literal("swap"), method_12417, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689), Reflex::Literal("clear"), method_12418, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<pat::UserData*,std::allocator<pat::UserData*> > -------------------------------
static void constructor_13591( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::UserData*>();
  else ::new(mem) ::std::vector<pat::UserData*>();
}

static void constructor_13592( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::UserData*>(*(const ::std::allocator<pat::UserData*>*)arg[0]);
  else ::new(mem) ::std::vector<pat::UserData*>(*(const ::std::allocator<pat::UserData*>*)arg[0]);
}

static void constructor_13593( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::UserData*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::UserData*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::UserData*>(*(::std::size_t*)arg[0],
      *(::pat::UserData* const*)arg[1]);
  else ::new(mem) ::std::vector<pat::UserData*>(*(::std::size_t*)arg[0],
      *(::pat::UserData* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::UserData*>(*(::std::size_t*)arg[0],
      *(::pat::UserData* const*)arg[1],
      *(const ::std::allocator<pat::UserData*>*)arg[2]);
  else ::new(mem) ::std::vector<pat::UserData*>(*(::std::size_t*)arg[0],
      *(::pat::UserData* const*)arg[1],
      *(const ::std::allocator<pat::UserData*>*)arg[2]);
  }
}

static void constructor_13594( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::UserData*>(*(const ::std::vector<pat::UserData*>*)arg[0]);
  else ::new(mem) ::std::vector<pat::UserData*>(*(const ::std::vector<pat::UserData*>*)arg[0]);
}

static void destructor_13595(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::UserData*>*)o)->::std::vector<pat::UserData*>::~vector)();
}
static  void operator_13596( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::UserData*>*)o)->operator=)(*(const ::std::vector<pat::UserData*>*)arg[0]);
  else   (((::std::vector<pat::UserData*>*)o)->operator=)(*(const ::std::vector<pat::UserData*>*)arg[0]);
}

static  void method_13597( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::UserData*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::pat::UserData* const*)arg[1]);
}

static  void method_13598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> >)((((::std::vector<pat::UserData*>*)o)->begin)());
  else   (((::std::vector<pat::UserData*>*)o)->begin)();
}

static  void method_13599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::UserData* const*,std::vector<pat::UserData*> >)((((const ::std::vector<pat::UserData*>*)o)->begin)());
  else   (((const ::std::vector<pat::UserData*>*)o)->begin)();
}

static  void method_13600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> >)((((::std::vector<pat::UserData*>*)o)->end)());
  else   (((::std::vector<pat::UserData*>*)o)->end)();
}

static  void method_13601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::UserData* const*,std::vector<pat::UserData*> >)((((const ::std::vector<pat::UserData*>*)o)->end)());
  else   (((const ::std::vector<pat::UserData*>*)o)->end)();
}

static  void method_13606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::UserData*>*)o)->size)());
  else   (((const ::std::vector<pat::UserData*>*)o)->size)();
}

static  void method_13607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::UserData*>*)o)->max_size)());
  else   (((const ::std::vector<pat::UserData*>*)o)->max_size)();
}

static  void method_13608( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::UserData*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::UserData*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::pat::UserData*)arg[1]);
  }
}

static  void method_13609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::UserData*>*)o)->capacity)());
  else   (((const ::std::vector<pat::UserData*>*)o)->capacity)();
}

static  void method_13610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::UserData*>*)o)->empty)());
  else   (((const ::std::vector<pat::UserData*>*)o)->empty)();
}

static  void method_13611( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::UserData*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::UserData*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::UserData*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::UserData*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::UserData*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::UserData*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::UserData*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13616( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::UserData*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::UserData*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::UserData*>*)o)->front)();
  else   (((::std::vector<pat::UserData*>*)o)->front)();
}

static  void method_13618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::UserData*>*)o)->front)();
  else   (((const ::std::vector<pat::UserData*>*)o)->front)();
}

static  void method_13619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::UserData*>*)o)->back)();
  else   (((::std::vector<pat::UserData*>*)o)->back)();
}

static  void method_13620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::UserData*>*)o)->back)();
  else   (((const ::std::vector<pat::UserData*>*)o)->back)();
}

static  void method_13621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::UserData*>*)o)->data)());
  else   (((::std::vector<pat::UserData*>*)o)->data)();
}

static  void method_13622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::UserData*>*)o)->data)());
  else   (((const ::std::vector<pat::UserData*>*)o)->data)();
}

static  void method_13623( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::UserData*>*)o)->push_back)(*(::pat::UserData* const*)arg[0]);
}

static  void method_13624( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::UserData*>*)o)->pop_back)();
}

static  void method_13625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> >)((((::std::vector<pat::UserData*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> >*)arg[0],
    *(::pat::UserData* const*)arg[1]));
  else   (((::std::vector<pat::UserData*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> >*)arg[0],
    *(::pat::UserData* const*)arg[1]);
}

static  void method_13626( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::UserData*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::pat::UserData* const*)arg[2]);
}

static  void method_13627( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> >)((((::std::vector<pat::UserData*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> >*)arg[0]));
  else   (((::std::vector<pat::UserData*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> >*)arg[0]);
}

static  void method_13628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> >)((((::std::vector<pat::UserData*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> >*)arg[1]));
  else   (((::std::vector<pat::UserData*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::UserData**,std::vector<pat::UserData*> >*)arg[1]);
}

static  void method_13629( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::UserData*>*)o)->swap)(*(::std::vector<pat::UserData*>*)arg[0]);
}

static  void method_13630( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::UserData*>*)o)->clear)();
}

static void method_newdel_2920( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::UserData*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::UserData*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::UserData*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::UserData*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::UserData*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::UserData*,std::allocator<pat::UserData*> >")), ::Reflex::BaseOffset< ::std::vector<pat::UserData*>,::std::_Vector_base<pat::UserData*,std::allocator<pat::UserData*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::UserData*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::UserData*> >::Generate();
}

//------Dictionary for class vector<pat::UserData*,std::allocator<pat::UserData*> > -------------------------------
void __std__vector_pat__UserDatap__db_datamem(Reflex::Class*);
void __std__vector_pat__UserDatap__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__UserDatap__datamem_bld(&__std__vector_pat__UserDatap__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__UserDatap__funcmem_bld(&__std__vector_pat__UserDatap__db_funcmem);
void __std__vector_pat__UserDatap__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::UserData*>"), typeid(::std::vector<pat::UserData*>), sizeof(::std::vector<pat::UserData*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2472, ::Reflex::BaseOffset< ::std::vector<pat::UserData*>, ::std::_Vector_base<pat::UserData*,std::allocator<pat::UserData*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13571, Reflex::Literal("std::vector<pat::UserData*>::_Alloc_value_type"))
  .AddTypedef(type_2472, Reflex::Literal("std::vector<pat::UserData*>::_Base"))
  .AddTypedef(type_3119, Reflex::Literal("std::vector<pat::UserData*>::_Tp_alloc_type"))
  .AddTypedef(type_8155, Reflex::Literal("std::vector<pat::UserData*>::_Alloc_traits"))
  .AddTypedef(type_13571, Reflex::Literal("std::vector<pat::UserData*>::value_type"))
  .AddTypedef(type_9682, Reflex::Literal("std::vector<pat::UserData*>::pointer"))
  .AddTypedef(type_13578, Reflex::Literal("std::vector<pat::UserData*>::const_pointer"))
  .AddTypedef(type_13580, Reflex::Literal("std::vector<pat::UserData*>::reference"))
  .AddTypedef(type_13582, Reflex::Literal("std::vector<pat::UserData*>::const_reference"))
  .AddTypedef(type_8008, Reflex::Literal("std::vector<pat::UserData*>::iterator"))
  .AddTypedef(type_8009, Reflex::Literal("std::vector<pat::UserData*>::const_iterator"))
  .AddTypedef(type_3281, Reflex::Literal("std::vector<pat::UserData*>::const_reverse_iterator"))
  .AddTypedef(type_3282, Reflex::Literal("std::vector<pat::UserData*>::reverse_iterator"))
  .AddTypedef(type_3086, Reflex::Literal("std::vector<pat::UserData*>::size_type"))
  .AddTypedef(type_3008, Reflex::Literal("std::vector<pat::UserData*>::difference_type"))
  .AddTypedef(type_3119, Reflex::Literal("std::vector<pat::UserData*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13591, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28001), Reflex::Literal("vector"), constructor_13592, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3086, type_13582, type_28001), Reflex::Literal("vector"), constructor_13593, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28993), Reflex::Literal("vector"), constructor_13594, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13595, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2920, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__UserDatap__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::UserData*,std::allocator<pat::UserData*> > -------------------
void __std__vector_pat__UserDatap__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::UserData*,std::allocator<pat::UserData*> > -------------------
void __std__vector_pat__UserDatap__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28994, type_28993), Reflex::Literal("operator="), operator_13596, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_3086, type_13582), Reflex::Literal("assign"), method_13597, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8008), Reflex::Literal("begin"), method_13598, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8009), Reflex::Literal("begin"), method_13599, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8008), Reflex::Literal("end"), method_13600, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8009), Reflex::Literal("end"), method_13601, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3086), Reflex::Literal("size"), method_13606, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3086), Reflex::Literal("max_size"), method_13607, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_3086, type_13571), Reflex::Literal("resize"), method_13608, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3086), Reflex::Literal("capacity"), method_13609, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1580), Reflex::Literal("empty"), method_13610, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_3086), Reflex::Literal("reserve"), method_13611, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13580, type_3086), Reflex::Literal("operator[]"), operator_13612, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13582, type_3086), Reflex::Literal("operator[]"), operator_13613, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13580, type_3086), Reflex::Literal("at"), method_13615, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13582, type_3086), Reflex::Literal("at"), method_13616, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13580), Reflex::Literal("front"), method_13617, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13582), Reflex::Literal("front"), method_13618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13580), Reflex::Literal("back"), method_13619, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13582), Reflex::Literal("back"), method_13620, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9682), Reflex::Literal("data"), method_13621, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13578), Reflex::Literal("data"), method_13622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_13582), Reflex::Literal("push_back"), method_13623, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689), Reflex::Literal("pop_back"), method_13624, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8008, type_8008, type_13582), Reflex::Literal("insert"), method_13625, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_8008, type_3086, type_13582), Reflex::Literal("insert"), method_13626, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8008, type_8008), Reflex::Literal("erase"), method_13627, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8008, type_8008, type_8008), Reflex::Literal("erase"), method_13628, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_28994), Reflex::Literal("swap"), method_13629, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689), Reflex::Literal("clear"), method_13630, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class ValueMap<edm::Ptr<pat::UserData> > -------------------------------
static void destructor_19879(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->::edm::ValueMap<edm::Ptr<pat::UserData> >::~ValueMap)();
}
static void constructor_19880( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<edm::Ptr<pat::UserData> >(*(const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)arg[0]);
  else ::new(mem) ::edm::ValueMap<edm::Ptr<pat::UserData> >(*(const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)arg[0]);
}

static void constructor_19881( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<edm::Ptr<pat::UserData> >();
  else ::new(mem) ::edm::ValueMap<edm::Ptr<pat::UserData> >();
}

static  void method_19882( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->swap)(*(::edm::ValueMap<edm::Ptr<pat::UserData> >*)arg[0]);
}

static  void operator_19883( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->operator=)(*(const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)arg[0]);
  else   (((::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->operator=)(*(const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)arg[0]);
}

static  void method_19884( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_19885( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_19886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_19887( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->operator+=)(*(const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)arg[0]);
  else   (((::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->operator+=)(*(const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)arg[0]);
}

static  void method_19888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_19889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->size)());
  else   (((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->size)();
}

static  void method_19890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->idSize)());
  else   (((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->idSize)();
}

static  void method_19891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->empty)());
  else   (((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->empty)();
}

static  void method_19892( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->clear)();
}

static  void method_19893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<edm::Ptr<pat::UserData> >::const_iterator)((((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->begin)());
  else   (((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->begin)();
}

static  void method_19894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<edm::Ptr<pat::UserData> >::const_iterator)((((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->end)());
  else   (((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->end)();
}

static  void method_19895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->ids)();
  else   (((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->ids)();
}

static  void method_19896( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->get)(*(::size_t*)arg[0]);
  else   (((const ::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_19897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->Class_Version)());
  else   (((::edm::ValueMap<edm::Ptr<pat::UserData> >*)o)->Class_Version)();
}

static void method_newdel_4718( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<edm::Ptr<pat::UserData> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<edm::Ptr<pat::UserData> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<edm::Ptr<pat::UserData> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<edm::Ptr<pat::UserData> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<edm::Ptr<pat::UserData> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ValueMap<edm::Ptr<pat::UserData> > -------------------------------
void __edm__ValueMap_edm__Ptr_pat__UserData_s__db_datamem(Reflex::Class*);
void __edm__ValueMap_edm__Ptr_pat__UserData_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ValueMap_edm__Ptr_pat__UserData_s__datamem_bld(&__edm__ValueMap_edm__Ptr_pat__UserData_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__ValueMap_edm__Ptr_pat__UserData_s__funcmem_bld(&__edm__ValueMap_edm__Ptr_pat__UserData_s__db_funcmem);
void __edm__ValueMap_edm__Ptr_pat__UserData_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ValueMap<edm::Ptr<pat::UserData> >"), typeid(::edm::ValueMap<edm::Ptr<pat::UserData> >), sizeof(::edm::ValueMap<edm::Ptr<pat::UserData> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::ValueMap<edm::Ptr<pat::UserData> >::Class_Version())
  .AddTypedef(type_4878, Reflex::Literal("edm::ValueMap<edm::Ptr<pat::UserData> >::value_type"))
  .AddTypedef(type_2900, Reflex::Literal("edm::ValueMap<edm::Ptr<pat::UserData> >::container"))
  .AddTypedef(type_361, Reflex::Literal("edm::ValueMap<edm::Ptr<pat::UserData> >::offset"))
  .AddTypedef(type_2899, Reflex::Literal("edm::ValueMap<edm::Ptr<pat::UserData> >::id_offset_vector"))
  .AddTypedef(type_12368, Reflex::Literal("edm::ValueMap<edm::Ptr<pat::UserData> >::reference_type"))
  .AddTypedef(type_12370, Reflex::Literal("edm::ValueMap<edm::Ptr<pat::UserData> >::const_reference_type"))
  .AddTypedef(type_19875, Reflex::Literal("edm::ValueMap<edm::Ptr<pat::UserData> >::Filler"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValueMap"), destructor_19879, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31955), Reflex::Literal("ValueMap"), constructor_19880, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ValueMap"), constructor_19881, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4718, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ValueMap_edm__Ptr_pat__UserData_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ValueMap_edm__Ptr_pat__UserData_s__funcmem_bld);
}

//------Delayed data member builder for class ValueMap<edm::Ptr<pat::UserData> > -------------------
void __edm__ValueMap_edm__Ptr_pat__UserData_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2900, Reflex::Literal("values_"), OffsetOf(__shadow__::__edm__ValueMap_edm__Ptr_pat__UserData_s_, values_), ::Reflex::PROTECTED)
  .AddDataMember(type_2899, Reflex::Literal("ids_"), OffsetOf(__shadow__::__edm__ValueMap_edm__Ptr_pat__UserData_s_, ids_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class ValueMap<edm::Ptr<pat::UserData> > -------------------
void __edm__ValueMap_edm__Ptr_pat__UserData_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_31956), Reflex::Literal("swap"), method_19882, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31956, type_31955), Reflex::Literal("operator="), operator_19883, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2099, type_4894, type_2099), Reflex::Literal("rawIndexOf"), method_19884, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12370, type_4894, type_2099), Reflex::Literal("get"), method_19885, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12368, type_4894, type_2099), Reflex::Literal("get"), method_19886, 0, "id;idx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31956, type_31955), Reflex::Literal("operator+="), operator_19887, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1580, type_4894), Reflex::Literal("contains"), method_19888, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2099), Reflex::Literal("size"), method_19889, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2099), Reflex::Literal("idSize"), method_19890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1580), Reflex::Literal("empty"), method_19891, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689), Reflex::Literal("clear"), method_19892, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19877), Reflex::Literal("begin"), method_19893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19877), Reflex::Literal("end"), method_19894, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28952), Reflex::Literal("ids"), method_19895, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12370, type_2099), Reflex::Literal("get"), method_19896, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_232), Reflex::Literal("Class_Version"), method_19897, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > > -------------------------------
static void constructor_19829( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >();
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >();
}

static void constructor_19830( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >(*(::std::auto_ptr<edm::ValueMap<edm::Ptr<pat::UserData> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >(*(::std::auto_ptr<edm::ValueMap<edm::Ptr<pat::UserData> > >*)arg[0]);
}

static void destructor_19831(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >::~Wrapper)();
}
static  void method_19832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->product)();
}

static  void operator_19833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->operator->)();
}

static  void method_19834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->productTypeInfo)();
}

static  void method_19835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->typeInfo)();
}

static void constructor_19836( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >((::edm::ValueMap<edm::Ptr<pat::UserData> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >((::edm::ValueMap<edm::Ptr<pat::UserData> >*)arg[0]);
}

static  void method_19837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->getInterface)();
}

static  void method_19838( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_19839( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_19840( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_19841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->dynamicTypeInfo)();
}

static  void method_19842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->isPresent)();
}

static  void method_19843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4711( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > > -------------------------------
void __edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s__datamem_bld(&__edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s__funcmem_bld(&__edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s__db_funcmem);
void __edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >"), typeid(::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >), sizeof(::edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4718, Reflex::Literal("edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >::value_type"))
  .AddTypedef(type_4718, Reflex::Literal("edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_19829, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2710), Reflex::Literal("Wrapper"), constructor_19830, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_19831, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31946), Reflex::Literal("Wrapper"), constructor_19836, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4711, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > > -------------------
void __edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1580, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4718, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > > -------------------
void __edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31945), Reflex::Literal("product"), method_19832, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31945), Reflex::Literal("operator->"), operator_19833, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("productTypeInfo"), method_19834, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeInfo"), method_19835, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31947), Reflex::Literal("getInterface"), method_19837, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_17630, type_17724, type_31573), Reflex::Literal("fillView"), method_19838, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_17769, type_353, type_10978), Reflex::Literal("setPtr"), method_19839, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_17769, type_21244, type_17724), Reflex::Literal("fillPtrVector"), method_19840, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("dynamicTypeInfo"), method_19841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1580), Reflex::Literal("isPresent"), method_19842, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("dynamicTypeInfo_"), method_19843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class UserHolder<reco::Vertex> -------------------------------
static  void operator_27573( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::UserHolder<reco::Vertex>*)o)->operator=)(*(const ::pat::UserHolder<reco::Vertex>*)arg[0]);
  else   (((::pat::UserHolder<reco::Vertex>*)o)->operator=)(*(const ::pat::UserHolder<reco::Vertex>*)arg[0]);
}

static void constructor_27574( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<reco::Vertex>(*(const ::pat::UserHolder<reco::Vertex>*)arg[0]);
  else ::new(mem) ::pat::UserHolder<reco::Vertex>(*(const ::pat::UserHolder<reco::Vertex>*)arg[0]);
}

static void constructor_27575( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<reco::Vertex>();
  else ::new(mem) ::pat::UserHolder<reco::Vertex>();
}

static void constructor_27576( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<reco::Vertex>(*(const ::reco::Vertex*)arg[0]);
  else ::new(mem) ::pat::UserHolder<reco::Vertex>(*(const ::reco::Vertex*)arg[0]);
}

static  void method_27577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserHolder<reco::Vertex>*)o)->clone)());
  else   (((const ::pat::UserHolder<reco::Vertex>*)o)->clone)();
}

static  void method_27578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<reco::Vertex>*)o)->typeId)();
  else   (((const ::pat::UserHolder<reco::Vertex>*)o)->typeId)();
}

static  void method_27579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<reco::Vertex>*)o)->typeName)();
  else   (((const ::pat::UserHolder<reco::Vertex>*)o)->typeName)();
}

static void destructor_27582(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::UserHolder<reco::Vertex>*)o)->::pat::UserHolder<reco::Vertex>::~UserHolder)();
}
static void method_newdel_8865( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<reco::Vertex> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<reco::Vertex> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<reco::Vertex> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<reco::Vertex> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<reco::Vertex> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::UserData")), ::Reflex::BaseOffset< ::pat::UserHolder<reco::Vertex>,::pat::UserData >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class UserHolder<reco::Vertex> -------------------------------
void __pat__UserHolder_reco__Vertex__db_datamem(Reflex::Class*);
void __pat__UserHolder_reco__Vertex__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__UserHolder_reco__Vertex__datamem_bld(&__pat__UserHolder_reco__Vertex__db_datamem);
Reflex::GenreflexMemberBuilder __pat__UserHolder_reco__Vertex__funcmem_bld(&__pat__UserHolder_reco__Vertex__db_funcmem);
void __pat__UserHolder_reco__Vertex__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::UserHolder<reco::Vertex>"), typeid(::pat::UserHolder<reco::Vertex>), sizeof(::pat::UserHolder<reco::Vertex>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "pat::UserHolder<*>")
  .AddBase(type_8862, ::Reflex::BaseOffset< ::pat::UserHolder<reco::Vertex>, ::pat::UserData >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33573, type_33574), Reflex::Literal("operator="), operator_27573, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33574), Reflex::Literal("UserHolder"), constructor_27574, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("UserHolder"), constructor_27575, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12944), Reflex::Literal("UserHolder"), constructor_27576, 0, "data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UserHolder"), destructor_27582, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8865, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__UserHolder_reco__Vertex__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__UserHolder_reco__Vertex__funcmem_bld);
}

//------Delayed data member builder for class UserHolder<reco::Vertex> -------------------
void __pat__UserHolder_reco__Vertex__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7786, Reflex::Literal("obj_"), OffsetOf(__shadow__::__pat__UserHolder_reco__Vertex_, obj_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class UserHolder<reco::Vertex> -------------------
void __pat__UserHolder_reco__Vertex__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33575), Reflex::Literal("clone"), method_27577, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeId"), method_27578, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10789), Reflex::Literal("typeName"), method_27579, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class UserHolder<reco::Track> -------------------------------
static  void operator_27584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::UserHolder<reco::Track>*)o)->operator=)(*(const ::pat::UserHolder<reco::Track>*)arg[0]);
  else   (((::pat::UserHolder<reco::Track>*)o)->operator=)(*(const ::pat::UserHolder<reco::Track>*)arg[0]);
}

static void constructor_27585( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<reco::Track>(*(const ::pat::UserHolder<reco::Track>*)arg[0]);
  else ::new(mem) ::pat::UserHolder<reco::Track>(*(const ::pat::UserHolder<reco::Track>*)arg[0]);
}

static void constructor_27586( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<reco::Track>();
  else ::new(mem) ::pat::UserHolder<reco::Track>();
}

static void constructor_27587( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<reco::Track>(*(const ::reco::Track*)arg[0]);
  else ::new(mem) ::pat::UserHolder<reco::Track>(*(const ::reco::Track*)arg[0]);
}

static  void method_27588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserHolder<reco::Track>*)o)->clone)());
  else   (((const ::pat::UserHolder<reco::Track>*)o)->clone)();
}

static  void method_27589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<reco::Track>*)o)->typeId)();
  else   (((const ::pat::UserHolder<reco::Track>*)o)->typeId)();
}

static  void method_27590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<reco::Track>*)o)->typeName)();
  else   (((const ::pat::UserHolder<reco::Track>*)o)->typeName)();
}

static void destructor_27593(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::UserHolder<reco::Track>*)o)->::pat::UserHolder<reco::Track>::~UserHolder)();
}
static void method_newdel_8866( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<reco::Track> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<reco::Track> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<reco::Track> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<reco::Track> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<reco::Track> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::UserData")), ::Reflex::BaseOffset< ::pat::UserHolder<reco::Track>,::pat::UserData >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class UserHolder<reco::Track> -------------------------------
void __pat__UserHolder_reco__Track__db_datamem(Reflex::Class*);
void __pat__UserHolder_reco__Track__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__UserHolder_reco__Track__datamem_bld(&__pat__UserHolder_reco__Track__db_datamem);
Reflex::GenreflexMemberBuilder __pat__UserHolder_reco__Track__funcmem_bld(&__pat__UserHolder_reco__Track__db_funcmem);
void __pat__UserHolder_reco__Track__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::UserHolder<reco::Track>"), typeid(::pat::UserHolder<reco::Track>), sizeof(::pat::UserHolder<reco::Track>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "pat::UserHolder<*>")
  .AddBase(type_8862, ::Reflex::BaseOffset< ::pat::UserHolder<reco::Track>, ::pat::UserData >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33576, type_33577), Reflex::Literal("operator="), operator_27584, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33577), Reflex::Literal("UserHolder"), constructor_27585, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("UserHolder"), constructor_27586, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12560), Reflex::Literal("UserHolder"), constructor_27587, 0, "data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UserHolder"), destructor_27593, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8866, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__UserHolder_reco__Track__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__UserHolder_reco__Track__funcmem_bld);
}

//------Delayed data member builder for class UserHolder<reco::Track> -------------------
void __pat__UserHolder_reco__Track__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7778, Reflex::Literal("obj_"), OffsetOf(__shadow__::__pat__UserHolder_reco__Track_, obj_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class UserHolder<reco::Track> -------------------
void __pat__UserHolder_reco__Track__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33578), Reflex::Literal("clone"), method_27588, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeId"), method_27589, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10789), Reflex::Literal("typeName"), method_27590, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class UserHolder<ROOT::Math::SVector<double, 5> > -------------------------------
static  void operator_27595( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::UserHolder<ROOT::Math::SVector<double,5> >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SVector<double,5> >*)arg[0]);
  else   (((::pat::UserHolder<ROOT::Math::SVector<double,5> >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SVector<double,5> >*)arg[0]);
}

static void constructor_27596( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,5> >(*(const ::pat::UserHolder<ROOT::Math::SVector<double,5> >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,5> >(*(const ::pat::UserHolder<ROOT::Math::SVector<double,5> >*)arg[0]);
}

static void constructor_27597( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,5> >();
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,5> >();
}

static void constructor_27598( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,5> >(*(const ::ROOT::Math::SVector<double,5>*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,5> >(*(const ::ROOT::Math::SVector<double,5>*)arg[0]);
}

static  void method_27599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserHolder<ROOT::Math::SVector<double,5> >*)o)->clone)());
  else   (((const ::pat::UserHolder<ROOT::Math::SVector<double,5> >*)o)->clone)();
}

static  void method_27600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SVector<double,5> >*)o)->typeId)();
  else   (((const ::pat::UserHolder<ROOT::Math::SVector<double,5> >*)o)->typeId)();
}

static  void method_27601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SVector<double,5> >*)o)->typeName)();
  else   (((const ::pat::UserHolder<ROOT::Math::SVector<double,5> >*)o)->typeName)();
}

static void destructor_27604(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::UserHolder<ROOT::Math::SVector<double,5> >*)o)->::pat::UserHolder<ROOT::Math::SVector<double,5> >::~UserHolder)();
}
static void method_newdel_8867( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,5> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,5> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,5> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,5> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,5> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::UserData")), ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SVector<double,5> >,::pat::UserData >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class UserHolder<ROOT::Math::SVector<double, 5> > -------------------------------
void __pat__UserHolder_ROOT__Math__SVector_double_5_s__db_datamem(Reflex::Class*);
void __pat__UserHolder_ROOT__Math__SVector_double_5_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SVector_double_5_s__datamem_bld(&__pat__UserHolder_ROOT__Math__SVector_double_5_s__db_datamem);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SVector_double_5_s__funcmem_bld(&__pat__UserHolder_ROOT__Math__SVector_double_5_s__db_funcmem);
void __pat__UserHolder_ROOT__Math__SVector_double_5_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SVector<double,5> >"), typeid(::pat::UserHolder<ROOT::Math::SVector<double,5> >), sizeof(::pat::UserHolder<ROOT::Math::SVector<double,5> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "pat::UserHolder<*>")
  .AddBase(type_8862, ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SVector<double,5> >, ::pat::UserData >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33579, type_33580), Reflex::Literal("operator="), operator_27595, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33580), Reflex::Literal("UserHolder"), constructor_27596, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("UserHolder"), constructor_27597, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22125), Reflex::Literal("UserHolder"), constructor_27598, 0, "data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UserHolder"), destructor_27604, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8867, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__UserHolder_ROOT__Math__SVector_double_5_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__UserHolder_ROOT__Math__SVector_double_5_s__funcmem_bld);
}

//------Delayed data member builder for class UserHolder<ROOT::Math::SVector<double, 5> > -------------------
void __pat__UserHolder_ROOT__Math__SVector_double_5_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1764, Reflex::Literal("obj_"), OffsetOf(__shadow__::__pat__UserHolder_ROOT__Math__SVector_double_5_s_, obj_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class UserHolder<ROOT::Math::SVector<double, 5> > -------------------
void __pat__UserHolder_ROOT__Math__SVector_double_5_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33581), Reflex::Literal("clone"), method_27599, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeId"), method_27600, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10789), Reflex::Literal("typeName"), method_27601, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class UserHolder<ROOT::Math::SVector<double, 4> > -------------------------------
static  void operator_27606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::UserHolder<ROOT::Math::SVector<double,4> >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SVector<double,4> >*)arg[0]);
  else   (((::pat::UserHolder<ROOT::Math::SVector<double,4> >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SVector<double,4> >*)arg[0]);
}

static void constructor_27607( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,4> >(*(const ::pat::UserHolder<ROOT::Math::SVector<double,4> >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,4> >(*(const ::pat::UserHolder<ROOT::Math::SVector<double,4> >*)arg[0]);
}

static void constructor_27608( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,4> >();
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,4> >();
}

static void constructor_27609( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,4> >(*(const ::ROOT::Math::SVector<double,4>*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,4> >(*(const ::ROOT::Math::SVector<double,4>*)arg[0]);
}

static  void method_27610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserHolder<ROOT::Math::SVector<double,4> >*)o)->clone)());
  else   (((const ::pat::UserHolder<ROOT::Math::SVector<double,4> >*)o)->clone)();
}

static  void method_27611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SVector<double,4> >*)o)->typeId)();
  else   (((const ::pat::UserHolder<ROOT::Math::SVector<double,4> >*)o)->typeId)();
}

static  void method_27612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SVector<double,4> >*)o)->typeName)();
  else   (((const ::pat::UserHolder<ROOT::Math::SVector<double,4> >*)o)->typeName)();
}

static void destructor_27615(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::UserHolder<ROOT::Math::SVector<double,4> >*)o)->::pat::UserHolder<ROOT::Math::SVector<double,4> >::~UserHolder)();
}
static void method_newdel_8868( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,4> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,4> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,4> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,4> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,4> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::UserData")), ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SVector<double,4> >,::pat::UserData >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class UserHolder<ROOT::Math::SVector<double, 4> > -------------------------------
void __pat__UserHolder_ROOT__Math__SVector_double_4_s__db_datamem(Reflex::Class*);
void __pat__UserHolder_ROOT__Math__SVector_double_4_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SVector_double_4_s__datamem_bld(&__pat__UserHolder_ROOT__Math__SVector_double_4_s__db_datamem);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SVector_double_4_s__funcmem_bld(&__pat__UserHolder_ROOT__Math__SVector_double_4_s__db_funcmem);
void __pat__UserHolder_ROOT__Math__SVector_double_4_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SVector<double,4> >"), typeid(::pat::UserHolder<ROOT::Math::SVector<double,4> >), sizeof(::pat::UserHolder<ROOT::Math::SVector<double,4> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "pat::UserHolder<*>")
  .AddBase(type_8862, ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SVector<double,4> >, ::pat::UserData >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33582, type_33583), Reflex::Literal("operator="), operator_27606, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33583), Reflex::Literal("UserHolder"), constructor_27607, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("UserHolder"), constructor_27608, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21335), Reflex::Literal("UserHolder"), constructor_27609, 0, "data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UserHolder"), destructor_27615, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8868, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__UserHolder_ROOT__Math__SVector_double_4_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__UserHolder_ROOT__Math__SVector_double_4_s__funcmem_bld);
}

//------Delayed data member builder for class UserHolder<ROOT::Math::SVector<double, 4> > -------------------
void __pat__UserHolder_ROOT__Math__SVector_double_4_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_692, Reflex::Literal("obj_"), OffsetOf(__shadow__::__pat__UserHolder_ROOT__Math__SVector_double_4_s_, obj_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class UserHolder<ROOT::Math::SVector<double, 4> > -------------------
void __pat__UserHolder_ROOT__Math__SVector_double_4_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33584), Reflex::Literal("clone"), method_27610, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeId"), method_27611, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10789), Reflex::Literal("typeName"), method_27612, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class UserHolder<ROOT::Math::SVector<double, 3> > -------------------------------
static  void operator_27617( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::UserHolder<ROOT::Math::SVector<double,3> >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SVector<double,3> >*)arg[0]);
  else   (((::pat::UserHolder<ROOT::Math::SVector<double,3> >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SVector<double,3> >*)arg[0]);
}

static void constructor_27618( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,3> >(*(const ::pat::UserHolder<ROOT::Math::SVector<double,3> >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,3> >(*(const ::pat::UserHolder<ROOT::Math::SVector<double,3> >*)arg[0]);
}

static void constructor_27619( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,3> >();
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,3> >();
}

static void constructor_27620( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,3> >(*(const ::ROOT::Math::SVector<double,3>*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,3> >(*(const ::ROOT::Math::SVector<double,3>*)arg[0]);
}

static  void method_27621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserHolder<ROOT::Math::SVector<double,3> >*)o)->clone)());
  else   (((const ::pat::UserHolder<ROOT::Math::SVector<double,3> >*)o)->clone)();
}

static  void method_27622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SVector<double,3> >*)o)->typeId)();
  else   (((const ::pat::UserHolder<ROOT::Math::SVector<double,3> >*)o)->typeId)();
}

static  void method_27623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SVector<double,3> >*)o)->typeName)();
  else   (((const ::pat::UserHolder<ROOT::Math::SVector<double,3> >*)o)->typeName)();
}

static void destructor_27626(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::UserHolder<ROOT::Math::SVector<double,3> >*)o)->::pat::UserHolder<ROOT::Math::SVector<double,3> >::~UserHolder)();
}
static void method_newdel_8869( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,3> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,3> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,3> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,3> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,3> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::UserData")), ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SVector<double,3> >,::pat::UserData >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class UserHolder<ROOT::Math::SVector<double, 3> > -------------------------------
void __pat__UserHolder_ROOT__Math__SVector_double_3_s__db_datamem(Reflex::Class*);
void __pat__UserHolder_ROOT__Math__SVector_double_3_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SVector_double_3_s__datamem_bld(&__pat__UserHolder_ROOT__Math__SVector_double_3_s__db_datamem);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SVector_double_3_s__funcmem_bld(&__pat__UserHolder_ROOT__Math__SVector_double_3_s__db_funcmem);
void __pat__UserHolder_ROOT__Math__SVector_double_3_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SVector<double,3> >"), typeid(::pat::UserHolder<ROOT::Math::SVector<double,3> >), sizeof(::pat::UserHolder<ROOT::Math::SVector<double,3> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "pat::UserHolder<*>")
  .AddBase(type_8862, ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SVector<double,3> >, ::pat::UserData >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33585, type_33586), Reflex::Literal("operator="), operator_27617, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33586), Reflex::Literal("UserHolder"), constructor_27618, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("UserHolder"), constructor_27619, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22110), Reflex::Literal("UserHolder"), constructor_27620, 0, "data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UserHolder"), destructor_27626, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8869, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__UserHolder_ROOT__Math__SVector_double_3_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__UserHolder_ROOT__Math__SVector_double_3_s__funcmem_bld);
}

//------Delayed data member builder for class UserHolder<ROOT::Math::SVector<double, 3> > -------------------
void __pat__UserHolder_ROOT__Math__SVector_double_3_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1762, Reflex::Literal("obj_"), OffsetOf(__shadow__::__pat__UserHolder_ROOT__Math__SVector_double_3_s_, obj_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class UserHolder<ROOT::Math::SVector<double, 3> > -------------------
void __pat__UserHolder_ROOT__Math__SVector_double_3_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33587), Reflex::Literal("clone"), method_27621, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeId"), method_27622, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10789), Reflex::Literal("typeName"), method_27623, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class UserHolder<ROOT::Math::SVector<double, 2> > -------------------------------
static  void operator_27628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::UserHolder<ROOT::Math::SVector<double,2> >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SVector<double,2> >*)arg[0]);
  else   (((::pat::UserHolder<ROOT::Math::SVector<double,2> >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SVector<double,2> >*)arg[0]);
}

static void constructor_27629( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,2> >(*(const ::pat::UserHolder<ROOT::Math::SVector<double,2> >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,2> >(*(const ::pat::UserHolder<ROOT::Math::SVector<double,2> >*)arg[0]);
}

static void constructor_27630( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,2> >();
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,2> >();
}

static void constructor_27631( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,2> >(*(const ::ROOT::Math::SVector<double,2>*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SVector<double,2> >(*(const ::ROOT::Math::SVector<double,2>*)arg[0]);
}

static  void method_27632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserHolder<ROOT::Math::SVector<double,2> >*)o)->clone)());
  else   (((const ::pat::UserHolder<ROOT::Math::SVector<double,2> >*)o)->clone)();
}

static  void method_27633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SVector<double,2> >*)o)->typeId)();
  else   (((const ::pat::UserHolder<ROOT::Math::SVector<double,2> >*)o)->typeId)();
}

static  void method_27634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SVector<double,2> >*)o)->typeName)();
  else   (((const ::pat::UserHolder<ROOT::Math::SVector<double,2> >*)o)->typeName)();
}

static void destructor_27637(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::UserHolder<ROOT::Math::SVector<double,2> >*)o)->::pat::UserHolder<ROOT::Math::SVector<double,2> >::~UserHolder)();
}
static void method_newdel_8870( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,2> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,2> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,2> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,2> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SVector<double,2> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::UserData")), ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SVector<double,2> >,::pat::UserData >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class UserHolder<ROOT::Math::SVector<double, 2> > -------------------------------
void __pat__UserHolder_ROOT__Math__SVector_double_2_s__db_datamem(Reflex::Class*);
void __pat__UserHolder_ROOT__Math__SVector_double_2_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SVector_double_2_s__datamem_bld(&__pat__UserHolder_ROOT__Math__SVector_double_2_s__db_datamem);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SVector_double_2_s__funcmem_bld(&__pat__UserHolder_ROOT__Math__SVector_double_2_s__db_funcmem);
void __pat__UserHolder_ROOT__Math__SVector_double_2_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SVector<double,2> >"), typeid(::pat::UserHolder<ROOT::Math::SVector<double,2> >), sizeof(::pat::UserHolder<ROOT::Math::SVector<double,2> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "pat::UserHolder<*>")
  .AddBase(type_8862, ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SVector<double,2> >, ::pat::UserData >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33588, type_33589), Reflex::Literal("operator="), operator_27628, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33589), Reflex::Literal("UserHolder"), constructor_27629, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("UserHolder"), constructor_27630, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22120), Reflex::Literal("UserHolder"), constructor_27631, 0, "data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UserHolder"), destructor_27637, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8870, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__UserHolder_ROOT__Math__SVector_double_2_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__UserHolder_ROOT__Math__SVector_double_2_s__funcmem_bld);
}

//------Delayed data member builder for class UserHolder<ROOT::Math::SVector<double, 2> > -------------------
void __pat__UserHolder_ROOT__Math__SVector_double_2_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1760, Reflex::Literal("obj_"), OffsetOf(__shadow__::__pat__UserHolder_ROOT__Math__SVector_double_2_s_, obj_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class UserHolder<ROOT::Math::SVector<double, 2> > -------------------
void __pat__UserHolder_ROOT__Math__SVector_double_2_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33590), Reflex::Literal("clone"), method_27632, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeId"), method_27633, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10789), Reflex::Literal("typeName"), method_27634, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class UserHolder<ROOT::Math::SMatrix<double, 5, 5, ROOT::Math::MatRepSym<double, 5> > > -------------------------------
static  void operator_27639( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >*)arg[0]);
  else   (((::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >*)arg[0]);
}

static void constructor_27640( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >*)arg[0]);
}

static void constructor_27641( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >();
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >();
}

static void constructor_27642( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >(*(const ::ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >(*(const ::ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >*)arg[0]);
}

static  void method_27643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >*)o)->clone)());
  else   (((const ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >*)o)->clone)();
}

static  void method_27644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >*)o)->typeId)();
  else   (((const ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >*)o)->typeId)();
}

static  void method_27645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >*)o)->typeName)();
  else   (((const ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >*)o)->typeName)();
}

static void destructor_27648(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >*)o)->::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >::~UserHolder)();
}
static void method_newdel_8871( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::UserData")), ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >,::pat::UserData >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class UserHolder<ROOT::Math::SMatrix<double, 5, 5, ROOT::Math::MatRepSym<double, 5> > > -------------------------------
void __pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s__db_datamem(Reflex::Class*);
void __pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s__datamem_bld(&__pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s__funcmem_bld(&__pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s__db_funcmem);
void __pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >"), typeid(::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >), sizeof(::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "pat::UserHolder<*>")
  .AddBase(type_8862, ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > >, ::pat::UserData >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33591, type_33592), Reflex::Literal("operator="), operator_27639, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33592), Reflex::Literal("UserHolder"), constructor_27640, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("UserHolder"), constructor_27641, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17679), Reflex::Literal("UserHolder"), constructor_27642, 0, "data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UserHolder"), destructor_27648, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8871, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s__funcmem_bld);
}

//------Delayed data member builder for class UserHolder<ROOT::Math::SMatrix<double, 5, 5, ROOT::Math::MatRepSym<double, 5> > > -------------------
void __pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_120, Reflex::Literal("obj_"), OffsetOf(__shadow__::__pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s_, obj_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class UserHolder<ROOT::Math::SMatrix<double, 5, 5, ROOT::Math::MatRepSym<double, 5> > > -------------------
void __pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33593), Reflex::Literal("clone"), method_27643, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeId"), method_27644, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10789), Reflex::Literal("typeName"), method_27645, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class UserHolder<ROOT::Math::SMatrix<double, 4, 4, ROOT::Math::MatRepSym<double, 4> > > -------------------------------
static  void operator_27650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >*)arg[0]);
  else   (((::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >*)arg[0]);
}

static void constructor_27651( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >*)arg[0]);
}

static void constructor_27652( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >();
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >();
}

static void constructor_27653( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >(*(const ::ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >(*(const ::ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >*)arg[0]);
}

static  void method_27654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >*)o)->clone)());
  else   (((const ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >*)o)->clone)();
}

static  void method_27655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >*)o)->typeId)();
  else   (((const ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >*)o)->typeId)();
}

static  void method_27656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >*)o)->typeName)();
  else   (((const ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >*)o)->typeName)();
}

static void destructor_27659(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >*)o)->::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >::~UserHolder)();
}
static void method_newdel_8872( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::UserData")), ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >,::pat::UserData >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class UserHolder<ROOT::Math::SMatrix<double, 4, 4, ROOT::Math::MatRepSym<double, 4> > > -------------------------------
void __pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s__db_datamem(Reflex::Class*);
void __pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s__datamem_bld(&__pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s__funcmem_bld(&__pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s__db_funcmem);
void __pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >"), typeid(::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >), sizeof(::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "pat::UserHolder<*>")
  .AddBase(type_8862, ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > >, ::pat::UserData >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33594, type_33595), Reflex::Literal("operator="), operator_27650, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33595), Reflex::Literal("UserHolder"), constructor_27651, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("UserHolder"), constructor_27652, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17654), Reflex::Literal("UserHolder"), constructor_27653, 0, "data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UserHolder"), destructor_27659, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8872, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s__funcmem_bld);
}

//------Delayed data member builder for class UserHolder<ROOT::Math::SMatrix<double, 4, 4, ROOT::Math::MatRepSym<double, 4> > > -------------------
void __pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_115, Reflex::Literal("obj_"), OffsetOf(__shadow__::__pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s_, obj_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class UserHolder<ROOT::Math::SMatrix<double, 4, 4, ROOT::Math::MatRepSym<double, 4> > > -------------------
void __pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33596), Reflex::Literal("clone"), method_27654, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeId"), method_27655, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10789), Reflex::Literal("typeName"), method_27656, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class UserHolder<ROOT::Math::SMatrix<double, 3, 3, ROOT::Math::MatRepSym<double, 3> > > -------------------------------
static  void operator_27661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >*)arg[0]);
  else   (((::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >*)arg[0]);
}

static void constructor_27662( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >*)arg[0]);
}

static void constructor_27663( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >();
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >();
}

static void constructor_27664( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >(*(const ::ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >(*(const ::ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >*)arg[0]);
}

static  void method_27665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >*)o)->clone)());
  else   (((const ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >*)o)->clone)();
}

static  void method_27666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >*)o)->typeId)();
  else   (((const ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >*)o)->typeId)();
}

static  void method_27667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >*)o)->typeName)();
  else   (((const ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >*)o)->typeName)();
}

static void destructor_27670(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >*)o)->::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >::~UserHolder)();
}
static void method_newdel_8873( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x26( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::UserData")), ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >,::pat::UserData >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class UserHolder<ROOT::Math::SMatrix<double, 3, 3, ROOT::Math::MatRepSym<double, 3> > > -------------------------------
void __pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s__db_datamem(Reflex::Class*);
void __pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s__datamem_bld(&__pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s__funcmem_bld(&__pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s__db_funcmem);
void __pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >"), typeid(::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >), sizeof(::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "pat::UserHolder<*>")
  .AddBase(type_8862, ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > >, ::pat::UserData >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33597, type_33598), Reflex::Literal("operator="), operator_27661, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33598), Reflex::Literal("UserHolder"), constructor_27662, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("UserHolder"), constructor_27663, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17563), Reflex::Literal("UserHolder"), constructor_27664, 0, "data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UserHolder"), destructor_27670, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8873, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x26, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s__funcmem_bld);
}

//------Delayed data member builder for class UserHolder<ROOT::Math::SMatrix<double, 3, 3, ROOT::Math::MatRepSym<double, 3> > > -------------------
void __pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_107, Reflex::Literal("obj_"), OffsetOf(__shadow__::__pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s_, obj_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class UserHolder<ROOT::Math::SMatrix<double, 3, 3, ROOT::Math::MatRepSym<double, 3> > > -------------------
void __pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33599), Reflex::Literal("clone"), method_27665, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeId"), method_27666, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10789), Reflex::Literal("typeName"), method_27667, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class UserHolder<ROOT::Math::SMatrix<double, 2, 2, ROOT::Math::MatRepSym<double, 2> > > -------------------------------
static  void operator_27672( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >*)arg[0]);
  else   (((::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >*)arg[0]);
}

static void constructor_27673( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >(*(const ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >*)arg[0]);
}

static void constructor_27674( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >();
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >();
}

static void constructor_27675( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >(*(const ::ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >(*(const ::ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >*)arg[0]);
}

static  void method_27676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >*)o)->clone)());
  else   (((const ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >*)o)->clone)();
}

static  void method_27677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >*)o)->typeId)();
  else   (((const ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >*)o)->typeId)();
}

static  void method_27678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >*)o)->typeName)();
  else   (((const ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >*)o)->typeName)();
}

static void destructor_27681(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >*)o)->::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >::~UserHolder)();
}
static void method_newdel_8874( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::UserData")), ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >,::pat::UserData >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class UserHolder<ROOT::Math::SMatrix<double, 2, 2, ROOT::Math::MatRepSym<double, 2> > > -------------------------------
void __pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s__db_datamem(Reflex::Class*);
void __pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s__datamem_bld(&__pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s__funcmem_bld(&__pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s__db_funcmem);
void __pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >"), typeid(::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >), sizeof(::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "pat::UserHolder<*>")
  .AddBase(type_8862, ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > >, ::pat::UserData >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33600, type_33601), Reflex::Literal("operator="), operator_27672, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33601), Reflex::Literal("UserHolder"), constructor_27673, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("UserHolder"), constructor_27674, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22109), Reflex::Literal("UserHolder"), constructor_27675, 0, "data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UserHolder"), destructor_27681, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8874, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s__funcmem_bld);
}

//------Delayed data member builder for class UserHolder<ROOT::Math::SMatrix<double, 2, 2, ROOT::Math::MatRepSym<double, 2> > > -------------------
void __pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1670, Reflex::Literal("obj_"), OffsetOf(__shadow__::__pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s_, obj_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class UserHolder<ROOT::Math::SMatrix<double, 2, 2, ROOT::Math::MatRepSym<double, 2> > > -------------------
void __pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33602), Reflex::Literal("clone"), method_27676, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeId"), method_27677, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10789), Reflex::Literal("typeName"), method_27678, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > > -------------------------------
static  void operator_27683( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >*)arg[0]);
  else   (((::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >*)arg[0]);
}

static void constructor_27684( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >(*(const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >(*(const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >*)arg[0]);
}

static void constructor_27685( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >();
  else ::new(mem) ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >();
}

static void constructor_27686( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >(*(const ::ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >(*(const ::ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >*)arg[0]);
}

static  void method_27687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >*)o)->clone)());
  else   (((const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >*)o)->clone)();
}

static  void method_27688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >*)o)->typeId)();
  else   (((const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >*)o)->typeId)();
}

static  void method_27689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >*)o)->typeName)();
  else   (((const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >*)o)->typeName)();
}

static void destructor_27692(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >*)o)->::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >::~UserHolder)();
}
static void method_newdel_8875( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::UserData")), ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >,::pat::UserData >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > > -------------------------------
void __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s__db_datamem(Reflex::Class*);
void __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s__datamem_bld(&__pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s__funcmem_bld(&__pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s__db_funcmem);
void __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >"), typeid(::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >), sizeof(::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "pat::UserHolder<*>")
  .AddBase(type_8862, ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >, ::pat::UserData >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33603, type_33604), Reflex::Literal("operator="), operator_27683, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33604), Reflex::Literal("UserHolder"), constructor_27684, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("UserHolder"), constructor_27685, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32394), Reflex::Literal("UserHolder"), constructor_27686, 0, "data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UserHolder"), destructor_27692, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8875, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s__funcmem_bld);
}

//------Delayed data member builder for class UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > > -------------------
void __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6804, Reflex::Literal("obj_"), OffsetOf(__shadow__::__pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s_, obj_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > > -------------------
void __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33605), Reflex::Literal("clone"), method_27687, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeId"), method_27688, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10789), Reflex::Literal("typeName"), method_27689, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > -------------------------------
static  void operator_27694( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)arg[0]);
  else   (((::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)arg[0]);
}

static void constructor_27695( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >(*(const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >(*(const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)arg[0]);
}

static void constructor_27696( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >();
  else ::new(mem) ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >();
}

static void constructor_27697( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >(*(const ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >(*(const ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >*)arg[0]);
}

static  void method_27698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)o)->clone)());
  else   (((const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)o)->clone)();
}

static  void method_27699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)o)->typeId)();
  else   (((const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)o)->typeId)();
}

static  void method_27700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)o)->typeName)();
  else   (((const ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)o)->typeName)();
}

static void destructor_27703(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)o)->::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >::~UserHolder)();
}
static void method_newdel_8876( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x32( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::UserData")), ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >,::pat::UserData >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > -------------------------------
void __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s__db_datamem(Reflex::Class*);
void __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s__datamem_bld(&__pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s__funcmem_bld(&__pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s__db_funcmem);
void __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >"), typeid(::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >), sizeof(::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "pat::UserHolder<*>")
  .AddBase(type_8862, ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >, ::pat::UserData >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33606, type_33607), Reflex::Literal("operator="), operator_27694, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33607), Reflex::Literal("UserHolder"), constructor_27695, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("UserHolder"), constructor_27696, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32333), Reflex::Literal("UserHolder"), constructor_27697, 0, "data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UserHolder"), destructor_27703, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8876, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x32, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s__funcmem_bld);
}

//------Delayed data member builder for class UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > -------------------
void __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6800, Reflex::Literal("obj_"), OffsetOf(__shadow__::__pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s_, obj_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > -------------------
void __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33608), Reflex::Literal("clone"), method_27698, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeId"), method_27699, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10789), Reflex::Literal("typeName"), method_27700, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>, ROOT::Math::DefaultCoordinateSystemTag> > -------------------------------
static  void operator_27705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)arg[0]);
  else   (((::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)arg[0]);
}

static void constructor_27706( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >(*(const ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >(*(const ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)arg[0]);
}

static void constructor_27707( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >();
  else ::new(mem) ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >();
}

static void constructor_27708( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >(*(const ::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >(*(const ::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>*)arg[0]);
}

static  void method_27709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->clone)());
  else   (((const ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->clone)();
}

static  void method_27710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->typeId)();
  else   (((const ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->typeId)();
}

static  void method_27711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->typeName)();
  else   (((const ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->typeName)();
}

static void destructor_27714(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >::~UserHolder)();
}
static void method_newdel_8877( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x34( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::UserData")), ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >,::pat::UserData >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>, ROOT::Math::DefaultCoordinateSystemTag> > -------------------------------
void __pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__db_datamem(Reflex::Class*);
void __pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__datamem_bld(&__pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__db_datamem);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__funcmem_bld(&__pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__db_funcmem);
void __pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >"), typeid(::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >), sizeof(::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "pat::UserHolder<*>")
  .AddBase(type_8862, ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >, ::pat::UserData >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33609, type_33610), Reflex::Literal("operator="), operator_27705, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33610), Reflex::Literal("UserHolder"), constructor_27706, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("UserHolder"), constructor_27707, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32435), Reflex::Literal("UserHolder"), constructor_27708, 0, "data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UserHolder"), destructor_27714, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8877, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x34, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__funcmem_bld);
}

//------Delayed data member builder for class UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>, ROOT::Math::DefaultCoordinateSystemTag> > -------------------
void __pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6810, Reflex::Literal("obj_"), OffsetOf(__shadow__::__pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s_, obj_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>, ROOT::Math::DefaultCoordinateSystemTag> > -------------------
void __pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33611), Reflex::Literal("clone"), method_27709, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeId"), method_27710, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10789), Reflex::Literal("typeName"), method_27711, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>, ROOT::Math::DefaultCoordinateSystemTag> > -------------------------------
static  void operator_27716( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)arg[0]);
  else   (((::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->operator=)(*(const ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)arg[0]);
}

static void constructor_27717( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >(*(const ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >(*(const ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)arg[0]);
}

static void constructor_27718( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >();
  else ::new(mem) ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >();
}

static void constructor_27719( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >(*(const ::ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>*)arg[0]);
  else ::new(mem) ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >(*(const ::ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>*)arg[0]);
}

static  void method_27720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->clone)());
  else   (((const ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->clone)();
}

static  void method_27721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->typeId)();
  else   (((const ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->typeId)();
}

static  void method_27722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->typeName)();
  else   (((const ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->typeName)();
}

static void destructor_27725(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)o)->::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >::~UserHolder)();
}
static void method_newdel_8878( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x36( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::UserData")), ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >,::pat::UserData >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>, ROOT::Math::DefaultCoordinateSystemTag> > -------------------------------
void __pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__db_datamem(Reflex::Class*);
void __pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__datamem_bld(&__pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__db_datamem);
Reflex::GenreflexMemberBuilder __pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__funcmem_bld(&__pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__db_funcmem);
void __pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >"), typeid(::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >), sizeof(::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "pat::UserHolder<*>")
  .AddBase(type_8862, ::Reflex::BaseOffset< ::pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >, ::pat::UserData >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33612, type_33613), Reflex::Literal("operator="), operator_27716, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33613), Reflex::Literal("UserHolder"), constructor_27717, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("UserHolder"), constructor_27718, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32438), Reflex::Literal("UserHolder"), constructor_27719, 0, "data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UserHolder"), destructor_27725, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8878, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x36, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__funcmem_bld);
}

//------Delayed data member builder for class UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>, ROOT::Math::DefaultCoordinateSystemTag> > -------------------
void __pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6816, Reflex::Literal("obj_"), OffsetOf(__shadow__::__pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s_, obj_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>, ROOT::Math::DefaultCoordinateSystemTag> > -------------------
void __pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33614), Reflex::Literal("clone"), method_27720, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeId"), method_27721, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10789), Reflex::Literal("typeName"), method_27722, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > -------------------------------
static void constructor_20918( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >();
  else ::new(mem) ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >();
}

static void constructor_20919( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >(*(::std::size_t*)arg[0]);
}

static void constructor_20920( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >(*(const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)arg[0]);
  else ::new(mem) ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >(*(const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)arg[0]);
}

static void destructor_20921(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::~OwnVector)();
}
static  void method_20922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::iterator)((((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->begin)());
  else   (((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->begin)();
}

static  void method_20923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::iterator)((((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->end)());
  else   (((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->end)();
}

static  void method_20924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::const_iterator)((((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->begin)());
  else   (((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->begin)();
}

static  void method_20925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::const_iterator)((((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->end)());
  else   (((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->end)();
}

static  void method_20926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->size)());
  else   (((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->size)();
}

static  void method_20927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->empty)());
  else   (((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->empty)();
}

static  void operator_20928( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20929( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20930( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->operator=)(*(const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)arg[0]);
  else   (((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->operator=)(*(const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)arg[0]);
}

static  void method_20931( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void method_20932( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->push_back)(*(const ::pat::UserData*)arg[0]);
}

static  void method_20933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->is_back_safe)());
  else   (((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->is_back_safe)();
}

static  void method_20934( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->pop_back)();
}

static  void method_20935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->back)();
  else   (((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->back)();
}

static  void method_20936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->back)();
  else   (((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->back)();
}

static  void method_20937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->front)();
  else   (((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->front)();
}

static  void method_20938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->front)();
  else   (((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->front)();
}

static  void method_20939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->data)();
  else   (((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->data)();
}

static  void method_20940( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->clear)();
}

static  void method_20941( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::iterator)((((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->erase)(*(::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::iterator*)arg[0]));
  else   (((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->erase)(*(::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::iterator*)arg[0]);
}

static  void method_20942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::iterator)((((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->erase)(*(::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::iterator*)arg[0],
    *(::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::iterator*)arg[1]));
  else   (((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->erase)(*(::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::iterator*)arg[0],
    *(::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::iterator*)arg[1]);
}

static  void method_20944( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->swap)(*(::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)arg[0]);
}

static  void method_20945( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_20946( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20947( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->Class_Version)());
  else   (((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)o)->Class_Version)();
}

static void method_newdel_4921( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > -------------------------------
void __edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s__db_datamem(Reflex::Class*);
void __edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s__datamem_bld(&__edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s__funcmem_bld(&__edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s__db_funcmem);
void __edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >"), typeid(::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >), sizeof(::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::Class_Version())
  .AddTypedef(type_2920, Reflex::Literal("edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::base"))
  .AddTypedef(type_3086, Reflex::Literal("edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::size_type"))
  .AddTypedef(type_8862, Reflex::Literal("edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::value_type"))
  .AddTypedef(type_13571, Reflex::Literal("edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::pointer"))
  .AddTypedef(type_20911, Reflex::Literal("edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::reference"))
  .AddTypedef(type_20913, Reflex::Literal("edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::const_reference"))
  .AddTypedef(type_4918, Reflex::Literal("edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >::policy_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("OwnVector"), constructor_20918, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3086), Reflex::Literal("OwnVector"), constructor_20919, 0, "n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32146), Reflex::Literal("OwnVector"), constructor_20920, 0, "o", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~OwnVector"), destructor_20921, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4921, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s__funcmem_bld);
}

//------Delayed data member builder for class OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > -------------------
void __edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2920, Reflex::Literal("data_"), OffsetOf(__shadow__::__edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_, data_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > -------------------
void __edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20916), Reflex::Literal("begin"), method_20922, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20916), Reflex::Literal("end"), method_20923, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20917), Reflex::Literal("begin"), method_20924, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20917), Reflex::Literal("end"), method_20925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3086), Reflex::Literal("size"), method_20926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1580), Reflex::Literal("empty"), method_20927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20911, type_3086), Reflex::Literal("operator[]"), operator_20928, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20913, type_3086), Reflex::Literal("operator[]"), operator_20929, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32147, type_32146), Reflex::Literal("operator="), operator_20930, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_2099), Reflex::Literal("reserve"), method_20931, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_20913), Reflex::Literal("push_back"), method_20932, 0, "d", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1580), Reflex::Literal("is_back_safe"), method_20933, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689), Reflex::Literal("pop_back"), method_20934, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20911), Reflex::Literal("back"), method_20935, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20913), Reflex::Literal("back"), method_20936, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20911), Reflex::Literal("front"), method_20937, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20913), Reflex::Literal("front"), method_20938, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28993), Reflex::Literal("data"), method_20939, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689), Reflex::Literal("clear"), method_20940, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20916, type_20916), Reflex::Literal("erase"), method_20941, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20916, type_20916, type_20916), Reflex::Literal("erase"), method_20942, 0, "first;last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_32147), Reflex::Literal("swap"), method_20944, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_17630, type_17724, type_17725), Reflex::Literal("fillView"), method_20945, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_17769, type_353, type_10978), Reflex::Literal("setPtr"), method_20946, 0, "toType;index;ptr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_17769, type_21244, type_17724), Reflex::Literal("fillPtrVector"), method_20947, 0, "toType;indices;ptrs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_232), Reflex::Literal("Class_Version"), method_20948, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::OwnVector<pat::UserData, edm::ClonePolicy<pat::UserData> > > -------------------------------
static void constructor_19850( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >();
  else ::new(mem) ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >();
}

static void constructor_19851( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >(*(::std::auto_ptr<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >(*(::std::auto_ptr<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)arg[0]);
}

static void destructor_19852(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >::~Wrapper)();
}
static  void method_19853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->product)();
}

static  void operator_19854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->operator->)();
}

static  void method_19855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->productTypeInfo)();
}

static  void method_19856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->typeInfo)();
}

static void constructor_19857( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >((::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >*)arg[0]);
}

static  void method_19858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->getInterface)();
}

static  void method_19859( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_19860( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_19861( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_19862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->dynamicTypeInfo)();
}

static  void method_19863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->isPresent)();
}

static  void method_19864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4712( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::OwnVector<pat::UserData, edm::ClonePolicy<pat::UserData> > > -------------------------------
void __edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s__datamem_bld(&__edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s__funcmem_bld(&__edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s__db_funcmem);
void __edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >"), typeid(::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >), sizeof(::edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::UserDataCollection>")
  .AddTypedef(type_4921, Reflex::Literal("edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >::value_type"))
  .AddTypedef(type_4921, Reflex::Literal("edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_19850, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2711), Reflex::Literal("Wrapper"), constructor_19851, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_19852, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31951), Reflex::Literal("Wrapper"), constructor_19857, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4712, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::OwnVector<pat::UserData, edm::ClonePolicy<pat::UserData> > > -------------------
void __edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1580, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4921, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::OwnVector<pat::UserData, edm::ClonePolicy<pat::UserData> > > -------------------
void __edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31950), Reflex::Literal("product"), method_19853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31950), Reflex::Literal("operator->"), operator_19854, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("productTypeInfo"), method_19855, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("typeInfo"), method_19856, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31952), Reflex::Literal("getInterface"), method_19858, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_17630, type_17724, type_31573), Reflex::Literal("fillView"), method_19859, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_17769, type_353, type_10978), Reflex::Literal("setPtr"), method_19860, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_689, type_17769, type_21244, type_17724), Reflex::Literal("fillPtrVector"), method_19861, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("dynamicTypeInfo"), method_19862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1580), Reflex::Literal("isPresent"), method_19863, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17769), Reflex::Literal("dynamicTypeInfo_"), method_19864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __pat__UserData_dict(); 
      __edm__Ptr_pat__UserData__dict(); 
      __std__vector_edm__Ptr_pat__UserData_s__dict(); 
      __std__vector_pat__UserDatap__dict(); 
      __edm__ValueMap_edm__Ptr_pat__UserData_s__dict(); 
      __edm__Wrapper_edm__ValueMap_edm__Ptr_pat__UserData_s_s__dict(); 
      __pat__UserHolder_reco__Vertex__dict(); 
      __pat__UserHolder_reco__Track__dict(); 
      __pat__UserHolder_ROOT__Math__SVector_double_5_s__dict(); 
      __pat__UserHolder_ROOT__Math__SVector_double_4_s__dict(); 
      __pat__UserHolder_ROOT__Math__SVector_double_3_s__dict(); 
      __pat__UserHolder_ROOT__Math__SVector_double_2_s__dict(); 
      __pat__UserHolder_ROOT__Math__SMatrix_double_5_5_ROOT__Math__MatRepSym_double_5_s_s__dict(); 
      __pat__UserHolder_ROOT__Math__SMatrix_double_4_4_ROOT__Math__MatRepSym_double_4_s_s__dict(); 
      __pat__UserHolder_ROOT__Math__SMatrix_double_3_3_ROOT__Math__MatRepSym_double_3_s_s__dict(); 
      __pat__UserHolder_ROOT__Math__SMatrix_double_2_2_ROOT__Math__MatRepSym_double_2_s_s__dict(); 
      __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PtEtaPhiM4D_double_s_s__dict(); 
      __pat__UserHolder_ROOT__Math__LorentzVector_ROOT__Math__PxPyPzE4D_double_s_s__dict(); 
      __pat__UserHolder_ROOT__Math__PositionVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__dict(); 
      __pat__UserHolder_ROOT__Math__DisplacementVector3D_ROOT__Math__Cartesian3D_double__ROOT__Math__DefaultCoordinateSystemTag_s__dict(); 
      __edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s__dict(); 
      __edm__Wrapper_edm__OwnVector_pat__UserData_edm__ClonePolicy_pat__UserData_s_s__dict(); 
    }
    ~Dictionaries() {
      type_8862.Unload(); // class pat::UserData 
      type_4878.Unload(); // class edm::Ptr<pat::UserData> 
      type_2900.Unload(); // class std::vector<edm::Ptr<pat::UserData> > 
      type_2920.Unload(); // class std::vector<pat::UserData*> 
      type_4718.Unload(); // class edm::ValueMap<edm::Ptr<pat::UserData> > 
      type_4711.Unload(); // class edm::Wrapper<edm::ValueMap<edm::Ptr<pat::UserData> > > 
      type_8865.Unload(); // class pat::UserHolder<reco::Vertex> 
      type_8866.Unload(); // class pat::UserHolder<reco::Track> 
      type_8867.Unload(); // class pat::UserHolder<ROOT::Math::SVector<double,5> > 
      type_8868.Unload(); // class pat::UserHolder<ROOT::Math::SVector<double,4> > 
      type_8869.Unload(); // class pat::UserHolder<ROOT::Math::SVector<double,3> > 
      type_8870.Unload(); // class pat::UserHolder<ROOT::Math::SVector<double,2> > 
      type_8871.Unload(); // class pat::UserHolder<ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> > > 
      type_8872.Unload(); // class pat::UserHolder<ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> > > 
      type_8873.Unload(); // class pat::UserHolder<ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > > 
      type_8874.Unload(); // class pat::UserHolder<ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> > > 
      type_8875.Unload(); // class pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > > 
      type_8876.Unload(); // class pat::UserHolder<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > 
      type_8877.Unload(); // class pat::UserHolder<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > 
      type_8878.Unload(); // class pat::UserHolder<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > 
      type_4921.Unload(); // class edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > 
      type_4712.Unload(); // class edm::Wrapper<edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
