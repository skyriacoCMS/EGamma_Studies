// Generated at Fri Dec  5 09:58:18 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/PatCandidates/src/classes_objects.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

#include "TBuffer.h"
#include "TVirtualObject.h"
#include <vector>
#include "TSchemaHelper.h"


namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("__gnu_cxx") );
  ::Reflex::NamespaceBuilder nsb3( Reflex::Literal("pat") );
  ::Reflex::NamespaceBuilder nsb4( Reflex::Literal("edm::reftobase") );
  ::Reflex::NamespaceBuilder nsb5( Reflex::Literal("pat::tau") );
  ::Reflex::Type type_72 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_67 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_780 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_990 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_1810 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_1632 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_261 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_112 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_13544 = ::Reflex::TypeBuilder(Reflex::Literal("pat::MET"));
  ::Reflex::Type type_13487 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Jet"));
  ::Reflex::Type type_13568 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Tau"));
  ::Reflex::Type type_13575 = ::Reflex::TypeBuilder(Reflex::Literal("pat::MHT"));
  ::Reflex::Type type_131 = ::Reflex::TypeBuilder(Reflex::Literal("signed char"));
  ::Reflex::Type type_11551 = ::Reflex::TypeBuilder(Reflex::Literal("reco::MET"));
  ::Reflex::Type type_11344 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Jet"));
  ::Reflex::Type type_13465 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Muon"));
  ::Reflex::Type type_227 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_58 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_11232 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Muon"));
  ::Reflex::Type type_757 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned char"));
  ::Reflex::Type type_11423 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Track"));
  ::Reflex::Type type_11342 = ::Reflex::TypeBuilder(Reflex::Literal("reco::JetID"));
  ::Reflex::Type type_13525 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Photon"));
  ::Reflex::Type type_11499 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PFTau"));
  ::Reflex::Type type_7198 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCore"));
  ::Reflex::Type type_232 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_11380 = ::Reflex::TypeBuilder(Reflex::Literal("reco::GenMET"));
  ::Reflex::Type type_11426 = ::Reflex::TypeBuilder(Reflex::Literal("reco::GenJet"));
  ::Reflex::Type type_11479 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Photon"));
  ::Reflex::Type type_11465 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Vertex"));
  ::Reflex::Type type_555 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_13527 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Particle"));
  ::Reflex::Type type_11630 = ::Reflex::TypeBuilder(Reflex::Literal("reco::BaseTau"));
  ::Reflex::Type type_13576 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Electron"));
  ::Reflex::Type type_11586 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CaloTau"));
  ::Reflex::Type type_7365 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_9075 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate"));
  ::Reflex::Type type_13535 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Conversion"));
  ::Reflex::Type type_13517 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Hemisphere"));
  ::Reflex::Type type_13478 = ::Reflex::TypeBuilder(Reflex::Literal("pat::PFParticle"));
  ::Reflex::Type type_507 = ::Reflex::TypeBuilder(Reflex::Literal("SpecificPFMETData"));
  ::Reflex::Type type_3531 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_11548 = ::Reflex::TypeBuilder(Reflex::Literal("reco::IsoDeposit"));
  ::Reflex::Type type_3570 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<bool>"));
  ::Reflex::Type type_7197 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TriggerNames"));
  ::Reflex::Type type_11257 = ::Reflex::TypeBuilder(Reflex::Literal("reco::GenParticle"));
  ::Reflex::Type type_3527 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<float>"));
  ::Reflex::Type type_987 = ::Reflex::TypeBuilder(Reflex::Literal("SpecificCaloMETData"));
  ::Reflex::Type type_60538 = ::Reflex::TypeBuilder(Reflex::Literal("pat::MET::Vector2"));
  ::Reflex::Type type_11627 = ::Reflex::TypeBuilder(Reflex::Literal("reco::BaseTagInfo"));
  ::Reflex::Type type_666 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<CaloTower>"));
  ::Reflex::Type type_11217 = ::Reflex::TypeBuilder(Reflex::Literal("reco::GsfElectron"));
  ::Reflex::Type type_7319 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::Tau>"));
  ::Reflex::Type type_7323 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::MET>"));
  ::Reflex::Type type_7324 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::Jet>"));
  ::Reflex::Type type_11602 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PFCandidate"));
  ::Reflex::Type type_6832 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<int>"));
  ::Reflex::Type type_9074 = ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate"));
  ::Reflex::Type type_7331 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::MET>"));
  ::Reflex::Type type_7333 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::Jet>"));
  ::Reflex::Type type_3545 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_7320 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::Muon>"));
  ::Reflex::Type type_9073 = ::Reflex::TypeBuilder(Reflex::Literal("pat::PackedCandidate"));
  ::Reflex::Type type_7337 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::Muon>"));
  ::Reflex::Type type_7363 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EDProductGetter"));
  ::Reflex::Type type_11424 = ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate"));
  ::Reflex::Type type_13540 = ::Reflex::TypeBuilder(Reflex::Literal("pat::GenericParticle"));
  ::Reflex::Type type_3515 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::MET>"));
  ::Reflex::Type type_11626 = ::Reflex::TypeBuilder(Reflex::Literal("reco::JetFlavourInfo"));
  ::Reflex::Type type_11527 = ::Reflex::TypeBuilder(Reflex::Literal("reco::TrackIPTagInfo"));
  ::Reflex::Type type_3516 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::Jet>"));
  ::Reflex::Type type_3518 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::Tau>"));
  ::Reflex::Type type_3521 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::MHT>"));
  ::Reflex::Type type_7471 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCoreWithIndex"));
  ::Reflex::Type type_9072 = ::Reflex::TypeBuilder(Reflex::Literal("pat::PackedGenParticle"));
  ::Reflex::Type type_13523 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PFJet::Specific"));
  ::Reflex::Type type_7334 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::Photon>"));
  ::Reflex::Type type_59330 = ::Reflex::EnumTypeBuilder(Reflex::Literal("pat::Muon::IPTYPE"));
  ::Reflex::Type type_3519 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::Muon>"));
  ::Reflex::Type type_2999 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_13493 = ::Reflex::EnumTypeBuilder(Reflex::Literal("pat::IsolationKeys"));
  ::Reflex::Type type_13472 = ::Reflex::TypeBuilder(Reflex::Literal("pat::VertexAssociation"));
  ::Reflex::Type type_13473 = ::Reflex::TypeBuilder(Reflex::Literal("reco::JPTJet::Specific"));
  ::Reflex::Type type_7335 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::BaseTau>"));
  ::Reflex::Type type_7322 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::Electron>"));
  ::Reflex::Type type_13508 = ::Reflex::TypeBuilder(Reflex::Literal("pat::LookupTableRecord"));
  ::Reflex::Type type_7327 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::UserData>"));
  ::Reflex::Type type_13506 = ::Reflex::TypeBuilder(Reflex::Literal("pat::CandKinResolution"));
  ::Reflex::Type type_3526 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::Track>"));
  ::Reflex::Type type_13564 = ::Reflex::TypeBuilder(Reflex::Literal("pat::CompositeCandidate"));
  ::Reflex::Type type_3873 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::MET>"));
  ::Reflex::Type type_11305 = ::Reflex::TypeBuilder(Reflex::Literal("reco::SoftLeptonTagInfo"));
  ::Reflex::Type type_13510 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CaloJet::Specific"));
  ::Reflex::Type type_3874 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::Jet>"));
  ::Reflex::Type type_3517 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::Photon>"));
  ::Reflex::Type type_25966 = ::Reflex::TypeBuilder(Reflex::Literal("pat::tau::TauPFSpecific"));
  ::Reflex::Type type_3876 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::Tau>"));
  ::Reflex::Type type_13529 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Lepton<reco::Muon>"));
  ::Reflex::Type type_3879 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::MHT>"));
  ::Reflex::Type type_3504 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_7325 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::Candidate>"));
  ::Reflex::Type type_11585 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CompositeCandidate"));
  ::Reflex::Type type_3543 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::GenMET>"));
  ::Reflex::Type type_7304 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<reco::MET>"));
  ::Reflex::Type type_3556 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::GenJet>"));
  ::Reflex::Type type_7305 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<reco::Jet>"));
  ::Reflex::Type type_26098 = ::Reflex::TypeBuilder(Reflex::Literal("pat::tau::TauPFEssential"));
  ::Reflex::Type type_3877 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::Muon>"));
  ::Reflex::Type type_7321 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::Conversion>"));
  ::Reflex::Type type_3506 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_47548 = ::Reflex::TypeBuilder(Reflex::Literal("reco::candidate::iterator"));
  ::Reflex::Type type_3514 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::Particle>"));
  ::Reflex::Type type_13550 = ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::MET>"));
  ::Reflex::Type type_13551 = ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::Jet>"));
  ::Reflex::Type type_48127 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Photon::ShowerShape"));
  ::Reflex::Type type_26032 = ::Reflex::TypeBuilder(Reflex::Literal("pat::tau::TauCaloSpecific"));
  ::Reflex::Type type_7309 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<reco::Muon>"));
  ::Reflex::Type type_62053 = ::Reflex::EnumTypeBuilder(Reflex::Literal("pat::Electron::IPTYPE"));
  ::Reflex::Type type_3520 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::Electron>"));
  ::Reflex::Type type_3505 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_3525 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::GsfTrack>"));
  ::Reflex::Type type_7328 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::PFCandidate>"));
  ::Reflex::Type type_7332 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::BaseTagInfo>"));
  ::Reflex::Type type_3584 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned short>"));
  ::Reflex::Type type_7342 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::CaloCluster>"));
  ::Reflex::Type type_3875 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::Photon>"));
  ::Reflex::Type type_13528 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Lepton<reco::BaseTau>"));
  ::Reflex::Type type_7339 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::GsfElectron>"));
  ::Reflex::Type type_13554 = ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::Muon>"));
  ::Reflex::Type type_3509 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::Conversion>"));
  ::Reflex::Type type_11590 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CompositePtrCandidate"));
  ::Reflex::Type type_3510 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::Hemisphere>"));
  ::Reflex::Type type_3512 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::PFParticle>"));
  ::Reflex::Type type_7306 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<reco::Photon>"));
  ::Reflex::Type type_11248 = ::Reflex::TypeBuilder(Reflex::Literal("reco::MuonMETCorrectionData"));
  ::Reflex::Type type_3872 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::Particle>"));
  ::Reflex::Type type_60536 = ::Reflex::EnumTypeBuilder(Reflex::Literal("pat::MET::METUncertainty"));
  ::Reflex::Type type_11561 = ::Reflex::TypeBuilder(Reflex::Literal("reco::SecondaryVertexTagInfo"));
  ::Reflex::Type type_13552 = ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::Photon>"));
  ::Reflex::Type type_7308 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<reco::BaseTau>"));
  ::Reflex::Type type_3878 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::Electron>"));
  ::Reflex::Type type_13486 = ::Reflex::TypeBuilder(Reflex::Literal("pat::TriggerObjectStandAlone"));
  ::Reflex::Type type_7330 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::LeafCandidate>"));
  ::Reflex::Type type_3539 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SpecificPFMETData>"));
  ::Reflex::Type type_3548 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::PFCandidate>"));
  ::Reflex::Type type_6466 = ::Reflex::TypeBuilder(Reflex::Literal("edm::FwdPtr<reco::BaseTagInfo>"));
  ::Reflex::Type type_3585 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::CaloCluster>"));
  ::Reflex::Type type_13553 = ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::BaseTau>"));
  ::Reflex::Type type_3533 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::GenParticle>"));
  ::Reflex::Type type_19497 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase"));
  ::Reflex::Type type_7298 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<reco::Candidate>"));
  ::Reflex::Type type_3867 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::Conversion>"));
  ::Reflex::Type type_3868 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::Hemisphere>"));
  ::Reflex::Type type_3524 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::SuperCluster>"));
  ::Reflex::Type type_3870 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::PFParticle>"));
  ::Reflex::Type type_60534 = ::Reflex::EnumTypeBuilder(Reflex::Literal("pat::MET::UncorrectionType"));
  ::Reflex::Type type_6449 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::Candidate>"));
  ::Reflex::Type type_13530 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Lepton<reco::GsfElectron>"));
  ::Reflex::Type type_46617 = ::Reflex::TypeBuilder(Reflex::Literal("reco::GsfElectron::ShowerShape"));
  ::Reflex::Type type_22727 = ::Reflex::TypeBuilder(Reflex::Literal("pat::MET::PackedMETUncertainty"));
  ::Reflex::Type type_13634 = ::Reflex::EnumTypeBuilder(Reflex::Literal("trigger::TriggerObjectType"));
  ::Reflex::Type type_3090 = ::Reflex::TypeBuilder(Reflex::Literal("std::random_access_iterator_tag"));
  ::Reflex::Type type_47549 = ::Reflex::TypeBuilder(Reflex::Literal("reco::candidate::const_iterator"));
  ::Reflex::Type type_3540 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SpecificCaloMETData>"));
  ::Reflex::Type type_3542 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::MET::UncorInfo>"));
  ::Reflex::Type type_3552 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::JetCorrFactors>"));
  ::Reflex::Type type_59674 = ::Reflex::EnumTypeBuilder(Reflex::Literal("pat::JetCorrFactors::Flavor"));
  ::Reflex::Type type_3600 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::RecoTauPiZero>"));
  ::Reflex::Type type_46872 = ::Reflex::EnumTypeBuilder(Reflex::Literal("reco::Muon::ArbitrationType"));
  ::Reflex::Type type_11228 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CompositeRefBaseCandidate"));
  ::Reflex::Type type_5370 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorBase<unsigned int>"));
  ::Reflex::Type type_3508 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::PackedCandidate>"));
  ::Reflex::Type type_3511 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::GenericParticle>"));
  ::Reflex::Type type_7301 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<reco::PFCandidate>"));
  ::Reflex::Type type_3558 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ptr<CaloTower> >"));
  ::Reflex::Type type_7310 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<reco::GsfElectron>"));
  ::Reflex::Type type_59788 = ::Reflex::EnumTypeBuilder(Reflex::Literal("pat::PackedCandidate::PVAssoc"));
  ::Reflex::Type type_13547 = ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::PFCandidate>"));
  ::Reflex::Type type_60537 = ::Reflex::EnumTypeBuilder(Reflex::Literal("pat::MET::METUncertaintyLevel"));
  ::Reflex::Type type_3549 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::PFJet::Specific>"));
  ::Reflex::Type type_3624 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::GsfElectronCore>"));
  ::Reflex::Type type_13555 = ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::GsfElectron>"));
  ::Reflex::Type type_7329 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::CompositeCandidate>"));
  ::Reflex::Type type_3507 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::PackedGenParticle>"));
  ::Reflex::Type type_3522 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::VertexAssociation>"));
  ::Reflex::Type type_3550 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::JPTJet::Specific>"));
  ::Reflex::Type type_3596 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::TauJetCorrFactors>"));
  ::Reflex::Type type_3535 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::LookupTableRecord>"));
  ::Reflex::Type type_3529 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::CandKinResolution>"));
  ::Reflex::Type type_7303 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<reco::LeafCandidate>"));
  ::Reflex::Type type_7200 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolderBase"));
  ::Reflex::Type type_7484 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::Tau> >"));
  ::Reflex::Type type_7481 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::MET> >"));
  ::Reflex::Type type_7482 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::Jet> >"));
  ::Reflex::Type type_3866 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::PackedCandidate>"));
  ::Reflex::Type type_13546 = ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::RecoCandidate>"));
  ::Reflex::Type type_3869 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::GenericParticle>"));
  ::Reflex::Type type_3513 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::CompositeCandidate>"));
  ::Reflex::Type type_13549 = ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>"));
  ::Reflex::Type type_2742 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::FwdPtr<CaloTower> >"));
  ::Reflex::Type type_3551 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::CaloJet::Specific>"));
  ::Reflex::Type type_3597 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::tau::TauPFSpecific>"));
  ::Reflex::Type type_7232 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Tau> >"));
  ::Reflex::Type type_7229 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::MET> >"));
  ::Reflex::Type type_7485 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::Muon> >"));
  ::Reflex::Type type_7230 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Jet> >"));
  ::Reflex::Type type_6817 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::MHT> >"));
  ::Reflex::Type type_6818 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::MET> >"));
  ::Reflex::Type type_6819 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Jet> >"));
  ::Reflex::Type type_6821 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Tau> >"));
  ::Reflex::Type type_3528 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_3599 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::tau::TauPFEssential>"));
  ::Reflex::Type type_3258 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::MHT> >"));
  ::Reflex::Type type_3259 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::MET> >"));
  ::Reflex::Type type_3260 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::Jet> >"));
  ::Reflex::Type type_3262 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::Tau> >"));
  ::Reflex::Type type_7233 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Muon> >"));
  ::Reflex::Type type_3017 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::MET*>"));
  ::Reflex::Type type_3018 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::Jet*>"));
  ::Reflex::Type type_3020 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::Tau*>"));
  ::Reflex::Type type_3016 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::MHT*>"));
  ::Reflex::Type type_6822 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Muon> >"));
  ::Reflex::Type type_3865 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::PackedGenParticle>"));
  ::Reflex::Type type_3598 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>"));
  ::Reflex::Type type_3263 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::Muon> >"));
  ::Reflex::Type type_7483 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::Photon> >"));
  ::Reflex::Type type_3021 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::Muon*>"));
  ::Reflex::Type type_3871 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::CompositeCandidate>"));
  ::Reflex::Type type_3449 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,bool>"));
  ::Reflex::Type type_3954 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::tau::TauPFSpecific>"));
  ::Reflex::Type type_3530 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ptr<reco::Candidate> >"));
  ::Reflex::Type type_6986 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::Tau> >"));
  ::Reflex::Type type_6983 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::MET> >"));
  ::Reflex::Type type_7231 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Photon> >"));
  ::Reflex::Type type_6984 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::Jet> >"));
  ::Reflex::Type type_6820 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Photon> >"));
  ::Reflex::Type type_59789 = ::Reflex::EnumTypeBuilder(Reflex::Literal("pat::PackedCandidate::LostInnerHits"));
  ::Reflex::Type type_3441 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,float>"));
  ::Reflex::Type type_3620 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::MuonMETCorrectionData>"));
  ::Reflex::Type type_3951 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::tau::TauPFEssential>"));
  ::Reflex::Type type_3261 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::Photon> >"));
  ::Reflex::Type type_7302 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<reco::CompositeCandidate>"));
  ::Reflex::Type type_7480 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::Particle> >"));
  ::Reflex::Type type_6987 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::Muon> >"));
  ::Reflex::Type type_7486 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::Electron> >"));
  ::Reflex::Type type_3019 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::Photon*>"));
  ::Reflex::Type type_13548 = ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::CompositeCandidate>"));
  ::Reflex::Type type_3557 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ptr<reco::PFCandidate> >"));
  ::Reflex::Type type_3601 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::PFRecoTauChargedHadron>"));
  ::Reflex::Type type_3953 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::tau::TauCaloSpecific>"));
  ::Reflex::Type type_3536 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::TriggerObjectStandAlone>"));
  ::Reflex::Type type_7228 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Particle> >"));
  ::Reflex::Type type_7131 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::Tau> >"));
  ::Reflex::Type type_7128 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::MET> >"));
  ::Reflex::Type type_7129 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::Jet> >"));
  ::Reflex::Type type_7234 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Electron> >"));
  ::Reflex::Type type_6816 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Particle> >"));
  ::Reflex::Type type_6823 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Electron> >"));
  ::Reflex::Type type_3257 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::Particle> >"));
  ::Reflex::Type type_3264 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::Electron> >"));
  ::Reflex::Type type_7478 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::PFParticle> >"));
  ::Reflex::Type type_6985 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::Photon> >"));
  ::Reflex::Type type_7132 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::Muon> >"));
  ::Reflex::Type type_7476 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::Hemisphere> >"));
  ::Reflex::Type type_7475 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::Conversion> >"));
  ::Reflex::Type type_3015 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::Particle*>"));
  ::Reflex::Type type_3022 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::Electron*>"));
  ::Reflex::Type type_3541 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>"));
  ::Reflex::Type type_7226 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::PFParticle> >"));
  ::Reflex::Type type_7224 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Hemisphere> >"));
  ::Reflex::Type type_7223 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Conversion> >"));
  ::Reflex::Type type_6811 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Conversion> >"));
  ::Reflex::Type type_6812 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Hemisphere> >"));
  ::Reflex::Type type_6814 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::PFParticle> >"));
  ::Reflex::Type type_3547 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::FwdPtr<reco::PFCandidate> >"));
  ::Reflex::Type type_3546 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::FwdPtr<reco::BaseTagInfo> >"));
  ::Reflex::Type type_3252 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::Conversion> >"));
  ::Reflex::Type type_3253 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::Hemisphere> >"));
  ::Reflex::Type type_3255 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::PFParticle> >"));
  ::Reflex::Type type_6982 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::Particle> >"));
  ::Reflex::Type type_7130 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::Photon> >"));
  ::Reflex::Type type_6988 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::Electron> >"));
  ::Reflex::Type type_3010 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::Conversion*>"));
  ::Reflex::Type type_3011 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::Hemisphere*>"));
  ::Reflex::Type type_3013 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::PFParticle*>"));
  ::Reflex::Type type_40410 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>"));
  ::Reflex::Type type_3235 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::RefHolderBase>"));
  ::Reflex::Type type_7060 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::MHT> >"));
  ::Reflex::Type type_7061 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::MET> >"));
  ::Reflex::Type type_7062 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::Jet> >"));
  ::Reflex::Type type_7064 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::Tau> >"));
  ::Reflex::Type type_3532 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::PtrVector<reco::Candidate> >"));
  ::Reflex::Type type_3894 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pat::MET::PackedMETUncertainty>"));
  ::Reflex::Type type_7065 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::Muon> >"));
  ::Reflex::Type type_7127 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::Particle> >"));
  ::Reflex::Type type_6980 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::PFParticle> >"));
  ::Reflex::Type type_6978 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::Hemisphere> >"));
  ::Reflex::Type type_6977 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::Conversion> >"));
  ::Reflex::Type type_7133 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::Electron> >"));
  ::Reflex::Type type_7477 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::GenericParticle> >"));
  ::Reflex::Type type_7474 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::PackedCandidate> >"));
  ::Reflex::Type type_7221 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::PackedCandidate> >"));
  ::Reflex::Type type_7063 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::Photon> >"));
  ::Reflex::Type type_7225 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::GenericParticle> >"));
  ::Reflex::Type type_7125 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::PFParticle> >"));
  ::Reflex::Type type_7123 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::Hemisphere> >"));
  ::Reflex::Type type_7122 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::Conversion> >"));
  ::Reflex::Type type_6810 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::PackedCandidate> >"));
  ::Reflex::Type type_6813 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::GenericParticle> >"));
  ::Reflex::Type type_3251 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::PackedCandidate> >"));
  ::Reflex::Type type_3254 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::GenericParticle> >"));
  ::Reflex::Type type_7473 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::PackedGenParticle> >"));
  ::Reflex::Type type_3009 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::PackedCandidate*>"));
  ::Reflex::Type type_3012 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::GenericParticle*>"));
  ::Reflex::Type type_7059 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::Particle> >"));
  ::Reflex::Type type_7066 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::Electron> >"));
  ::Reflex::Type type_7222 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::PackedGenParticle> >"));
  ::Reflex::Type type_7479 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::CompositeCandidate> >"));
  ::Reflex::Type type_3233 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_40438 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<reco::Candidate>"));
  ::Reflex::Type type_6809 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::PackedGenParticle> >"));
  ::Reflex::Type type_3250 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::PackedGenParticle> >"));
  ::Reflex::Type type_6979 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::GenericParticle> >"));
  ::Reflex::Type type_7227 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::CompositeCandidate> >"));
  ::Reflex::Type type_6976 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::PackedCandidate> >"));
  ::Reflex::Type type_3008 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::PackedGenParticle*>"));
  ::Reflex::Type type_6815 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::CompositeCandidate> >"));
  ::Reflex::Type type_7054 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::Conversion> >"));
  ::Reflex::Type type_7055 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::Hemisphere> >"));
  ::Reflex::Type type_7057 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::PFParticle> >"));
  ::Reflex::Type type_3256 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<pat::CompositeCandidate> >"));
  ::Reflex::Type type_3014 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const pat::CompositeCandidate*>"));
  ::Reflex::Type type_7358 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Association<std::vector<pat::PackedCandidate> >"));
  ::Reflex::Type type_3503 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<edm::ProductID,unsigned int> >"));
  ::Reflex::Type type_40974 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolderBase::const_iterator"));
  ::Reflex::Type type_2843 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::MET,std::allocator<pat::MET> >"));
  ::Reflex::Type type_12375 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::MET> >"));
  ::Reflex::Type type_2853 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Jet,std::allocator<pat::Jet> >"));
  ::Reflex::Type type_12385 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::Jet> >"));
  ::Reflex::Type type_7117 = ::Reflex::TypeBuilder(Reflex::Literal("edm::AtomicPtrCache<std::vector<reco::SuperCluster> >"));
  ::Reflex::Type type_3583 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >"));
  ::Reflex::Type type_2886 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Tau,std::allocator<pat::Tau> >"));
  ::Reflex::Type type_12418 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::Tau> >"));
  ::Reflex::Type type_2829 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::MHT,std::allocator<pat::MHT> >"));
  ::Reflex::Type type_12361 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::MHT> >"));
  ::Reflex::Type type_6975 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::PackedGenParticle> >"));
  ::Reflex::Type type_7124 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::GenericParticle> >"));
  ::Reflex::Type type_7121 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::PackedCandidate> >"));
  ::Reflex::Type type_3555 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >"));
  ::Reflex::Type type_12434 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::Muon> >"));
  ::Reflex::Type type_6174 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_6981 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::CompositeCandidate> >"));
  ::Reflex::Type type_7116 = ::Reflex::TypeBuilder(Reflex::Literal("edm::AtomicPtrCache<std::vector<edm::Ptr<CaloTower> > >"));
  ::Reflex::Type type_2902 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Muon,std::allocator<pat::Muon> >"));
  ::Reflex::Type type_7120 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::PackedGenParticle> >"));
  ::Reflex::Type type_12407 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::Photon> >"));
  ::Reflex::Type type_7126 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::CompositeCandidate> >"));
  ::Reflex::Type type_40973 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolderBase::const_iterator_imp"));
  ::Reflex::Type type_7053 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::PackedCandidate> >"));
  ::Reflex::Type type_7056 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::GenericParticle> >"));
  ::Reflex::Type type_10171 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >"));
  ::Reflex::Type type_12369 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::Particle> >"));
  ::Reflex::Type type_12438 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::Electron> >"));
  ::Reflex::Type type_2875 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Photon,std::allocator<pat::Photon> >"));
  ::Reflex::Type type_7052 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::PackedGenParticle> >"));
  ::Reflex::Type type_10175 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >"));
  ::Reflex::Type type_12363 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::Conversion> >"));
  ::Reflex::Type type_12364 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::Hemisphere> >"));
  ::Reflex::Type type_3523 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> >"));
  ::Reflex::Type type_12367 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::PFParticle> >"));
  ::Reflex::Type type_7058 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<pat::CompositeCandidate> >"));
  ::Reflex::Type type_7463 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> >"));
  ::Reflex::Type type_116 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >"));
  ::Reflex::Type type_129 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >"));
  ::Reflex::Type type_2837 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Particle,std::allocator<pat::Particle> >"));
  ::Reflex::Type type_12001 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> >"));
  ::Reflex::Type type_7115 = ::Reflex::TypeBuilder(Reflex::Literal("edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >"));
  ::Reflex::Type type_12020 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> >"));
  ::Reflex::Type type_12085 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> >"));
  ::Reflex::Type type_2906 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Electron,std::allocator<pat::Electron> >"));
  ::Reflex::Type type_11973 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> >"));
  ::Reflex::Type type_12439 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::PackedCandidate> >"));
  ::Reflex::Type type_12366 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::GenericParticle> >"));
  ::Reflex::Type type_12116 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> >"));
  ::Reflex::Type type_35592 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet>"));
  ::Reflex::Type type_35616 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau>"));
  ::Reflex::Type type_35580 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET>"));
  ::Reflex::Type type_3234 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >"));
  ::Reflex::Type type_7465 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OwnVector<reco::Candidate,edm::ClonePolicy<reco::Candidate> >"));
  ::Reflex::Type type_71364 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<reco::Candidate>::const_iterator"));
  ::Reflex::Type type_12362 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::PackedGenParticle> >"));
  ::Reflex::Type type_2831 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Conversion,std::allocator<pat::Conversion> >"));
  ::Reflex::Type type_2832 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Hemisphere,std::allocator<pat::Hemisphere> >"));
  ::Reflex::Type type_869 = ::Reflex::TypeBuilder(Reflex::Literal("edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >"));
  ::Reflex::Type type_2835 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::PFParticle,std::allocator<pat::PFParticle> >"));
  ::Reflex::Type type_35628 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon>"));
  ::Reflex::Type type_6794 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >"));
  ::Reflex::Type type_12368 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::CompositeCandidate> >"));
  ::Reflex::Type type_12417 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::tau::TauPFSpecific> >"));
  ::Reflex::Type type_3232 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::Association<std::vector<pat::PackedCandidate> > >"));
  ::Reflex::Type type_11974 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >"));
  ::Reflex::Type type_11975 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >"));
  ::Reflex::Type type_11977 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >"));
  ::Reflex::Type type_11972 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >"));
  ::Reflex::Type type_547 = ::Reflex::TypeBuilder(Reflex::Literal("edm::SortedCollection<EcalRecHit,edm::StrictWeakOrdering<EcalRecHit> >"));
  ::Reflex::Type type_12064 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> >"));
  ::Reflex::Type type_12414 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::tau::TauPFEssential> >"));
  ::Reflex::Type type_7464 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OwnVector<reco::BaseTagInfo,edm::ClonePolicy<reco::BaseTagInfo> >"));
  ::Reflex::Type type_12416 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::tau::TauCaloSpecific> >"));
  ::Reflex::Type type_71363 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<reco::Candidate>::const_iterator_imp"));
  ::Reflex::Type type_11978 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >"));
  ::Reflex::Type type_3537 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,pat::LookupTableRecord> >"));
  ::Reflex::Type type_35604 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon>"));
  ::Reflex::Type type_11990 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> >"));
  ::Reflex::Type type_12121 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> >"));
  ::Reflex::Type type_11976 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >"));
  ::Reflex::Type type_12371 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pat::MET::PackedMETUncertainty> >"));
  ::Reflex::Type type_35568 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle>"));
  ::Reflex::Type type_37548 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::Tau> >"));
  ::Reflex::Type type_37542 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::MET> >"));
  ::Reflex::Type type_37544 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::Jet> >"));
  ::Reflex::Type type_35640 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron>"));
  ::Reflex::Type type_37550 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::Muon> >"));
  ::Reflex::Type type_7037 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::Association<std::vector<pat::PackedCandidate> > >"));
  ::Reflex::Type type_2907 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::PackedCandidate,std::allocator<pat::PackedCandidate> >"));
  ::Reflex::Type type_11981 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> >"));
  ::Reflex::Type type_11982 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> >"));
  ::Reflex::Type type_2834 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::GenericParticle,std::allocator<pat::GenericParticle> >"));
  ::Reflex::Type type_11988 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> >"));
  ::Reflex::Type type_37546 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::Photon> >"));
  ::Reflex::Type type_11971 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >"));
  ::Reflex::Type type_11979 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >"));
  ::Reflex::Type type_35520 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere>"));
  ::Reflex::Type type_35544 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle>"));
  ::Reflex::Type type_35508 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion>"));
  ::Reflex::Type type_37540 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::Particle> >"));
  ::Reflex::Type type_37552 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::Electron> >"));
  ::Reflex::Type type_2830 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::PackedGenParticle,std::allocator<pat::PackedGenParticle> >"));
  ::Reflex::Type type_37536 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::PFParticle> >"));
  ::Reflex::Type type_37532 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::Hemisphere> >"));
  ::Reflex::Type type_37530 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::Conversion> >"));
  ::Reflex::Type type_11966 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >"));
  ::Reflex::Type type_11967 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >"));
  ::Reflex::Type type_11969 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >"));
  ::Reflex::Type type_2836 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::CompositeCandidate,std::allocator<pat::CompositeCandidate> >"));
  ::Reflex::Type type_2885 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::tau::TauPFSpecific,std::allocator<pat::tau::TauPFSpecific> >"));
  ::Reflex::Type type_2882 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::tau::TauPFEssential,std::allocator<pat::tau::TauPFEssential> >"));
  ::Reflex::Type type_4321 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> > >"));
  ::Reflex::Type type_4341 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> > >"));
  ::Reflex::Type type_4407 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> > >"));
  ::Reflex::Type type_4293 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> > >"));
  ::Reflex::Type type_12122 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> >"));
  ::Reflex::Type type_11987 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> >"));
  ::Reflex::Type type_2884 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::tau::TauCaloSpecific,std::allocator<pat::tau::TauCaloSpecific> >"));
  ::Reflex::Type type_37534 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::GenericParticle> >"));
  ::Reflex::Type type_37528 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::PackedCandidate> >"));
  ::Reflex::Type type_4439 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> > >"));
  ::Reflex::Type type_37526 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::PackedGenParticle> >"));
  ::Reflex::Type type_35532 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle>"));
  ::Reflex::Type type_35496 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate>"));
  ::Reflex::Type type_37538 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<pat::CompositeCandidate> >"));
  ::Reflex::Type type_11980 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >"));
  ::Reflex::Type type_4320 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> > >"));
  ::Reflex::Type type_4340 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> > >"));
  ::Reflex::Type type_4385 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> > >"));
  ::Reflex::Type type_4406 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> > >"));
  ::Reflex::Type type_4292 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> > >"));
  ::Reflex::Type type_11965 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >"));
  ::Reflex::Type type_11968 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >"));
  ::Reflex::Type type_11989 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >"));
  ::Reflex::Type type_12083 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >"));
  ::Reflex::Type type_35484 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle>"));
  ::Reflex::Type type_4438 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> > >"));
  ::Reflex::Type type_12077 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >"));
  ::Reflex::Type type_35556 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate>"));
  ::Reflex::Type type_4309 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> > >"));
  ::Reflex::Type type_4447 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> > >"));
  ::Reflex::Type type_11964 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >"));
  ::Reflex::Type type_2839 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::MET::PackedMETUncertainty,std::allocator<pat::MET::PackedMETUncertainty> >"));
  ::Reflex::Type type_12081 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >"));
  ::Reflex::Type type_4384 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> > >"));
  ::Reflex::Type type_11970 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >"));
  ::Reflex::Type type_12084 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >"));
  ::Reflex::Type type_4297 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> > >"));
  ::Reflex::Type type_4299 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> > >"));
  ::Reflex::Type type_4305 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> > >"));
  ::Reflex::Type type_10181 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>"));
  ::Reflex::Type type_12078 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >"));
  ::Reflex::Type type_4308 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> > >"));
  ::Reflex::Type type_4446 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> > >"));
  ::Reflex::Type type_12082 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >"));
  ::Reflex::Type type_10187 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>"));
  ::Reflex::Type type_7378 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >"));
  ::Reflex::Type type_7375 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >"));
  ::Reflex::Type type_7376 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >"));
  ::Reflex::Type type_4296 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> > >"));
  ::Reflex::Type type_4298 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> > >"));
  ::Reflex::Type type_4304 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> > >"));
  ::Reflex::Type type_11993 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >"));
  ::Reflex::Type type_45703 = ::Reflex::TypeBuilder(Reflex::Literal("reco::candidate::iterator_imp_specific<edm::OwnVector<reco::Candidate,edm::ClonePolicy<reco::Candidate> > >"));
  ::Reflex::Type type_7379 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >"));
  ::Reflex::Type type_4449 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> > >"));
  ::Reflex::Type type_4303 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> > >"));
  ::Reflex::Type type_6485 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >"));
  ::Reflex::Type type_6487 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >"));
  ::Reflex::Type type_6484 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >"));
  ::Reflex::Type type_11994 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >"));
  ::Reflex::Type type_45701 = ::Reflex::TypeBuilder(Reflex::Literal("reco::candidate::const_iterator_imp_specific<edm::OwnVector<reco::Candidate,edm::ClonePolicy<reco::Candidate> > >"));
  ::Reflex::Type type_4295 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> > >"));
  ::Reflex::Type type_6488 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >"));
  ::Reflex::Type type_4448 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> > >"));
  ::Reflex::Type type_4302 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> > >"));
  ::Reflex::Type type_4307 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> > >"));
  ::Reflex::Type type_4405 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> > >"));
  ::Reflex::Type type_7377 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >"));
  ::Reflex::Type type_7397 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >"));
  ::Reflex::Type type_7406 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::PFJet>,reco::PFJet,edm::refhelper::FindUsingAdvance<std::vector<reco::PFJet>,reco::PFJet> >"));
  ::Reflex::Type type_4399 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> > >"));
  ::Reflex::Type type_4294 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> > >"));
  ::Reflex::Type type_4403 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> > >"));
  ::Reflex::Type type_6386 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >"));
  ::Reflex::Type type_6388 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >"));
  ::Reflex::Type type_6385 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >"));
  ::Reflex::Type type_7389 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::Vertex>,reco::Vertex,edm::refhelper::FindUsingAdvance<std::vector<reco::Vertex>,reco::Vertex> >"));
  ::Reflex::Type type_4306 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> > >"));
  ::Reflex::Type type_7382 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::GenJet>,reco::GenJet,edm::refhelper::FindUsingAdvance<std::vector<reco::GenJet>,reco::GenJet> >"));
  ::Reflex::Type type_4404 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> > >"));
  ::Reflex::Type type_6486 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >"));
  ::Reflex::Type type_6550 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >"));
  ::Reflex::Type type_4398 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> > >"));
  ::Reflex::Type type_6389 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >"));
  ::Reflex::Type type_6838 = ::Reflex::TypeBuilder(Reflex::Literal("edm::FwdRef<std::vector<reco::GenJet>,reco::GenJet,edm::refhelper::FindUsingAdvance<std::vector<reco::GenJet>,reco::GenJet> >"));
  ::Reflex::Type type_7374 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >"));
  ::Reflex::Type type_7380 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >"));
  ::Reflex::Type type_4402 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> > >"));
  ::Reflex::Type type_6803 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >"));
  ::Reflex::Type type_6804 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >"));
  ::Reflex::Type type_6806 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >"));
  ::Reflex::Type type_6551 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::GenJet>,reco::GenJet,edm::refhelper::FindUsingAdvance<std::vector<reco::GenJet>,reco::GenJet> >"));
  ::Reflex::Type type_3244 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >"));
  ::Reflex::Type type_3245 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >"));
  ::Reflex::Type type_3247 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >"));
  ::Reflex::Type type_7436 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::GsfTrack>,reco::GsfTrack,edm::refhelper::FindUsingAdvance<std::vector<reco::GsfTrack>,reco::GsfTrack> >"));
  ::Reflex::Type type_4313 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> > >"));
  ::Reflex::Type type_6807 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >"));
  ::Reflex::Type type_6483 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >"));
  ::Reflex::Type type_6489 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >"));
  ::Reflex::Type type_6387 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >"));
  ::Reflex::Type type_3248 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >"));
  ::Reflex::Type type_7372 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >"));
  ::Reflex::Type type_7370 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >"));
  ::Reflex::Type type_7369 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >"));
  ::Reflex::Type type_40430 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >"));
  ::Reflex::Type type_40431 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >"));
  ::Reflex::Type type_40433 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >"));
  ::Reflex::Type type_4312 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> > >"));
  ::Reflex::Type type_7046 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >"));
  ::Reflex::Type type_7047 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >"));
  ::Reflex::Type type_7049 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >"));
  ::Reflex::Type type_40434 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >"));
  ::Reflex::Type type_6805 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >"));
  ::Reflex::Type type_6479 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >"));
  ::Reflex::Type type_6478 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >"));
  ::Reflex::Type type_6481 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >"));
  ::Reflex::Type type_6384 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >"));
  ::Reflex::Type type_6390 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >"));
  ::Reflex::Type type_3246 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >"));
  ::Reflex::Type type_7050 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >"));
  ::Reflex::Type type_7381 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >"));
  ::Reflex::Type type_7366 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::PFCandidate>,reco::PFCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::PFCandidate>,reco::PFCandidate> >"));
  ::Reflex::Type type_7438 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::SuperCluster>,reco::SuperCluster,edm::refhelper::FindUsingAdvance<std::vector<reco::SuperCluster>,reco::SuperCluster> >"));
  ::Reflex::Type type_7118 = ::Reflex::TypeBuilder(Reflex::Literal("edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >"));
  ::Reflex::Type type_40432 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >"));
  ::Reflex::Type type_6802 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >"));
  ::Reflex::Type type_6808 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >"));
  ::Reflex::Type type_6380 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >"));
  ::Reflex::Type type_6379 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >"));
  ::Reflex::Type type_6382 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >"));
  ::Reflex::Type type_3243 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >"));
  ::Reflex::Type type_7048 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >"));
  ::Reflex::Type type_3249 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >"));
  ::Reflex::Type type_40447 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >"));
  ::Reflex::Type type_40448 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >"));
  ::Reflex::Type type_40450 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >"));
  ::Reflex::Type type_40451 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >"));
  ::Reflex::Type type_7371 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >"));
  ::Reflex::Type type_7367 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >"));
  ::Reflex::Type type_7401 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::CaloTauTagInfo>,reco::CaloTauTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloTauTagInfo>,reco::CaloTauTagInfo> >"));
  ::Reflex::Type type_40429 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >"));
  ::Reflex::Type type_40435 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >"));
  ::Reflex::Type type_6797 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >"));
  ::Reflex::Type type_6798 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >"));
  ::Reflex::Type type_6800 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >"));
  ::Reflex::Type type_3534 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > >"));
  ::Reflex::Type type_3238 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >"));
  ::Reflex::Type type_3239 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >"));
  ::Reflex::Type type_3241 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >"));
  ::Reflex::Type type_7045 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >"));
  ::Reflex::Type type_7051 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >"));
  ::Reflex::Type type_37549 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >"));
  ::Reflex::Type type_37543 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >"));
  ::Reflex::Type type_37545 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >"));
  ::Reflex::Type type_7439 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::GsfElectronCore>,reco::GsfElectronCore,edm::refhelper::FindUsingAdvance<std::vector<reco::GsfElectronCore>,reco::GsfElectronCore> >"));
  ::Reflex::Type type_6480 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >"));
  ::Reflex::Type type_6477 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >"));
  ::Reflex::Type type_40449 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >"));
  ::Reflex::Type type_37551 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >"));
  ::Reflex::Type type_7368 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >"));
  ::Reflex::Type type_40427 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >"));
  ::Reflex::Type type_7040 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >"));
  ::Reflex::Type type_7041 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >"));
  ::Reflex::Type type_7043 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >"));
  ::Reflex::Type type_7373 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >"));
  ::Reflex::Type type_6476 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >"));
  ::Reflex::Type type_6381 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >"));
  ::Reflex::Type type_6378 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >"));
  ::Reflex::Type type_40446 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >"));
  ::Reflex::Type type_40452 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >"));
  ::Reflex::Type type_37547 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >"));
  ::Reflex::Type type_6482 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >"));
  ::Reflex::Type type_6799 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >"));
  ::Reflex::Type type_6377 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >"));
  ::Reflex::Type type_3240 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >"));
  ::Reflex::Type type_40444 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >"));
  ::Reflex::Type type_37541 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >"));
  ::Reflex::Type type_37553 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >"));
  ::Reflex::Type type_6383 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >"));
  ::Reflex::Type type_40426 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >"));
  ::Reflex::Type type_7042 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >"));
  ::Reflex::Type type_37537 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >"));
  ::Reflex::Type type_37533 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >"));
  ::Reflex::Type type_37531 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >"));
  ::Reflex::Type type_7404 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::PFRecoTauChargedHadron>,reco::PFRecoTauChargedHadron,edm::refhelper::FindUsingAdvance<std::vector<reco::PFRecoTauChargedHadron>,reco::PFRecoTauChargedHadron> >"));
  ::Reflex::Type type_6801 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >"));
  ::Reflex::Type type_3242 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >"));
  ::Reflex::Type type_40428 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >"));
  ::Reflex::Type type_7044 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >"));
  ::Reflex::Type type_40443 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >"));
  ::Reflex::Type type_1018 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower,edm::refhelper::FindUsingAdvance<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower> >"));
  ::Reflex::Type type_37535 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >"));
  ::Reflex::Type type_37529 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> > >"));
  ::Reflex::Type type_40424 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >"));
  ::Reflex::Type type_40445 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >"));
  ::Reflex::Type type_37527 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> > >"));
  ::Reflex::Type type_37539 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >"));
  ::Reflex::Type type_40439 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >"));
  ::Reflex::Type type_13468 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::ParticleRefVector"), type_6483);
  ::Reflex::Type type_13475 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::PhotonRefVector"), type_6486);
  ::Reflex::Type type_13479 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::MuonRefVector"), type_6488);
  ::Reflex::Type type_13483 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::PackedGenParticleRef"), type_7368);
  ::Reflex::Type type_13484 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::JetRefVector"), type_6485);
  ::Reflex::Type type_13490 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::GenericParticleRefVector"), type_6480);
  ::Reflex::Type type_13492 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::ParticleRef"), type_7374);
  ::Reflex::Type type_13500 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::GenericParticleRef"), type_7371);
  ::Reflex::Type type_13501 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::PackedCandidateRefVector"), type_6477);
  ::Reflex::Type type_13502 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::HemisphereRefVector"), type_6479);
  ::Reflex::Type type_13504 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::CompositeCandidateRefVector"), type_6482);
  ::Reflex::Type type_13505 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::PFParticleRef"), type_7372);
  ::Reflex::Type type_13507 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::ConversionRefVector"), type_6478);
  ::Reflex::Type type_13513 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TauRef"), type_7378);
  ::Reflex::Type type_13514 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::CompositeCandidateRef"), type_7373);
  ::Reflex::Type type_13516 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TauRefVector"), type_6487);
  ::Reflex::Type type_13522 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::METRefVector"), type_6484);
  ::Reflex::Type type_13531 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::PackedCandidateRef"), type_7367);
  ::Reflex::Type type_13534 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::METRef"), type_7375);
  ::Reflex::Type type_13536 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::PhotonRef"), type_7377);
  ::Reflex::Type type_13556 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::PFParticleRefVector"), type_6481);
  ::Reflex::Type type_13557 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::MuonRef"), type_7379);
  ::Reflex::Type type_13558 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::JetRef"), type_7376);
  ::Reflex::Type type_13560 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::HemisphereRef"), type_7370);
  ::Reflex::Type type_13563 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::ElectronRefVector"), type_6489);
  ::Reflex::Type type_13570 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::ConversionRef"), type_7369);
  ::Reflex::Type type_13573 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::ElectronRef"), type_7380);
  ::Reflex::Type type_13574 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::PackedGenParticleRefVector"), type_6476);
  ::Reflex::Type type_20576 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::PackedGenParticle>::const_iterator"), type_11964);
  ::Reflex::Type type_20639 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::PackedCandidate>::const_iterator"), type_11965);
  ::Reflex::Type type_20702 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::Conversion>::const_iterator"), type_11966);
  ::Reflex::Type type_20765 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::Hemisphere>::const_iterator"), type_11967);
  ::Reflex::Type type_20828 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::GenericParticle>::const_iterator"), type_11968);
  ::Reflex::Type type_20891 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::PFParticle>::const_iterator"), type_11969);
  ::Reflex::Type type_20954 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::CompositeCandidate>::const_iterator"), type_11970);
  ::Reflex::Type type_21017 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::Particle>::const_iterator"), type_11971);
  ::Reflex::Type type_21080 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::MET>::const_iterator"), type_11974);
  ::Reflex::Type type_21143 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::Jet>::const_iterator"), type_11975);
  ::Reflex::Type type_21206 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::Photon>::const_iterator"), type_11976);
  ::Reflex::Type type_21269 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::Tau>::const_iterator"), type_11977);
  ::Reflex::Type type_21332 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::Muon>::const_iterator"), type_11978);
  ::Reflex::Type type_21395 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::Electron>::const_iterator"), type_11979);
  ::Reflex::Type type_21458 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<pat::MHT>::const_iterator"), type_11972);
  ::Reflex::Type type_2024 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint16_t"), type_232);
  ::Reflex::Type type_10176 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::PtEtaPhiMLorentzVectorD"), type_10175);
  ::Reflex::Type type_10195 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::PtEtaPhiMLorentzVector"), type_10176);
  ::Reflex::Type type_10172 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZTLorentzVectorD"), type_10171);
  ::Reflex::Type type_10223 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZTLorentzVector"), type_10172);
  ::Reflex::Type type_10182 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZPointD"), type_10181);
  ::Reflex::Type type_10191 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZPoint"), type_10182);
  ::Reflex::Type type_626 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("int8_t"), type_131);
  ::Reflex::Type type_11252 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::GenParticleRef"), type_7381);
  ::Reflex::Type type_11459 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CandidateCollection"), type_7465);
  ::Reflex::Type type_10188 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZVectorD"), type_10187);
  ::Reflex::Type type_10222 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZVector"), type_10188);
  ::Reflex::Type type_20572 = ::Reflex::ReferenceBuilder(type_9072);
  ::Reflex::Type type_9072c = ::Reflex::ConstBuilder(type_9072);
  ::Reflex::Type type_17687 = ::Reflex::ReferenceBuilder(type_9072c);
  ::Reflex::Type type_11257c = ::Reflex::ConstBuilder(type_11257);
  ::Reflex::Type type_22224 = ::Reflex::ReferenceBuilder(type_11257c);
  ::Reflex::Type type_7381c = ::Reflex::ConstBuilder(type_7381);
  ::Reflex::Type type_17938 = ::Reflex::ReferenceBuilder(type_7381c);
  ::Reflex::Type type_2393 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_58);
  ::Reflex::Type type_9075c = ::Reflex::ConstBuilder(type_9075);
  ::Reflex::Type type_71865 = ::Reflex::PointerBuilder(type_9075c);
  ::Reflex::Type type_29399 = ::Reflex::PointerBuilder(type_9075);
  ::Reflex::Type type_3000 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2999);
  ::Reflex::Type type_3000c = ::Reflex::ConstBuilder(type_3000);
  ::Reflex::Type type_30686 = ::Reflex::ReferenceBuilder(type_3000c);
  ::Reflex::Type type_11562 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CandidatePtr"), type_7325);
  ::Reflex::Type type_10223c = ::Reflex::ConstBuilder(type_10223);
  ::Reflex::Type type_45676 = ::Reflex::ReferenceBuilder(type_10223c);
  ::Reflex::Type type_10195c = ::Reflex::ConstBuilder(type_10195);
  ::Reflex::Type type_45674 = ::Reflex::ReferenceBuilder(type_10195c);
  ::Reflex::Type type_10191c = ::Reflex::ConstBuilder(type_10191);
  ::Reflex::Type type_45678 = ::Reflex::ReferenceBuilder(type_10191c);
  ::Reflex::Type type_14425 = ::Reflex::PointerBuilder(type_9072);
  ::Reflex::Type type_35034 = ::Reflex::ReferenceBuilder(type_116);
  ::Reflex::Type type_11519 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CandidateBaseRef"), type_7298);
  ::Reflex::Type type_11519c = ::Reflex::ConstBuilder(type_11519);
  ::Reflex::Type type_72488 = ::Reflex::ReferenceBuilder(type_11519c);
  ::Reflex::Type type_11562c = ::Reflex::ConstBuilder(type_11562);
  ::Reflex::Type type_72489 = ::Reflex::ReferenceBuilder(type_11562c);
  ::Reflex::Type type_17685 = ::Reflex::PointerBuilder(type_9072c);
  ::Reflex::Type type_3845 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_58);
  ::Reflex::Type type_3753 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_67);
  ::Reflex::Type type_3865c = ::Reflex::ConstBuilder(type_3865);
  ::Reflex::Type type_62387 = ::Reflex::ReferenceBuilder(type_3865c);
  ::Reflex::Type type_3507c = ::Reflex::ConstBuilder(type_3507);
  ::Reflex::Type type_35489 = ::Reflex::ReferenceBuilder(type_3507c);
  ::Reflex::Type type_65082 = ::Reflex::ReferenceBuilder(type_3507);
  ::Reflex::Type type_2051 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint8_t"), type_757);
  ::Reflex::Type type_20635 = ::Reflex::ReferenceBuilder(type_9073);
  ::Reflex::Type type_9073c = ::Reflex::ConstBuilder(type_9073);
  ::Reflex::Type type_17698 = ::Reflex::ReferenceBuilder(type_9073c);
  ::Reflex::Type type_44753 = ::Reflex::ReferenceBuilder(type_9075c);
  ::Reflex::Type type_11501 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::VertexRef"), type_7389);
  ::Reflex::Type type_11501c = ::Reflex::ConstBuilder(type_11501);
  ::Reflex::Type type_73025 = ::Reflex::ReferenceBuilder(type_11501c);
  ::Reflex::Type type_11423c = ::Reflex::ConstBuilder(type_11423);
  ::Reflex::Type type_21777 = ::Reflex::ReferenceBuilder(type_11423c);
  ::Reflex::Type type_129c = ::Reflex::ConstBuilder(type_129);
  ::Reflex::Type type_35166 = ::Reflex::ReferenceBuilder(type_129c);
  ::Reflex::Type type_59788c = ::Reflex::ConstBuilder(type_59788);
  ::Reflex::Type type_15887 = ::Reflex::PointerBuilder(type_9073);
  ::Reflex::Type type_17696 = ::Reflex::PointerBuilder(type_9073c);
  ::Reflex::Type type_3866c = ::Reflex::ConstBuilder(type_3866);
  ::Reflex::Type type_63387 = ::Reflex::ReferenceBuilder(type_3866c);
  ::Reflex::Type type_3508c = ::Reflex::ConstBuilder(type_3508);
  ::Reflex::Type type_35501 = ::Reflex::ReferenceBuilder(type_3508c);
  ::Reflex::Type type_65083 = ::Reflex::ReferenceBuilder(type_3508);
  ::Reflex::Type type_20698 = ::Reflex::ReferenceBuilder(type_13535);
  ::Reflex::Type type_13535c = ::Reflex::ConstBuilder(type_13535);
  ::Reflex::Type type_17709 = ::Reflex::ReferenceBuilder(type_13535c);
  ::Reflex::Type type_112c = ::Reflex::ConstBuilder(type_112);
  ::Reflex::Type type_72c = ::Reflex::ConstBuilder(type_72);
  ::Reflex::Type type_14444 = ::Reflex::PointerBuilder(type_13535);
  ::Reflex::Type type_17707 = ::Reflex::PointerBuilder(type_13535c);
  ::Reflex::Type type_3867c = ::Reflex::ConstBuilder(type_3867);
  ::Reflex::Type type_62400 = ::Reflex::ReferenceBuilder(type_3867c);
  ::Reflex::Type type_3509c = ::Reflex::ConstBuilder(type_3509);
  ::Reflex::Type type_35513 = ::Reflex::ReferenceBuilder(type_3509c);
  ::Reflex::Type type_65084 = ::Reflex::ReferenceBuilder(type_3509);
  ::Reflex::Type type_20761 = ::Reflex::ReferenceBuilder(type_13517);
  ::Reflex::Type type_13517c = ::Reflex::ConstBuilder(type_13517);
  ::Reflex::Type type_17720 = ::Reflex::ReferenceBuilder(type_13517c);
  ::Reflex::Type type_14463 = ::Reflex::PointerBuilder(type_13517);
  ::Reflex::Type type_17718 = ::Reflex::PointerBuilder(type_13517c);
  ::Reflex::Type type_3868c = ::Reflex::ConstBuilder(type_3868);
  ::Reflex::Type type_62413 = ::Reflex::ReferenceBuilder(type_3868c);
  ::Reflex::Type type_3510c = ::Reflex::ConstBuilder(type_3510);
  ::Reflex::Type type_35525 = ::Reflex::ReferenceBuilder(type_3510c);
  ::Reflex::Type type_65085 = ::Reflex::ReferenceBuilder(type_3510);
  ::Reflex::Type type_11589 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::TrackRef"), type_7397);
  ::Reflex::Type type_11604 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::TrackCollection"), type_3526);
  ::Reflex::Type type_11616 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::GsfTrackRef"), type_7436);
  ::Reflex::Type type_11617 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::GsfTrackCollection"), type_3525);
  ::Reflex::Type type_1019 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("CaloTowerRef"), type_1018);
  ::Reflex::Type type_870 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("CaloTowerCollection"), type_869);
  ::Reflex::Type type_11485 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::SuperClusterRef"), type_7438);
  ::Reflex::Type type_11553 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::SuperClusterCollection"), type_3524);
  ::Reflex::Type type_11498 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::TrackRefVector"), type_6550);
  ::Reflex::Type type_20824 = ::Reflex::ReferenceBuilder(type_13540);
  ::Reflex::Type type_13540c = ::Reflex::ConstBuilder(type_13540);
  ::Reflex::Type type_17731 = ::Reflex::ReferenceBuilder(type_13540c);
  ::Reflex::Type type_7298c = ::Reflex::ConstBuilder(type_7298);
  ::Reflex::Type type_22542 = ::Reflex::ReferenceBuilder(type_7298c);
  ::Reflex::Type type_7325c = ::Reflex::ConstBuilder(type_7325);
  ::Reflex::Type type_22032 = ::Reflex::ReferenceBuilder(type_7325c);
  ::Reflex::Type type_14501 = ::Reflex::PointerBuilder(type_13540);
  ::Reflex::Type type_11589c = ::Reflex::ConstBuilder(type_11589);
  ::Reflex::Type type_72994 = ::Reflex::ReferenceBuilder(type_11589c);
  ::Reflex::Type type_11498c = ::Reflex::ConstBuilder(type_11498);
  ::Reflex::Type type_73028 = ::Reflex::ReferenceBuilder(type_11498c);
  ::Reflex::Type type_11616c = ::Reflex::ConstBuilder(type_11616);
  ::Reflex::Type type_73008 = ::Reflex::ReferenceBuilder(type_11616c);
  ::Reflex::Type type_11485c = ::Reflex::ConstBuilder(type_11485);
  ::Reflex::Type type_73176 = ::Reflex::ReferenceBuilder(type_11485c);
  ::Reflex::Type type_1019c = ::Reflex::ConstBuilder(type_1019);
  ::Reflex::Type type_75146 = ::Reflex::ReferenceBuilder(type_1019c);
  ::Reflex::Type type_13542 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::IsoDeposit"), type_11548);
  ::Reflex::Type type_13542c = ::Reflex::ConstBuilder(type_13542);
  ::Reflex::Type type_75131 = ::Reflex::PointerBuilder(type_13542c);
  ::Reflex::Type type_75132 = ::Reflex::ReferenceBuilder(type_13542c);
  ::Reflex::Type type_13472c = ::Reflex::ConstBuilder(type_13472);
  ::Reflex::Type type_21516 = ::Reflex::PointerBuilder(type_13472c);
  ::Reflex::Type type_3522c = ::Reflex::ConstBuilder(type_3522);
  ::Reflex::Type type_65099 = ::Reflex::ReferenceBuilder(type_3522c);
  ::Reflex::Type type_21520 = ::Reflex::ReferenceBuilder(type_13472c);
  ::Reflex::Type type_17729 = ::Reflex::PointerBuilder(type_13540c);
  ::Reflex::Type type_3869c = ::Reflex::ConstBuilder(type_3869);
  ::Reflex::Type type_62439 = ::Reflex::ReferenceBuilder(type_3869c);
  ::Reflex::Type type_3511c = ::Reflex::ConstBuilder(type_3511);
  ::Reflex::Type type_35537 = ::Reflex::ReferenceBuilder(type_3511c);
  ::Reflex::Type type_65086 = ::Reflex::ReferenceBuilder(type_3511);
  ::Reflex::Type type_20887 = ::Reflex::ReferenceBuilder(type_13478);
  ::Reflex::Type type_13478c = ::Reflex::ConstBuilder(type_13478);
  ::Reflex::Type type_17742 = ::Reflex::ReferenceBuilder(type_13478c);
  ::Reflex::Type type_7301c = ::Reflex::ConstBuilder(type_7301);
  ::Reflex::Type type_71877 = ::Reflex::ReferenceBuilder(type_7301c);
  ::Reflex::Type type_14520 = ::Reflex::PointerBuilder(type_13478);
  ::Reflex::Type type_17740 = ::Reflex::PointerBuilder(type_13478c);
  ::Reflex::Type type_3870c = ::Reflex::ConstBuilder(type_3870);
  ::Reflex::Type type_62452 = ::Reflex::ReferenceBuilder(type_3870c);
  ::Reflex::Type type_3512c = ::Reflex::ConstBuilder(type_3512);
  ::Reflex::Type type_35549 = ::Reflex::ReferenceBuilder(type_3512c);
  ::Reflex::Type type_65087 = ::Reflex::ReferenceBuilder(type_3512);
  ::Reflex::Type type_20950 = ::Reflex::ReferenceBuilder(type_13564);
  ::Reflex::Type type_13564c = ::Reflex::ConstBuilder(type_13564);
  ::Reflex::Type type_17753 = ::Reflex::ReferenceBuilder(type_13564c);
  ::Reflex::Type type_11585c = ::Reflex::ConstBuilder(type_11585);
  ::Reflex::Type type_28501 = ::Reflex::ReferenceBuilder(type_11585c);
  ::Reflex::Type type_14539 = ::Reflex::PointerBuilder(type_13564);
  ::Reflex::Type type_17751 = ::Reflex::PointerBuilder(type_13564c);
  ::Reflex::Type type_3871c = ::Reflex::ConstBuilder(type_3871);
  ::Reflex::Type type_62465 = ::Reflex::ReferenceBuilder(type_3871c);
  ::Reflex::Type type_3513c = ::Reflex::ConstBuilder(type_3513);
  ::Reflex::Type type_35561 = ::Reflex::ReferenceBuilder(type_3513c);
  ::Reflex::Type type_65088 = ::Reflex::ReferenceBuilder(type_3513);
  ::Reflex::Type type_21013 = ::Reflex::ReferenceBuilder(type_13527);
  ::Reflex::Type type_13527c = ::Reflex::ConstBuilder(type_13527);
  ::Reflex::Type type_17764 = ::Reflex::ReferenceBuilder(type_13527c);
  ::Reflex::Type type_9074c = ::Reflex::ConstBuilder(type_9074);
  ::Reflex::Type type_71891 = ::Reflex::ReferenceBuilder(type_9074c);
  ::Reflex::Type type_14558 = ::Reflex::PointerBuilder(type_13527);
  ::Reflex::Type type_17762 = ::Reflex::PointerBuilder(type_13527c);
  ::Reflex::Type type_3872c = ::Reflex::ConstBuilder(type_3872);
  ::Reflex::Type type_62478 = ::Reflex::ReferenceBuilder(type_3872c);
  ::Reflex::Type type_3514c = ::Reflex::ConstBuilder(type_3514);
  ::Reflex::Type type_35573 = ::Reflex::ReferenceBuilder(type_3514c);
  ::Reflex::Type type_65089 = ::Reflex::ReferenceBuilder(type_3514);
  ::Reflex::Type type_75147 = ::Reflex::PointerBuilder(type_3542);
  ::Reflex::Type type_11551c = ::Reflex::ConstBuilder(type_11551);
  ::Reflex::Type type_71898 = ::Reflex::ReferenceBuilder(type_11551c);
  ::Reflex::Type type_7304c = ::Reflex::ConstBuilder(type_7304);
  ::Reflex::Type type_71894 = ::Reflex::ReferenceBuilder(type_7304c);
  ::Reflex::Type type_7331c = ::Reflex::ConstBuilder(type_7331);
  ::Reflex::Type type_71965 = ::Reflex::ReferenceBuilder(type_7331c);
  ::Reflex::Type type_13544c = ::Reflex::ConstBuilder(type_13544);
  ::Reflex::Type type_17786 = ::Reflex::ReferenceBuilder(type_13544c);
  ::Reflex::Type type_21076 = ::Reflex::ReferenceBuilder(type_13544);
  ::Reflex::Type type_14672 = ::Reflex::PointerBuilder(type_13544);
  ::Reflex::Type type_11380c = ::Reflex::ConstBuilder(type_11380);
  ::Reflex::Type type_22799 = ::Reflex::PointerBuilder(type_11380c);
  ::Reflex::Type type_22803 = ::Reflex::ReferenceBuilder(type_11380c);
  ::Reflex::Type type_987c = ::Reflex::ConstBuilder(type_987);
  ::Reflex::Type type_22672 = ::Reflex::ReferenceBuilder(type_987c);
  ::Reflex::Type type_507c = ::Reflex::ConstBuilder(type_507);
  ::Reflex::Type type_22607 = ::Reflex::ReferenceBuilder(type_507c);
  ::Reflex::Type type_17784 = ::Reflex::PointerBuilder(type_13544c);
  ::Reflex::Type type_3873c = ::Reflex::ConstBuilder(type_3873);
  ::Reflex::Type type_62556 = ::Reflex::ReferenceBuilder(type_3873c);
  ::Reflex::Type type_3515c = ::Reflex::ConstBuilder(type_3515);
  ::Reflex::Type type_35585 = ::Reflex::ReferenceBuilder(type_3515c);
  ::Reflex::Type type_65090 = ::Reflex::ReferenceBuilder(type_3515);
  ::Reflex::Type type_2743 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("CaloTowerFwdPtrVector"), type_2742);
  ::Reflex::Type type_11471 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::PFCandidateCollection"), type_3548);
  ::Reflex::Type type_11435 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::PFCandidateFwdPtrVector"), type_3547);
  ::Reflex::Type type_11487 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::GenJetRefVector"), type_6551);
  ::Reflex::Type type_13467 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TagInfoFwdPtrCollection"), type_3546);
  ::Reflex::Type type_21139 = ::Reflex::ReferenceBuilder(type_13487);
  ::Reflex::Type type_13487c = ::Reflex::ConstBuilder(type_13487);
  ::Reflex::Type type_17797 = ::Reflex::ReferenceBuilder(type_13487c);
  ::Reflex::Type type_11344c = ::Reflex::ConstBuilder(type_11344);
  ::Reflex::Type type_71902 = ::Reflex::ReferenceBuilder(type_11344c);
  ::Reflex::Type type_7305c = ::Reflex::ConstBuilder(type_7305);
  ::Reflex::Type type_65058 = ::Reflex::ReferenceBuilder(type_7305c);
  ::Reflex::Type type_7333c = ::Reflex::ConstBuilder(type_7333);
  ::Reflex::Type type_71968 = ::Reflex::ReferenceBuilder(type_7333c);
  ::Reflex::Type type_14861 = ::Reflex::PointerBuilder(type_13487);
  ::Reflex::Type type_22220 = ::Reflex::PointerBuilder(type_11257c);
  ::Reflex::Type type_11426c = ::Reflex::ConstBuilder(type_11426);
  ::Reflex::Type type_23638 = ::Reflex::PointerBuilder(type_11426c);
  ::Reflex::Type type_11626c = ::Reflex::ConstBuilder(type_11626);
  ::Reflex::Type type_73489 = ::Reflex::ReferenceBuilder(type_11626c);
  ::Reflex::Type type_3528c = ::Reflex::ConstBuilder(type_3528);
  ::Reflex::Type type_18030 = ::Reflex::ReferenceBuilder(type_72c);
  ::Reflex::Type type_227c = ::Reflex::ConstBuilder(type_227);
  ::Reflex::Type type_18009 = ::Reflex::ReferenceBuilder(type_227c);
  ::Reflex::Type type_59674c = ::Reflex::ConstBuilder(type_59674);
  ::Reflex::Type type_75117 = ::Reflex::ReferenceBuilder(type_59674c);
  ::Reflex::Type type_3555c = ::Reflex::ConstBuilder(type_3555);
  ::Reflex::Type type_65188 = ::Reflex::ReferenceBuilder(type_3555c);
  ::Reflex::Type type_11627c = ::Reflex::ConstBuilder(type_11627);
  ::Reflex::Type type_24613 = ::Reflex::PointerBuilder(type_11627c);
  ::Reflex::Type type_11527c = ::Reflex::ConstBuilder(type_11527);
  ::Reflex::Type type_24029 = ::Reflex::PointerBuilder(type_11527c);
  ::Reflex::Type type_11305c = ::Reflex::ConstBuilder(type_11305);
  ::Reflex::Type type_24094 = ::Reflex::PointerBuilder(type_11305c);
  ::Reflex::Type type_11561c = ::Reflex::ConstBuilder(type_11561);
  ::Reflex::Type type_23833 = ::Reflex::PointerBuilder(type_11561c);
  ::Reflex::Type type_3441c = ::Reflex::ConstBuilder(type_3441);
  ::Reflex::Type type_23577 = ::Reflex::ReferenceBuilder(type_3441c);
  ::Reflex::Type type_6466c = ::Reflex::ConstBuilder(type_6466);
  ::Reflex::Type type_22994 = ::Reflex::ReferenceBuilder(type_6466c);
  ::Reflex::Type type_13503 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::CaloTowerFwdPtrCollection"), type_2742);
  ::Reflex::Type type_13503c = ::Reflex::ConstBuilder(type_13503);
  ::Reflex::Type type_75118 = ::Reflex::ReferenceBuilder(type_13503c);
  ::Reflex::Type type_13491 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::PFCandidateFwdPtrCollection"), type_3547);
  ::Reflex::Type type_13491c = ::Reflex::ConstBuilder(type_13491);
  ::Reflex::Type type_75119 = ::Reflex::ReferenceBuilder(type_13491c);
  ::Reflex::Type type_11252c = ::Reflex::ConstBuilder(type_11252);
  ::Reflex::Type type_75120 = ::Reflex::ReferenceBuilder(type_11252c);
  ::Reflex::Type type_6838c = ::Reflex::ConstBuilder(type_6838);
  ::Reflex::Type type_71068 = ::Reflex::ReferenceBuilder(type_6838c);
  ::Reflex::Type type_11342c = ::Reflex::ConstBuilder(type_11342);
  ::Reflex::Type type_73049 = ::Reflex::ReferenceBuilder(type_11342c);
  ::Reflex::Type type_13511 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::CaloSpecific"), type_13510);
  ::Reflex::Type type_13511c = ::Reflex::ConstBuilder(type_13511);
  ::Reflex::Type type_75121 = ::Reflex::ReferenceBuilder(type_13511c);
  ::Reflex::Type type_13474 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::JPTSpecific"), type_13473);
  ::Reflex::Type type_13474c = ::Reflex::ConstBuilder(type_13474);
  ::Reflex::Type type_75122 = ::Reflex::ReferenceBuilder(type_13474c);
  ::Reflex::Type type_13524 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::PFSpecific"), type_13523);
  ::Reflex::Type type_13524c = ::Reflex::ConstBuilder(type_13524);
  ::Reflex::Type type_75123 = ::Reflex::ReferenceBuilder(type_13524c);
  ::Reflex::Type type_667 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("CaloTowerPtr"), type_666);
  ::Reflex::Type type_3558c = ::Reflex::ConstBuilder(type_3558);
  ::Reflex::Type type_71768 = ::Reflex::ReferenceBuilder(type_3558c);
  ::Reflex::Type type_990c = ::Reflex::ConstBuilder(type_990);
  ::Reflex::Type type_10145 = ::Reflex::ReferenceBuilder(type_990c);
  ::Reflex::Type type_11263 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::PFCandidatePtr"), type_7328);
  ::Reflex::Type type_3557c = ::Reflex::ConstBuilder(type_3557);
  ::Reflex::Type type_65193 = ::Reflex::ReferenceBuilder(type_3557c);
  ::Reflex::Type type_2743c = ::Reflex::ConstBuilder(type_2743);
  ::Reflex::Type type_75124 = ::Reflex::ReferenceBuilder(type_2743c);
  ::Reflex::Type type_11435c = ::Reflex::ConstBuilder(type_11435);
  ::Reflex::Type type_75125 = ::Reflex::ReferenceBuilder(type_11435c);
  ::Reflex::Type type_13467c = ::Reflex::ConstBuilder(type_13467);
  ::Reflex::Type type_75126 = ::Reflex::ReferenceBuilder(type_13467c);
  ::Reflex::Type type_666c = ::Reflex::ConstBuilder(type_666);
  ::Reflex::Type type_35225 = ::Reflex::ReferenceBuilder(type_666c);
  ::Reflex::Type type_7328c = ::Reflex::ConstBuilder(type_7328);
  ::Reflex::Type type_23707 = ::Reflex::ReferenceBuilder(type_7328c);
  ::Reflex::Type type_7332c = ::Reflex::ConstBuilder(type_7332);
  ::Reflex::Type type_70692 = ::Reflex::ReferenceBuilder(type_7332c);
  ::Reflex::Type type_17795 = ::Reflex::PointerBuilder(type_13487c);
  ::Reflex::Type type_3874c = ::Reflex::ConstBuilder(type_3874);
  ::Reflex::Type type_62685 = ::Reflex::ReferenceBuilder(type_3874c);
  ::Reflex::Type type_3516c = ::Reflex::ConstBuilder(type_3516);
  ::Reflex::Type type_35597 = ::Reflex::ReferenceBuilder(type_3516c);
  ::Reflex::Type type_65091 = ::Reflex::ReferenceBuilder(type_3516);
  ::Reflex::Type type_831 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("EcalRecHitCollection"), type_547);
  ::Reflex::Type type_21202 = ::Reflex::ReferenceBuilder(type_13525);
  ::Reflex::Type type_13525c = ::Reflex::ConstBuilder(type_13525);
  ::Reflex::Type type_17808 = ::Reflex::ReferenceBuilder(type_13525c);
  ::Reflex::Type type_11479c = ::Reflex::ConstBuilder(type_11479);
  ::Reflex::Type type_27469 = ::Reflex::ReferenceBuilder(type_11479c);
  ::Reflex::Type type_7306c = ::Reflex::ConstBuilder(type_7306);
  ::Reflex::Type type_71905 = ::Reflex::ReferenceBuilder(type_7306c);
  ::Reflex::Type type_7334c = ::Reflex::ConstBuilder(type_7334);
  ::Reflex::Type type_71970 = ::Reflex::ReferenceBuilder(type_7334c);
  ::Reflex::Type type_15279 = ::Reflex::PointerBuilder(type_13525);
  ::Reflex::Type type_11624 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CaloClusterPtr"), type_7342);
  ::Reflex::Type type_3585c = ::Reflex::ConstBuilder(type_3585);
  ::Reflex::Type type_35752 = ::Reflex::ReferenceBuilder(type_3585c);
  ::Reflex::Type type_831c = ::Reflex::ConstBuilder(type_831);
  ::Reflex::Type type_75130 = ::Reflex::PointerBuilder(type_831c);
  ::Reflex::Type type_1811 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Bool_t"), type_1810);
  ::Reflex::Type type_3583c = ::Reflex::ConstBuilder(type_3583);
  ::Reflex::Type type_65275 = ::Reflex::ReferenceBuilder(type_3583c);
  ::Reflex::Type type_48127c = ::Reflex::ConstBuilder(type_48127);
  ::Reflex::Type type_73313 = ::Reflex::ReferenceBuilder(type_48127c);
  ::Reflex::Type type_7221c = ::Reflex::ConstBuilder(type_7221);
  ::Reflex::Type type_71851 = ::Reflex::ReferenceBuilder(type_7221c);
  ::Reflex::Type type_6477c = ::Reflex::ConstBuilder(type_6477);
  ::Reflex::Type type_70702 = ::Reflex::ReferenceBuilder(type_6477c);
  ::Reflex::Type type_17806 = ::Reflex::PointerBuilder(type_13525c);
  ::Reflex::Type type_3875c = ::Reflex::ConstBuilder(type_3875);
  ::Reflex::Type type_62971 = ::Reflex::ReferenceBuilder(type_3875c);
  ::Reflex::Type type_3517c = ::Reflex::ConstBuilder(type_3517);
  ::Reflex::Type type_35609 = ::Reflex::ReferenceBuilder(type_3517c);
  ::Reflex::Type type_65092 = ::Reflex::ReferenceBuilder(type_3517);
  ::Reflex::Type type_11460 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CandidatePtrVector"), type_6449);
  ::Reflex::Type type_21265 = ::Reflex::ReferenceBuilder(type_13568);
  ::Reflex::Type type_13568c = ::Reflex::ConstBuilder(type_13568);
  ::Reflex::Type type_17819 = ::Reflex::ReferenceBuilder(type_13568c);
  ::Reflex::Type type_11630c = ::Reflex::ConstBuilder(type_11630);
  ::Reflex::Type type_26889 = ::Reflex::ReferenceBuilder(type_11630c);
  ::Reflex::Type type_7308c = ::Reflex::ConstBuilder(type_7308);
  ::Reflex::Type type_71915 = ::Reflex::ReferenceBuilder(type_7308c);
  ::Reflex::Type type_7335c = ::Reflex::ConstBuilder(type_7335);
  ::Reflex::Type type_71972 = ::Reflex::ReferenceBuilder(type_7335c);
  ::Reflex::Type type_15488 = ::Reflex::PointerBuilder(type_13568);
  ::Reflex::Type type_11334 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::GenJetRef"), type_7382);
  ::Reflex::Type type_11334c = ::Reflex::ConstBuilder(type_11334);
  ::Reflex::Type type_75186 = ::Reflex::ReferenceBuilder(type_11334c);
  ::Reflex::Type type_26032c = ::Reflex::ConstBuilder(type_26032);
  ::Reflex::Type type_26043 = ::Reflex::ReferenceBuilder(type_26032c);
  ::Reflex::Type type_11425 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CaloTauTagInfoRef"), type_7401);
  ::Reflex::Type type_25966c = ::Reflex::ConstBuilder(type_25966);
  ::Reflex::Type type_25977 = ::Reflex::ReferenceBuilder(type_25966c);
  ::Reflex::Type type_26098c = ::Reflex::ConstBuilder(type_26098);
  ::Reflex::Type type_26109 = ::Reflex::ReferenceBuilder(type_26098c);
  ::Reflex::Type type_11513 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::PFJetRef"), type_7406);
  ::Reflex::Type type_11513c = ::Reflex::ConstBuilder(type_11513);
  ::Reflex::Type type_73153 = ::Reflex::ReferenceBuilder(type_11513c);
  ::Reflex::Type type_11287 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::PFRecoTauChargedHadronRef"), type_7404);
  ::Reflex::Type type_11263c = ::Reflex::ConstBuilder(type_11263);
  ::Reflex::Type type_3601c = ::Reflex::ConstBuilder(type_3601);
  ::Reflex::Type type_35776 = ::Reflex::ReferenceBuilder(type_3601c);
  ::Reflex::Type type_3600c = ::Reflex::ConstBuilder(type_3600);
  ::Reflex::Type type_35788 = ::Reflex::ReferenceBuilder(type_3600c);
  ::Reflex::Type type_11460c = ::Reflex::ConstBuilder(type_11460);
  ::Reflex::Type type_75189 = ::Reflex::ReferenceBuilder(type_11460c);
  ::Reflex::Type type_116c = ::Reflex::ConstBuilder(type_116);
  ::Reflex::Type type_35035 = ::Reflex::ReferenceBuilder(type_116c);
  ::Reflex::Type type_10222c = ::Reflex::ConstBuilder(type_10222);
  ::Reflex::Type type_73027 = ::Reflex::ReferenceBuilder(type_10222c);
  ::Reflex::Type type_1632c = ::Reflex::ConstBuilder(type_1632);
  ::Reflex::Type type_4688 = ::Reflex::PointerBuilder(type_1632c);
  ::Reflex::Type type_17817 = ::Reflex::PointerBuilder(type_13568c);
  ::Reflex::Type type_3876c = ::Reflex::ConstBuilder(type_3876);
  ::Reflex::Type type_63114 = ::Reflex::ReferenceBuilder(type_3876c);
  ::Reflex::Type type_3518c = ::Reflex::ConstBuilder(type_3518);
  ::Reflex::Type type_35621 = ::Reflex::ReferenceBuilder(type_3518c);
  ::Reflex::Type type_65093 = ::Reflex::ReferenceBuilder(type_3518);
  ::Reflex::Type type_11325 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::PFCandidateRef"), type_7366);
  ::Reflex::Type type_21328 = ::Reflex::ReferenceBuilder(type_13465);
  ::Reflex::Type type_13465c = ::Reflex::ConstBuilder(type_13465);
  ::Reflex::Type type_17830 = ::Reflex::ReferenceBuilder(type_13465c);
  ::Reflex::Type type_11232c = ::Reflex::ConstBuilder(type_11232);
  ::Reflex::Type type_27924 = ::Reflex::ReferenceBuilder(type_11232c);
  ::Reflex::Type type_7309c = ::Reflex::ConstBuilder(type_7309);
  ::Reflex::Type type_71920 = ::Reflex::ReferenceBuilder(type_7309c);
  ::Reflex::Type type_7337c = ::Reflex::ConstBuilder(type_7337);
  ::Reflex::Type type_71976 = ::Reflex::ReferenceBuilder(type_7337c);
  ::Reflex::Type type_15792 = ::Reflex::PointerBuilder(type_13465);
  ::Reflex::Type type_21773 = ::Reflex::PointerBuilder(type_11423c);
  ::Reflex::Type type_11248c = ::Reflex::ConstBuilder(type_11248);
  ::Reflex::Type type_26954 = ::Reflex::ReferenceBuilder(type_11248c);
  ::Reflex::Type type_11325c = ::Reflex::ConstBuilder(type_11325);
  ::Reflex::Type type_75111 = ::Reflex::ReferenceBuilder(type_11325c);
  ::Reflex::Type type_11465c = ::Reflex::ConstBuilder(type_11465);
  ::Reflex::Type type_27274 = ::Reflex::ReferenceBuilder(type_11465c);
  ::Reflex::Type type_17828 = ::Reflex::PointerBuilder(type_13465c);
  ::Reflex::Type type_3877c = ::Reflex::ConstBuilder(type_3877);
  ::Reflex::Type type_63322 = ::Reflex::ReferenceBuilder(type_3877c);
  ::Reflex::Type type_3519c = ::Reflex::ConstBuilder(type_3519);
  ::Reflex::Type type_35633 = ::Reflex::ReferenceBuilder(type_3519c);
  ::Reflex::Type type_65094 = ::Reflex::ReferenceBuilder(type_3519);
  ::Reflex::Type type_21391 = ::Reflex::ReferenceBuilder(type_13576);
  ::Reflex::Type type_13576c = ::Reflex::ConstBuilder(type_13576);
  ::Reflex::Type type_17841 = ::Reflex::ReferenceBuilder(type_13576c);
  ::Reflex::Type type_11217c = ::Reflex::ConstBuilder(type_11217);
  ::Reflex::Type type_29540 = ::Reflex::ReferenceBuilder(type_11217c);
  ::Reflex::Type type_7310c = ::Reflex::ConstBuilder(type_7310);
  ::Reflex::Type type_71925 = ::Reflex::ReferenceBuilder(type_7310c);
  ::Reflex::Type type_7339c = ::Reflex::ConstBuilder(type_7339);
  ::Reflex::Type type_71978 = ::Reflex::ReferenceBuilder(type_7339c);
  ::Reflex::Type type_15868 = ::Reflex::PointerBuilder(type_13576);
  ::Reflex::Type type_11383 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::GsfElectronCoreRef"), type_7439);
  ::Reflex::Type type_46617c = ::Reflex::ConstBuilder(type_46617);
  ::Reflex::Type type_73002 = ::Reflex::ReferenceBuilder(type_46617c);
  ::Reflex::Type type_17839 = ::Reflex::PointerBuilder(type_13576c);
  ::Reflex::Type type_3878c = ::Reflex::ConstBuilder(type_3878);
  ::Reflex::Type type_63374 = ::Reflex::ReferenceBuilder(type_3878c);
  ::Reflex::Type type_3520c = ::Reflex::ConstBuilder(type_3520);
  ::Reflex::Type type_35645 = ::Reflex::ReferenceBuilder(type_3520c);
  ::Reflex::Type type_65095 = ::Reflex::ReferenceBuilder(type_3520);
  ::Reflex::Type type_21454 = ::Reflex::ReferenceBuilder(type_13575);
  ::Reflex::Type type_13575c = ::Reflex::ConstBuilder(type_13575);
  ::Reflex::Type type_17775 = ::Reflex::ReferenceBuilder(type_13575c);
  ::Reflex::Type type_13443 = ::Reflex::ReferenceBuilder(type_112c);
  ::Reflex::Type type_14406 = ::Reflex::PointerBuilder(type_13575);
  ::Reflex::Type type_17773 = ::Reflex::PointerBuilder(type_13575c);
  ::Reflex::Type type_3879c = ::Reflex::ConstBuilder(type_3879);
  ::Reflex::Type type_62374 = ::Reflex::ReferenceBuilder(type_3879c);
  ::Reflex::Type type_3521c = ::Reflex::ConstBuilder(type_3521);
  ::Reflex::Type type_65096 = ::Reflex::ReferenceBuilder(type_3521c);
  ::Reflex::Type type_65097 = ::Reflex::ReferenceBuilder(type_3521);
  ::Reflex::Type type_22736 = ::Reflex::ReferenceBuilder(type_22727);
  ::Reflex::Type type_22727c = ::Reflex::ConstBuilder(type_22727);
  ::Reflex::Type type_22738 = ::Reflex::ReferenceBuilder(type_22727c);
  ::Reflex::Type type_14596 = ::Reflex::PointerBuilder(type_22727);
  ::Reflex::Type type_22734 = ::Reflex::PointerBuilder(type_22727c);
  ::Reflex::Type type_3894c = ::Reflex::ConstBuilder(type_3894);
  ::Reflex::Type type_62504 = ::Reflex::ReferenceBuilder(type_3894c);
  ::Reflex::Type type_3541c = ::Reflex::ConstBuilder(type_3541);
  ::Reflex::Type type_65155 = ::Reflex::ReferenceBuilder(type_3541c);
  ::Reflex::Type type_65156 = ::Reflex::ReferenceBuilder(type_3541);
  ::Reflex::Type type_25975 = ::Reflex::ReferenceBuilder(type_25966);
  ::Reflex::Type type_11499c = ::Reflex::ConstBuilder(type_11499);
  ::Reflex::Type type_26824 = ::Reflex::ReferenceBuilder(type_11499c);
  ::Reflex::Type type_15469 = ::Reflex::PointerBuilder(type_25966);
  ::Reflex::Type type_25973 = ::Reflex::PointerBuilder(type_25966c);
  ::Reflex::Type type_3954c = ::Reflex::ConstBuilder(type_3954);
  ::Reflex::Type type_63101 = ::Reflex::ReferenceBuilder(type_3954c);
  ::Reflex::Type type_3597c = ::Reflex::ConstBuilder(type_3597);
  ::Reflex::Type type_65349 = ::Reflex::ReferenceBuilder(type_3597c);
  ::Reflex::Type type_65350 = ::Reflex::ReferenceBuilder(type_3597);
  ::Reflex::Type type_26041 = ::Reflex::ReferenceBuilder(type_26032);
  ::Reflex::Type type_11586c = ::Reflex::ConstBuilder(type_11586);
  ::Reflex::Type type_26564 = ::Reflex::ReferenceBuilder(type_11586c);
  ::Reflex::Type type_15450 = ::Reflex::PointerBuilder(type_26032);
  ::Reflex::Type type_26039 = ::Reflex::PointerBuilder(type_26032c);
  ::Reflex::Type type_3953c = ::Reflex::ConstBuilder(type_3953);
  ::Reflex::Type type_63088 = ::Reflex::ReferenceBuilder(type_3953c);
  ::Reflex::Type type_3598c = ::Reflex::ConstBuilder(type_3598);
  ::Reflex::Type type_65370 = ::Reflex::ReferenceBuilder(type_3598c);
  ::Reflex::Type type_65371 = ::Reflex::ReferenceBuilder(type_3598);
  ::Reflex::Type type_26107 = ::Reflex::ReferenceBuilder(type_26098);
  ::Reflex::Type type_15412 = ::Reflex::PointerBuilder(type_26098);
  ::Reflex::Type type_26105 = ::Reflex::PointerBuilder(type_26098c);
  ::Reflex::Type type_3951c = ::Reflex::ConstBuilder(type_3951);
  ::Reflex::Type type_63062 = ::Reflex::ReferenceBuilder(type_3951c);
  ::Reflex::Type type_3599c = ::Reflex::ConstBuilder(type_3599);
  ::Reflex::Type type_65394 = ::Reflex::ReferenceBuilder(type_3599c);
  ::Reflex::Type type_65395 = ::Reflex::ReferenceBuilder(type_3599);
  ::Reflex::Type type_70698 = ::Reflex::PointerBuilder(type_3507c);
  ::Reflex::Type type_555c = ::Reflex::ConstBuilder(type_555);
  ::Reflex::Type type_35261 = ::Reflex::ReferenceBuilder(type_555c);
  ::Reflex::Type type_71002 = ::Reflex::PointerBuilder(type_3507);
  ::Reflex::Type type_7052c = ::Reflex::ConstBuilder(type_7052);
  ::Reflex::Type type_71003 = ::Reflex::PointerBuilder(type_7052c);
  ::Reflex::Type type_7365c = ::Reflex::ConstBuilder(type_7365);
  ::Reflex::Type type_35118 = ::Reflex::ReferenceBuilder(type_7365c);
  ::Reflex::Type type_35211 = ::Reflex::ReferenceBuilder(type_3504);
  ::Reflex::Type type_69482 = ::Reflex::ReferenceBuilder(type_6174);
  ::Reflex::Type type_780c = ::Reflex::ConstBuilder(type_780);
  ::Reflex::Type type_5416 = ::Reflex::PointerBuilder(type_780c);
  ::Reflex::Type type_18241 = ::Reflex::ReferenceBuilder(type_5416);
  ::Reflex::Type type_3505c = ::Reflex::ConstBuilder(type_3505);
  ::Reflex::Type type_35275 = ::Reflex::ReferenceBuilder(type_3505c);
  ::Reflex::Type type_70704 = ::Reflex::PointerBuilder(type_3508c);
  ::Reflex::Type type_71006 = ::Reflex::PointerBuilder(type_3508);
  ::Reflex::Type type_7053c = ::Reflex::ConstBuilder(type_7053);
  ::Reflex::Type type_71007 = ::Reflex::PointerBuilder(type_7053c);
  ::Reflex::Type type_70710 = ::Reflex::PointerBuilder(type_3509c);
  ::Reflex::Type type_71010 = ::Reflex::PointerBuilder(type_3509);
  ::Reflex::Type type_7054c = ::Reflex::ConstBuilder(type_7054);
  ::Reflex::Type type_71011 = ::Reflex::PointerBuilder(type_7054c);
  ::Reflex::Type type_70716 = ::Reflex::PointerBuilder(type_3510c);
  ::Reflex::Type type_71014 = ::Reflex::PointerBuilder(type_3510);
  ::Reflex::Type type_7055c = ::Reflex::ConstBuilder(type_7055);
  ::Reflex::Type type_71015 = ::Reflex::PointerBuilder(type_7055c);
  ::Reflex::Type type_70722 = ::Reflex::PointerBuilder(type_3511c);
  ::Reflex::Type type_71018 = ::Reflex::PointerBuilder(type_3511);
  ::Reflex::Type type_7056c = ::Reflex::ConstBuilder(type_7056);
  ::Reflex::Type type_71019 = ::Reflex::PointerBuilder(type_7056c);
  ::Reflex::Type type_70728 = ::Reflex::PointerBuilder(type_3512c);
  ::Reflex::Type type_71022 = ::Reflex::PointerBuilder(type_3512);
  ::Reflex::Type type_7057c = ::Reflex::ConstBuilder(type_7057);
  ::Reflex::Type type_71023 = ::Reflex::PointerBuilder(type_7057c);
  ::Reflex::Type type_70734 = ::Reflex::PointerBuilder(type_3513c);
  ::Reflex::Type type_71026 = ::Reflex::PointerBuilder(type_3513);
  ::Reflex::Type type_7058c = ::Reflex::ConstBuilder(type_7058);
  ::Reflex::Type type_71027 = ::Reflex::PointerBuilder(type_7058c);
  ::Reflex::Type type_70740 = ::Reflex::PointerBuilder(type_3514c);
  ::Reflex::Type type_71030 = ::Reflex::PointerBuilder(type_3514);
  ::Reflex::Type type_7059c = ::Reflex::ConstBuilder(type_7059);
  ::Reflex::Type type_71031 = ::Reflex::PointerBuilder(type_7059c);
  ::Reflex::Type type_71034 = ::Reflex::PointerBuilder(type_3521c);
  ::Reflex::Type type_71035 = ::Reflex::PointerBuilder(type_3521);
  ::Reflex::Type type_7060c = ::Reflex::ConstBuilder(type_7060);
  ::Reflex::Type type_71036 = ::Reflex::PointerBuilder(type_7060c);
  ::Reflex::Type type_70746 = ::Reflex::PointerBuilder(type_3515c);
  ::Reflex::Type type_71039 = ::Reflex::PointerBuilder(type_3515);
  ::Reflex::Type type_7061c = ::Reflex::ConstBuilder(type_7061);
  ::Reflex::Type type_71040 = ::Reflex::PointerBuilder(type_7061c);
  ::Reflex::Type type_70752 = ::Reflex::PointerBuilder(type_3516c);
  ::Reflex::Type type_71043 = ::Reflex::PointerBuilder(type_3516);
  ::Reflex::Type type_7062c = ::Reflex::ConstBuilder(type_7062);
  ::Reflex::Type type_71044 = ::Reflex::PointerBuilder(type_7062c);
  ::Reflex::Type type_70758 = ::Reflex::PointerBuilder(type_3517c);
  ::Reflex::Type type_71047 = ::Reflex::PointerBuilder(type_3517);
  ::Reflex::Type type_7063c = ::Reflex::ConstBuilder(type_7063);
  ::Reflex::Type type_71048 = ::Reflex::PointerBuilder(type_7063c);
  ::Reflex::Type type_70764 = ::Reflex::PointerBuilder(type_3518c);
  ::Reflex::Type type_71051 = ::Reflex::PointerBuilder(type_3518);
  ::Reflex::Type type_7064c = ::Reflex::ConstBuilder(type_7064);
  ::Reflex::Type type_71052 = ::Reflex::PointerBuilder(type_7064c);
  ::Reflex::Type type_70770 = ::Reflex::PointerBuilder(type_3519c);
  ::Reflex::Type type_71055 = ::Reflex::PointerBuilder(type_3519);
  ::Reflex::Type type_7065c = ::Reflex::ConstBuilder(type_7065);
  ::Reflex::Type type_71056 = ::Reflex::PointerBuilder(type_7065c);
  ::Reflex::Type type_70776 = ::Reflex::PointerBuilder(type_3520c);
  ::Reflex::Type type_71059 = ::Reflex::PointerBuilder(type_3520);
  ::Reflex::Type type_7066c = ::Reflex::ConstBuilder(type_7066);
  ::Reflex::Type type_71060 = ::Reflex::PointerBuilder(type_7066c);
  ::Reflex::Type type_71770 = ::Reflex::PointerBuilder(type_3524);
  ::Reflex::Type type_7117c = ::Reflex::ConstBuilder(type_7117);
  ::Reflex::Type type_71771 = ::Reflex::ReferenceBuilder(type_7117c);
  ::Reflex::Type type_71772 = ::Reflex::ReferenceBuilder(type_7117);
  ::Reflex::Type type_3524c = ::Reflex::ConstBuilder(type_3524);
  ::Reflex::Type type_70905 = ::Reflex::PointerBuilder(type_3524c);
  ::Reflex::Type type_36142 = ::Reflex::ReferenceBuilder(type_3524c);
  ::Reflex::Type type_65104 = ::Reflex::ReferenceBuilder(type_3524);
  ::Reflex::Type type_71943 = ::Reflex::ReferenceBuilder(type_7319);
  ::Reflex::Type type_7319c = ::Reflex::ConstBuilder(type_7319);
  ::Reflex::Type type_71944 = ::Reflex::ReferenceBuilder(type_7319c);
  ::Reflex::Type type_7363c = ::Reflex::ConstBuilder(type_7363);
  ::Reflex::Type type_35207 = ::Reflex::PointerBuilder(type_7363c);
  ::Reflex::Type type_7198c = ::Reflex::ConstBuilder(type_7198);
  ::Reflex::Type type_35224 = ::Reflex::ReferenceBuilder(type_7198c);
  ::Reflex::Type type_71945 = ::Reflex::ReferenceBuilder(type_7320);
  ::Reflex::Type type_7320c = ::Reflex::ConstBuilder(type_7320);
  ::Reflex::Type type_71946 = ::Reflex::ReferenceBuilder(type_7320c);
  ::Reflex::Type type_71947 = ::Reflex::ReferenceBuilder(type_7321);
  ::Reflex::Type type_7321c = ::Reflex::ConstBuilder(type_7321);
  ::Reflex::Type type_71948 = ::Reflex::ReferenceBuilder(type_7321c);
  ::Reflex::Type type_71949 = ::Reflex::ReferenceBuilder(type_7322);
  ::Reflex::Type type_7322c = ::Reflex::ConstBuilder(type_7322);
  ::Reflex::Type type_71950 = ::Reflex::ReferenceBuilder(type_7322c);
  ::Reflex::Type type_71951 = ::Reflex::ReferenceBuilder(type_7323);
  ::Reflex::Type type_7323c = ::Reflex::ConstBuilder(type_7323);
  ::Reflex::Type type_71952 = ::Reflex::ReferenceBuilder(type_7323c);
  ::Reflex::Type type_71953 = ::Reflex::ReferenceBuilder(type_7324);
  ::Reflex::Type type_7324c = ::Reflex::ConstBuilder(type_7324);
  ::Reflex::Type type_71954 = ::Reflex::ReferenceBuilder(type_7324c);
  ::Reflex::Type type_75133 = ::Reflex::ReferenceBuilder(type_13528);
  ::Reflex::Type type_13528c = ::Reflex::ConstBuilder(type_13528);
  ::Reflex::Type type_75134 = ::Reflex::ReferenceBuilder(type_13528c);
  ::Reflex::Type type_75135 = ::Reflex::PointerBuilder(type_13528);
  ::Reflex::Type type_2999c = ::Reflex::ConstBuilder(type_2999);
  ::Reflex::Type type_18052 = ::Reflex::ReferenceBuilder(type_2999c);
  ::Reflex::Type type_75136 = ::Reflex::ReferenceBuilder(type_13529);
  ::Reflex::Type type_13529c = ::Reflex::ConstBuilder(type_13529);
  ::Reflex::Type type_75137 = ::Reflex::ReferenceBuilder(type_13529c);
  ::Reflex::Type type_75138 = ::Reflex::PointerBuilder(type_13529);
  ::Reflex::Type type_75139 = ::Reflex::ReferenceBuilder(type_13530);
  ::Reflex::Type type_13530c = ::Reflex::ConstBuilder(type_13530);
  ::Reflex::Type type_75140 = ::Reflex::ReferenceBuilder(type_13530c);
  ::Reflex::Type type_75141 = ::Reflex::PointerBuilder(type_13530);
  ::Reflex::Type type_75166 = ::Reflex::ReferenceBuilder(type_13546);
  ::Reflex::Type type_13546c = ::Reflex::ConstBuilder(type_13546);
  ::Reflex::Type type_75167 = ::Reflex::ReferenceBuilder(type_13546c);
  ::Reflex::Type type_3536c = ::Reflex::ConstBuilder(type_3536);
  ::Reflex::Type type_35967 = ::Reflex::ReferenceBuilder(type_3536c);
  ::Reflex::Type type_13486c = ::Reflex::ConstBuilder(type_13486);
  ::Reflex::Type type_22409 = ::Reflex::PointerBuilder(type_13486c);
  ::Reflex::Type type_2393c = ::Reflex::ConstBuilder(type_2393);
  ::Reflex::Type type_13634c = ::Reflex::ConstBuilder(type_13634);
  ::Reflex::Type type_1810c = ::Reflex::ConstBuilder(type_1810);
  ::Reflex::Type type_22412 = ::Reflex::ReferenceBuilder(type_13486c);
  ::Reflex::Type type_7197c = ::Reflex::ConstBuilder(type_7197);
  ::Reflex::Type type_75115 = ::Reflex::ReferenceBuilder(type_7197c);
  ::Reflex::Type type_13508c = ::Reflex::ConstBuilder(type_13508);
  ::Reflex::Type type_17959 = ::Reflex::ReferenceBuilder(type_13508c);
  ::Reflex::Type type_65110 = ::Reflex::ReferenceBuilder(type_3528c);
  ::Reflex::Type type_3535c = ::Reflex::ConstBuilder(type_3535);
  ::Reflex::Type type_65126 = ::Reflex::ReferenceBuilder(type_3535c);
  ::Reflex::Type type_6449c = ::Reflex::ConstBuilder(type_6449);
  ::Reflex::Type type_22159 = ::Reflex::ReferenceBuilder(type_6449c);
  ::Reflex::Type type_7327c = ::Reflex::ConstBuilder(type_7327);
  ::Reflex::Type type_71958 = ::Reflex::ReferenceBuilder(type_7327c);
  ::Reflex::Type type_13506c = ::Reflex::ConstBuilder(type_13506);
  ::Reflex::Type type_21967 = ::Reflex::ReferenceBuilder(type_13506c);
  ::Reflex::Type type_75168 = ::Reflex::ReferenceBuilder(type_13547);
  ::Reflex::Type type_13547c = ::Reflex::ConstBuilder(type_13547);
  ::Reflex::Type type_75169 = ::Reflex::ReferenceBuilder(type_13547c);
  ::Reflex::Type type_11602c = ::Reflex::ConstBuilder(type_11602);
  ::Reflex::Type type_23124 = ::Reflex::ReferenceBuilder(type_11602c);
  ::Reflex::Type type_75170 = ::Reflex::ReferenceBuilder(type_13548);
  ::Reflex::Type type_13548c = ::Reflex::ConstBuilder(type_13548);
  ::Reflex::Type type_75171 = ::Reflex::ReferenceBuilder(type_13548c);
  ::Reflex::Type type_7302c = ::Reflex::ConstBuilder(type_7302);
  ::Reflex::Type type_71882 = ::Reflex::ReferenceBuilder(type_7302c);
  ::Reflex::Type type_7329c = ::Reflex::ConstBuilder(type_7329);
  ::Reflex::Type type_71961 = ::Reflex::ReferenceBuilder(type_7329c);
  ::Reflex::Type type_75172 = ::Reflex::ReferenceBuilder(type_13549);
  ::Reflex::Type type_13549c = ::Reflex::ConstBuilder(type_13549);
  ::Reflex::Type type_75173 = ::Reflex::ReferenceBuilder(type_13549c);
  ::Reflex::Type type_7303c = ::Reflex::ConstBuilder(type_7303);
  ::Reflex::Type type_71887 = ::Reflex::ReferenceBuilder(type_7303c);
  ::Reflex::Type type_7330c = ::Reflex::ConstBuilder(type_7330);
  ::Reflex::Type type_71963 = ::Reflex::ReferenceBuilder(type_7330c);
  ::Reflex::Type type_75174 = ::Reflex::ReferenceBuilder(type_13550);
  ::Reflex::Type type_13550c = ::Reflex::ConstBuilder(type_13550);
  ::Reflex::Type type_75175 = ::Reflex::ReferenceBuilder(type_13550c);
  ::Reflex::Type type_75176 = ::Reflex::ReferenceBuilder(type_13551);
  ::Reflex::Type type_13551c = ::Reflex::ConstBuilder(type_13551);
  ::Reflex::Type type_75177 = ::Reflex::ReferenceBuilder(type_13551c);
  ::Reflex::Type type_75178 = ::Reflex::ReferenceBuilder(type_13552);
  ::Reflex::Type type_13552c = ::Reflex::ConstBuilder(type_13552);
  ::Reflex::Type type_75179 = ::Reflex::ReferenceBuilder(type_13552c);
  ::Reflex::Type type_75180 = ::Reflex::ReferenceBuilder(type_13553);
  ::Reflex::Type type_13553c = ::Reflex::ConstBuilder(type_13553);
  ::Reflex::Type type_75181 = ::Reflex::ReferenceBuilder(type_13553c);
  ::Reflex::Type type_75182 = ::Reflex::ReferenceBuilder(type_13554);
  ::Reflex::Type type_13554c = ::Reflex::ConstBuilder(type_13554);
  ::Reflex::Type type_75183 = ::Reflex::ReferenceBuilder(type_13554c);
  ::Reflex::Type type_75184 = ::Reflex::ReferenceBuilder(type_13555);
  ::Reflex::Type type_13555c = ::Reflex::ConstBuilder(type_13555);
  ::Reflex::Type type_75185 = ::Reflex::ReferenceBuilder(type_13555c);
  ::Reflex::Type type_7374c = ::Reflex::ConstBuilder(type_7374);
  ::Reflex::Type type_6483c = ::Reflex::ConstBuilder(type_6483);
  ::Reflex::Type type_70738 = ::Reflex::ReferenceBuilder(type_6483c);
  ::Reflex::Type type_70739 = ::Reflex::ReferenceBuilder(type_7374c);
  ::Reflex::Type type_5370c = ::Reflex::ConstBuilder(type_5370);
  ::Reflex::Type type_35206 = ::Reflex::ReferenceBuilder(type_5370c);
  ::Reflex::Type type_6384c = ::Reflex::ConstBuilder(type_6384);
  ::Reflex::Type type_70741 = ::Reflex::ReferenceBuilder(type_6384c);
  ::Reflex::Type type_70742 = ::Reflex::ReferenceBuilder(type_6483);
  ::Reflex::Type type_7201 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::helper_vector"), type_7200);
  ::Reflex::Type type_35212 = ::Reflex::ReferenceBuilder(type_7201);
  ::Reflex::Type type_7377c = ::Reflex::ConstBuilder(type_7377);
  ::Reflex::Type type_6486c = ::Reflex::ConstBuilder(type_6486);
  ::Reflex::Type type_70756 = ::Reflex::ReferenceBuilder(type_6486c);
  ::Reflex::Type type_70757 = ::Reflex::ReferenceBuilder(type_7377c);
  ::Reflex::Type type_6387c = ::Reflex::ConstBuilder(type_6387);
  ::Reflex::Type type_70759 = ::Reflex::ReferenceBuilder(type_6387c);
  ::Reflex::Type type_70760 = ::Reflex::ReferenceBuilder(type_6486);
  ::Reflex::Type type_7379c = ::Reflex::ConstBuilder(type_7379);
  ::Reflex::Type type_6488c = ::Reflex::ConstBuilder(type_6488);
  ::Reflex::Type type_70768 = ::Reflex::ReferenceBuilder(type_6488c);
  ::Reflex::Type type_70769 = ::Reflex::ReferenceBuilder(type_7379c);
  ::Reflex::Type type_6389c = ::Reflex::ConstBuilder(type_6389);
  ::Reflex::Type type_70771 = ::Reflex::ReferenceBuilder(type_6389c);
  ::Reflex::Type type_70772 = ::Reflex::ReferenceBuilder(type_6488);
  ::Reflex::Type type_72000 = ::Reflex::ReferenceBuilder(type_7368);
  ::Reflex::Type type_7368c = ::Reflex::ConstBuilder(type_7368);
  ::Reflex::Type type_70697 = ::Reflex::ReferenceBuilder(type_7368c);
  ::Reflex::Type type_7473c = ::Reflex::ConstBuilder(type_7473);
  ::Reflex::Type type_72001 = ::Reflex::ReferenceBuilder(type_7473c);
  ::Reflex::Type type_7120c = ::Reflex::ConstBuilder(type_7120);
  ::Reflex::Type type_72002 = ::Reflex::ReferenceBuilder(type_7120c);
  ::Reflex::Type type_6476c = ::Reflex::ConstBuilder(type_6476);
  ::Reflex::Type type_70696 = ::Reflex::ReferenceBuilder(type_6476c);
  ::Reflex::Type type_6975c = ::Reflex::ConstBuilder(type_6975);
  ::Reflex::Type type_72003 = ::Reflex::ReferenceBuilder(type_6975c);
  ::Reflex::Type type_7222c = ::Reflex::ConstBuilder(type_7222);
  ::Reflex::Type type_72004 = ::Reflex::ReferenceBuilder(type_7222c);
  ::Reflex::Type type_7376c = ::Reflex::ConstBuilder(type_7376);
  ::Reflex::Type type_6485c = ::Reflex::ConstBuilder(type_6485);
  ::Reflex::Type type_70750 = ::Reflex::ReferenceBuilder(type_6485c);
  ::Reflex::Type type_70751 = ::Reflex::ReferenceBuilder(type_7376c);
  ::Reflex::Type type_6386c = ::Reflex::ConstBuilder(type_6386);
  ::Reflex::Type type_70753 = ::Reflex::ReferenceBuilder(type_6386c);
  ::Reflex::Type type_70754 = ::Reflex::ReferenceBuilder(type_6485);
  ::Reflex::Type type_7371c = ::Reflex::ConstBuilder(type_7371);
  ::Reflex::Type type_6480c = ::Reflex::ConstBuilder(type_6480);
  ::Reflex::Type type_70720 = ::Reflex::ReferenceBuilder(type_6480c);
  ::Reflex::Type type_70721 = ::Reflex::ReferenceBuilder(type_7371c);
  ::Reflex::Type type_6381c = ::Reflex::ConstBuilder(type_6381);
  ::Reflex::Type type_70723 = ::Reflex::ReferenceBuilder(type_6381c);
  ::Reflex::Type type_70724 = ::Reflex::ReferenceBuilder(type_6480);
  ::Reflex::Type type_72030 = ::Reflex::ReferenceBuilder(type_7374);
  ::Reflex::Type type_7480c = ::Reflex::ConstBuilder(type_7480);
  ::Reflex::Type type_72031 = ::Reflex::ReferenceBuilder(type_7480c);
  ::Reflex::Type type_7127c = ::Reflex::ConstBuilder(type_7127);
  ::Reflex::Type type_72032 = ::Reflex::ReferenceBuilder(type_7127c);
  ::Reflex::Type type_6982c = ::Reflex::ConstBuilder(type_6982);
  ::Reflex::Type type_72033 = ::Reflex::ReferenceBuilder(type_6982c);
  ::Reflex::Type type_7228c = ::Reflex::ConstBuilder(type_7228);
  ::Reflex::Type type_72034 = ::Reflex::ReferenceBuilder(type_7228c);
  ::Reflex::Type type_72015 = ::Reflex::ReferenceBuilder(type_7371);
  ::Reflex::Type type_7477c = ::Reflex::ConstBuilder(type_7477);
  ::Reflex::Type type_72016 = ::Reflex::ReferenceBuilder(type_7477c);
  ::Reflex::Type type_7124c = ::Reflex::ConstBuilder(type_7124);
  ::Reflex::Type type_72017 = ::Reflex::ReferenceBuilder(type_7124c);
  ::Reflex::Type type_6979c = ::Reflex::ConstBuilder(type_6979);
  ::Reflex::Type type_72018 = ::Reflex::ReferenceBuilder(type_6979c);
  ::Reflex::Type type_7225c = ::Reflex::ConstBuilder(type_7225);
  ::Reflex::Type type_72019 = ::Reflex::ReferenceBuilder(type_7225c);
  ::Reflex::Type type_7367c = ::Reflex::ConstBuilder(type_7367);
  ::Reflex::Type type_70703 = ::Reflex::ReferenceBuilder(type_7367c);
  ::Reflex::Type type_6378c = ::Reflex::ConstBuilder(type_6378);
  ::Reflex::Type type_70705 = ::Reflex::ReferenceBuilder(type_6378c);
  ::Reflex::Type type_70706 = ::Reflex::ReferenceBuilder(type_6477);
  ::Reflex::Type type_7370c = ::Reflex::ConstBuilder(type_7370);
  ::Reflex::Type type_6479c = ::Reflex::ConstBuilder(type_6479);
  ::Reflex::Type type_70714 = ::Reflex::ReferenceBuilder(type_6479c);
  ::Reflex::Type type_70715 = ::Reflex::ReferenceBuilder(type_7370c);
  ::Reflex::Type type_6380c = ::Reflex::ConstBuilder(type_6380);
  ::Reflex::Type type_70717 = ::Reflex::ReferenceBuilder(type_6380c);
  ::Reflex::Type type_70718 = ::Reflex::ReferenceBuilder(type_6479);
  ::Reflex::Type type_7373c = ::Reflex::ConstBuilder(type_7373);
  ::Reflex::Type type_6482c = ::Reflex::ConstBuilder(type_6482);
  ::Reflex::Type type_70732 = ::Reflex::ReferenceBuilder(type_6482c);
  ::Reflex::Type type_70733 = ::Reflex::ReferenceBuilder(type_7373c);
  ::Reflex::Type type_6383c = ::Reflex::ConstBuilder(type_6383);
  ::Reflex::Type type_70735 = ::Reflex::ReferenceBuilder(type_6383c);
  ::Reflex::Type type_70736 = ::Reflex::ReferenceBuilder(type_6482);
  ::Reflex::Type type_72020 = ::Reflex::ReferenceBuilder(type_7372);
  ::Reflex::Type type_7372c = ::Reflex::ConstBuilder(type_7372);
  ::Reflex::Type type_70727 = ::Reflex::ReferenceBuilder(type_7372c);
  ::Reflex::Type type_7478c = ::Reflex::ConstBuilder(type_7478);
  ::Reflex::Type type_72021 = ::Reflex::ReferenceBuilder(type_7478c);
  ::Reflex::Type type_7125c = ::Reflex::ConstBuilder(type_7125);
  ::Reflex::Type type_72022 = ::Reflex::ReferenceBuilder(type_7125c);
  ::Reflex::Type type_6481c = ::Reflex::ConstBuilder(type_6481);
  ::Reflex::Type type_70726 = ::Reflex::ReferenceBuilder(type_6481c);
  ::Reflex::Type type_6980c = ::Reflex::ConstBuilder(type_6980);
  ::Reflex::Type type_72023 = ::Reflex::ReferenceBuilder(type_6980c);
  ::Reflex::Type type_7226c = ::Reflex::ConstBuilder(type_7226);
  ::Reflex::Type type_72024 = ::Reflex::ReferenceBuilder(type_7226c);
  ::Reflex::Type type_7369c = ::Reflex::ConstBuilder(type_7369);
  ::Reflex::Type type_6478c = ::Reflex::ConstBuilder(type_6478);
  ::Reflex::Type type_70708 = ::Reflex::ReferenceBuilder(type_6478c);
  ::Reflex::Type type_70709 = ::Reflex::ReferenceBuilder(type_7369c);
  ::Reflex::Type type_6379c = ::Reflex::ConstBuilder(type_6379);
  ::Reflex::Type type_70711 = ::Reflex::ReferenceBuilder(type_6379c);
  ::Reflex::Type type_70712 = ::Reflex::ReferenceBuilder(type_6478);
  ::Reflex::Type type_72050 = ::Reflex::ReferenceBuilder(type_7378);
  ::Reflex::Type type_7378c = ::Reflex::ConstBuilder(type_7378);
  ::Reflex::Type type_70763 = ::Reflex::ReferenceBuilder(type_7378c);
  ::Reflex::Type type_7484c = ::Reflex::ConstBuilder(type_7484);
  ::Reflex::Type type_72051 = ::Reflex::ReferenceBuilder(type_7484c);
  ::Reflex::Type type_7131c = ::Reflex::ConstBuilder(type_7131);
  ::Reflex::Type type_72052 = ::Reflex::ReferenceBuilder(type_7131c);
  ::Reflex::Type type_6487c = ::Reflex::ConstBuilder(type_6487);
  ::Reflex::Type type_70762 = ::Reflex::ReferenceBuilder(type_6487c);
  ::Reflex::Type type_6986c = ::Reflex::ConstBuilder(type_6986);
  ::Reflex::Type type_72053 = ::Reflex::ReferenceBuilder(type_6986c);
  ::Reflex::Type type_7232c = ::Reflex::ConstBuilder(type_7232);
  ::Reflex::Type type_72054 = ::Reflex::ReferenceBuilder(type_7232c);
  ::Reflex::Type type_72025 = ::Reflex::ReferenceBuilder(type_7373);
  ::Reflex::Type type_7479c = ::Reflex::ConstBuilder(type_7479);
  ::Reflex::Type type_72026 = ::Reflex::ReferenceBuilder(type_7479c);
  ::Reflex::Type type_7126c = ::Reflex::ConstBuilder(type_7126);
  ::Reflex::Type type_72027 = ::Reflex::ReferenceBuilder(type_7126c);
  ::Reflex::Type type_6981c = ::Reflex::ConstBuilder(type_6981);
  ::Reflex::Type type_72028 = ::Reflex::ReferenceBuilder(type_6981c);
  ::Reflex::Type type_7227c = ::Reflex::ConstBuilder(type_7227);
  ::Reflex::Type type_72029 = ::Reflex::ReferenceBuilder(type_7227c);
  ::Reflex::Type type_6388c = ::Reflex::ConstBuilder(type_6388);
  ::Reflex::Type type_70765 = ::Reflex::ReferenceBuilder(type_6388c);
  ::Reflex::Type type_70766 = ::Reflex::ReferenceBuilder(type_6487);
  ::Reflex::Type type_7375c = ::Reflex::ConstBuilder(type_7375);
  ::Reflex::Type type_6484c = ::Reflex::ConstBuilder(type_6484);
  ::Reflex::Type type_70744 = ::Reflex::ReferenceBuilder(type_6484c);
  ::Reflex::Type type_70745 = ::Reflex::ReferenceBuilder(type_7375c);
  ::Reflex::Type type_6385c = ::Reflex::ConstBuilder(type_6385);
  ::Reflex::Type type_70747 = ::Reflex::ReferenceBuilder(type_6385c);
  ::Reflex::Type type_70748 = ::Reflex::ReferenceBuilder(type_6484);
  ::Reflex::Type type_71999 = ::Reflex::ReferenceBuilder(type_7367);
  ::Reflex::Type type_7474c = ::Reflex::ConstBuilder(type_7474);
  ::Reflex::Type type_71852 = ::Reflex::ReferenceBuilder(type_7474c);
  ::Reflex::Type type_7121c = ::Reflex::ConstBuilder(type_7121);
  ::Reflex::Type type_71776 = ::Reflex::ReferenceBuilder(type_7121c);
  ::Reflex::Type type_6976c = ::Reflex::ConstBuilder(type_6976);
  ::Reflex::Type type_71712 = ::Reflex::ReferenceBuilder(type_6976c);
  ::Reflex::Type type_72035 = ::Reflex::ReferenceBuilder(type_7375);
  ::Reflex::Type type_7481c = ::Reflex::ConstBuilder(type_7481);
  ::Reflex::Type type_72036 = ::Reflex::ReferenceBuilder(type_7481c);
  ::Reflex::Type type_7128c = ::Reflex::ConstBuilder(type_7128);
  ::Reflex::Type type_72037 = ::Reflex::ReferenceBuilder(type_7128c);
  ::Reflex::Type type_6983c = ::Reflex::ConstBuilder(type_6983);
  ::Reflex::Type type_72038 = ::Reflex::ReferenceBuilder(type_6983c);
  ::Reflex::Type type_7229c = ::Reflex::ConstBuilder(type_7229);
  ::Reflex::Type type_72039 = ::Reflex::ReferenceBuilder(type_7229c);
  ::Reflex::Type type_72045 = ::Reflex::ReferenceBuilder(type_7377);
  ::Reflex::Type type_7483c = ::Reflex::ConstBuilder(type_7483);
  ::Reflex::Type type_72046 = ::Reflex::ReferenceBuilder(type_7483c);
  ::Reflex::Type type_7130c = ::Reflex::ConstBuilder(type_7130);
  ::Reflex::Type type_72047 = ::Reflex::ReferenceBuilder(type_7130c);
  ::Reflex::Type type_6985c = ::Reflex::ConstBuilder(type_6985);
  ::Reflex::Type type_72048 = ::Reflex::ReferenceBuilder(type_6985c);
  ::Reflex::Type type_7231c = ::Reflex::ConstBuilder(type_7231);
  ::Reflex::Type type_72049 = ::Reflex::ReferenceBuilder(type_7231c);
  ::Reflex::Type type_6382c = ::Reflex::ConstBuilder(type_6382);
  ::Reflex::Type type_70729 = ::Reflex::ReferenceBuilder(type_6382c);
  ::Reflex::Type type_70730 = ::Reflex::ReferenceBuilder(type_6481);
  ::Reflex::Type type_72055 = ::Reflex::ReferenceBuilder(type_7379);
  ::Reflex::Type type_7485c = ::Reflex::ConstBuilder(type_7485);
  ::Reflex::Type type_72056 = ::Reflex::ReferenceBuilder(type_7485c);
  ::Reflex::Type type_7132c = ::Reflex::ConstBuilder(type_7132);
  ::Reflex::Type type_72057 = ::Reflex::ReferenceBuilder(type_7132c);
  ::Reflex::Type type_6987c = ::Reflex::ConstBuilder(type_6987);
  ::Reflex::Type type_72058 = ::Reflex::ReferenceBuilder(type_6987c);
  ::Reflex::Type type_7233c = ::Reflex::ConstBuilder(type_7233);
  ::Reflex::Type type_72059 = ::Reflex::ReferenceBuilder(type_7233c);
  ::Reflex::Type type_72040 = ::Reflex::ReferenceBuilder(type_7376);
  ::Reflex::Type type_7482c = ::Reflex::ConstBuilder(type_7482);
  ::Reflex::Type type_72041 = ::Reflex::ReferenceBuilder(type_7482c);
  ::Reflex::Type type_7129c = ::Reflex::ConstBuilder(type_7129);
  ::Reflex::Type type_72042 = ::Reflex::ReferenceBuilder(type_7129c);
  ::Reflex::Type type_6984c = ::Reflex::ConstBuilder(type_6984);
  ::Reflex::Type type_72043 = ::Reflex::ReferenceBuilder(type_6984c);
  ::Reflex::Type type_7230c = ::Reflex::ConstBuilder(type_7230);
  ::Reflex::Type type_72044 = ::Reflex::ReferenceBuilder(type_7230c);
  ::Reflex::Type type_72010 = ::Reflex::ReferenceBuilder(type_7370);
  ::Reflex::Type type_7476c = ::Reflex::ConstBuilder(type_7476);
  ::Reflex::Type type_72011 = ::Reflex::ReferenceBuilder(type_7476c);
  ::Reflex::Type type_7123c = ::Reflex::ConstBuilder(type_7123);
  ::Reflex::Type type_72012 = ::Reflex::ReferenceBuilder(type_7123c);
  ::Reflex::Type type_6978c = ::Reflex::ConstBuilder(type_6978);
  ::Reflex::Type type_72013 = ::Reflex::ReferenceBuilder(type_6978c);
  ::Reflex::Type type_7224c = ::Reflex::ConstBuilder(type_7224);
  ::Reflex::Type type_72014 = ::Reflex::ReferenceBuilder(type_7224c);
  ::Reflex::Type type_7380c = ::Reflex::ConstBuilder(type_7380);
  ::Reflex::Type type_6489c = ::Reflex::ConstBuilder(type_6489);
  ::Reflex::Type type_70774 = ::Reflex::ReferenceBuilder(type_6489c);
  ::Reflex::Type type_70775 = ::Reflex::ReferenceBuilder(type_7380c);
  ::Reflex::Type type_6390c = ::Reflex::ConstBuilder(type_6390);
  ::Reflex::Type type_70777 = ::Reflex::ReferenceBuilder(type_6390c);
  ::Reflex::Type type_70778 = ::Reflex::ReferenceBuilder(type_6489);
  ::Reflex::Type type_72005 = ::Reflex::ReferenceBuilder(type_7369);
  ::Reflex::Type type_7475c = ::Reflex::ConstBuilder(type_7475);
  ::Reflex::Type type_72006 = ::Reflex::ReferenceBuilder(type_7475c);
  ::Reflex::Type type_7122c = ::Reflex::ConstBuilder(type_7122);
  ::Reflex::Type type_72007 = ::Reflex::ReferenceBuilder(type_7122c);
  ::Reflex::Type type_6977c = ::Reflex::ConstBuilder(type_6977);
  ::Reflex::Type type_72008 = ::Reflex::ReferenceBuilder(type_6977c);
  ::Reflex::Type type_7223c = ::Reflex::ConstBuilder(type_7223);
  ::Reflex::Type type_72009 = ::Reflex::ReferenceBuilder(type_7223c);
  ::Reflex::Type type_72060 = ::Reflex::ReferenceBuilder(type_7380);
  ::Reflex::Type type_7486c = ::Reflex::ConstBuilder(type_7486);
  ::Reflex::Type type_72061 = ::Reflex::ReferenceBuilder(type_7486c);
  ::Reflex::Type type_7133c = ::Reflex::ConstBuilder(type_7133);
  ::Reflex::Type type_72062 = ::Reflex::ReferenceBuilder(type_7133c);
  ::Reflex::Type type_6988c = ::Reflex::ConstBuilder(type_6988);
  ::Reflex::Type type_72063 = ::Reflex::ReferenceBuilder(type_6988c);
  ::Reflex::Type type_7234c = ::Reflex::ConstBuilder(type_7234);
  ::Reflex::Type type_72064 = ::Reflex::ReferenceBuilder(type_7234c);
  ::Reflex::Type type_6377c = ::Reflex::ConstBuilder(type_6377);
  ::Reflex::Type type_70699 = ::Reflex::ReferenceBuilder(type_6377c);
  ::Reflex::Type type_70700 = ::Reflex::ReferenceBuilder(type_6476);
  ::Reflex::Type type_73862 = ::Reflex::ReferenceBuilder(type_11964);
  ::Reflex::Type type_11964c = ::Reflex::ConstBuilder(type_11964);
  ::Reflex::Type type_73863 = ::Reflex::ReferenceBuilder(type_11964c);
  ::Reflex::Type type_17685c = ::Reflex::ConstBuilder(type_17685);
  ::Reflex::Type type_73864 = ::Reflex::ReferenceBuilder(type_17685c);
  ::Reflex::Type type_3753c = ::Reflex::ConstBuilder(type_3753);
  ::Reflex::Type type_72493 = ::Reflex::ReferenceBuilder(type_3753c);
  ::Reflex::Type type_73865 = ::Reflex::ReferenceBuilder(type_11965);
  ::Reflex::Type type_11965c = ::Reflex::ConstBuilder(type_11965);
  ::Reflex::Type type_73866 = ::Reflex::ReferenceBuilder(type_11965c);
  ::Reflex::Type type_17696c = ::Reflex::ConstBuilder(type_17696);
  ::Reflex::Type type_73867 = ::Reflex::ReferenceBuilder(type_17696c);
  ::Reflex::Type type_73868 = ::Reflex::ReferenceBuilder(type_11966);
  ::Reflex::Type type_11966c = ::Reflex::ConstBuilder(type_11966);
  ::Reflex::Type type_73869 = ::Reflex::ReferenceBuilder(type_11966c);
  ::Reflex::Type type_17707c = ::Reflex::ConstBuilder(type_17707);
  ::Reflex::Type type_73870 = ::Reflex::ReferenceBuilder(type_17707c);
  ::Reflex::Type type_73871 = ::Reflex::ReferenceBuilder(type_11967);
  ::Reflex::Type type_11967c = ::Reflex::ConstBuilder(type_11967);
  ::Reflex::Type type_73872 = ::Reflex::ReferenceBuilder(type_11967c);
  ::Reflex::Type type_17718c = ::Reflex::ConstBuilder(type_17718);
  ::Reflex::Type type_73873 = ::Reflex::ReferenceBuilder(type_17718c);
  ::Reflex::Type type_73874 = ::Reflex::ReferenceBuilder(type_11968);
  ::Reflex::Type type_11968c = ::Reflex::ConstBuilder(type_11968);
  ::Reflex::Type type_73875 = ::Reflex::ReferenceBuilder(type_11968c);
  ::Reflex::Type type_17729c = ::Reflex::ConstBuilder(type_17729);
  ::Reflex::Type type_73876 = ::Reflex::ReferenceBuilder(type_17729c);
  ::Reflex::Type type_73877 = ::Reflex::ReferenceBuilder(type_11969);
  ::Reflex::Type type_11969c = ::Reflex::ConstBuilder(type_11969);
  ::Reflex::Type type_73878 = ::Reflex::ReferenceBuilder(type_11969c);
  ::Reflex::Type type_17740c = ::Reflex::ConstBuilder(type_17740);
  ::Reflex::Type type_73879 = ::Reflex::ReferenceBuilder(type_17740c);
  ::Reflex::Type type_73880 = ::Reflex::ReferenceBuilder(type_11970);
  ::Reflex::Type type_11970c = ::Reflex::ConstBuilder(type_11970);
  ::Reflex::Type type_73881 = ::Reflex::ReferenceBuilder(type_11970c);
  ::Reflex::Type type_17751c = ::Reflex::ConstBuilder(type_17751);
  ::Reflex::Type type_73882 = ::Reflex::ReferenceBuilder(type_17751c);
  ::Reflex::Type type_73883 = ::Reflex::ReferenceBuilder(type_11971);
  ::Reflex::Type type_11971c = ::Reflex::ConstBuilder(type_11971);
  ::Reflex::Type type_73884 = ::Reflex::ReferenceBuilder(type_11971c);
  ::Reflex::Type type_17762c = ::Reflex::ConstBuilder(type_17762);
  ::Reflex::Type type_73885 = ::Reflex::ReferenceBuilder(type_17762c);
  ::Reflex::Type type_73889 = ::Reflex::ReferenceBuilder(type_11974);
  ::Reflex::Type type_11974c = ::Reflex::ConstBuilder(type_11974);
  ::Reflex::Type type_73890 = ::Reflex::ReferenceBuilder(type_11974c);
  ::Reflex::Type type_17784c = ::Reflex::ConstBuilder(type_17784);
  ::Reflex::Type type_73891 = ::Reflex::ReferenceBuilder(type_17784c);
  ::Reflex::Type type_73892 = ::Reflex::ReferenceBuilder(type_11975);
  ::Reflex::Type type_11975c = ::Reflex::ConstBuilder(type_11975);
  ::Reflex::Type type_73893 = ::Reflex::ReferenceBuilder(type_11975c);
  ::Reflex::Type type_17795c = ::Reflex::ConstBuilder(type_17795);
  ::Reflex::Type type_73894 = ::Reflex::ReferenceBuilder(type_17795c);
  ::Reflex::Type type_73895 = ::Reflex::ReferenceBuilder(type_11976);
  ::Reflex::Type type_11976c = ::Reflex::ConstBuilder(type_11976);
  ::Reflex::Type type_73896 = ::Reflex::ReferenceBuilder(type_11976c);
  ::Reflex::Type type_17806c = ::Reflex::ConstBuilder(type_17806);
  ::Reflex::Type type_73897 = ::Reflex::ReferenceBuilder(type_17806c);
  ::Reflex::Type type_73898 = ::Reflex::ReferenceBuilder(type_11977);
  ::Reflex::Type type_11977c = ::Reflex::ConstBuilder(type_11977);
  ::Reflex::Type type_73899 = ::Reflex::ReferenceBuilder(type_11977c);
  ::Reflex::Type type_17817c = ::Reflex::ConstBuilder(type_17817);
  ::Reflex::Type type_73900 = ::Reflex::ReferenceBuilder(type_17817c);
  ::Reflex::Type type_73901 = ::Reflex::ReferenceBuilder(type_11978);
  ::Reflex::Type type_11978c = ::Reflex::ConstBuilder(type_11978);
  ::Reflex::Type type_73902 = ::Reflex::ReferenceBuilder(type_11978c);
  ::Reflex::Type type_17828c = ::Reflex::ConstBuilder(type_17828);
  ::Reflex::Type type_73903 = ::Reflex::ReferenceBuilder(type_17828c);
  ::Reflex::Type type_73904 = ::Reflex::ReferenceBuilder(type_11979);
  ::Reflex::Type type_11979c = ::Reflex::ConstBuilder(type_11979);
  ::Reflex::Type type_73905 = ::Reflex::ReferenceBuilder(type_11979c);
  ::Reflex::Type type_17839c = ::Reflex::ConstBuilder(type_17839);
  ::Reflex::Type type_73906 = ::Reflex::ReferenceBuilder(type_17839c);
  ::Reflex::Type type_73886 = ::Reflex::ReferenceBuilder(type_11972);
  ::Reflex::Type type_11972c = ::Reflex::ConstBuilder(type_11972);
  ::Reflex::Type type_73887 = ::Reflex::ReferenceBuilder(type_11972c);
  ::Reflex::Type type_17773c = ::Reflex::ConstBuilder(type_17773);
  ::Reflex::Type type_73888 = ::Reflex::ReferenceBuilder(type_17773c);
  ::Reflex::Type type_7358c = ::Reflex::ConstBuilder(type_7358);
  ::Reflex::Type type_71993 = ::Reflex::ReferenceBuilder(type_7358c);
  ::Reflex::Type type_71994 = ::Reflex::ReferenceBuilder(type_7358);
  ::Reflex::Type type_3503c = ::Reflex::ConstBuilder(type_3503);
  ::Reflex::Type type_65077 = ::Reflex::ReferenceBuilder(type_3503c);
  ::Reflex::Type type_70927 = ::Reflex::PointerBuilder(type_7358c);
  ::Reflex::Type type_70928 = ::Reflex::PointerBuilder(type_7358);
  ::Reflex::Type type_7037c = ::Reflex::ConstBuilder(type_7037);
  ::Reflex::Type type_70929 = ::Reflex::PointerBuilder(type_7037c);
  ::Reflex::Type type_70942 = ::Reflex::PointerBuilder(type_6478c);
  ::Reflex::Type type_70943 = ::Reflex::PointerBuilder(type_6478);
  ::Reflex::Type type_7040c = ::Reflex::ConstBuilder(type_7040);
  ::Reflex::Type type_70944 = ::Reflex::PointerBuilder(type_7040c);
  ::Reflex::Type type_70947 = ::Reflex::PointerBuilder(type_6479c);
  ::Reflex::Type type_70948 = ::Reflex::PointerBuilder(type_6479);
  ::Reflex::Type type_7041c = ::Reflex::ConstBuilder(type_7041);
  ::Reflex::Type type_70949 = ::Reflex::PointerBuilder(type_7041c);
  ::Reflex::Type type_70952 = ::Reflex::PointerBuilder(type_6480c);
  ::Reflex::Type type_70953 = ::Reflex::PointerBuilder(type_6480);
  ::Reflex::Type type_7042c = ::Reflex::ConstBuilder(type_7042);
  ::Reflex::Type type_70954 = ::Reflex::PointerBuilder(type_7042c);
  ::Reflex::Type type_70957 = ::Reflex::PointerBuilder(type_6481c);
  ::Reflex::Type type_70958 = ::Reflex::PointerBuilder(type_6481);
  ::Reflex::Type type_7043c = ::Reflex::ConstBuilder(type_7043);
  ::Reflex::Type type_70959 = ::Reflex::PointerBuilder(type_7043c);
  ::Reflex::Type type_70962 = ::Reflex::PointerBuilder(type_6482c);
  ::Reflex::Type type_70963 = ::Reflex::PointerBuilder(type_6482);
  ::Reflex::Type type_7044c = ::Reflex::ConstBuilder(type_7044);
  ::Reflex::Type type_70964 = ::Reflex::PointerBuilder(type_7044c);
  ::Reflex::Type type_70967 = ::Reflex::PointerBuilder(type_6483c);
  ::Reflex::Type type_70968 = ::Reflex::PointerBuilder(type_6483);
  ::Reflex::Type type_7045c = ::Reflex::ConstBuilder(type_7045);
  ::Reflex::Type type_70969 = ::Reflex::PointerBuilder(type_7045c);
  ::Reflex::Type type_70972 = ::Reflex::PointerBuilder(type_6484c);
  ::Reflex::Type type_70973 = ::Reflex::PointerBuilder(type_6484);
  ::Reflex::Type type_7046c = ::Reflex::ConstBuilder(type_7046);
  ::Reflex::Type type_70974 = ::Reflex::PointerBuilder(type_7046c);
  ::Reflex::Type type_70977 = ::Reflex::PointerBuilder(type_6485c);
  ::Reflex::Type type_70978 = ::Reflex::PointerBuilder(type_6485);
  ::Reflex::Type type_7047c = ::Reflex::ConstBuilder(type_7047);
  ::Reflex::Type type_70979 = ::Reflex::PointerBuilder(type_7047c);
  ::Reflex::Type type_70982 = ::Reflex::PointerBuilder(type_6486c);
  ::Reflex::Type type_70983 = ::Reflex::PointerBuilder(type_6486);
  ::Reflex::Type type_7048c = ::Reflex::ConstBuilder(type_7048);
  ::Reflex::Type type_70984 = ::Reflex::PointerBuilder(type_7048c);
  ::Reflex::Type type_70987 = ::Reflex::PointerBuilder(type_6487c);
  ::Reflex::Type type_70988 = ::Reflex::PointerBuilder(type_6487);
  ::Reflex::Type type_7049c = ::Reflex::ConstBuilder(type_7049);
  ::Reflex::Type type_70989 = ::Reflex::PointerBuilder(type_7049c);
  ::Reflex::Type type_70992 = ::Reflex::PointerBuilder(type_6488c);
  ::Reflex::Type type_70993 = ::Reflex::PointerBuilder(type_6488);
  ::Reflex::Type type_7050c = ::Reflex::ConstBuilder(type_7050);
  ::Reflex::Type type_70994 = ::Reflex::PointerBuilder(type_7050c);
  ::Reflex::Type type_70997 = ::Reflex::PointerBuilder(type_6489c);
  ::Reflex::Type type_70998 = ::Reflex::PointerBuilder(type_6489);
  ::Reflex::Type type_7051c = ::Reflex::ConstBuilder(type_7051);
  ::Reflex::Type type_70999 = ::Reflex::PointerBuilder(type_7051c);
  ::Reflex::Type type_71760 = ::Reflex::PointerBuilder(type_3557);
  ::Reflex::Type type_7115c = ::Reflex::ConstBuilder(type_7115);
  ::Reflex::Type type_71761 = ::Reflex::ReferenceBuilder(type_7115c);
  ::Reflex::Type type_71762 = ::Reflex::ReferenceBuilder(type_7115);
  ::Reflex::Type type_71763 = ::Reflex::PointerBuilder(type_3557c);
  ::Reflex::Type type_65194 = ::Reflex::ReferenceBuilder(type_3557);
  ::Reflex::Type type_15184 = ::Reflex::PointerBuilder(type_6550);
  ::Reflex::Type type_7118c = ::Reflex::ConstBuilder(type_7118);
  ::Reflex::Type type_71773 = ::Reflex::ReferenceBuilder(type_7118c);
  ::Reflex::Type type_71774 = ::Reflex::ReferenceBuilder(type_7118);
  ::Reflex::Type type_6550c = ::Reflex::ConstBuilder(type_6550);
  ::Reflex::Type type_24871 = ::Reflex::PointerBuilder(type_6550c);
  ::Reflex::Type type_24875 = ::Reflex::ReferenceBuilder(type_6550c);
  ::Reflex::Type type_24873 = ::Reflex::ReferenceBuilder(type_6550);
  ::Reflex::Type type_71850 = ::Reflex::ReferenceBuilder(type_7221);
  ::Reflex::Type type_40424c = ::Reflex::ConstBuilder(type_40424);
  ::Reflex::Type type_79149 = ::Reflex::ReferenceBuilder(type_40424c);
  ::Reflex::Type type_79150 = ::Reflex::ReferenceBuilder(type_40424);
  ::Reflex::Type type_19497c = ::Reflex::ConstBuilder(type_19497);
  ::Reflex::Type type_71823 = ::Reflex::PointerBuilder(type_19497c);
  ::Reflex::Type type_79151 = ::Reflex::PointerBuilder(type_40424);
  ::Reflex::Type type_79154 = ::Reflex::ReferenceBuilder(type_40426);
  ::Reflex::Type type_40426c = ::Reflex::ConstBuilder(type_40426);
  ::Reflex::Type type_79155 = ::Reflex::ReferenceBuilder(type_40426c);
  ::Reflex::Type type_37173 = ::Reflex::PointerBuilder(type_19497);
  ::Reflex::Type type_76012 = ::Reflex::ReferenceBuilder(type_19497c);
  ::Reflex::Type type_37175 = ::Reflex::ReferenceBuilder(type_19497);
  ::Reflex::Type type_18062 = ::Reflex::ReferenceBuilder(type_2999);
  ::Reflex::Type type_79156 = ::Reflex::ReferenceBuilder(type_40427);
  ::Reflex::Type type_40427c = ::Reflex::ConstBuilder(type_40427);
  ::Reflex::Type type_79157 = ::Reflex::ReferenceBuilder(type_40427c);
  ::Reflex::Type type_79158 = ::Reflex::ReferenceBuilder(type_40428);
  ::Reflex::Type type_40428c = ::Reflex::ConstBuilder(type_40428);
  ::Reflex::Type type_79159 = ::Reflex::ReferenceBuilder(type_40428c);
  ::Reflex::Type type_79160 = ::Reflex::ReferenceBuilder(type_40429);
  ::Reflex::Type type_40429c = ::Reflex::ConstBuilder(type_40429);
  ::Reflex::Type type_79161 = ::Reflex::ReferenceBuilder(type_40429c);
  ::Reflex::Type type_79162 = ::Reflex::ReferenceBuilder(type_40430);
  ::Reflex::Type type_40430c = ::Reflex::ConstBuilder(type_40430);
  ::Reflex::Type type_79163 = ::Reflex::ReferenceBuilder(type_40430c);
  ::Reflex::Type type_79164 = ::Reflex::ReferenceBuilder(type_40431);
  ::Reflex::Type type_40431c = ::Reflex::ConstBuilder(type_40431);
  ::Reflex::Type type_79165 = ::Reflex::ReferenceBuilder(type_40431c);
  ::Reflex::Type type_79166 = ::Reflex::ReferenceBuilder(type_40432);
  ::Reflex::Type type_40432c = ::Reflex::ConstBuilder(type_40432);
  ::Reflex::Type type_79167 = ::Reflex::ReferenceBuilder(type_40432c);
  ::Reflex::Type type_79168 = ::Reflex::ReferenceBuilder(type_40433);
  ::Reflex::Type type_40433c = ::Reflex::ConstBuilder(type_40433);
  ::Reflex::Type type_79169 = ::Reflex::ReferenceBuilder(type_40433c);
  ::Reflex::Type type_79170 = ::Reflex::ReferenceBuilder(type_40434);
  ::Reflex::Type type_40434c = ::Reflex::ConstBuilder(type_40434);
  ::Reflex::Type type_79171 = ::Reflex::ReferenceBuilder(type_40434c);
  ::Reflex::Type type_79172 = ::Reflex::ReferenceBuilder(type_40435);
  ::Reflex::Type type_40435c = ::Reflex::ConstBuilder(type_40435);
  ::Reflex::Type type_79173 = ::Reflex::ReferenceBuilder(type_40435c);
  ::Reflex::Type type_40439c = ::Reflex::ConstBuilder(type_40439);
  ::Reflex::Type type_79180 = ::Reflex::ReferenceBuilder(type_40439c);
  ::Reflex::Type type_79178 = ::Reflex::PointerBuilder(type_40438);
  ::Reflex::Type type_79181 = ::Reflex::ReferenceBuilder(type_40439);
  ::Reflex::Type type_40410c = ::Reflex::ConstBuilder(type_40410);
  ::Reflex::Type type_79179 = ::Reflex::PointerBuilder(type_40410c);
  ::Reflex::Type type_40443c = ::Reflex::ConstBuilder(type_40443);
  ::Reflex::Type type_79188 = ::Reflex::ReferenceBuilder(type_40443c);
  ::Reflex::Type type_79189 = ::Reflex::ReferenceBuilder(type_40443);
  ::Reflex::Type type_71862 = ::Reflex::PointerBuilder(type_40410);
  ::Reflex::Type type_79148 = ::Reflex::ReferenceBuilder(type_40410c);
  ::Reflex::Type type_40444c = ::Reflex::ConstBuilder(type_40444);
  ::Reflex::Type type_79190 = ::Reflex::ReferenceBuilder(type_40444c);
  ::Reflex::Type type_79191 = ::Reflex::ReferenceBuilder(type_40444);
  ::Reflex::Type type_40445c = ::Reflex::ConstBuilder(type_40445);
  ::Reflex::Type type_79192 = ::Reflex::ReferenceBuilder(type_40445c);
  ::Reflex::Type type_79193 = ::Reflex::ReferenceBuilder(type_40445);
  ::Reflex::Type type_40446c = ::Reflex::ConstBuilder(type_40446);
  ::Reflex::Type type_79194 = ::Reflex::ReferenceBuilder(type_40446c);
  ::Reflex::Type type_79195 = ::Reflex::ReferenceBuilder(type_40446);
  ::Reflex::Type type_40447c = ::Reflex::ConstBuilder(type_40447);
  ::Reflex::Type type_79196 = ::Reflex::ReferenceBuilder(type_40447c);
  ::Reflex::Type type_79197 = ::Reflex::ReferenceBuilder(type_40447);
  ::Reflex::Type type_40448c = ::Reflex::ConstBuilder(type_40448);
  ::Reflex::Type type_79198 = ::Reflex::ReferenceBuilder(type_40448c);
  ::Reflex::Type type_79199 = ::Reflex::ReferenceBuilder(type_40448);
  ::Reflex::Type type_40449c = ::Reflex::ConstBuilder(type_40449);
  ::Reflex::Type type_79200 = ::Reflex::ReferenceBuilder(type_40449c);
  ::Reflex::Type type_79201 = ::Reflex::ReferenceBuilder(type_40449);
  ::Reflex::Type type_40450c = ::Reflex::ConstBuilder(type_40450);
  ::Reflex::Type type_79202 = ::Reflex::ReferenceBuilder(type_40450c);
  ::Reflex::Type type_79203 = ::Reflex::ReferenceBuilder(type_40450);
  ::Reflex::Type type_40451c = ::Reflex::ConstBuilder(type_40451);
  ::Reflex::Type type_79204 = ::Reflex::ReferenceBuilder(type_40451c);
  ::Reflex::Type type_79205 = ::Reflex::ReferenceBuilder(type_40451);
  ::Reflex::Type type_40452c = ::Reflex::ConstBuilder(type_40452);
  ::Reflex::Type type_79206 = ::Reflex::ReferenceBuilder(type_40452c);
  ::Reflex::Type type_79207 = ::Reflex::ReferenceBuilder(type_40452);
  ::Reflex::Type type_6794f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<edm::Association<pat::PackedCandidateCollection> >"), type_6794);
  ::Reflex::Type type_6797f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::ConversionRefVector>"), type_6797);
  ::Reflex::Type type_6798f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::HemisphereRefVector>"), type_6798);
  ::Reflex::Type type_6799f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::GenericParticleRefVector>"), type_6799);
  ::Reflex::Type type_6800f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::PFParticleRefVector>"), type_6800);
  ::Reflex::Type type_6801f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::CompositeCandidateRefVector>"), type_6801);
  ::Reflex::Type type_6802f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::ParticleRefVector>"), type_6802);
  ::Reflex::Type type_6803f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::METRefVector>"), type_6803);
  ::Reflex::Type type_6804f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::JetRefVector>"), type_6804);
  ::Reflex::Type type_6805f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::PhotonRefVector>"), type_6805);
  ::Reflex::Type type_6806f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::TauRefVector>"), type_6806);
  ::Reflex::Type type_6807f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::MuonRefVector>"), type_6807);
  ::Reflex::Type type_6808f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<pat::ElectronRefVector>"), type_6808);
  ::Reflex::Type type_7115f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::AtomicPtrCache<std::vector<reco::PFCandidatePtr> >"), type_7115);
  ::Reflex::Type type_7118f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::AtomicPtrCache<reco::TrackRefVector>"), type_7118);
  ::Reflex::Type type_7221f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::RefProd<pat::PackedCandidateCollection>"), type_7221);
  ::Reflex::Type type_7358f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Association<pat::PackedCandidateCollection>"), type_7358);
  ::Reflex::Type type_40424f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolder<pat::CompositeCandidateRefVector>"), type_40424);
  ::Reflex::Type type_40426f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<pat::GenericParticleRef>"), type_40426);
  ::Reflex::Type type_40427f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<pat::PFParticleRef>"), type_40427);
  ::Reflex::Type type_40428f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<pat::CompositeCandidateRef>"), type_40428);
  ::Reflex::Type type_40429f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<pat::ParticleRef>"), type_40429);
  ::Reflex::Type type_40430f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<pat::METRef>"), type_40430);
  ::Reflex::Type type_40431f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<pat::JetRef>"), type_40431);
  ::Reflex::Type type_40432f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<pat::PhotonRef>"), type_40432);
  ::Reflex::Type type_40433f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<pat::TauRef>"), type_40433);
  ::Reflex::Type type_40434f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<pat::MuonRef>"), type_40434);
  ::Reflex::Type type_40435f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<pat::ElectronRef>"), type_40435);
  ::Reflex::Type type_40439f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::VectorHolder<reco::Candidate, pat::CompositeCandidateRefVector>"), type_40439);
  ::Reflex::Type type_40443f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate, pat::GenericParticleRef>"), type_40443);
  ::Reflex::Type type_40444f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate, pat::PFParticleRef>"), type_40444);
  ::Reflex::Type type_40445f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate, pat::CompositeCandidateRef>"), type_40445);
  ::Reflex::Type type_40446f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate, pat::ParticleRef>"), type_40446);
  ::Reflex::Type type_40447f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate, pat::METRef>"), type_40447);
  ::Reflex::Type type_40448f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate, pat::JetRef>"), type_40448);
  ::Reflex::Type type_40449f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate, pat::PhotonRef>"), type_40449);
  ::Reflex::Type type_40450f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate, pat::TauRef>"), type_40450);
  ::Reflex::Type type_40451f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate, pat::MuonRef>"), type_40451);
  ::Reflex::Type type_40452f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate, pat::ElectronRef>"), type_40452);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __pat__PackedGenParticle
#undef __pat__PackedGenParticle
#endif
class __pat__PackedGenParticle : public ::reco::Candidate {
  public:
  __pat__PackedGenParticle();
  virtual ~__pat__PackedGenParticle() throw();
  ::uint16_t packedPt_;
  ::uint16_t packedEta_;
  ::uint16_t packedPhi_;
  ::uint16_t packedM_;
  ::math::PtEtaPhiMLorentzVector p4_;
  ::math::XYZTLorentzVector p4c_;
  ::math::XYZPoint vertex_;
  float dxy_;
  float dz_;
  float dphi_;
  int pdgId_;
  ::int8_t charge_;
  ::reco::GenParticleRef mother_;
  bool unpacked_;
};
#ifdef __std__vector_pat__PackedGenParticle_
#undef __std__vector_pat__PackedGenParticle_
#endif
class __std__vector_pat__PackedGenParticle_ : protected ::std::_Vector_base<pat::PackedGenParticle,std::allocator<pat::PackedGenParticle> > {
  public:
  __std__vector_pat__PackedGenParticle_();
};
#ifdef __pat__PackedCandidate
#undef __pat__PackedCandidate
#endif
class __pat__PackedCandidate : public ::reco::Candidate {
  public:
  __pat__PackedCandidate();
  virtual ~__pat__PackedCandidate() throw();
#ifdef __pat__PackedCandidate__qualityFlagsShiftsAndMasks
#undef __pat__PackedCandidate__qualityFlagsShiftsAndMasks
#endif
  enum __pat__PackedCandidate__qualityFlagsShiftsAndMasks {};
  ::uint16_t packedPt_;
  ::uint16_t packedEta_;
  ::uint16_t packedPhi_;
  ::uint16_t packedM_;
  ::uint16_t packedDxy_;
  ::uint16_t packedDz_;
  ::uint16_t packedDPhi_;
  ::uint16_t packedCovarianceDxyDxy_;
  ::uint16_t packedCovarianceDxyDz_;
  ::uint16_t packedCovarianceDzDz_;
  ::int8_t packedCovarianceDlambdaDz_;
  ::int8_t packedCovarianceDphiDxy_;
  ::int8_t packedCovarianceDptDpt_;
  ::int8_t packedCovarianceDetaDeta_;
  ::int8_t packedCovarianceDphiDphi_;
  ::math::PtEtaPhiMLorentzVector p4_;
  ::math::XYZTLorentzVector p4c_;
  ::math::XYZPoint vertex_;
  float dxy_;
  float dz_;
  float dphi_;
  int pdgId_;
  ::uint16_t qualityFlags_;
  ::edm::Ref<std::vector<reco::Vertex>,reco::Vertex,edm::refhelper::FindUsingAdvance<std::vector<reco::Vertex>,reco::Vertex> > pvRef_;
  bool unpacked_;
  bool unpackedVtx_;
  float dxydxy_;
  float dzdz_;
  float dxydz_;
  float dlambdadz_;
  float dphidxy_;
  float dptdpt_;
  float detadeta_;
  float dphidphi_;
  ::uint8_t packedHits_;
  ::uint8_t normalizedChi2_;
};
#ifdef __std__vector_pat__PackedCandidate_
#undef __std__vector_pat__PackedCandidate_
#endif
class __std__vector_pat__PackedCandidate_ : protected ::std::_Vector_base<pat::PackedCandidate,std::allocator<pat::PackedCandidate> > {
  public:
  __std__vector_pat__PackedCandidate_();
};
#ifdef __pat__Conversion
#undef __pat__Conversion
#endif
class __pat__Conversion {
  public:
  __pat__Conversion();
  virtual ~__pat__Conversion() throw();
  double vtxProb_;
  double lxy_;
  int nHitsMax_;
  int index_;
};
#ifdef __std__vector_pat__Conversion_
#undef __std__vector_pat__Conversion_
#endif
class __std__vector_pat__Conversion_ : protected ::std::_Vector_base<pat::Conversion,std::allocator<pat::Conversion> > {
  public:
  __std__vector_pat__Conversion_();
};
#ifdef __pat__Hemisphere
#undef __pat__Hemisphere
#endif
class __pat__Hemisphere : public ::reco::CompositePtrCandidate {
  public:
  __pat__Hemisphere();
  virtual ~__pat__Hemisphere() throw();
};
#ifdef __std__vector_pat__Hemisphere_
#undef __std__vector_pat__Hemisphere_
#endif
class __std__vector_pat__Hemisphere_ : protected ::std::_Vector_base<pat::Hemisphere,std::allocator<pat::Hemisphere> > {
  public:
  __std__vector_pat__Hemisphere_();
};
#ifdef __pat__GenericParticle
#undef __pat__GenericParticle
#endif
class __pat__GenericParticle : public ::pat::PATObject<reco::RecoCandidate> {
  public:
  __pat__GenericParticle();
  virtual ~__pat__GenericParticle() throw();
  virtual ::reco::TrackRef track() const throw();
  virtual ::reco::TrackRef combinedMuon() const throw();
  virtual ::pat::GenericParticle* clone() const throw();
  virtual void setGsfTrack(edm::Ref<std::vector<reco::GsfTrack, std::allocator<reco::GsfTrack> >, reco::GsfTrack, edm::refhelper::FindUsingAdvance<std::vector<reco::GsfTrack, std::allocator<reco::GsfTrack> >, reco::GsfTrack> > const&, bool) throw();
  virtual void setCaloTower(edm::Ref<edm::SortedCollection<CaloTower, edm::StrictWeakOrdering<CaloTower> >, CaloTower, edm::refhelper::FindUsingAdvance<edm::SortedCollection<CaloTower, edm::StrictWeakOrdering<CaloTower> >, CaloTower> > const&, bool) throw();
  virtual ::size_t numberOfTracks() const throw();
  virtual ::reco::GsfTrackRef gsfTrack() const throw();
  virtual void setTrack(edm::Ref<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track, edm::refhelper::FindUsingAdvance<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track> > const&, bool) throw();
  virtual ::CaloTowerRef caloTower() const throw();
  virtual void setCombinedMuon(edm::Ref<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track, edm::refhelper::FindUsingAdvance<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track> > const&, bool) throw();
  virtual ::reco::SuperClusterRef superCluster() const throw();
  virtual ::reco::TrackRef standAloneMuon() const throw();
  virtual ::reco::TrackRef track(unsigned long) const throw();
  virtual void setTracks(edm::RefVector<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track, edm::refhelper::FindUsingAdvance<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track> > const&, bool) throw();
  virtual void setStandAloneMuon(edm::Ref<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track, edm::refhelper::FindUsingAdvance<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track> > const&, bool) throw();
  virtual void setSuperCluster(edm::Ref<std::vector<reco::SuperCluster, std::allocator<reco::SuperCluster> >, reco::SuperCluster, edm::refhelper::FindUsingAdvance<std::vector<reco::SuperCluster, std::allocator<reco::SuperCluster> >, reco::SuperCluster> > const&, bool) throw();
  virtual bool overlap(reco::Candidate const&) const throw();
  ::reco::TrackRef trackRef_;
  ::reco::TrackRef standaloneTrackRef_;
  ::reco::TrackRef combinedTrackRef_;
  ::reco::TrackCollection track_;
  ::reco::TrackCollection standaloneTrack_;
  ::reco::TrackCollection combinedTrack_;
  ::reco::GsfTrackRef gsfTrackRef_;
  ::reco::GsfTrackCollection gsfTrack_;
  ::CaloTowerRef caloTowerRef_;
  ::CaloTowerCollection caloTower_;
  ::reco::SuperClusterRef superClusterRef_;
  ::reco::SuperClusterCollection superCluster_;
  ::reco::TrackRefVector trackRefs_;
  ::reco::TrackCollection tracks_;
  float quality_;
  ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > isoDeposits_;
  ::std::vector<float> isolations_;
  ::std::vector<pat::VertexAssociation> vtxAss_;
};
#ifdef __std__vector_pat__GenericParticle_
#undef __std__vector_pat__GenericParticle_
#endif
class __std__vector_pat__GenericParticle_ : protected ::std::_Vector_base<pat::GenericParticle,std::allocator<pat::GenericParticle> > {
  public:
  __std__vector_pat__GenericParticle_();
};
#ifdef __pat__PFParticle
#undef __pat__PFParticle
#endif
class __pat__PFParticle : public ::pat::PATObject<reco::PFCandidate> {
  public:
  __pat__PFParticle();
  virtual ~__pat__PFParticle() throw();
  virtual ::pat::PFParticle* clone() const throw();
};
#ifdef __std__vector_pat__PFParticle_
#undef __std__vector_pat__PFParticle_
#endif
class __std__vector_pat__PFParticle_ : protected ::std::_Vector_base<pat::PFParticle,std::allocator<pat::PFParticle> > {
  public:
  __std__vector_pat__PFParticle_();
};
#ifdef __pat__CompositeCandidate
#undef __pat__CompositeCandidate
#endif
class __pat__CompositeCandidate : public ::pat::PATObject<reco::CompositeCandidate> {
  public:
  __pat__CompositeCandidate();
  virtual ~__pat__CompositeCandidate() throw();
  virtual ::pat::CompositeCandidate* clone() const throw();
};
#ifdef __std__vector_pat__CompositeCandidate_
#undef __std__vector_pat__CompositeCandidate_
#endif
class __std__vector_pat__CompositeCandidate_ : protected ::std::_Vector_base<pat::CompositeCandidate,std::allocator<pat::CompositeCandidate> > {
  public:
  __std__vector_pat__CompositeCandidate_();
};
#ifdef __pat__Particle
#undef __pat__Particle
#endif
class __pat__Particle : public ::pat::PATObject<reco::LeafCandidate> {
  public:
  __pat__Particle();
  virtual ~__pat__Particle() throw();
  virtual ::pat::Particle* clone() const throw();
};
#ifdef __std__vector_pat__Particle_
#undef __std__vector_pat__Particle_
#endif
class __std__vector_pat__Particle_ : protected ::std::_Vector_base<pat::Particle,std::allocator<pat::Particle> > {
  public:
  __std__vector_pat__Particle_();
};
#ifdef __pat__MET
#undef __pat__MET
#endif
class __pat__MET : public ::pat::PATObject<reco::MET> {
  public:
  __pat__MET();
  virtual ~__pat__MET() throw();
  virtual ::pat::MET* clone() const throw();
  ::std::vector<reco::GenMET> genMET_;
  ::std::vector<SpecificCaloMETData> caloMET_;
  ::std::vector<SpecificPFMETData> pfMET_;
  void* uncorInfo_;
  unsigned int nCorrections_;
  ::std::vector<pat::MET::PackedMETUncertainty> uncertaintiesRaw_;
  ::std::vector<pat::MET::PackedMETUncertainty> uncertaintiesType1_;
  ::std::vector<pat::MET::PackedMETUncertainty> uncertaintiesType1p2_;
};
#ifdef __std__vector_pat__MET_
#undef __std__vector_pat__MET_
#endif
class __std__vector_pat__MET_ : protected ::std::_Vector_base<pat::MET,std::allocator<pat::MET> > {
  public:
  __std__vector_pat__MET_();
};
#ifdef __pat__Jet
#undef __pat__Jet
#endif
class __pat__Jet : public ::pat::PATObject<reco::Jet> {
  public:
  __pat__Jet();
  virtual ~__pat__Jet() throw();
  virtual ::pat::Jet* clone() const throw();
  virtual const ::reco::Candidate* daughter(unsigned long) const throw();
  virtual ::size_t numberOfDaughters() const throw();
  bool embeddedCaloTowers_;
  ::edm::AtomicPtrCache<std::vector<edm::Ptr<CaloTower> > > caloTowersTemp_;
  ::CaloTowerCollection caloTowers_;
  ::CaloTowerFwdPtrVector caloTowersFwdPtr_;
  bool embeddedPFCandidates_;
  ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > pfCandidatesTemp_;
  ::reco::PFCandidateCollection pfCandidates_;
  ::reco::PFCandidateFwdPtrVector pfCandidatesFwdPtr_;
  ::std::vector<reco::GenJet> genJet_;
  ::reco::GenJetRefVector genJetRef_;
  ::edm::FwdRef<std::vector<reco::GenJet>,reco::GenJet,edm::refhelper::FindUsingAdvance<std::vector<reco::GenJet>,reco::GenJet> > genJetFwdRef_;
  ::reco::JetFlavourInfo jetFlavourInfo_;
  ::std::vector<pat::JetCorrFactors> jec_;
  unsigned int currentJECSet_;
  unsigned int currentJECLevel_;
  ::pat::JetCorrFactors::Flavor currentJECFlavor_;
  ::std::vector<std::pair<std::basic_string<char>,float> > pairDiscriVector_;
  ::std::vector<std::basic_string<char> > tagInfoLabels_;
  ::edm::OwnVector<reco::BaseTagInfo,edm::ClonePolicy<reco::BaseTagInfo> > tagInfos_;
  ::pat::TagInfoFwdPtrCollection tagInfosFwdPtr_;
  float jetCharge_;
  ::reco::TrackRefVector associatedTracks_;
  ::std::vector<reco::CaloJet::Specific> specificCalo_;
  ::std::vector<reco::JPTJet::Specific> specificJPT_;
  ::std::vector<reco::PFJet::Specific> specificPF_;
  ::reco::JetID jetID_;
};
#ifdef __std__vector_pat__Jet_
#undef __std__vector_pat__Jet_
#endif
class __std__vector_pat__Jet_ : protected ::std::_Vector_base<pat::Jet,std::allocator<pat::Jet> > {
  public:
  __std__vector_pat__Jet_();
};
#ifdef __pat__Photon
#undef __pat__Photon
#endif
class __pat__Photon : public ::pat::PATObject<reco::Photon> {
  public:
  __pat__Photon();
  virtual ~__pat__Photon() throw();
  virtual ::size_t numberOfSourceCandidatePtrs() const throw();
  virtual ::reco::CandidatePtr sourceCandidatePtr(unsigned long) const throw();
  virtual ::pat::Photon* clone() const throw();
  virtual ::reco::SuperClusterRef superCluster() const throw();
  bool embeddedSuperCluster_;
  ::std::vector<reco::SuperCluster> superCluster_;
  ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> > superClusterRelinked_;
  ::std::vector<reco::CaloCluster> basicClusters_;
  ::std::vector<reco::CaloCluster> preshowerClusters_;
  bool embeddedSeedCluster_;
  ::std::vector<reco::CaloCluster> seedCluster_;
  bool embeddedRecHits_;
  ::EcalRecHitCollection recHits_;
  ::std::vector<std::pair<std::basic_string<char>,bool> > photonIDs_;
  ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > isoDeposits_;
  ::std::vector<float> isolations_;
  ::edm::RefProd<std::vector<pat::PackedCandidate> > packedPFCandidates_;
  ::std::vector<unsigned short> associatedPackedFCandidateIndices_;
  ::reco::Photon::ShowerShape full5x5_showerShape_;
  bool passElectronVeto_;
  bool hasPixelSeed_;
  float seedEnergy_;
  float eMax_;
  float e2nd_;
  float e3x3_;
  float eTop_;
  float eBottom_;
  float eLeft_;
  float eRight_;
  float see_;
  float spp_;
  float sep_;
  float maxDR_;
  float maxDRDPhi_;
  float maxDRDEta_;
  float maxDRRawEnergy_;
  float subClusRawE1_;
  float subClusRawE2_;
  float subClusRawE3_;
  float subClusDPhi1_;
  float subClusDPhi2_;
  float subClusDPhi3_;
  float subClusDEta1_;
  float subClusDEta2_;
  float subClusDEta3_;
  float cryEta_;
  float cryPhi_;
  float iEta_;
  float iPhi_;
};
#ifdef __std__vector_pat__Photon_
#undef __std__vector_pat__Photon_
#endif
class __std__vector_pat__Photon_ : protected ::std::_Vector_base<pat::Photon,std::allocator<pat::Photon> > {
  public:
  __std__vector_pat__Photon_();
};
#ifdef __pat__Tau
#undef __pat__Tau
#endif
class __pat__Tau : public ::pat::Lepton<reco::BaseTau> {
  public:
  __pat__Tau();
  virtual ~__pat__Tau() throw();
  virtual ::pat::Tau* clone() const throw();
  virtual const ::reco::TrackRefVector& isolationTracks() const throw();
  virtual const ::reco::TrackRefVector& signalTracks() const throw();
  virtual ::size_t numberOfSourceCandidatePtrs() const throw();
  virtual ::reco::CandidatePtr sourceCandidatePtr(unsigned long) const throw();
  virtual ::reco::TrackRef leadTrack() const throw();
  bool embeddedIsolationTracks_;
  ::std::vector<reco::Track> isolationTracks_;
  ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > > isolationTracksTransientRefVector_;
  bool embeddedLeadTrack_;
  ::std::vector<reco::Track> leadTrack_;
  bool embeddedSignalTracks_;
  ::std::vector<reco::Track> signalTracks_;
  ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > > signalTracksTransientRefVector_;
  ::std::vector<reco::PFCandidate> leadPFCand_;
  bool embeddedLeadPFCand_;
  ::std::vector<reco::PFCandidate> leadPFChargedHadrCand_;
  bool embeddedLeadPFChargedHadrCand_;
  ::std::vector<reco::PFCandidate> leadPFNeutralCand_;
  bool embeddedLeadPFNeutralCand_;
  ::std::vector<reco::PFCandidate> signalPFCands_;
  bool embeddedSignalPFCands_;
  ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > signalPFCandsTransientPtrs_;
  ::std::vector<reco::PFCandidate> signalPFChargedHadrCands_;
  bool embeddedSignalPFChargedHadrCands_;
  ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > signalPFChargedHadrCandsTransientPtrs_;
  ::std::vector<reco::PFCandidate> signalPFNeutralHadrCands_;
  bool embeddedSignalPFNeutralHadrCands_;
  ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > signalPFNeutralHadrCandsTransientPtrs_;
  ::std::vector<reco::PFCandidate> signalPFGammaCands_;
  bool embeddedSignalPFGammaCands_;
  ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > signalPFGammaCandsTransientPtrs_;
  ::std::vector<reco::PFCandidate> isolationPFCands_;
  bool embeddedIsolationPFCands_;
  ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > isolationPFCandsTransientPtrs_;
  ::std::vector<reco::PFCandidate> isolationPFChargedHadrCands_;
  bool embeddedIsolationPFChargedHadrCands_;
  ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > isolationPFChargedHadrCandsTransientPtrs_;
  ::std::vector<reco::PFCandidate> isolationPFNeutralHadrCands_;
  bool embeddedIsolationPFNeutralHadrCands_;
  ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > isolationPFNeutralHadrCandsTransientPtrs_;
  ::std::vector<reco::PFCandidate> isolationPFGammaCands_;
  bool embeddedIsolationPFGammaCands_;
  ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > isolationPFGammaCandsTransientPtrs_;
  ::std::vector<reco::GenJet> genJet_;
  ::std::vector<std::pair<std::basic_string<char>,float> > tauIDs_;
  ::std::vector<pat::tau::TauPFSpecific> pfSpecific_;
  ::std::vector<pat::tau::TauCaloSpecific> caloSpecific_;
  ::std::vector<pat::TauJetCorrFactors> jec_;
  unsigned int currentJECSet_;
  unsigned int currentJECLevel_;
  ::reco::CandidatePtrVector signalChargedHadrCandPtrs_;
  ::reco::CandidatePtrVector signalNeutralHadrCandPtrs_;
  ::reco::CandidatePtrVector signalGammaCandPtrs_;
  ::reco::CandidatePtrVector isolationChargedHadrCandPtrs_;
  ::reco::CandidatePtrVector isolationNeutralHadrCandPtrs_;
  ::reco::CandidatePtrVector isolationGammaCandPtrs_;
  ::std::vector<pat::tau::TauPFEssential> pfEssential_;
};
#ifdef __std__vector_pat__Tau_
#undef __std__vector_pat__Tau_
#endif
class __std__vector_pat__Tau_ : protected ::std::_Vector_base<pat::Tau,std::allocator<pat::Tau> > {
  public:
  __std__vector_pat__Tau_();
};
#ifdef __pat__Muon
#undef __pat__Muon
#endif
class __pat__Muon : public ::pat::Lepton<reco::Muon> {
  public:
  __pat__Muon();
  virtual ~__pat__Muon() throw();
  virtual ::reco::TrackRef track() const throw();
  virtual ::reco::TrackRef combinedMuon() const throw();
  virtual ::pat::Muon* clone() const throw();
  virtual ::reco::TrackRef tpfmsTrack() const throw();
  virtual ::reco::CandidatePtr sourceCandidatePtr(unsigned long) const throw();
  virtual ::reco::TrackRef globalTrack() const throw();
  virtual ::size_t numberOfSourceCandidatePtrs() const throw();
  virtual ::reco::TrackRef tunePMuonBestTrack() const throw();
  virtual ::reco::TrackRef outerTrack() const throw();
  virtual const ::reco::Track* bestTrack() const throw();
  virtual ::reco::TrackRef innerTrack() const throw();
  virtual ::reco::TrackRef dytTrack() const throw();
  virtual ::reco::TrackRef standAloneMuon() const throw();
  virtual ::reco::TrackRef muonBestTrack() const throw();
  virtual ::reco::TrackRef pickyTrack() const throw();
  bool embeddedMuonBestTrack_;
  ::std::vector<reco::Track> muonBestTrack_;
  bool embeddedTunePMuonBestTrack_;
  ::std::vector<reco::Track> tunePMuonBestTrack_;
  bool embeddedTrack_;
  ::std::vector<reco::Track> track_;
  bool embeddedStandAloneMuon_;
  ::std::vector<reco::Track> standAloneMuon_;
  bool embeddedCombinedMuon_;
  ::std::vector<reco::Track> combinedMuon_;
  bool embeddedTCMETMuonCorrs_;
  ::std::vector<reco::MuonMETCorrectionData> tcMETMuonCorrs_;
  bool embeddedCaloMETMuonCorrs_;
  ::std::vector<reco::MuonMETCorrectionData> caloMETMuonCorrs_;
  bool embeddedPickyMuon_;
  bool embeddedTpfmsMuon_;
  bool embeddedDytMuon_;
  ::std::vector<reco::Track> pickyMuon_;
  ::std::vector<reco::Track> tpfmsMuon_;
  ::std::vector<reco::Track> dytMuon_;
  bool embeddedPFCandidate_;
  ::reco::PFCandidateCollection pfCandidate_;
  ::reco::PFCandidateRef pfCandidateRef_;
  bool cachedNormChi2_;
  bool cachedDB_;
  bool cachedNumberOfValidHits_;
  double normChi2_;
  double dB_;
  double edB_;
  ::std::vector<bool> cachedIP_;
  ::std::vector<double> ip_;
  ::std::vector<double> eip_;
  unsigned int numberOfValidHits_;
};
#ifdef __std__vector_pat__Muon_
#undef __std__vector_pat__Muon_
#endif
class __std__vector_pat__Muon_ : protected ::std::_Vector_base<pat::Muon,std::allocator<pat::Muon> > {
  public:
  __std__vector_pat__Muon_();
};
#ifdef __pat__Electron
#undef __pat__Electron
#endif
class __pat__Electron : public ::pat::Lepton<reco::GsfElectron> {
  public:
  __pat__Electron();
  virtual ~__pat__Electron() throw();
  virtual ::reco::TrackRef track() const throw();
  virtual ::pat::Electron* clone() const throw();
  virtual ::size_t numberOfSourceCandidatePtrs() const throw();
  virtual ::reco::GsfElectronCoreRef core() const throw();
  virtual ::reco::SuperClusterRef superCluster() const throw();
  virtual ::reco::CandidatePtr sourceCandidatePtr(unsigned long) const throw();
  virtual ::reco::GsfTrackRef gsfTrack() const throw();
  bool embeddedGsfElectronCore_;
  ::std::vector<reco::GsfElectronCore> gsfElectronCore_;
  bool embeddedGsfTrack_;
  ::std::vector<reco::GsfTrack> gsfTrack_;
  bool embeddedSuperCluster_;
  bool embeddedPflowSuperCluster_;
  ::std::vector<reco::SuperCluster> superCluster_;
  ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> > superClusterRelinked_;
  ::std::vector<reco::CaloCluster> basicClusters_;
  ::std::vector<reco::CaloCluster> preshowerClusters_;
  ::std::vector<reco::CaloCluster> pflowBasicClusters_;
  ::std::vector<reco::CaloCluster> pflowPreshowerClusters_;
  ::std::vector<reco::SuperCluster> pflowSuperCluster_;
  bool embeddedTrack_;
  ::std::vector<reco::Track> track_;
  bool embeddedSeedCluster_;
  ::std::vector<reco::CaloCluster> seedCluster_;
  bool embeddedRecHits_;
  ::EcalRecHitCollection recHits_;
  ::std::vector<std::pair<std::basic_string<char>,float> > electronIDs_;
  bool isPF_;
  bool embeddedPFCandidate_;
  ::reco::PFCandidateCollection pfCandidate_;
  ::reco::PFCandidateRef pfCandidateRef_;
  ::math::XYZTLorentzVector ecalDrivenMomentum_;
  bool cachedDB_;
  double dB_;
  double edB_;
  float sigmaIetaIphi_;
  float full5x5_sigmaIetaIphi_;
  double ip3d_;
  double ecalRegressionEnergy_;
  double ecalTrackRegressionEnergy_;
  double ecalRegressionError_;
  double ecalTrackRegressionError_;
  double ecalScale_;
  double ecalSmear_;
  double ecalRegressionScale_;
  double ecalRegressionSmear_;
  double ecalTrackRegressionScale_;
  double ecalTrackRegressionSmear_;
  ::reco::GsfElectron::ShowerShape full5x5_showerShape_;
  bool passConversionVeto_;
  ::std::vector<bool> cachedIP_;
  ::std::vector<double> ip_;
  ::std::vector<double> eip_;
  ::edm::RefProd<std::vector<pat::PackedCandidate> > packedPFCandidates_;
  ::std::vector<unsigned short> associatedPackedFCandidateIndices_;
};
#ifdef __std__vector_pat__Electron_
#undef __std__vector_pat__Electron_
#endif
class __std__vector_pat__Electron_ : protected ::std::_Vector_base<pat::Electron,std::allocator<pat::Electron> > {
  public:
  __std__vector_pat__Electron_();
};
#ifdef __pat__MHT
#undef __pat__MHT
#endif
class __pat__MHT : public ::reco::CompositeRefBaseCandidate {
  public:
  __pat__MHT();
  virtual ~__pat__MHT() throw();
  double ht_;
  double significance_;
  double number_of_jets_;
  double number_of_electrons_;
  double number_of_muons_;
};
#ifdef __std__vector_pat__MHT_
#undef __std__vector_pat__MHT_
#endif
class __std__vector_pat__MHT_ : protected ::std::_Vector_base<pat::MHT,std::allocator<pat::MHT> > {
  public:
  __std__vector_pat__MHT_();
};
#ifdef __pat__MET__PackedMETUncertainty
#undef __pat__MET__PackedMETUncertainty
#endif
class __pat__MET__PackedMETUncertainty {
  public:
  __pat__MET__PackedMETUncertainty();
  float dpx_;
  float dpy_;
  float dsumEt_;
};
#ifdef __std__vector_pat__MET__PackedMETUncertainty_
#undef __std__vector_pat__MET__PackedMETUncertainty_
#endif
class __std__vector_pat__MET__PackedMETUncertainty_ : protected ::std::_Vector_base<pat::MET::PackedMETUncertainty,std::allocator<pat::MET::PackedMETUncertainty> > {
  public:
  __std__vector_pat__MET__PackedMETUncertainty_();
};
#ifdef __pat__tau__TauPFSpecific
#undef __pat__tau__TauPFSpecific
#endif
struct __pat__tau__TauPFSpecific {
  public:
  __pat__tau__TauPFSpecific();
  ::reco::PFJetRef pfJetRef_;
  ::reco::PFCandidatePtr leadPFChargedHadrCand_;
  float leadPFChargedHadrCandsignedSipt_;
  ::reco::PFCandidatePtr leadPFNeutralCand_;
  ::reco::PFCandidatePtr leadPFCand_;
  ::std::vector<edm::Ptr<reco::PFCandidate> > selectedSignalPFCands_;
  ::std::vector<edm::Ptr<reco::PFCandidate> > selectedSignalPFChargedHadrCands_;
  ::std::vector<edm::Ptr<reco::PFCandidate> > selectedSignalPFNeutrHadrCands_;
  ::std::vector<edm::Ptr<reco::PFCandidate> > selectedSignalPFGammaCands_;
  ::std::vector<reco::PFRecoTauChargedHadron> signalTauChargedHadronCandidates_;
  ::std::vector<reco::RecoTauPiZero> signalPiZeroCandidates_;
  ::std::vector<edm::Ptr<reco::PFCandidate> > selectedIsolationPFCands_;
  ::std::vector<edm::Ptr<reco::PFCandidate> > selectedIsolationPFChargedHadrCands_;
  ::std::vector<edm::Ptr<reco::PFCandidate> > selectedIsolationPFNeutrHadrCands_;
  ::std::vector<edm::Ptr<reco::PFCandidate> > selectedIsolationPFGammaCands_;
  ::std::vector<reco::PFRecoTauChargedHadron> isolationTauChargedHadronCandidates_;
  ::std::vector<reco::RecoTauPiZero> isolationPiZeroCandidates_;
  float isolationPFChargedHadrCandsPtSum_;
  float isolationPFGammaCandsEtSum_;
  float maximumHCALPFClusterEt_;
  float emFraction_;
  float hcalTotOverPLead_;
  float hcalMaxOverPLead_;
  float hcal3x3OverPLead_;
  float ecalStripSumEOverPLead_;
  float bremsRecoveryEOverPLead_;
  ::reco::TrackRef electronPreIDTrack_;
  float electronPreIDOutput_;
  bool electronPreIDDecision_;
  float caloComp_;
  float segComp_;
  bool muonDecision_;
  float etaetaMoment_;
  float phiphiMoment_;
  float etaphiMoment_;
};
#ifdef __std__vector_pat__tau__TauPFSpecific_
#undef __std__vector_pat__tau__TauPFSpecific_
#endif
class __std__vector_pat__tau__TauPFSpecific_ : protected ::std::_Vector_base<pat::tau::TauPFSpecific,std::allocator<pat::tau::TauPFSpecific> > {
  public:
  __std__vector_pat__tau__TauPFSpecific_();
};
#ifdef __pat__tau__TauCaloSpecific
#undef __pat__tau__TauCaloSpecific
#endif
struct __pat__tau__TauCaloSpecific {
  public:
  __pat__tau__TauCaloSpecific();
  ::reco::CaloTauTagInfoRef CaloTauTagInfoRef_;
  float leadTracksignedSipt_;
  float leadTrackHCAL3x3hitsEtSum_;
  float leadTrackHCAL3x3hottesthitDEta_;
  float signalTracksInvariantMass_;
  float TracksInvariantMass_;
  float isolationTracksPtSum_;
  float isolationECALhitsEtSum_;
  float maximumHCALhitEt_;
  ::math::XYZTLorentzVector p4Jet_;
  float etaetaMoment_;
  float phiphiMoment_;
  float etaphiMoment_;
};
#ifdef __std__vector_pat__tau__TauCaloSpecific_
#undef __std__vector_pat__tau__TauCaloSpecific_
#endif
class __std__vector_pat__tau__TauCaloSpecific_ : protected ::std::_Vector_base<pat::tau::TauCaloSpecific,std::allocator<pat::tau::TauCaloSpecific> > {
  public:
  __std__vector_pat__tau__TauCaloSpecific_();
};
#ifdef __pat__tau__TauPFEssential
#undef __pat__tau__TauPFEssential
#endif
struct __pat__tau__TauPFEssential {
  public:
  __pat__tau__TauPFEssential();
  ::math::XYZTLorentzVector p4Jet_;
  ::math::XYZTLorentzVector p4CorrJet_;
  int decayMode_;
  ::math::XYZPoint dxy_PCA_;
  double dxy_;
  double dxy_error_;
  double dxy_Sig_;
  ::reco::VertexRef pv_;
  ::math::XYZPoint pvPos_;
  ::ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > pvCov_;
  bool hasSV_;
  ::math::XYZVector flightLength_;
  double flightLengthSig_;
  ::reco::VertexRef sv_;
  ::math::XYZPoint svPos_;
  ::ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > svCov_;
};
#ifdef __std__vector_pat__tau__TauPFEssential_
#undef __std__vector_pat__tau__TauPFEssential_
#endif
class __std__vector_pat__tau__TauPFEssential_ : protected ::std::_Vector_base<pat::tau::TauPFEssential,std::allocator<pat::tau::TauPFEssential> > {
  public:
  __std__vector_pat__tau__TauPFEssential_();
};
#ifdef __edm__Wrapper_std__vector_pat__PackedGenParticle_s_
#undef __edm__Wrapper_std__vector_pat__PackedGenParticle_s_
#endif
class __edm__Wrapper_std__vector_pat__PackedGenParticle_s_ {
  public:
  __edm__Wrapper_std__vector_pat__PackedGenParticle_s_();
  bool present;
  ::std::vector<pat::PackedGenParticle> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__PackedCandidate_s_
#undef __edm__Wrapper_std__vector_pat__PackedCandidate_s_
#endif
class __edm__Wrapper_std__vector_pat__PackedCandidate_s_ {
  public:
  __edm__Wrapper_std__vector_pat__PackedCandidate_s_();
  bool present;
  ::std::vector<pat::PackedCandidate> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__Conversion_s_
#undef __edm__Wrapper_std__vector_pat__Conversion_s_
#endif
class __edm__Wrapper_std__vector_pat__Conversion_s_ {
  public:
  __edm__Wrapper_std__vector_pat__Conversion_s_();
  bool present;
  ::std::vector<pat::Conversion> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__Hemisphere_s_
#undef __edm__Wrapper_std__vector_pat__Hemisphere_s_
#endif
class __edm__Wrapper_std__vector_pat__Hemisphere_s_ {
  public:
  __edm__Wrapper_std__vector_pat__Hemisphere_s_();
  bool present;
  ::std::vector<pat::Hemisphere> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__GenericParticle_s_
#undef __edm__Wrapper_std__vector_pat__GenericParticle_s_
#endif
class __edm__Wrapper_std__vector_pat__GenericParticle_s_ {
  public:
  __edm__Wrapper_std__vector_pat__GenericParticle_s_();
  bool present;
  ::std::vector<pat::GenericParticle> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__PFParticle_s_
#undef __edm__Wrapper_std__vector_pat__PFParticle_s_
#endif
class __edm__Wrapper_std__vector_pat__PFParticle_s_ {
  public:
  __edm__Wrapper_std__vector_pat__PFParticle_s_();
  bool present;
  ::std::vector<pat::PFParticle> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__CompositeCandidate_s_
#undef __edm__Wrapper_std__vector_pat__CompositeCandidate_s_
#endif
class __edm__Wrapper_std__vector_pat__CompositeCandidate_s_ {
  public:
  __edm__Wrapper_std__vector_pat__CompositeCandidate_s_();
  bool present;
  ::std::vector<pat::CompositeCandidate> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__Particle_s_
#undef __edm__Wrapper_std__vector_pat__Particle_s_
#endif
class __edm__Wrapper_std__vector_pat__Particle_s_ {
  public:
  __edm__Wrapper_std__vector_pat__Particle_s_();
  bool present;
  ::std::vector<pat::Particle> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__MHT_s_
#undef __edm__Wrapper_std__vector_pat__MHT_s_
#endif
class __edm__Wrapper_std__vector_pat__MHT_s_ {
  public:
  __edm__Wrapper_std__vector_pat__MHT_s_();
  bool present;
  ::std::vector<pat::MHT> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__MET_s_
#undef __edm__Wrapper_std__vector_pat__MET_s_
#endif
class __edm__Wrapper_std__vector_pat__MET_s_ {
  public:
  __edm__Wrapper_std__vector_pat__MET_s_();
  bool present;
  ::std::vector<pat::MET> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__Jet_s_
#undef __edm__Wrapper_std__vector_pat__Jet_s_
#endif
class __edm__Wrapper_std__vector_pat__Jet_s_ {
  public:
  __edm__Wrapper_std__vector_pat__Jet_s_();
  bool present;
  ::std::vector<pat::Jet> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__Photon_s_
#undef __edm__Wrapper_std__vector_pat__Photon_s_
#endif
class __edm__Wrapper_std__vector_pat__Photon_s_ {
  public:
  __edm__Wrapper_std__vector_pat__Photon_s_();
  bool present;
  ::std::vector<pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__Tau_s_
#undef __edm__Wrapper_std__vector_pat__Tau_s_
#endif
class __edm__Wrapper_std__vector_pat__Tau_s_ {
  public:
  __edm__Wrapper_std__vector_pat__Tau_s_();
  bool present;
  ::std::vector<pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__Muon_s_
#undef __edm__Wrapper_std__vector_pat__Muon_s_
#endif
class __edm__Wrapper_std__vector_pat__Muon_s_ {
  public:
  __edm__Wrapper_std__vector_pat__Muon_s_();
  bool present;
  ::std::vector<pat::Muon> obj;
};
#ifdef __edm__Wrapper_std__vector_pat__Electron_s_
#undef __edm__Wrapper_std__vector_pat__Electron_s_
#endif
class __edm__Wrapper_std__vector_pat__Electron_s_ {
  public:
  __edm__Wrapper_std__vector_pat__Electron_s_();
  bool present;
  ::std::vector<pat::Electron> obj;
};
#ifdef __edm__AtomicPtrCache_std__vector_reco__SuperCluster_s_
#undef __edm__AtomicPtrCache_std__vector_reco__SuperCluster_s_
#endif
class __edm__AtomicPtrCache_std__vector_reco__SuperCluster_s_ {
  public:
  __edm__AtomicPtrCache_std__vector_reco__SuperCluster_s_();
  void* m_data;
};
#ifdef __edm__Ptr_pat__Tau_
#undef __edm__Ptr_pat__Tau_
#endif
class __edm__Ptr_pat__Tau_ {
  public:
  __edm__Ptr_pat__Tau_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_pat__Muon_
#undef __edm__Ptr_pat__Muon_
#endif
class __edm__Ptr_pat__Muon_ {
  public:
  __edm__Ptr_pat__Muon_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_pat__Conversion_
#undef __edm__Ptr_pat__Conversion_
#endif
class __edm__Ptr_pat__Conversion_ {
  public:
  __edm__Ptr_pat__Conversion_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_pat__Electron_
#undef __edm__Ptr_pat__Electron_
#endif
class __edm__Ptr_pat__Electron_ {
  public:
  __edm__Ptr_pat__Electron_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_pat__MET_
#undef __edm__Ptr_pat__MET_
#endif
class __edm__Ptr_pat__MET_ {
  public:
  __edm__Ptr_pat__MET_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_pat__Jet_
#undef __edm__Ptr_pat__Jet_
#endif
class __edm__Ptr_pat__Jet_ {
  public:
  __edm__Ptr_pat__Jet_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __pat__Lepton_reco__BaseTau_
#undef __pat__Lepton_reco__BaseTau_
#endif
class __pat__Lepton_reco__BaseTau_ : public ::pat::PATObject<reco::BaseTau> {
  public:
  __pat__Lepton_reco__BaseTau_();
  virtual ~__pat__Lepton_reco__BaseTau_() throw();
  virtual ::pat::Lepton<reco::BaseTau>* clone() const throw();
  ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > isoDeposits_;
  ::std::vector<float> isolations_;
};
#ifdef __pat__Lepton_reco__Muon_
#undef __pat__Lepton_reco__Muon_
#endif
class __pat__Lepton_reco__Muon_ : public ::pat::PATObject<reco::Muon> {
  public:
  __pat__Lepton_reco__Muon_();
  virtual ~__pat__Lepton_reco__Muon_() throw();
  virtual ::pat::Lepton<reco::Muon>* clone() const throw();
  ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > isoDeposits_;
  ::std::vector<float> isolations_;
};
#ifdef __pat__Lepton_reco__GsfElectron_
#undef __pat__Lepton_reco__GsfElectron_
#endif
class __pat__Lepton_reco__GsfElectron_ : public ::pat::PATObject<reco::GsfElectron> {
  public:
  __pat__Lepton_reco__GsfElectron_();
  virtual ~__pat__Lepton_reco__GsfElectron_() throw();
  virtual ::pat::Lepton<reco::GsfElectron>* clone() const throw();
  ::std::vector<std::pair<pat::IsolationKeys,reco::IsoDeposit> > isoDeposits_;
  ::std::vector<float> isolations_;
};
#ifdef __pat__PATObject_reco__RecoCandidate_
#undef __pat__PATObject_reco__RecoCandidate_
#endif
class __pat__PATObject_reco__RecoCandidate_ : public ::reco::RecoCandidate {
  public:
  __pat__PATObject_reco__RecoCandidate_();
  virtual ~__pat__PATObject_reco__RecoCandidate_() throw();
  ::edm::Ptr<reco::Candidate> refToOrig_;
  ::std::vector<pat::TriggerObjectStandAlone> triggerObjectMatchesEmbedded_;
  ::std::vector<pat::LookupTableRecord> efficiencyValues_;
  ::std::vector<std::basic_string<char> > efficiencyNames_;
  ::std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > > genParticleRef_;
  ::std::vector<reco::GenParticle> genParticleEmbedded_;
  ::std::vector<std::basic_string<char> > overlapLabels_;
  ::std::vector<edm::PtrVector<reco::Candidate> > overlapItems_;
  ::std::vector<std::basic_string<char> > userDataLabels_;
  ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > userDataObjects_;
  ::std::vector<std::basic_string<char> > userFloatLabels_;
  ::std::vector<float> userFloats_;
  ::std::vector<std::basic_string<char> > userIntLabels_;
  ::std::vector<int> userInts_;
  ::std::vector<std::basic_string<char> > userCandLabels_;
  ::std::vector<edm::Ptr<reco::Candidate> > userCands_;
  ::std::vector<pat::CandKinResolution> kinResolutions_;
  ::std::vector<std::basic_string<char> > kinResolutionLabels_;
};
#ifdef __pat__PATObject_reco__PFCandidate_
#undef __pat__PATObject_reco__PFCandidate_
#endif
class __pat__PATObject_reco__PFCandidate_ : public ::reco::PFCandidate {
  public:
  __pat__PATObject_reco__PFCandidate_();
  virtual ~__pat__PATObject_reco__PFCandidate_() throw();
  ::edm::Ptr<reco::Candidate> refToOrig_;
  ::std::vector<pat::TriggerObjectStandAlone> triggerObjectMatchesEmbedded_;
  ::std::vector<pat::LookupTableRecord> efficiencyValues_;
  ::std::vector<std::basic_string<char> > efficiencyNames_;
  ::std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > > genParticleRef_;
  ::std::vector<reco::GenParticle> genParticleEmbedded_;
  ::std::vector<std::basic_string<char> > overlapLabels_;
  ::std::vector<edm::PtrVector<reco::Candidate> > overlapItems_;
  ::std::vector<std::basic_string<char> > userDataLabels_;
  ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > userDataObjects_;
  ::std::vector<std::basic_string<char> > userFloatLabels_;
  ::std::vector<float> userFloats_;
  ::std::vector<std::basic_string<char> > userIntLabels_;
  ::std::vector<int> userInts_;
  ::std::vector<std::basic_string<char> > userCandLabels_;
  ::std::vector<edm::Ptr<reco::Candidate> > userCands_;
  ::std::vector<pat::CandKinResolution> kinResolutions_;
  ::std::vector<std::basic_string<char> > kinResolutionLabels_;
};
#ifdef __pat__PATObject_reco__CompositeCandidate_
#undef __pat__PATObject_reco__CompositeCandidate_
#endif
class __pat__PATObject_reco__CompositeCandidate_ : public ::reco::CompositeCandidate {
  public:
  __pat__PATObject_reco__CompositeCandidate_();
  virtual ~__pat__PATObject_reco__CompositeCandidate_() throw();
  ::edm::Ptr<reco::Candidate> refToOrig_;
  ::std::vector<pat::TriggerObjectStandAlone> triggerObjectMatchesEmbedded_;
  ::std::vector<pat::LookupTableRecord> efficiencyValues_;
  ::std::vector<std::basic_string<char> > efficiencyNames_;
  ::std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > > genParticleRef_;
  ::std::vector<reco::GenParticle> genParticleEmbedded_;
  ::std::vector<std::basic_string<char> > overlapLabels_;
  ::std::vector<edm::PtrVector<reco::Candidate> > overlapItems_;
  ::std::vector<std::basic_string<char> > userDataLabels_;
  ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > userDataObjects_;
  ::std::vector<std::basic_string<char> > userFloatLabels_;
  ::std::vector<float> userFloats_;
  ::std::vector<std::basic_string<char> > userIntLabels_;
  ::std::vector<int> userInts_;
  ::std::vector<std::basic_string<char> > userCandLabels_;
  ::std::vector<edm::Ptr<reco::Candidate> > userCands_;
  ::std::vector<pat::CandKinResolution> kinResolutions_;
  ::std::vector<std::basic_string<char> > kinResolutionLabels_;
};
#ifdef __pat__PATObject_reco__LeafCandidate_
#undef __pat__PATObject_reco__LeafCandidate_
#endif
class __pat__PATObject_reco__LeafCandidate_ : public ::reco::LeafCandidate {
  public:
  __pat__PATObject_reco__LeafCandidate_();
  virtual ~__pat__PATObject_reco__LeafCandidate_() throw();
  ::edm::Ptr<reco::Candidate> refToOrig_;
  ::std::vector<pat::TriggerObjectStandAlone> triggerObjectMatchesEmbedded_;
  ::std::vector<pat::LookupTableRecord> efficiencyValues_;
  ::std::vector<std::basic_string<char> > efficiencyNames_;
  ::std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > > genParticleRef_;
  ::std::vector<reco::GenParticle> genParticleEmbedded_;
  ::std::vector<std::basic_string<char> > overlapLabels_;
  ::std::vector<edm::PtrVector<reco::Candidate> > overlapItems_;
  ::std::vector<std::basic_string<char> > userDataLabels_;
  ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > userDataObjects_;
  ::std::vector<std::basic_string<char> > userFloatLabels_;
  ::std::vector<float> userFloats_;
  ::std::vector<std::basic_string<char> > userIntLabels_;
  ::std::vector<int> userInts_;
  ::std::vector<std::basic_string<char> > userCandLabels_;
  ::std::vector<edm::Ptr<reco::Candidate> > userCands_;
  ::std::vector<pat::CandKinResolution> kinResolutions_;
  ::std::vector<std::basic_string<char> > kinResolutionLabels_;
};
#ifdef __pat__PATObject_reco__MET_
#undef __pat__PATObject_reco__MET_
#endif
class __pat__PATObject_reco__MET_ : public ::reco::MET {
  public:
  __pat__PATObject_reco__MET_();
  virtual ~__pat__PATObject_reco__MET_() throw();
  ::edm::Ptr<reco::Candidate> refToOrig_;
  ::std::vector<pat::TriggerObjectStandAlone> triggerObjectMatchesEmbedded_;
  ::std::vector<pat::LookupTableRecord> efficiencyValues_;
  ::std::vector<std::basic_string<char> > efficiencyNames_;
  ::std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > > genParticleRef_;
  ::std::vector<reco::GenParticle> genParticleEmbedded_;
  ::std::vector<std::basic_string<char> > overlapLabels_;
  ::std::vector<edm::PtrVector<reco::Candidate> > overlapItems_;
  ::std::vector<std::basic_string<char> > userDataLabels_;
  ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > userDataObjects_;
  ::std::vector<std::basic_string<char> > userFloatLabels_;
  ::std::vector<float> userFloats_;
  ::std::vector<std::basic_string<char> > userIntLabels_;
  ::std::vector<int> userInts_;
  ::std::vector<std::basic_string<char> > userCandLabels_;
  ::std::vector<edm::Ptr<reco::Candidate> > userCands_;
  ::std::vector<pat::CandKinResolution> kinResolutions_;
  ::std::vector<std::basic_string<char> > kinResolutionLabels_;
};
#ifdef __pat__PATObject_reco__Jet_
#undef __pat__PATObject_reco__Jet_
#endif
class __pat__PATObject_reco__Jet_ : public ::reco::Jet {
  public:
  __pat__PATObject_reco__Jet_();
  virtual ~__pat__PATObject_reco__Jet_() throw();
  ::edm::Ptr<reco::Candidate> refToOrig_;
  ::std::vector<pat::TriggerObjectStandAlone> triggerObjectMatchesEmbedded_;
  ::std::vector<pat::LookupTableRecord> efficiencyValues_;
  ::std::vector<std::basic_string<char> > efficiencyNames_;
  ::std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > > genParticleRef_;
  ::std::vector<reco::GenParticle> genParticleEmbedded_;
  ::std::vector<std::basic_string<char> > overlapLabels_;
  ::std::vector<edm::PtrVector<reco::Candidate> > overlapItems_;
  ::std::vector<std::basic_string<char> > userDataLabels_;
  ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > userDataObjects_;
  ::std::vector<std::basic_string<char> > userFloatLabels_;
  ::std::vector<float> userFloats_;
  ::std::vector<std::basic_string<char> > userIntLabels_;
  ::std::vector<int> userInts_;
  ::std::vector<std::basic_string<char> > userCandLabels_;
  ::std::vector<edm::Ptr<reco::Candidate> > userCands_;
  ::std::vector<pat::CandKinResolution> kinResolutions_;
  ::std::vector<std::basic_string<char> > kinResolutionLabels_;
};
#ifdef __pat__PATObject_reco__Photon_
#undef __pat__PATObject_reco__Photon_
#endif
class __pat__PATObject_reco__Photon_ : public ::reco::Photon {
  public:
  __pat__PATObject_reco__Photon_();
  virtual ~__pat__PATObject_reco__Photon_() throw();
  ::edm::Ptr<reco::Candidate> refToOrig_;
  ::std::vector<pat::TriggerObjectStandAlone> triggerObjectMatchesEmbedded_;
  ::std::vector<pat::LookupTableRecord> efficiencyValues_;
  ::std::vector<std::basic_string<char> > efficiencyNames_;
  ::std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > > genParticleRef_;
  ::std::vector<reco::GenParticle> genParticleEmbedded_;
  ::std::vector<std::basic_string<char> > overlapLabels_;
  ::std::vector<edm::PtrVector<reco::Candidate> > overlapItems_;
  ::std::vector<std::basic_string<char> > userDataLabels_;
  ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > userDataObjects_;
  ::std::vector<std::basic_string<char> > userFloatLabels_;
  ::std::vector<float> userFloats_;
  ::std::vector<std::basic_string<char> > userIntLabels_;
  ::std::vector<int> userInts_;
  ::std::vector<std::basic_string<char> > userCandLabels_;
  ::std::vector<edm::Ptr<reco::Candidate> > userCands_;
  ::std::vector<pat::CandKinResolution> kinResolutions_;
  ::std::vector<std::basic_string<char> > kinResolutionLabels_;
};
#ifdef __pat__PATObject_reco__BaseTau_
#undef __pat__PATObject_reco__BaseTau_
#endif
class __pat__PATObject_reco__BaseTau_ : public ::reco::BaseTau {
  public:
  __pat__PATObject_reco__BaseTau_();
  virtual ~__pat__PATObject_reco__BaseTau_() throw();
  ::edm::Ptr<reco::Candidate> refToOrig_;
  ::std::vector<pat::TriggerObjectStandAlone> triggerObjectMatchesEmbedded_;
  ::std::vector<pat::LookupTableRecord> efficiencyValues_;
  ::std::vector<std::basic_string<char> > efficiencyNames_;
  ::std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > > genParticleRef_;
  ::std::vector<reco::GenParticle> genParticleEmbedded_;
  ::std::vector<std::basic_string<char> > overlapLabels_;
  ::std::vector<edm::PtrVector<reco::Candidate> > overlapItems_;
  ::std::vector<std::basic_string<char> > userDataLabels_;
  ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > userDataObjects_;
  ::std::vector<std::basic_string<char> > userFloatLabels_;
  ::std::vector<float> userFloats_;
  ::std::vector<std::basic_string<char> > userIntLabels_;
  ::std::vector<int> userInts_;
  ::std::vector<std::basic_string<char> > userCandLabels_;
  ::std::vector<edm::Ptr<reco::Candidate> > userCands_;
  ::std::vector<pat::CandKinResolution> kinResolutions_;
  ::std::vector<std::basic_string<char> > kinResolutionLabels_;
};
#ifdef __pat__PATObject_reco__Muon_
#undef __pat__PATObject_reco__Muon_
#endif
class __pat__PATObject_reco__Muon_ : public ::reco::Muon {
  public:
  __pat__PATObject_reco__Muon_();
  virtual ~__pat__PATObject_reco__Muon_() throw();
  ::edm::Ptr<reco::Candidate> refToOrig_;
  ::std::vector<pat::TriggerObjectStandAlone> triggerObjectMatchesEmbedded_;
  ::std::vector<pat::LookupTableRecord> efficiencyValues_;
  ::std::vector<std::basic_string<char> > efficiencyNames_;
  ::std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > > genParticleRef_;
  ::std::vector<reco::GenParticle> genParticleEmbedded_;
  ::std::vector<std::basic_string<char> > overlapLabels_;
  ::std::vector<edm::PtrVector<reco::Candidate> > overlapItems_;
  ::std::vector<std::basic_string<char> > userDataLabels_;
  ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > userDataObjects_;
  ::std::vector<std::basic_string<char> > userFloatLabels_;
  ::std::vector<float> userFloats_;
  ::std::vector<std::basic_string<char> > userIntLabels_;
  ::std::vector<int> userInts_;
  ::std::vector<std::basic_string<char> > userCandLabels_;
  ::std::vector<edm::Ptr<reco::Candidate> > userCands_;
  ::std::vector<pat::CandKinResolution> kinResolutions_;
  ::std::vector<std::basic_string<char> > kinResolutionLabels_;
};
#ifdef __pat__PATObject_reco__GsfElectron_
#undef __pat__PATObject_reco__GsfElectron_
#endif
class __pat__PATObject_reco__GsfElectron_ : public ::reco::GsfElectron {
  public:
  __pat__PATObject_reco__GsfElectron_();
  virtual ~__pat__PATObject_reco__GsfElectron_() throw();
  ::edm::Ptr<reco::Candidate> refToOrig_;
  ::std::vector<pat::TriggerObjectStandAlone> triggerObjectMatchesEmbedded_;
  ::std::vector<pat::LookupTableRecord> efficiencyValues_;
  ::std::vector<std::basic_string<char> > efficiencyNames_;
  ::std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > > genParticleRef_;
  ::std::vector<reco::GenParticle> genParticleEmbedded_;
  ::std::vector<std::basic_string<char> > overlapLabels_;
  ::std::vector<edm::PtrVector<reco::Candidate> > overlapItems_;
  ::std::vector<std::basic_string<char> > userDataLabels_;
  ::edm::OwnVector<pat::UserData,edm::ClonePolicy<pat::UserData> > userDataObjects_;
  ::std::vector<std::basic_string<char> > userFloatLabels_;
  ::std::vector<float> userFloats_;
  ::std::vector<std::basic_string<char> > userIntLabels_;
  ::std::vector<int> userInts_;
  ::std::vector<std::basic_string<char> > userCandLabels_;
  ::std::vector<edm::Ptr<reco::Candidate> > userCands_;
  ::std::vector<pat::CandKinResolution> kinResolutions_;
  ::std::vector<std::basic_string<char> > kinResolutionLabels_;
};
#ifdef __edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_
#undef __edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_
#endif
class __edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_ {
  public:
  __edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_
#undef __edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_
#endif
class __edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_ {
  public:
  __edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_
#undef __edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_
#endif
class __edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_ {
  public:
  __edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s_
#undef __edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s_
#endif
class __edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s_ {
  public:
  __edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_
#undef __edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_
#endif
class __edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_ {
  public:
  __edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_
#undef __edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_
#endif
class __edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_ {
  public:
  __edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_
#undef __edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_
#endif
class __edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_ {
  public:
  __edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_
#undef __edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_
#endif
class __edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_ {
  public:
  __edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s_
#undef __edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s_
#endif
class __edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s_ {
  public:
  __edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_
#undef __edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_
#endif
class __edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_ {
  public:
  __edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_
#undef __edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_
#endif
class __edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_ {
  public:
  __edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_
#undef __edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_
#endif
class __edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_ {
  public:
  __edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_
#undef __edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_
#endif
class __edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_ {
  public:
  __edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_
#undef __edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_
#endif
class __edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_ {
  public:
  __edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_
#undef __edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_
#endif
class __edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_ {
  public:
  __edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_
#undef __edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_
#endif
class __edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_ {
  public:
  __edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_
#undef __edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_
#endif
class __edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_ {
  public:
  __edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s_
#undef __edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s_
#endif
class __edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s_ {
  public:
  __edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_
#undef __edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_
#endif
class __edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_ {
  public:
  __edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_
#undef __edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_
#endif
class __edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_ {
  public:
  __edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_
#undef __edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_
#endif
class __edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_ {
  public:
  __edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_
#undef __edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_
#endif
class __edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_ {
  public:
  __edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_
#undef __edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_
#endif
class __edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_ {
  public:
  __edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_
#undef __edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_
#endif
class __edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_ {
  public:
  __edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_
#undef __edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_
#endif
class __edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_ {
  public:
  __edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_
#undef __edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_
#endif
class __edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_ {
  public:
  __edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_
#undef __edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_
#endif
class __edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_ {
  public:
  __edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s_
#undef __edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s_
#endif
class __edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s_ {
  public:
  __edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s_
#undef ____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s_
#undef ____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s_
#undef ____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s_
#undef ____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s_
#undef ____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s_
#undef ____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s_
#undef ____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s_
#undef ____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s_
#undef ____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s_
#undef ____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s_
#undef ____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s_
#undef ____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s_
#undef ____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s_
#undef ____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s_
#undef ____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s_
#endif
class ____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s_ {
  public:
  ____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s_();
  void* _M_current;
};
#ifdef __edm__Association_std__vector_pat__PackedCandidate_s_
#undef __edm__Association_std__vector_pat__PackedCandidate_s_
#endif
class __edm__Association_std__vector_pat__PackedCandidate_s_ : private ::edm::ValueMap<int> {
  public:
  __edm__Association_std__vector_pat__PackedCandidate_s_();
  ::edm::RefProd<std::vector<pat::PackedCandidate> > ref_;
};
#ifdef __edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s_
#undef __edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s_
#endif
class __edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s_ {
  public:
  __edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s_();
  bool present;
  ::edm::Association<std::vector<pat::PackedCandidate> > obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s_();
  bool present;
  ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s_();
  bool present;
  ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_();
  bool present;
  ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_();
  bool present;
  ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_();
  bool present;
  ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_();
  bool present;
  ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_();
  bool present;
  ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_();
  bool present;
  ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_();
  bool present;
  ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_();
  bool present;
  ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_();
  bool present;
  ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_();
  bool present;
  ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > obj;
};
#ifdef __edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s_
#undef __edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s_
#endif
class __edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s_ {
  public:
  __edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s_();
  void* m_data;
};
#ifdef __edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s_
#undef __edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s_
#endif
class __edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s_ {
  public:
  __edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s_();
  void* m_data;
};
#ifdef __edm__RefProd_std__vector_pat__PackedCandidate_s_
#undef __edm__RefProd_std__vector_pat__PackedCandidate_s_
#endif
class __edm__RefProd_std__vector_pat__PackedCandidate_s_ {
  public:
  __edm__RefProd_std__vector_pat__PackedCandidate_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_
#undef __edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_
#endif
class __edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_ : public ::edm::reftobase::RefVectorHolderBase {
  public:
  __edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_();
  virtual ~__edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_() throw();
  ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > refs_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_() throw();
  ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_() throw();
  ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_() throw();
  ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_() throw();
  ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_() throw();
  ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_() throw();
  ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_() throw();
  ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_() throw();
  ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_() throw();
  ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_() throw();
  ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > ref_;
};
#ifdef __edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_
#undef __edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_
#endif
class __edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_ : public ::edm::reftobase::BaseVectorHolder<reco::Candidate> {
  public:
  __edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_();
  virtual ~__edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_() throw();
  ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > refVector_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_() throw();
  ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_() throw();
  ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_() throw();
  ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_() throw();
  ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_() throw();
  ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_() throw();
  ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_() throw();
  ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_() throw();
  ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_() throw();
  ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_() throw();
  ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > ref_;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class PackedGenParticle -------------------------------
static  void operator_60361( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::PackedGenParticle*)o)->operator=)(*(const ::pat::PackedGenParticle*)arg[0]);
  else   (((::pat::PackedGenParticle*)o)->operator=)(*(const ::pat::PackedGenParticle*)arg[0]);
}

static void constructor_60362( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PackedGenParticle(*(const ::pat::PackedGenParticle*)arg[0]);
  else ::new(mem) ::pat::PackedGenParticle(*(const ::pat::PackedGenParticle*)arg[0]);
}

static void constructor_60363( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PackedGenParticle();
  else ::new(mem) ::pat::PackedGenParticle();
}

static void constructor_60364( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PackedGenParticle(*(const ::reco::GenParticle*)arg[0]);
  else ::new(mem) ::pat::PackedGenParticle(*(const ::reco::GenParticle*)arg[0]);
}

static void constructor_60365( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PackedGenParticle(*(const ::reco::GenParticle*)arg[0],
      *(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[1]);
  else ::new(mem) ::pat::PackedGenParticle(*(const ::reco::GenParticle*)arg[0],
      *(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[1]);
}

static void destructor_60366(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::PackedGenParticle*)o)->::pat::PackedGenParticle::~PackedGenParticle)();
}
static  void method_60367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::candidate::const_iterator)((((const ::pat::PackedGenParticle*)o)->begin)());
  else   (((const ::pat::PackedGenParticle*)o)->begin)();
}

static  void method_60368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::candidate::const_iterator)((((const ::pat::PackedGenParticle*)o)->end)());
  else   (((const ::pat::PackedGenParticle*)o)->end)();
}

static  void method_60369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::candidate::iterator)((((::pat::PackedGenParticle*)o)->begin)());
  else   (((::pat::PackedGenParticle*)o)->begin)();
}

static  void method_60370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::candidate::iterator)((((::pat::PackedGenParticle*)o)->end)());
  else   (((::pat::PackedGenParticle*)o)->end)();
}

static  void method_60371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PackedGenParticle*)o)->numberOfDaughters)());
  else   (((const ::pat::PackedGenParticle*)o)->numberOfDaughters)();
}

static  void method_60372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PackedGenParticle*)o)->daughter)(*(::size_t*)arg[0]));
  else   (((const ::pat::PackedGenParticle*)o)->daughter)(*(::size_t*)arg[0]);
}

static  void method_60373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PackedGenParticle*)o)->numberOfMothers)());
  else   (((const ::pat::PackedGenParticle*)o)->numberOfMothers)();
}

static  void method_60374( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PackedGenParticle*)o)->mother)(*(::size_t*)arg[0]));
  else   (((const ::pat::PackedGenParticle*)o)->mother)(*(::size_t*)arg[0]);
}

static  void method_60375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::pat::PackedGenParticle*)o)->daughter)(*(::size_t*)arg[0]));
  else   (((::pat::PackedGenParticle*)o)->daughter)(*(::size_t*)arg[0]);
}

static  void method_60376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::pat::PackedGenParticle*)o)->daughter)(*(const ::std::string*)arg[0]));
  else   (((::pat::PackedGenParticle*)o)->daughter)(*(const ::std::string*)arg[0]);
}

static  void method_60377( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PackedGenParticle*)o)->daughter)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::PackedGenParticle*)o)->daughter)(*(const ::std::string*)arg[0]);
}

static  void method_60378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PackedGenParticle*)o)->numberOfSourceCandidatePtrs)());
  else   (((const ::pat::PackedGenParticle*)o)->numberOfSourceCandidatePtrs)();
}

static  void method_60379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtr)((((const ::pat::PackedGenParticle*)o)->sourceCandidatePtr)(*(::size_t*)arg[0]));
  else   (((const ::pat::PackedGenParticle*)o)->sourceCandidatePtr)(*(::size_t*)arg[0]);
}

static  void method_60380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PackedGenParticle*)o)->charge)());
  else   (((const ::pat::PackedGenParticle*)o)->charge)();
}

static  void method_60381( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedGenParticle*)o)->setCharge)(*(int*)arg[0]);
}

static  void method_60382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PackedGenParticle*)o)->threeCharge)());
  else   (((const ::pat::PackedGenParticle*)o)->threeCharge)();
}

static  void method_60383( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedGenParticle*)o)->setThreeCharge)(*(int*)arg[0]);
}

static  void method_60384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PackedGenParticle*)o)->p4)();
  else   (((const ::pat::PackedGenParticle*)o)->p4)();
}

static  void method_60385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PackedGenParticle*)o)->polarP4)();
  else   (((const ::pat::PackedGenParticle*)o)->polarP4)();
}

static  void method_60386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (math::XYZVector)((((const ::pat::PackedGenParticle*)o)->momentum)());
  else   (((const ::pat::PackedGenParticle*)o)->momentum)();
}

static  void method_60387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (math::XYZVector)((((const ::pat::PackedGenParticle*)o)->boostToCM)());
  else   (((const ::pat::PackedGenParticle*)o)->boostToCM)();
}

static  void method_60388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->p)());
  else   (((const ::pat::PackedGenParticle*)o)->p)();
}

static  void method_60389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->energy)());
  else   (((const ::pat::PackedGenParticle*)o)->energy)();
}

static  void method_60390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->et)());
  else   (((const ::pat::PackedGenParticle*)o)->et)();
}

static  void method_60391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedGenParticle*)o)->mass)());
  else   (((const ::pat::PackedGenParticle*)o)->mass)();
}

static  void method_60392( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedGenParticle*)o)->massSqr)());
  else   (((const ::pat::PackedGenParticle*)o)->massSqr)();
}

static  void method_60393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->mt)());
  else   (((const ::pat::PackedGenParticle*)o)->mt)();
}

static  void method_60394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->mtSqr)());
  else   (((const ::pat::PackedGenParticle*)o)->mtSqr)();
}

static  void method_60395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->px)());
  else   (((const ::pat::PackedGenParticle*)o)->px)();
}

static  void method_60396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->py)());
  else   (((const ::pat::PackedGenParticle*)o)->py)();
}

static  void method_60397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->pz)());
  else   (((const ::pat::PackedGenParticle*)o)->pz)();
}

static  void method_60398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedGenParticle*)o)->pt)());
  else   (((const ::pat::PackedGenParticle*)o)->pt)();
}

static  void method_60399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedGenParticle*)o)->phi)());
  else   (((const ::pat::PackedGenParticle*)o)->phi)();
}

static  void method_60400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->theta)());
  else   (((const ::pat::PackedGenParticle*)o)->theta)();
}

static  void method_60401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedGenParticle*)o)->eta)());
  else   (((const ::pat::PackedGenParticle*)o)->eta)();
}

static  void method_60402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->rapidity)());
  else   (((const ::pat::PackedGenParticle*)o)->rapidity)();
}

static  void method_60403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->y)());
  else   (((const ::pat::PackedGenParticle*)o)->y)();
}

static  void method_60404( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedGenParticle*)o)->setP4)(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static  void method_60405( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedGenParticle*)o)->setP4)(*(const ::math::PtEtaPhiMLorentzVector*)arg[0]);
}

static  void method_60406( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedGenParticle*)o)->setMass)(*(double*)arg[0]);
}

static  void method_60407( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedGenParticle*)o)->setPz)(*(double*)arg[0]);
}

static  void method_60408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PackedGenParticle*)o)->vertex)();
  else   (((const ::pat::PackedGenParticle*)o)->vertex)();
}

static  void method_60409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->vx)());
  else   (((const ::pat::PackedGenParticle*)o)->vx)();
}

static  void method_60410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->vy)());
  else   (((const ::pat::PackedGenParticle*)o)->vy)();
}

static  void method_60411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->vz)());
  else   (((const ::pat::PackedGenParticle*)o)->vz)();
}

static  void method_60412( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedGenParticle*)o)->setVertex)(*(const ::math::XYZPoint*)arg[0]);
}

static  void method_60413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedGenParticle*)o)->dxy)());
  else   (((const ::pat::PackedGenParticle*)o)->dxy)();
}

static  void method_60414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedGenParticle*)o)->dz)());
  else   (((const ::pat::PackedGenParticle*)o)->dz)();
}

static  void method_60415( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedGenParticle*)o)->dxy)(*(const ::math::XYZPoint*)arg[0]));
  else   (((const ::pat::PackedGenParticle*)o)->dxy)(*(const ::math::XYZPoint*)arg[0]);
}

static  void method_60416( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedGenParticle*)o)->dz)(*(const ::math::XYZPoint*)arg[0]));
  else   (((const ::pat::PackedGenParticle*)o)->dz)(*(const ::math::XYZPoint*)arg[0]);
}

static  void method_60417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PackedGenParticle*)o)->pdgId)());
  else   (((const ::pat::PackedGenParticle*)o)->pdgId)();
}

static  void method_60418( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedGenParticle*)o)->setPdgId)(*(int*)arg[0]);
}

static  void method_60419( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PackedGenParticle*)o)->status)());
  else   (((const ::pat::PackedGenParticle*)o)->status)();
}

static  void method_60420( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedGenParticle*)o)->setStatus)(*(int*)arg[0]);
}

static  void method_60421( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::PackedGenParticle*)o)->setLongLived)();
}

static  void method_60422( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedGenParticle*)o)->longLived)());
  else   (((const ::pat::PackedGenParticle*)o)->longLived)();
}

static  void method_60423( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::PackedGenParticle*)o)->setMassConstraint)();
}

static  void method_60424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedGenParticle*)o)->massConstraint)());
  else   (((const ::pat::PackedGenParticle*)o)->massConstraint)();
}

static  void method_60425( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PackedGenParticle*)o)->clone)());
  else   (((const ::pat::PackedGenParticle*)o)->clone)();
}

static  void method_60426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->vertexChi2)());
  else   (((const ::pat::PackedGenParticle*)o)->vertexChi2)();
}

static  void method_60427( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->vertexNdof)());
  else   (((const ::pat::PackedGenParticle*)o)->vertexNdof)();
}

static  void method_60428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->vertexNormalizedChi2)());
  else   (((const ::pat::PackedGenParticle*)o)->vertexNormalizedChi2)();
}

static  void method_60429( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedGenParticle*)o)->vertexCovariance)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::pat::PackedGenParticle*)o)->vertexCovariance)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_60430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >)((((const ::pat::PackedGenParticle*)o)->vertexCovariance)());
  else   (((const ::pat::PackedGenParticle*)o)->vertexCovariance)();
}

static  void method_60431( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::pat::PackedGenParticle*)o)->fillVertexCovariance)(*(::ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >*)arg[0]);
}

static  void method_60432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedGenParticle*)o)->hasMasterClone)());
  else   (((const ::pat::PackedGenParticle*)o)->hasMasterClone)();
}

static  void method_60433( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PackedGenParticle*)o)->masterClone)();
  else   (((const ::pat::PackedGenParticle*)o)->masterClone)();
}

static  void method_60434( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedGenParticle*)o)->hasMasterClonePtr)());
  else   (((const ::pat::PackedGenParticle*)o)->hasMasterClonePtr)();
}

static  void method_60435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PackedGenParticle*)o)->masterClonePtr)();
  else   (((const ::pat::PackedGenParticle*)o)->masterClonePtr)();
}

static  void method_60436( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedGenParticle*)o)->isElectron)());
  else   (((const ::pat::PackedGenParticle*)o)->isElectron)();
}

static  void method_60437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedGenParticle*)o)->isMuon)());
  else   (((const ::pat::PackedGenParticle*)o)->isMuon)();
}

static  void method_60438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedGenParticle*)o)->isStandAloneMuon)());
  else   (((const ::pat::PackedGenParticle*)o)->isStandAloneMuon)();
}

static  void method_60439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedGenParticle*)o)->isGlobalMuon)());
  else   (((const ::pat::PackedGenParticle*)o)->isGlobalMuon)();
}

static  void method_60440( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedGenParticle*)o)->isTrackerMuon)());
  else   (((const ::pat::PackedGenParticle*)o)->isTrackerMuon)();
}

static  void method_60441( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedGenParticle*)o)->isCaloMuon)());
  else   (((const ::pat::PackedGenParticle*)o)->isCaloMuon)();
}

static  void method_60442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedGenParticle*)o)->isPhoton)());
  else   (((const ::pat::PackedGenParticle*)o)->isPhoton)();
}

static  void method_60443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedGenParticle*)o)->isConvertedPhoton)());
  else   (((const ::pat::PackedGenParticle*)o)->isConvertedPhoton)();
}

static  void method_60444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedGenParticle*)o)->isJet)());
  else   (((const ::pat::PackedGenParticle*)o)->isJet)();
}

static void method_newdel_9072( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::PackedGenParticle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::PackedGenParticle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::PackedGenParticle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::PackedGenParticle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::PackedGenParticle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::PackedGenParticle,::reco::Candidate >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

void read___pat__PackedGenParticle_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  bool &unpacked_ = *(bool*)(target + OffsetOf(__shadow__::__pat__PackedGenParticle, unpacked_));

  if( oldObj ) {}
  //--- User's code ---
    unpacked_ = false;
    
  
}

//------Dictionary for class PackedGenParticle -------------------------------
void __pat__PackedGenParticle_db_datamem(Reflex::Class*);
void __pat__PackedGenParticle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__PackedGenParticle_datamem_bld(&__pat__PackedGenParticle_db_datamem);
Reflex::GenreflexMemberBuilder __pat__PackedGenParticle_funcmem_bld(&__pat__PackedGenParticle_db_funcmem);
void __pat__PackedGenParticle_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(1);
  rule = &readrules[0];
  rule->fSourceClass = "pat::PackedGenParticle";
  rule->fTarget      = "unpacked_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__PackedGenParticle_0);
  rule->fCode        = "\n    unpacked_ = false;\n    \n  ";
  rule->fVersion     = "[1-]";


  ::Reflex::ClassBuilder(Reflex::Literal("pat::PackedGenParticle"), typeid(::pat::PackedGenParticle), sizeof(::pat::PackedGenParticle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty("ioread", readrules )
  .AddBase(type_9075, ::Reflex::BaseOffset< ::pat::PackedGenParticle, ::reco::Candidate >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_11459, Reflex::Literal("pat::PackedGenParticle::daughters"))
  .AddTypedef(type_10223, Reflex::Literal("pat::PackedGenParticle::LorentzVector"))
  .AddTypedef(type_10195, Reflex::Literal("pat::PackedGenParticle::PolarLorentzVector"))
  .AddTypedef(type_10191, Reflex::Literal("pat::PackedGenParticle::Point"))
  .AddTypedef(type_10222, Reflex::Literal("pat::PackedGenParticle::Vector"))
  .AddTypedef(type_227, Reflex::Literal("pat::PackedGenParticle::index"))
  .AddEnum(Reflex::Literal("pat::PackedGenParticle::PVAssoc"), Reflex::Literal("NoPV=0;PVLoose=1;PVTight=2;PVUsedInFit=3"), &typeid(pat::PackedGenParticle::PVAssoc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_45701, Reflex::Literal("pat::PackedGenParticle::const_iterator_imp_specific"))
  .AddTypedef(type_45703, Reflex::Literal("pat::PackedGenParticle::iterator_imp_specific"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20572, type_17687), Reflex::Literal("operator="), operator_60361, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17687), Reflex::Literal("PackedGenParticle"), constructor_60362, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PackedGenParticle"), constructor_60363, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22224), Reflex::Literal("PackedGenParticle"), constructor_60364, 0, "c", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22224, type_17938), Reflex::Literal("PackedGenParticle"), constructor_60365, 0, "c;mother", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PackedGenParticle"), destructor_60366, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9072, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__PackedGenParticle_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__PackedGenParticle_funcmem_bld);
}

//------Delayed data member builder for class PackedGenParticle -------------------
void __pat__PackedGenParticle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2024, Reflex::Literal("packedPt_"), OffsetOf(__shadow__::__pat__PackedGenParticle, packedPt_), ::Reflex::PROTECTED)
  .AddDataMember(type_2024, Reflex::Literal("packedEta_"), OffsetOf(__shadow__::__pat__PackedGenParticle, packedEta_), ::Reflex::PROTECTED)
  .AddDataMember(type_2024, Reflex::Literal("packedPhi_"), OffsetOf(__shadow__::__pat__PackedGenParticle, packedPhi_), ::Reflex::PROTECTED)
  .AddDataMember(type_2024, Reflex::Literal("packedM_"), OffsetOf(__shadow__::__pat__PackedGenParticle, packedM_), ::Reflex::PROTECTED)
  .AddDataMember(type_10195, Reflex::Literal("p4_"), OffsetOf(__shadow__::__pat__PackedGenParticle, p4_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_10223, Reflex::Literal("p4c_"), OffsetOf(__shadow__::__pat__PackedGenParticle, p4c_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_10191, Reflex::Literal("vertex_"), OffsetOf(__shadow__::__pat__PackedGenParticle, vertex_), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_990, Reflex::Literal("dxy_"), OffsetOf(__shadow__::__pat__PackedGenParticle, dxy_), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_990, Reflex::Literal("dz_"), OffsetOf(__shadow__::__pat__PackedGenParticle, dz_), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_990, Reflex::Literal("dphi_"), OffsetOf(__shadow__::__pat__PackedGenParticle, dphi_), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_72, Reflex::Literal("pdgId_"), OffsetOf(__shadow__::__pat__PackedGenParticle, pdgId_), ::Reflex::PROTECTED)
  .AddDataMember(type_626, Reflex::Literal("charge_"), OffsetOf(__shadow__::__pat__PackedGenParticle, charge_), ::Reflex::PROTECTED)
  .AddDataMember(type_11252, Reflex::Literal("mother_"), OffsetOf(__shadow__::__pat__PackedGenParticle, mother_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("unpacked_"), OffsetOf(__shadow__::__pat__PackedGenParticle, unpacked_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class PackedGenParticle -------------------
void __pat__PackedGenParticle_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47549), Reflex::Literal("begin"), method_60367, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47549), Reflex::Literal("end"), method_60368, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47548), Reflex::Literal("begin"), method_60369, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47548), Reflex::Literal("end"), method_60370, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("numberOfDaughters"), method_60371, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865, type_2393), Reflex::Literal("daughter"), method_60372, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("numberOfMothers"), method_60373, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865, type_2393), Reflex::Literal("mother"), method_60374, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29399, type_2393), Reflex::Literal("daughter"), method_60375, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29399, type_30686), Reflex::Literal("daughter"), method_60376, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865, type_30686), Reflex::Literal("daughter"), method_60377, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("numberOfSourceCandidatePtrs"), method_60378, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11562, type_2393), Reflex::Literal("sourceCandidatePtr"), method_60379, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("charge"), method_60380, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_72), Reflex::Literal("setCharge"), method_60381, 0, "charge", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("threeCharge"), method_60382, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_72), Reflex::Literal("setThreeCharge"), method_60383, 0, "threecharge", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45676), Reflex::Literal("p4"), method_60384, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45674), Reflex::Literal("polarP4"), method_60385, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10222), Reflex::Literal("momentum"), method_60386, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10222), Reflex::Literal("boostToCM"), method_60387, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("p"), method_60388, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("energy"), method_60389, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("et"), method_60390, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("mass"), method_60391, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("massSqr"), method_60392, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("mt"), method_60393, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("mtSqr"), method_60394, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("px"), method_60395, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("py"), method_60396, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("pz"), method_60397, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("pt"), method_60398, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("phi"), method_60399, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("theta"), method_60400, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("eta"), method_60401, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("rapidity"), method_60402, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("y"), method_60403, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_45676), Reflex::Literal("setP4"), method_60404, 0, "p4", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_45674), Reflex::Literal("setP4"), method_60405, 0, "p4", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112), Reflex::Literal("setMass"), method_60406, 0, "m", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112), Reflex::Literal("setPz"), method_60407, 0, "pz", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45678), Reflex::Literal("vertex"), method_60408, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("vx"), method_60409, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("vy"), method_60410, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("vz"), method_60411, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_45678), Reflex::Literal("setVertex"), method_60412, 0, "vertex", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("dxy"), method_60413, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("dz"), method_60414, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_45678), Reflex::Literal("dxy"), method_60415, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_45678), Reflex::Literal("dz"), method_60416, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("pdgId"), method_60417, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_72), Reflex::Literal("setPdgId"), method_60418, 0, "pdgId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("status"), method_60419, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_72), Reflex::Literal("setStatus"), method_60420, 0, "status", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("setLongLived"), method_60421, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("longLived"), method_60422, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("setMassConstraint"), method_60423, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("massConstraint"), method_60424, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14425), Reflex::Literal("clone"), method_60425, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("vertexChi2"), method_60426, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("vertexNdof"), method_60427, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("vertexNormalizedChi2"), method_60428, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_72, type_72), Reflex::Literal("vertexCovariance"), method_60429, 0, "i;j", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_116), Reflex::Literal("vertexCovariance"), method_60430, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35034), Reflex::Literal("fillVertexCovariance"), method_60431, 0, "v", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasMasterClone"), method_60432, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72488), Reflex::Literal("masterClone"), method_60433, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasMasterClonePtr"), method_60434, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72489), Reflex::Literal("masterClonePtr"), method_60435, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isElectron"), method_60436, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isMuon"), method_60437, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isStandAloneMuon"), method_60438, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isGlobalMuon"), method_60439, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTrackerMuon"), method_60440, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isCaloMuon"), method_60441, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPhoton"), method_60442, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isConvertedPhoton"), method_60443, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isJet"), method_60444, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<pat::PackedGenParticle,std::allocator<pat::PackedGenParticle> > -------------------------------
static void constructor_20582( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PackedGenParticle>();
  else ::new(mem) ::std::vector<pat::PackedGenParticle>();
}

static void constructor_20583( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PackedGenParticle>(*(const ::std::allocator<pat::PackedGenParticle>*)arg[0]);
  else ::new(mem) ::std::vector<pat::PackedGenParticle>(*(const ::std::allocator<pat::PackedGenParticle>*)arg[0]);
}

static void constructor_20584( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PackedGenParticle>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::PackedGenParticle>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PackedGenParticle>(*(::std::size_t*)arg[0],
      *(const ::pat::PackedGenParticle*)arg[1]);
  else ::new(mem) ::std::vector<pat::PackedGenParticle>(*(::std::size_t*)arg[0],
      *(const ::pat::PackedGenParticle*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PackedGenParticle>(*(::std::size_t*)arg[0],
      *(const ::pat::PackedGenParticle*)arg[1],
      *(const ::std::allocator<pat::PackedGenParticle>*)arg[2]);
  else ::new(mem) ::std::vector<pat::PackedGenParticle>(*(::std::size_t*)arg[0],
      *(const ::pat::PackedGenParticle*)arg[1],
      *(const ::std::allocator<pat::PackedGenParticle>*)arg[2]);
  }
}

static void constructor_20585( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PackedGenParticle>(*(const ::std::vector<pat::PackedGenParticle>*)arg[0]);
  else ::new(mem) ::std::vector<pat::PackedGenParticle>(*(const ::std::vector<pat::PackedGenParticle>*)arg[0]);
}

static void destructor_20586(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::PackedGenParticle>*)o)->::std::vector<pat::PackedGenParticle>::~vector)();
}
static  void operator_20587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::PackedGenParticle>*)o)->operator=)(*(const ::std::vector<pat::PackedGenParticle>*)arg[0]);
  else   (((::std::vector<pat::PackedGenParticle>*)o)->operator=)(*(const ::std::vector<pat::PackedGenParticle>*)arg[0]);
}

static  void method_20588( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::PackedGenParticle>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::PackedGenParticle*)arg[1]);
}

static  void method_20589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >)((((::std::vector<pat::PackedGenParticle>*)o)->begin)());
  else   (((::std::vector<pat::PackedGenParticle>*)o)->begin)();
}

static  void method_20590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >)((((const ::std::vector<pat::PackedGenParticle>*)o)->begin)());
  else   (((const ::std::vector<pat::PackedGenParticle>*)o)->begin)();
}

static  void method_20591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >)((((::std::vector<pat::PackedGenParticle>*)o)->end)());
  else   (((::std::vector<pat::PackedGenParticle>*)o)->end)();
}

static  void method_20592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >)((((const ::std::vector<pat::PackedGenParticle>*)o)->end)());
  else   (((const ::std::vector<pat::PackedGenParticle>*)o)->end)();
}

static  void method_20597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::PackedGenParticle>*)o)->size)());
  else   (((const ::std::vector<pat::PackedGenParticle>*)o)->size)();
}

static  void method_20598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::PackedGenParticle>*)o)->max_size)());
  else   (((const ::std::vector<pat::PackedGenParticle>*)o)->max_size)();
}

static  void method_20599( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::PackedGenParticle>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::PackedGenParticle>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::PackedGenParticle*)arg[1]);
  }
}

static  void method_20600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::PackedGenParticle>*)o)->capacity)());
  else   (((const ::std::vector<pat::PackedGenParticle>*)o)->capacity)();
}

static  void method_20601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::PackedGenParticle>*)o)->empty)());
  else   (((const ::std::vector<pat::PackedGenParticle>*)o)->empty)();
}

static  void method_20602( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::PackedGenParticle>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::PackedGenParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::PackedGenParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20604( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::PackedGenParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::PackedGenParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::PackedGenParticle>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::PackedGenParticle>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20607( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::PackedGenParticle>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::PackedGenParticle>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::PackedGenParticle>*)o)->front)();
  else   (((::std::vector<pat::PackedGenParticle>*)o)->front)();
}

static  void method_20609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::PackedGenParticle>*)o)->front)();
  else   (((const ::std::vector<pat::PackedGenParticle>*)o)->front)();
}

static  void method_20610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::PackedGenParticle>*)o)->back)();
  else   (((::std::vector<pat::PackedGenParticle>*)o)->back)();
}

static  void method_20611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::PackedGenParticle>*)o)->back)();
  else   (((const ::std::vector<pat::PackedGenParticle>*)o)->back)();
}

static  void method_20612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::PackedGenParticle>*)o)->data)());
  else   (((::std::vector<pat::PackedGenParticle>*)o)->data)();
}

static  void method_20613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::PackedGenParticle>*)o)->data)());
  else   (((const ::std::vector<pat::PackedGenParticle>*)o)->data)();
}

static  void method_20614( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::PackedGenParticle>*)o)->push_back)(*(const ::pat::PackedGenParticle*)arg[0]);
}

static  void method_20615( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::PackedGenParticle>*)o)->pop_back)();
}

static  void method_20616( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >)((((::std::vector<pat::PackedGenParticle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)arg[0],
    *(const ::pat::PackedGenParticle*)arg[1]));
  else   (((::std::vector<pat::PackedGenParticle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)arg[0],
    *(const ::pat::PackedGenParticle*)arg[1]);
}

static  void method_20617( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::PackedGenParticle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::PackedGenParticle*)arg[2]);
}

static  void method_20618( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >)((((::std::vector<pat::PackedGenParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)arg[0]));
  else   (((::std::vector<pat::PackedGenParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)arg[0]);
}

static  void method_20619( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >)((((::std::vector<pat::PackedGenParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)arg[1]));
  else   (((::std::vector<pat::PackedGenParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)arg[1]);
}

static  void method_20620( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::PackedGenParticle>*)o)->swap)(*(::std::vector<pat::PackedGenParticle>*)arg[0]);
}

static  void method_20621( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::PackedGenParticle>*)o)->clear)();
}

static void method_newdel_3507( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::PackedGenParticle> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::PackedGenParticle> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::PackedGenParticle> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::PackedGenParticle> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::PackedGenParticle> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::PackedGenParticle,std::allocator<pat::PackedGenParticle> >")), ::Reflex::BaseOffset< ::std::vector<pat::PackedGenParticle>,::std::_Vector_base<pat::PackedGenParticle,std::allocator<pat::PackedGenParticle> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::PackedGenParticle> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::PackedGenParticle> >::Generate();
}

//------Dictionary for class vector<pat::PackedGenParticle,std::allocator<pat::PackedGenParticle> > -------------------------------
void __std__vector_pat__PackedGenParticle__db_datamem(Reflex::Class*);
void __std__vector_pat__PackedGenParticle__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__PackedGenParticle__datamem_bld(&__std__vector_pat__PackedGenParticle__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__PackedGenParticle__funcmem_bld(&__std__vector_pat__PackedGenParticle__db_funcmem);
void __std__vector_pat__PackedGenParticle__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::PackedGenParticle>"), typeid(::std::vector<pat::PackedGenParticle>), sizeof(::std::vector<pat::PackedGenParticle>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2830, ::Reflex::BaseOffset< ::std::vector<pat::PackedGenParticle>, ::std::_Vector_base<pat::PackedGenParticle,std::allocator<pat::PackedGenParticle> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_9072, Reflex::Literal("std::vector<pat::PackedGenParticle>::_Alloc_value_type"))
  .AddTypedef(type_2830, Reflex::Literal("std::vector<pat::PackedGenParticle>::_Base"))
  .AddTypedef(type_3865, Reflex::Literal("std::vector<pat::PackedGenParticle>::_Tp_alloc_type"))
  .AddTypedef(type_12362, Reflex::Literal("std::vector<pat::PackedGenParticle>::_Alloc_traits"))
  .AddTypedef(type_9072, Reflex::Literal("std::vector<pat::PackedGenParticle>::value_type"))
  .AddTypedef(type_14425, Reflex::Literal("std::vector<pat::PackedGenParticle>::pointer"))
  .AddTypedef(type_17685, Reflex::Literal("std::vector<pat::PackedGenParticle>::const_pointer"))
  .AddTypedef(type_20572, Reflex::Literal("std::vector<pat::PackedGenParticle>::reference"))
  .AddTypedef(type_17687, Reflex::Literal("std::vector<pat::PackedGenParticle>::const_reference"))
  .AddTypedef(type_11980, Reflex::Literal("std::vector<pat::PackedGenParticle>::iterator"))
  .AddTypedef(type_11964, Reflex::Literal("std::vector<pat::PackedGenParticle>::const_iterator"))
  .AddTypedef(type_4294, Reflex::Literal("std::vector<pat::PackedGenParticle>::const_reverse_iterator"))
  .AddTypedef(type_4295, Reflex::Literal("std::vector<pat::PackedGenParticle>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::PackedGenParticle>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::PackedGenParticle>::difference_type"))
  .AddTypedef(type_3865, Reflex::Literal("std::vector<pat::PackedGenParticle>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_20582, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62387), Reflex::Literal("vector"), constructor_20583, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_17687, type_62387), Reflex::Literal("vector"), constructor_20584, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35489), Reflex::Literal("vector"), constructor_20585, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20586, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3507, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__PackedGenParticle__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::PackedGenParticle,std::allocator<pat::PackedGenParticle> > -------------------
void __std__vector_pat__PackedGenParticle__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::PackedGenParticle,std::allocator<pat::PackedGenParticle> > -------------------
void __std__vector_pat__PackedGenParticle__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65082, type_35489), Reflex::Literal("operator="), operator_20587, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_17687), Reflex::Literal("assign"), method_20588, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11980), Reflex::Literal("begin"), method_20589, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11964), Reflex::Literal("begin"), method_20590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11980), Reflex::Literal("end"), method_20591, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11964), Reflex::Literal("end"), method_20592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_20597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_20598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_9072), Reflex::Literal("resize"), method_20599, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_20600, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_20601, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_20602, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20572, type_3845), Reflex::Literal("operator[]"), operator_20603, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17687, type_3845), Reflex::Literal("operator[]"), operator_20604, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20572, type_3845), Reflex::Literal("at"), method_20606, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17687, type_3845), Reflex::Literal("at"), method_20607, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20572), Reflex::Literal("front"), method_20608, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17687), Reflex::Literal("front"), method_20609, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20572), Reflex::Literal("back"), method_20610, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17687), Reflex::Literal("back"), method_20611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14425), Reflex::Literal("data"), method_20612, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17685), Reflex::Literal("data"), method_20613, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17687), Reflex::Literal("push_back"), method_20614, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_20615, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11980, type_11980, type_17687), Reflex::Literal("insert"), method_20616, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_11980, type_3845, type_17687), Reflex::Literal("insert"), method_20617, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11980, type_11980), Reflex::Literal("erase"), method_20618, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11980, type_11980, type_11980), Reflex::Literal("erase"), method_20619, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65082), Reflex::Literal("swap"), method_20620, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_20621, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PackedCandidate -------------------------------
static  void operator_59793( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::PackedCandidate*)o)->operator=)(*(const ::pat::PackedCandidate*)arg[0]);
  else   (((::pat::PackedCandidate*)o)->operator=)(*(const ::pat::PackedCandidate*)arg[0]);
}

static void constructor_59794( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PackedCandidate(*(const ::pat::PackedCandidate*)arg[0]);
  else ::new(mem) ::pat::PackedCandidate(*(const ::pat::PackedCandidate*)arg[0]);
}

static void constructor_59795( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PackedCandidate();
  else ::new(mem) ::pat::PackedCandidate();
}

static void constructor_59796( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PackedCandidate(*(const ::reco::Candidate*)arg[0],
      *(const ::reco::VertexRef*)arg[1]);
  else ::new(mem) ::pat::PackedCandidate(*(const ::reco::Candidate*)arg[0],
      *(const ::reco::VertexRef*)arg[1]);
}

static void constructor_59797( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PackedCandidate(*(const ::math::PtEtaPhiMLorentzVector*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(float*)arg[2],
      *(int*)arg[3],
      *(const ::reco::VertexRef*)arg[4]);
  else ::new(mem) ::pat::PackedCandidate(*(const ::math::PtEtaPhiMLorentzVector*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(float*)arg[2],
      *(int*)arg[3],
      *(const ::reco::VertexRef*)arg[4]);
}

static void constructor_59798( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PackedCandidate(*(const ::math::XYZTLorentzVector*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(float*)arg[2],
      *(int*)arg[3],
      *(const ::reco::VertexRef*)arg[4]);
  else ::new(mem) ::pat::PackedCandidate(*(const ::math::XYZTLorentzVector*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(float*)arg[2],
      *(int*)arg[3],
      *(const ::reco::VertexRef*)arg[4]);
}

static void destructor_59799(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::PackedCandidate*)o)->::pat::PackedCandidate::~PackedCandidate)();
}
static  void method_59800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::candidate::const_iterator)((((const ::pat::PackedCandidate*)o)->begin)());
  else   (((const ::pat::PackedCandidate*)o)->begin)();
}

static  void method_59801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::candidate::const_iterator)((((const ::pat::PackedCandidate*)o)->end)());
  else   (((const ::pat::PackedCandidate*)o)->end)();
}

static  void method_59802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::candidate::iterator)((((::pat::PackedCandidate*)o)->begin)());
  else   (((::pat::PackedCandidate*)o)->begin)();
}

static  void method_59803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::candidate::iterator)((((::pat::PackedCandidate*)o)->end)());
  else   (((::pat::PackedCandidate*)o)->end)();
}

static  void method_59804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PackedCandidate*)o)->numberOfDaughters)());
  else   (((const ::pat::PackedCandidate*)o)->numberOfDaughters)();
}

static  void method_59805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PackedCandidate*)o)->daughter)(*(::size_t*)arg[0]));
  else   (((const ::pat::PackedCandidate*)o)->daughter)(*(::size_t*)arg[0]);
}

static  void method_59806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PackedCandidate*)o)->numberOfMothers)());
  else   (((const ::pat::PackedCandidate*)o)->numberOfMothers)();
}

static  void method_59807( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PackedCandidate*)o)->mother)(*(::size_t*)arg[0]));
  else   (((const ::pat::PackedCandidate*)o)->mother)(*(::size_t*)arg[0]);
}

static  void method_59808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::pat::PackedCandidate*)o)->daughter)(*(::size_t*)arg[0]));
  else   (((::pat::PackedCandidate*)o)->daughter)(*(::size_t*)arg[0]);
}

static  void method_59809( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::pat::PackedCandidate*)o)->daughter)(*(const ::std::string*)arg[0]));
  else   (((::pat::PackedCandidate*)o)->daughter)(*(const ::std::string*)arg[0]);
}

static  void method_59810( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PackedCandidate*)o)->daughter)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::PackedCandidate*)o)->daughter)(*(const ::std::string*)arg[0]);
}

static  void method_59811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PackedCandidate*)o)->numberOfSourceCandidatePtrs)());
  else   (((const ::pat::PackedCandidate*)o)->numberOfSourceCandidatePtrs)();
}

static  void method_59812( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtr)((((const ::pat::PackedCandidate*)o)->sourceCandidatePtr)(*(::size_t*)arg[0]));
  else   (((const ::pat::PackedCandidate*)o)->sourceCandidatePtr)(*(::size_t*)arg[0]);
}

static  void method_59813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PackedCandidate*)o)->charge)());
  else   (((const ::pat::PackedCandidate*)o)->charge)();
}

static  void method_59814( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setCharge)(*(int*)arg[0]);
}

static  void method_59815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PackedCandidate*)o)->threeCharge)());
  else   (((const ::pat::PackedCandidate*)o)->threeCharge)();
}

static  void method_59816( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setThreeCharge)(*(int*)arg[0]);
}

static  void method_59817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PackedCandidate*)o)->p4)();
  else   (((const ::pat::PackedCandidate*)o)->p4)();
}

static  void method_59818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PackedCandidate*)o)->polarP4)();
  else   (((const ::pat::PackedCandidate*)o)->polarP4)();
}

static  void method_59819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (math::XYZVector)((((const ::pat::PackedCandidate*)o)->momentum)());
  else   (((const ::pat::PackedCandidate*)o)->momentum)();
}

static  void method_59820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (math::XYZVector)((((const ::pat::PackedCandidate*)o)->boostToCM)());
  else   (((const ::pat::PackedCandidate*)o)->boostToCM)();
}

static  void method_59821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->p)());
  else   (((const ::pat::PackedCandidate*)o)->p)();
}

static  void method_59822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->energy)());
  else   (((const ::pat::PackedCandidate*)o)->energy)();
}

static  void method_59823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->et)());
  else   (((const ::pat::PackedCandidate*)o)->et)();
}

static  void method_59824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedCandidate*)o)->mass)());
  else   (((const ::pat::PackedCandidate*)o)->mass)();
}

static  void method_59825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedCandidate*)o)->massSqr)());
  else   (((const ::pat::PackedCandidate*)o)->massSqr)();
}

static  void method_59826( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->mt)());
  else   (((const ::pat::PackedCandidate*)o)->mt)();
}

static  void method_59827( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->mtSqr)());
  else   (((const ::pat::PackedCandidate*)o)->mtSqr)();
}

static  void method_59828( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->px)());
  else   (((const ::pat::PackedCandidate*)o)->px)();
}

static  void method_59829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->py)());
  else   (((const ::pat::PackedCandidate*)o)->py)();
}

static  void method_59830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->pz)());
  else   (((const ::pat::PackedCandidate*)o)->pz)();
}

static  void method_59831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedCandidate*)o)->pt)());
  else   (((const ::pat::PackedCandidate*)o)->pt)();
}

static  void method_59832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedCandidate*)o)->phi)());
  else   (((const ::pat::PackedCandidate*)o)->phi)();
}

static  void method_59833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedCandidate*)o)->phiAtVtx)());
  else   (((const ::pat::PackedCandidate*)o)->phiAtVtx)();
}

static  void method_59834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->theta)());
  else   (((const ::pat::PackedCandidate*)o)->theta)();
}

static  void method_59835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedCandidate*)o)->eta)());
  else   (((const ::pat::PackedCandidate*)o)->eta)();
}

static  void method_59836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->rapidity)());
  else   (((const ::pat::PackedCandidate*)o)->rapidity)();
}

static  void method_59837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->y)());
  else   (((const ::pat::PackedCandidate*)o)->y)();
}

static  void method_59838( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setP4)(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static  void method_59839( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setP4)(*(const ::math::PtEtaPhiMLorentzVector*)arg[0]);
}

static  void method_59840( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setMass)(*(double*)arg[0]);
}

static  void method_59841( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setPz)(*(double*)arg[0]);
}

static  void method_59842( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setTrackProperties)(*(const ::reco::Track*)arg[0],
    *(const ::ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >*)arg[1]);
}

static  void method_59843( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setTrackProperties)(*(const ::reco::Track*)arg[0]);
}

static  void method_59844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PackedCandidate*)o)->numberOfPixelHits)());
  else   (((const ::pat::PackedCandidate*)o)->numberOfPixelHits)();
}

static  void method_59845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PackedCandidate*)o)->numberOfHits)());
  else   (((const ::pat::PackedCandidate*)o)->numberOfHits)();
}

static  void method_59846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PackedCandidate*)o)->vertex)();
  else   (((const ::pat::PackedCandidate*)o)->vertex)();
}

static  void method_59847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->vx)());
  else   (((const ::pat::PackedCandidate*)o)->vx)();
}

static  void method_59848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->vy)());
  else   (((const ::pat::PackedCandidate*)o)->vy)();
}

static  void method_59849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->vz)());
  else   (((const ::pat::PackedCandidate*)o)->vz)();
}

static  void method_59850( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setVertex)(*(const ::math::XYZPoint*)arg[0]);
}

static  void method_59851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PackedCandidate*)o)->fromPV)());
  else   (((const ::pat::PackedCandidate*)o)->fromPV)();
}

static  void method_59852( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setFromPV)(*(::pat::PackedCandidate::PVAssoc*)arg[0]);
}

static  void method_59853( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setVertexRef)(*(const ::reco::VertexRef*)arg[0]);
}

static  void method_59854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::VertexRef)((((const ::pat::PackedCandidate*)o)->vertexRef)());
  else   (((const ::pat::PackedCandidate*)o)->vertexRef)();
}

static  void method_59855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedCandidate*)o)->dxy)());
  else   (((const ::pat::PackedCandidate*)o)->dxy)();
}

static  void method_59856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedCandidate*)o)->dz)());
  else   (((const ::pat::PackedCandidate*)o)->dz)();
}

static  void method_59857( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedCandidate*)o)->dxy)(*(const ::math::XYZPoint*)arg[0]));
  else   (((const ::pat::PackedCandidate*)o)->dxy)(*(const ::math::XYZPoint*)arg[0]);
}

static  void method_59858( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedCandidate*)o)->dz)(*(const ::math::XYZPoint*)arg[0]));
  else   (((const ::pat::PackedCandidate*)o)->dz)(*(const ::math::XYZPoint*)arg[0]);
}

static  void method_59859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedCandidate*)o)->dzError)());
  else   (((const ::pat::PackedCandidate*)o)->dzError)();
}

static  void method_59860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PackedCandidate*)o)->dxyError)());
  else   (((const ::pat::PackedCandidate*)o)->dxyError)();
}

static  void method_59861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Track)((((const ::pat::PackedCandidate*)o)->pseudoTrack)());
  else   (((const ::pat::PackedCandidate*)o)->pseudoTrack)();
}

static  void method_59862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedCandidate*)o)->trackHighPurity)());
  else   (((const ::pat::PackedCandidate*)o)->trackHighPurity)();
}

static  void method_59863( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setTrackHighPurity)(*(bool*)arg[0]);
}

static  void method_59864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PackedCandidate*)o)->lostInnerHits)());
  else   (((const ::pat::PackedCandidate*)o)->lostInnerHits)();
}

static  void method_59865( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setLostInnerHits)(*(::pat::PackedCandidate::LostInnerHits*)arg[0]);
}

static  void method_59866( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setMuonID)(*(bool*)arg[0],
    *(bool*)arg[1]);
}

static  void method_59867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PackedCandidate*)o)->pdgId)());
  else   (((const ::pat::PackedCandidate*)o)->pdgId)();
}

static  void method_59868( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setPdgId)(*(int*)arg[0]);
}

static  void method_59869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PackedCandidate*)o)->status)());
  else   (((const ::pat::PackedCandidate*)o)->status)();
}

static  void method_59870( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PackedCandidate*)o)->setStatus)(*(int*)arg[0]);
}

static  void method_59871( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::PackedCandidate*)o)->setLongLived)();
}

static  void method_59872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedCandidate*)o)->longLived)());
  else   (((const ::pat::PackedCandidate*)o)->longLived)();
}

static  void method_59873( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::PackedCandidate*)o)->setMassConstraint)();
}

static  void method_59874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedCandidate*)o)->massConstraint)());
  else   (((const ::pat::PackedCandidate*)o)->massConstraint)();
}

static  void method_59875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PackedCandidate*)o)->clone)());
  else   (((const ::pat::PackedCandidate*)o)->clone)();
}

static  void method_59876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->vertexChi2)());
  else   (((const ::pat::PackedCandidate*)o)->vertexChi2)();
}

static  void method_59877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->vertexNdof)());
  else   (((const ::pat::PackedCandidate*)o)->vertexNdof)();
}

static  void method_59878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->vertexNormalizedChi2)());
  else   (((const ::pat::PackedCandidate*)o)->vertexNormalizedChi2)();
}

static  void method_59879( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::PackedCandidate*)o)->vertexCovariance)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::pat::PackedCandidate*)o)->vertexCovariance)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_59880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >)((((const ::pat::PackedCandidate*)o)->vertexCovariance)());
  else   (((const ::pat::PackedCandidate*)o)->vertexCovariance)();
}

static  void method_59881( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::pat::PackedCandidate*)o)->fillVertexCovariance)(*(::ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >*)arg[0]);
}

static  void method_59882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedCandidate*)o)->hasMasterClone)());
  else   (((const ::pat::PackedCandidate*)o)->hasMasterClone)();
}

static  void method_59883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PackedCandidate*)o)->masterClone)();
  else   (((const ::pat::PackedCandidate*)o)->masterClone)();
}

static  void method_59884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedCandidate*)o)->hasMasterClonePtr)());
  else   (((const ::pat::PackedCandidate*)o)->hasMasterClonePtr)();
}

static  void method_59885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PackedCandidate*)o)->masterClonePtr)();
  else   (((const ::pat::PackedCandidate*)o)->masterClonePtr)();
}

static  void method_59886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedCandidate*)o)->isElectron)());
  else   (((const ::pat::PackedCandidate*)o)->isElectron)();
}

static  void method_59887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedCandidate*)o)->isMuon)());
  else   (((const ::pat::PackedCandidate*)o)->isMuon)();
}

static  void method_59888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedCandidate*)o)->isStandAloneMuon)());
  else   (((const ::pat::PackedCandidate*)o)->isStandAloneMuon)();
}

static  void method_59889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedCandidate*)o)->isGlobalMuon)());
  else   (((const ::pat::PackedCandidate*)o)->isGlobalMuon)();
}

static  void method_59890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedCandidate*)o)->isTrackerMuon)());
  else   (((const ::pat::PackedCandidate*)o)->isTrackerMuon)();
}

static  void method_59891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedCandidate*)o)->isCaloMuon)());
  else   (((const ::pat::PackedCandidate*)o)->isCaloMuon)();
}

static  void method_59892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedCandidate*)o)->isPhoton)());
  else   (((const ::pat::PackedCandidate*)o)->isPhoton)();
}

static  void method_59893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedCandidate*)o)->isConvertedPhoton)());
  else   (((const ::pat::PackedCandidate*)o)->isConvertedPhoton)();
}

static  void method_59894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PackedCandidate*)o)->isJet)());
  else   (((const ::pat::PackedCandidate*)o)->isJet)();
}

static void method_newdel_9073( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::PackedCandidate >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::PackedCandidate >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::PackedCandidate >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::PackedCandidate >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::PackedCandidate >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::PackedCandidate,::reco::Candidate >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

void read___pat__PackedCandidate_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  bool &unpacked_ = *(bool*)(target + OffsetOf(__shadow__::__pat__PackedCandidate, unpacked_));

  if( oldObj ) {}
  //--- User's code ---
    unpacked_ = false;
    
  
}

void read___pat__PackedCandidate_1( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  bool &unpackedVtx_ = *(bool*)(target + OffsetOf(__shadow__::__pat__PackedCandidate, unpackedVtx_));

  if( oldObj ) {}
  //--- User's code ---
    unpackedVtx_ = false;
    
  
}

//------Dictionary for class PackedCandidate -------------------------------
void __pat__PackedCandidate_db_datamem(Reflex::Class*);
void __pat__PackedCandidate_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__PackedCandidate_datamem_bld(&__pat__PackedCandidate_db_datamem);
Reflex::GenreflexMemberBuilder __pat__PackedCandidate_funcmem_bld(&__pat__PackedCandidate_db_funcmem);
void __pat__PackedCandidate_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(2);
  rule = &readrules[0];
  rule->fSourceClass = "pat::PackedCandidate";
  rule->fTarget      = "unpacked_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__PackedCandidate_0);
  rule->fCode        = "\n    unpacked_ = false;\n    \n  ";
  rule->fVersion     = "[1-]";
  rule = &readrules[1];
  rule->fSourceClass = "pat::PackedCandidate";
  rule->fTarget      = "unpackedVtx_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__PackedCandidate_1);
  rule->fCode        = "\n    unpackedVtx_ = false;\n    \n  ";
  rule->fVersion     = "[1-]";


  ::Reflex::ClassBuilder(Reflex::Literal("pat::PackedCandidate"), typeid(::pat::PackedCandidate), sizeof(::pat::PackedCandidate), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "13")
  .AddProperty("ioread", readrules )
  .AddBase(type_9075, ::Reflex::BaseOffset< ::pat::PackedCandidate, ::reco::Candidate >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_11459, Reflex::Literal("pat::PackedCandidate::daughters"))
  .AddTypedef(type_10223, Reflex::Literal("pat::PackedCandidate::LorentzVector"))
  .AddTypedef(type_10195, Reflex::Literal("pat::PackedCandidate::PolarLorentzVector"))
  .AddTypedef(type_10191, Reflex::Literal("pat::PackedCandidate::Point"))
  .AddTypedef(type_10222, Reflex::Literal("pat::PackedCandidate::Vector"))
  .AddTypedef(type_227, Reflex::Literal("pat::PackedCandidate::index"))
  .AddEnum(Reflex::Literal("pat::PackedCandidate::PVAssoc"), Reflex::Literal("NoPV=0;PVLoose=1;PVTight=2;PVUsedInFit=3"), &typeid(pat::PackedCandidate::PVAssoc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("pat::PackedCandidate::LostInnerHits"), Reflex::Literal("validHitInFirstPixelBarrelLayer=-1;noLostInnerHits=0;oneLostInnerHit=1;moreLostInnerHits=2"), &typeid(pat::PackedCandidate::LostInnerHits), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("pat::PackedCandidate::qualityFlagsShiftsAndMasks"), Reflex::Literal("fromPVMask=3;fromPVShift=0;trackHighPurityMask=4;trackHighPurityShift=2;lostInnerHitsMask=24;lostInnerHitsShift=3;muonFlagsMask=768;muonFlagsShift=8"), &typeid(::Reflex::UnknownType), ::Reflex::PROTECTED | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_45701, Reflex::Literal("pat::PackedCandidate::const_iterator_imp_specific"))
  .AddTypedef(type_45703, Reflex::Literal("pat::PackedCandidate::iterator_imp_specific"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20635, type_17698), Reflex::Literal("operator="), operator_59793, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17698), Reflex::Literal("PackedCandidate"), constructor_59794, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PackedCandidate"), constructor_59795, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_44753, type_73025), Reflex::Literal("PackedCandidate"), constructor_59796, 0, "c;pv", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45674, type_45678, type_990, type_72, type_73025), Reflex::Literal("PackedCandidate"), constructor_59797, 0, "p4;vtx;phiAtVtx;pdgId;pv", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45676, type_45678, type_990, type_72, type_73025), Reflex::Literal("PackedCandidate"), constructor_59798, 0, "p4;vtx;phiAtVtx;pdgId;pv", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PackedCandidate"), destructor_59799, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9073, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__PackedCandidate_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__PackedCandidate_funcmem_bld);
}

//------Delayed data member builder for class PackedCandidate -------------------
void __pat__PackedCandidate_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2024, Reflex::Literal("packedPt_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedPt_), ::Reflex::PROTECTED)
  .AddDataMember(type_2024, Reflex::Literal("packedEta_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedEta_), ::Reflex::PROTECTED)
  .AddDataMember(type_2024, Reflex::Literal("packedPhi_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedPhi_), ::Reflex::PROTECTED)
  .AddDataMember(type_2024, Reflex::Literal("packedM_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedM_), ::Reflex::PROTECTED)
  .AddDataMember(type_2024, Reflex::Literal("packedDxy_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedDxy_), ::Reflex::PROTECTED)
  .AddDataMember(type_2024, Reflex::Literal("packedDz_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedDz_), ::Reflex::PROTECTED)
  .AddDataMember(type_2024, Reflex::Literal("packedDPhi_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedDPhi_), ::Reflex::PROTECTED)
  .AddDataMember(type_2024, Reflex::Literal("packedCovarianceDxyDxy_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedCovarianceDxyDxy_), ::Reflex::PROTECTED)
  .AddDataMember(type_2024, Reflex::Literal("packedCovarianceDxyDz_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedCovarianceDxyDz_), ::Reflex::PROTECTED)
  .AddDataMember(type_2024, Reflex::Literal("packedCovarianceDzDz_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedCovarianceDzDz_), ::Reflex::PROTECTED)
  .AddDataMember(type_626, Reflex::Literal("packedCovarianceDlambdaDz_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedCovarianceDlambdaDz_), ::Reflex::PROTECTED)
  .AddDataMember(type_626, Reflex::Literal("packedCovarianceDphiDxy_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedCovarianceDphiDxy_), ::Reflex::PROTECTED)
  .AddDataMember(type_626, Reflex::Literal("packedCovarianceDptDpt_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedCovarianceDptDpt_), ::Reflex::PROTECTED)
  .AddDataMember(type_626, Reflex::Literal("packedCovarianceDetaDeta_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedCovarianceDetaDeta_), ::Reflex::PROTECTED)
  .AddDataMember(type_626, Reflex::Literal("packedCovarianceDphiDphi_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedCovarianceDphiDphi_), ::Reflex::PROTECTED)
  .AddDataMember(type_10195, Reflex::Literal("p4_"), OffsetOf(__shadow__::__pat__PackedCandidate, p4_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_10223, Reflex::Literal("p4c_"), OffsetOf(__shadow__::__pat__PackedCandidate, p4c_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_10191, Reflex::Literal("vertex_"), OffsetOf(__shadow__::__pat__PackedCandidate, vertex_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_990, Reflex::Literal("dxy_"), OffsetOf(__shadow__::__pat__PackedCandidate, dxy_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_990, Reflex::Literal("dz_"), OffsetOf(__shadow__::__pat__PackedCandidate, dz_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_990, Reflex::Literal("dphi_"), OffsetOf(__shadow__::__pat__PackedCandidate, dphi_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_72, Reflex::Literal("pdgId_"), OffsetOf(__shadow__::__pat__PackedCandidate, pdgId_), ::Reflex::PROTECTED)
  .AddDataMember(type_2024, Reflex::Literal("qualityFlags_"), OffsetOf(__shadow__::__pat__PackedCandidate, qualityFlags_), ::Reflex::PROTECTED)
  .AddDataMember(type_7389, Reflex::Literal("pvRef_"), OffsetOf(__shadow__::__pat__PackedCandidate, pvRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("unpacked_"), OffsetOf(__shadow__::__pat__PackedCandidate, unpacked_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_1810, Reflex::Literal("unpackedVtx_"), OffsetOf(__shadow__::__pat__PackedCandidate, unpackedVtx_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_990, Reflex::Literal("dxydxy_"), OffsetOf(__shadow__::__pat__PackedCandidate, dxydxy_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_990, Reflex::Literal("dzdz_"), OffsetOf(__shadow__::__pat__PackedCandidate, dzdz_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_990, Reflex::Literal("dxydz_"), OffsetOf(__shadow__::__pat__PackedCandidate, dxydz_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_990, Reflex::Literal("dlambdadz_"), OffsetOf(__shadow__::__pat__PackedCandidate, dlambdadz_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_990, Reflex::Literal("dphidxy_"), OffsetOf(__shadow__::__pat__PackedCandidate, dphidxy_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_990, Reflex::Literal("dptdpt_"), OffsetOf(__shadow__::__pat__PackedCandidate, dptdpt_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_990, Reflex::Literal("detadeta_"), OffsetOf(__shadow__::__pat__PackedCandidate, detadeta_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_990, Reflex::Literal("dphidphi_"), OffsetOf(__shadow__::__pat__PackedCandidate, dphidphi_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2051, Reflex::Literal("packedHits_"), OffsetOf(__shadow__::__pat__PackedCandidate, packedHits_), ::Reflex::PROTECTED)
  .AddDataMember(type_2051, Reflex::Literal("normalizedChi2_"), OffsetOf(__shadow__::__pat__PackedCandidate, normalizedChi2_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class PackedCandidate -------------------
void __pat__PackedCandidate_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47549), Reflex::Literal("begin"), method_59800, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47549), Reflex::Literal("end"), method_59801, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47548), Reflex::Literal("begin"), method_59802, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47548), Reflex::Literal("end"), method_59803, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("numberOfDaughters"), method_59804, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865, type_2393), Reflex::Literal("daughter"), method_59805, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("numberOfMothers"), method_59806, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865, type_2393), Reflex::Literal("mother"), method_59807, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29399, type_2393), Reflex::Literal("daughter"), method_59808, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29399, type_30686), Reflex::Literal("daughter"), method_59809, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865, type_30686), Reflex::Literal("daughter"), method_59810, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("numberOfSourceCandidatePtrs"), method_59811, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11562, type_2393), Reflex::Literal("sourceCandidatePtr"), method_59812, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("charge"), method_59813, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_72), Reflex::Literal("setCharge"), method_59814, 0, "charge", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("threeCharge"), method_59815, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_72), Reflex::Literal("setThreeCharge"), method_59816, 0, "threecharge", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45676), Reflex::Literal("p4"), method_59817, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45674), Reflex::Literal("polarP4"), method_59818, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10222), Reflex::Literal("momentum"), method_59819, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10222), Reflex::Literal("boostToCM"), method_59820, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("p"), method_59821, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("energy"), method_59822, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("et"), method_59823, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("mass"), method_59824, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("massSqr"), method_59825, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("mt"), method_59826, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("mtSqr"), method_59827, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("px"), method_59828, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("py"), method_59829, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("pz"), method_59830, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("pt"), method_59831, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("phi"), method_59832, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("phiAtVtx"), method_59833, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("theta"), method_59834, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("eta"), method_59835, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("rapidity"), method_59836, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("y"), method_59837, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_45676), Reflex::Literal("setP4"), method_59838, 0, "p4", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_45674), Reflex::Literal("setP4"), method_59839, 0, "p4", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112), Reflex::Literal("setMass"), method_59840, 0, "m", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112), Reflex::Literal("setPz"), method_59841, 0, "pz", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_21777, type_35166), Reflex::Literal("setTrackProperties"), method_59842, 0, "tk;covariance", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_21777), Reflex::Literal("setTrackProperties"), method_59843, 0, "tk", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("numberOfPixelHits"), method_59844, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("numberOfHits"), method_59845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45678), Reflex::Literal("vertex"), method_59846, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("vx"), method_59847, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("vy"), method_59848, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("vz"), method_59849, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_45678), Reflex::Literal("setVertex"), method_59850, 0, "vertex", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_59788c), Reflex::Literal("fromPV"), method_59851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_59788), Reflex::Literal("setFromPV"), method_59852, 0, "fromPV", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_73025), Reflex::Literal("setVertexRef"), method_59853, 0, "vertexRef", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11501c), Reflex::Literal("vertexRef"), method_59854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("dxy"), method_59855, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("dz"), method_59856, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_45678), Reflex::Literal("dxy"), method_59857, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_45678), Reflex::Literal("dz"), method_59858, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("dzError"), method_59859, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("dxyError"), method_59860, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11423), Reflex::Literal("pseudoTrack"), method_59861, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("trackHighPurity"), method_59862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_1810), Reflex::Literal("setTrackHighPurity"), method_59863, 0, "highPurity", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_59789), Reflex::Literal("lostInnerHits"), method_59864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_59789), Reflex::Literal("setLostInnerHits"), method_59865, 0, "hits", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_1810, type_1810), Reflex::Literal("setMuonID"), method_59866, 0, "isStandAlone;isGlobal", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("pdgId"), method_59867, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_72), Reflex::Literal("setPdgId"), method_59868, 0, "pdgId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("status"), method_59869, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_72), Reflex::Literal("setStatus"), method_59870, 0, "status", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("setLongLived"), method_59871, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("longLived"), method_59872, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("setMassConstraint"), method_59873, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("massConstraint"), method_59874, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15887), Reflex::Literal("clone"), method_59875, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("vertexChi2"), method_59876, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("vertexNdof"), method_59877, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("vertexNormalizedChi2"), method_59878, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_72, type_72), Reflex::Literal("vertexCovariance"), method_59879, 0, "i;j", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_116), Reflex::Literal("vertexCovariance"), method_59880, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35034), Reflex::Literal("fillVertexCovariance"), method_59881, 0, "v", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasMasterClone"), method_59882, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72488), Reflex::Literal("masterClone"), method_59883, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasMasterClonePtr"), method_59884, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72489), Reflex::Literal("masterClonePtr"), method_59885, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isElectron"), method_59886, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isMuon"), method_59887, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isStandAloneMuon"), method_59888, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isGlobalMuon"), method_59889, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTrackerMuon"), method_59890, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isCaloMuon"), method_59891, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPhoton"), method_59892, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isConvertedPhoton"), method_59893, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isJet"), method_59894, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<pat::PackedCandidate,std::allocator<pat::PackedCandidate> > -------------------------------
static void constructor_20645( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PackedCandidate>();
  else ::new(mem) ::std::vector<pat::PackedCandidate>();
}

static void constructor_20646( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PackedCandidate>(*(const ::std::allocator<pat::PackedCandidate>*)arg[0]);
  else ::new(mem) ::std::vector<pat::PackedCandidate>(*(const ::std::allocator<pat::PackedCandidate>*)arg[0]);
}

static void constructor_20647( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PackedCandidate>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::PackedCandidate>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PackedCandidate>(*(::std::size_t*)arg[0],
      *(const ::pat::PackedCandidate*)arg[1]);
  else ::new(mem) ::std::vector<pat::PackedCandidate>(*(::std::size_t*)arg[0],
      *(const ::pat::PackedCandidate*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PackedCandidate>(*(::std::size_t*)arg[0],
      *(const ::pat::PackedCandidate*)arg[1],
      *(const ::std::allocator<pat::PackedCandidate>*)arg[2]);
  else ::new(mem) ::std::vector<pat::PackedCandidate>(*(::std::size_t*)arg[0],
      *(const ::pat::PackedCandidate*)arg[1],
      *(const ::std::allocator<pat::PackedCandidate>*)arg[2]);
  }
}

static void constructor_20648( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PackedCandidate>(*(const ::std::vector<pat::PackedCandidate>*)arg[0]);
  else ::new(mem) ::std::vector<pat::PackedCandidate>(*(const ::std::vector<pat::PackedCandidate>*)arg[0]);
}

static void destructor_20649(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::PackedCandidate>*)o)->::std::vector<pat::PackedCandidate>::~vector)();
}
static  void operator_20650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::PackedCandidate>*)o)->operator=)(*(const ::std::vector<pat::PackedCandidate>*)arg[0]);
  else   (((::std::vector<pat::PackedCandidate>*)o)->operator=)(*(const ::std::vector<pat::PackedCandidate>*)arg[0]);
}

static  void method_20651( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::PackedCandidate>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::PackedCandidate*)arg[1]);
}

static  void method_20652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> >)((((::std::vector<pat::PackedCandidate>*)o)->begin)());
  else   (((::std::vector<pat::PackedCandidate>*)o)->begin)();
}

static  void method_20653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >)((((const ::std::vector<pat::PackedCandidate>*)o)->begin)());
  else   (((const ::std::vector<pat::PackedCandidate>*)o)->begin)();
}

static  void method_20654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> >)((((::std::vector<pat::PackedCandidate>*)o)->end)());
  else   (((::std::vector<pat::PackedCandidate>*)o)->end)();
}

static  void method_20655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >)((((const ::std::vector<pat::PackedCandidate>*)o)->end)());
  else   (((const ::std::vector<pat::PackedCandidate>*)o)->end)();
}

static  void method_20660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::PackedCandidate>*)o)->size)());
  else   (((const ::std::vector<pat::PackedCandidate>*)o)->size)();
}

static  void method_20661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::PackedCandidate>*)o)->max_size)());
  else   (((const ::std::vector<pat::PackedCandidate>*)o)->max_size)();
}

static  void method_20662( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::PackedCandidate>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::PackedCandidate>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::PackedCandidate*)arg[1]);
  }
}

static  void method_20663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::PackedCandidate>*)o)->capacity)());
  else   (((const ::std::vector<pat::PackedCandidate>*)o)->capacity)();
}

static  void method_20664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::PackedCandidate>*)o)->empty)());
  else   (((const ::std::vector<pat::PackedCandidate>*)o)->empty)();
}

static  void method_20665( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::PackedCandidate>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::PackedCandidate>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::PackedCandidate>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20667( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::PackedCandidate>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::PackedCandidate>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::PackedCandidate>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::PackedCandidate>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20670( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::PackedCandidate>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::PackedCandidate>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::PackedCandidate>*)o)->front)();
  else   (((::std::vector<pat::PackedCandidate>*)o)->front)();
}

static  void method_20672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::PackedCandidate>*)o)->front)();
  else   (((const ::std::vector<pat::PackedCandidate>*)o)->front)();
}

static  void method_20673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::PackedCandidate>*)o)->back)();
  else   (((::std::vector<pat::PackedCandidate>*)o)->back)();
}

static  void method_20674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::PackedCandidate>*)o)->back)();
  else   (((const ::std::vector<pat::PackedCandidate>*)o)->back)();
}

static  void method_20675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::PackedCandidate>*)o)->data)());
  else   (((::std::vector<pat::PackedCandidate>*)o)->data)();
}

static  void method_20676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::PackedCandidate>*)o)->data)());
  else   (((const ::std::vector<pat::PackedCandidate>*)o)->data)();
}

static  void method_20677( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::PackedCandidate>*)o)->push_back)(*(const ::pat::PackedCandidate*)arg[0]);
}

static  void method_20678( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::PackedCandidate>*)o)->pop_back)();
}

static  void method_20679( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> >)((((::std::vector<pat::PackedCandidate>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)arg[0],
    *(const ::pat::PackedCandidate*)arg[1]));
  else   (((::std::vector<pat::PackedCandidate>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)arg[0],
    *(const ::pat::PackedCandidate*)arg[1]);
}

static  void method_20680( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::PackedCandidate>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::PackedCandidate*)arg[2]);
}

static  void method_20681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> >)((((::std::vector<pat::PackedCandidate>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)arg[0]));
  else   (((::std::vector<pat::PackedCandidate>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)arg[0]);
}

static  void method_20682( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> >)((((::std::vector<pat::PackedCandidate>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)arg[1]));
  else   (((::std::vector<pat::PackedCandidate>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)arg[1]);
}

static  void method_20683( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::PackedCandidate>*)o)->swap)(*(::std::vector<pat::PackedCandidate>*)arg[0]);
}

static  void method_20684( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::PackedCandidate>*)o)->clear)();
}

static void method_newdel_3508( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::PackedCandidate> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::PackedCandidate> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::PackedCandidate> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::PackedCandidate> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::PackedCandidate> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::PackedCandidate,std::allocator<pat::PackedCandidate> >")), ::Reflex::BaseOffset< ::std::vector<pat::PackedCandidate>,::std::_Vector_base<pat::PackedCandidate,std::allocator<pat::PackedCandidate> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::PackedCandidate> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::PackedCandidate> >::Generate();
}

//------Dictionary for class vector<pat::PackedCandidate,std::allocator<pat::PackedCandidate> > -------------------------------
void __std__vector_pat__PackedCandidate__db_datamem(Reflex::Class*);
void __std__vector_pat__PackedCandidate__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__PackedCandidate__datamem_bld(&__std__vector_pat__PackedCandidate__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__PackedCandidate__funcmem_bld(&__std__vector_pat__PackedCandidate__db_funcmem);
void __std__vector_pat__PackedCandidate__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::PackedCandidate>"), typeid(::std::vector<pat::PackedCandidate>), sizeof(::std::vector<pat::PackedCandidate>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2907, ::Reflex::BaseOffset< ::std::vector<pat::PackedCandidate>, ::std::_Vector_base<pat::PackedCandidate,std::allocator<pat::PackedCandidate> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_9073, Reflex::Literal("std::vector<pat::PackedCandidate>::_Alloc_value_type"))
  .AddTypedef(type_2907, Reflex::Literal("std::vector<pat::PackedCandidate>::_Base"))
  .AddTypedef(type_3866, Reflex::Literal("std::vector<pat::PackedCandidate>::_Tp_alloc_type"))
  .AddTypedef(type_12439, Reflex::Literal("std::vector<pat::PackedCandidate>::_Alloc_traits"))
  .AddTypedef(type_9073, Reflex::Literal("std::vector<pat::PackedCandidate>::value_type"))
  .AddTypedef(type_15887, Reflex::Literal("std::vector<pat::PackedCandidate>::pointer"))
  .AddTypedef(type_17696, Reflex::Literal("std::vector<pat::PackedCandidate>::const_pointer"))
  .AddTypedef(type_20635, Reflex::Literal("std::vector<pat::PackedCandidate>::reference"))
  .AddTypedef(type_17698, Reflex::Literal("std::vector<pat::PackedCandidate>::const_reference"))
  .AddTypedef(type_12122, Reflex::Literal("std::vector<pat::PackedCandidate>::iterator"))
  .AddTypedef(type_11965, Reflex::Literal("std::vector<pat::PackedCandidate>::const_iterator"))
  .AddTypedef(type_4448, Reflex::Literal("std::vector<pat::PackedCandidate>::const_reverse_iterator"))
  .AddTypedef(type_4449, Reflex::Literal("std::vector<pat::PackedCandidate>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::PackedCandidate>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::PackedCandidate>::difference_type"))
  .AddTypedef(type_3866, Reflex::Literal("std::vector<pat::PackedCandidate>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_20645, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63387), Reflex::Literal("vector"), constructor_20646, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_17698, type_63387), Reflex::Literal("vector"), constructor_20647, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35501), Reflex::Literal("vector"), constructor_20648, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20649, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3508, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__PackedCandidate__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::PackedCandidate,std::allocator<pat::PackedCandidate> > -------------------
void __std__vector_pat__PackedCandidate__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::PackedCandidate,std::allocator<pat::PackedCandidate> > -------------------
void __std__vector_pat__PackedCandidate__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65083, type_35501), Reflex::Literal("operator="), operator_20650, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_17698), Reflex::Literal("assign"), method_20651, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12122), Reflex::Literal("begin"), method_20652, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11965), Reflex::Literal("begin"), method_20653, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12122), Reflex::Literal("end"), method_20654, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11965), Reflex::Literal("end"), method_20655, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_20660, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_20661, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_9073), Reflex::Literal("resize"), method_20662, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_20663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_20664, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_20665, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20635, type_3845), Reflex::Literal("operator[]"), operator_20666, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17698, type_3845), Reflex::Literal("operator[]"), operator_20667, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20635, type_3845), Reflex::Literal("at"), method_20669, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17698, type_3845), Reflex::Literal("at"), method_20670, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20635), Reflex::Literal("front"), method_20671, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17698), Reflex::Literal("front"), method_20672, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20635), Reflex::Literal("back"), method_20673, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17698), Reflex::Literal("back"), method_20674, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15887), Reflex::Literal("data"), method_20675, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17696), Reflex::Literal("data"), method_20676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17698), Reflex::Literal("push_back"), method_20677, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_20678, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12122, type_12122, type_17698), Reflex::Literal("insert"), method_20679, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_12122, type_3845, type_17698), Reflex::Literal("insert"), method_20680, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12122, type_12122), Reflex::Literal("erase"), method_20681, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12122, type_12122, type_12122), Reflex::Literal("erase"), method_20682, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65083), Reflex::Literal("swap"), method_20683, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_20684, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Conversion -------------------------------
static  void operator_60324( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::Conversion*)o)->operator=)(*(const ::pat::Conversion*)arg[0]);
  else   (((::pat::Conversion*)o)->operator=)(*(const ::pat::Conversion*)arg[0]);
}

static void constructor_60325( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Conversion(*(const ::pat::Conversion*)arg[0]);
  else ::new(mem) ::pat::Conversion(*(const ::pat::Conversion*)arg[0]);
}

static void constructor_60326( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Conversion();
  else ::new(mem) ::pat::Conversion();
}

static void constructor_60327( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Conversion(*(int*)arg[0]);
  else ::new(mem) ::pat::Conversion(*(int*)arg[0]);
}

static void destructor_60328(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::Conversion*)o)->::pat::Conversion::~Conversion)();
}
static  void method_60329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Conversion*)o)->vtxProb)());
  else   (((const ::pat::Conversion*)o)->vtxProb)();
}

static  void method_60330( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Conversion*)o)->setVtxProb)(*(double*)arg[0]);
}

static  void method_60331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Conversion*)o)->lxy)());
  else   (((const ::pat::Conversion*)o)->lxy)();
}

static  void method_60332( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Conversion*)o)->setLxy)(*(double*)arg[0]);
}

static  void method_60333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Conversion*)o)->nHitsMax)());
  else   (((const ::pat::Conversion*)o)->nHitsMax)();
}

static  void method_60334( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Conversion*)o)->setNHitsMax)(*(int*)arg[0]);
}

static  void method_60335( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Conversion*)o)->index)());
  else   (((const ::pat::Conversion*)o)->index)();
}

static void method_newdel_13535( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::Conversion >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::Conversion >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::Conversion >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::Conversion >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::Conversion >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Conversion -------------------------------
void __pat__Conversion_db_datamem(Reflex::Class*);
void __pat__Conversion_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__Conversion_datamem_bld(&__pat__Conversion_db_datamem);
Reflex::GenreflexMemberBuilder __pat__Conversion_funcmem_bld(&__pat__Conversion_db_funcmem);
void __pat__Conversion_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::Conversion"), typeid(::pat::Conversion), sizeof(::pat::Conversion), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "11")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20698, type_17709), Reflex::Literal("operator="), operator_60324, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17709), Reflex::Literal("Conversion"), constructor_60325, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Conversion"), constructor_60326, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72), Reflex::Literal("Conversion"), constructor_60327, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Conversion"), destructor_60328, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13535, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__Conversion_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__Conversion_funcmem_bld);
}

//------Delayed data member builder for class Conversion -------------------
void __pat__Conversion_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_112, Reflex::Literal("vtxProb_"), OffsetOf(__shadow__::__pat__Conversion, vtxProb_), ::Reflex::PRIVATE)
  .AddDataMember(type_112, Reflex::Literal("lxy_"), OffsetOf(__shadow__::__pat__Conversion, lxy_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("nHitsMax_"), OffsetOf(__shadow__::__pat__Conversion, nHitsMax_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("index_"), OffsetOf(__shadow__::__pat__Conversion, index_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Conversion -------------------
void __pat__Conversion_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112c), Reflex::Literal("vtxProb"), method_60329, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112), Reflex::Literal("setVtxProb"), method_60330, 0, "vtxProb", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112c), Reflex::Literal("lxy"), method_60331, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112), Reflex::Literal("setLxy"), method_60332, 0, "lxy", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72c), Reflex::Literal("nHitsMax"), method_60333, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_72), Reflex::Literal("setNHitsMax"), method_60334, 0, "nHitsMax", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72c), Reflex::Literal("index"), method_60335, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<pat::Conversion,std::allocator<pat::Conversion> > -------------------------------
static void constructor_20708( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Conversion>();
  else ::new(mem) ::std::vector<pat::Conversion>();
}

static void constructor_20709( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Conversion>(*(const ::std::allocator<pat::Conversion>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Conversion>(*(const ::std::allocator<pat::Conversion>*)arg[0]);
}

static void constructor_20710( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Conversion>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::Conversion>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Conversion>(*(::std::size_t*)arg[0],
      *(const ::pat::Conversion*)arg[1]);
  else ::new(mem) ::std::vector<pat::Conversion>(*(::std::size_t*)arg[0],
      *(const ::pat::Conversion*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Conversion>(*(::std::size_t*)arg[0],
      *(const ::pat::Conversion*)arg[1],
      *(const ::std::allocator<pat::Conversion>*)arg[2]);
  else ::new(mem) ::std::vector<pat::Conversion>(*(::std::size_t*)arg[0],
      *(const ::pat::Conversion*)arg[1],
      *(const ::std::allocator<pat::Conversion>*)arg[2]);
  }
}

static void constructor_20711( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Conversion>(*(const ::std::vector<pat::Conversion>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Conversion>(*(const ::std::vector<pat::Conversion>*)arg[0]);
}

static void destructor_20712(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::Conversion>*)o)->::std::vector<pat::Conversion>::~vector)();
}
static  void operator_20713( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Conversion>*)o)->operator=)(*(const ::std::vector<pat::Conversion>*)arg[0]);
  else   (((::std::vector<pat::Conversion>*)o)->operator=)(*(const ::std::vector<pat::Conversion>*)arg[0]);
}

static  void method_20714( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Conversion>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::Conversion*)arg[1]);
}

static  void method_20715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> >)((((::std::vector<pat::Conversion>*)o)->begin)());
  else   (((::std::vector<pat::Conversion>*)o)->begin)();
}

static  void method_20716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >)((((const ::std::vector<pat::Conversion>*)o)->begin)());
  else   (((const ::std::vector<pat::Conversion>*)o)->begin)();
}

static  void method_20717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> >)((((::std::vector<pat::Conversion>*)o)->end)());
  else   (((::std::vector<pat::Conversion>*)o)->end)();
}

static  void method_20718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >)((((const ::std::vector<pat::Conversion>*)o)->end)());
  else   (((const ::std::vector<pat::Conversion>*)o)->end)();
}

static  void method_20723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Conversion>*)o)->size)());
  else   (((const ::std::vector<pat::Conversion>*)o)->size)();
}

static  void method_20724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Conversion>*)o)->max_size)());
  else   (((const ::std::vector<pat::Conversion>*)o)->max_size)();
}

static  void method_20725( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::Conversion>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::Conversion>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::Conversion*)arg[1]);
  }
}

static  void method_20726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Conversion>*)o)->capacity)());
  else   (((const ::std::vector<pat::Conversion>*)o)->capacity)();
}

static  void method_20727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::Conversion>*)o)->empty)());
  else   (((const ::std::vector<pat::Conversion>*)o)->empty)();
}

static  void method_20728( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Conversion>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20729( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Conversion>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Conversion>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Conversion>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Conversion>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20732( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Conversion>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Conversion>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20733( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Conversion>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Conversion>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Conversion>*)o)->front)();
  else   (((::std::vector<pat::Conversion>*)o)->front)();
}

static  void method_20735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Conversion>*)o)->front)();
  else   (((const ::std::vector<pat::Conversion>*)o)->front)();
}

static  void method_20736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Conversion>*)o)->back)();
  else   (((::std::vector<pat::Conversion>*)o)->back)();
}

static  void method_20737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Conversion>*)o)->back)();
  else   (((const ::std::vector<pat::Conversion>*)o)->back)();
}

static  void method_20738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::Conversion>*)o)->data)());
  else   (((::std::vector<pat::Conversion>*)o)->data)();
}

static  void method_20739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::Conversion>*)o)->data)());
  else   (((const ::std::vector<pat::Conversion>*)o)->data)();
}

static  void method_20740( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Conversion>*)o)->push_back)(*(const ::pat::Conversion*)arg[0]);
}

static  void method_20741( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Conversion>*)o)->pop_back)();
}

static  void method_20742( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> >)((((::std::vector<pat::Conversion>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> >*)arg[0],
    *(const ::pat::Conversion*)arg[1]));
  else   (((::std::vector<pat::Conversion>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> >*)arg[0],
    *(const ::pat::Conversion*)arg[1]);
}

static  void method_20743( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Conversion>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::Conversion*)arg[2]);
}

static  void method_20744( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> >)((((::std::vector<pat::Conversion>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> >*)arg[0]));
  else   (((::std::vector<pat::Conversion>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> >*)arg[0]);
}

static  void method_20745( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> >)((((::std::vector<pat::Conversion>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> >*)arg[1]));
  else   (((::std::vector<pat::Conversion>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Conversion*,std::vector<pat::Conversion> >*)arg[1]);
}

static  void method_20746( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Conversion>*)o)->swap)(*(::std::vector<pat::Conversion>*)arg[0]);
}

static  void method_20747( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Conversion>*)o)->clear)();
}

static void method_newdel_3509( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Conversion> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Conversion> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Conversion> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Conversion> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Conversion> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Conversion,std::allocator<pat::Conversion> >")), ::Reflex::BaseOffset< ::std::vector<pat::Conversion>,::std::_Vector_base<pat::Conversion,std::allocator<pat::Conversion> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::Conversion> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::Conversion> >::Generate();
}

//------Dictionary for class vector<pat::Conversion,std::allocator<pat::Conversion> > -------------------------------
void __std__vector_pat__Conversion__db_datamem(Reflex::Class*);
void __std__vector_pat__Conversion__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__Conversion__datamem_bld(&__std__vector_pat__Conversion__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__Conversion__funcmem_bld(&__std__vector_pat__Conversion__db_funcmem);
void __std__vector_pat__Conversion__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::Conversion>"), typeid(::std::vector<pat::Conversion>), sizeof(::std::vector<pat::Conversion>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2831, ::Reflex::BaseOffset< ::std::vector<pat::Conversion>, ::std::_Vector_base<pat::Conversion,std::allocator<pat::Conversion> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13535, Reflex::Literal("std::vector<pat::Conversion>::_Alloc_value_type"))
  .AddTypedef(type_2831, Reflex::Literal("std::vector<pat::Conversion>::_Base"))
  .AddTypedef(type_3867, Reflex::Literal("std::vector<pat::Conversion>::_Tp_alloc_type"))
  .AddTypedef(type_12363, Reflex::Literal("std::vector<pat::Conversion>::_Alloc_traits"))
  .AddTypedef(type_13535, Reflex::Literal("std::vector<pat::Conversion>::value_type"))
  .AddTypedef(type_14444, Reflex::Literal("std::vector<pat::Conversion>::pointer"))
  .AddTypedef(type_17707, Reflex::Literal("std::vector<pat::Conversion>::const_pointer"))
  .AddTypedef(type_20698, Reflex::Literal("std::vector<pat::Conversion>::reference"))
  .AddTypedef(type_17709, Reflex::Literal("std::vector<pat::Conversion>::const_reference"))
  .AddTypedef(type_11981, Reflex::Literal("std::vector<pat::Conversion>::iterator"))
  .AddTypedef(type_11966, Reflex::Literal("std::vector<pat::Conversion>::const_iterator"))
  .AddTypedef(type_4296, Reflex::Literal("std::vector<pat::Conversion>::const_reverse_iterator"))
  .AddTypedef(type_4297, Reflex::Literal("std::vector<pat::Conversion>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::Conversion>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::Conversion>::difference_type"))
  .AddTypedef(type_3867, Reflex::Literal("std::vector<pat::Conversion>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_20708, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62400), Reflex::Literal("vector"), constructor_20709, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_17709, type_62400), Reflex::Literal("vector"), constructor_20710, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35513), Reflex::Literal("vector"), constructor_20711, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20712, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3509, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__Conversion__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::Conversion,std::allocator<pat::Conversion> > -------------------
void __std__vector_pat__Conversion__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::Conversion,std::allocator<pat::Conversion> > -------------------
void __std__vector_pat__Conversion__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65084, type_35513), Reflex::Literal("operator="), operator_20713, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_17709), Reflex::Literal("assign"), method_20714, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11981), Reflex::Literal("begin"), method_20715, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11966), Reflex::Literal("begin"), method_20716, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11981), Reflex::Literal("end"), method_20717, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11966), Reflex::Literal("end"), method_20718, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_20723, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_20724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_13535), Reflex::Literal("resize"), method_20725, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_20726, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_20727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_20728, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20698, type_3845), Reflex::Literal("operator[]"), operator_20729, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17709, type_3845), Reflex::Literal("operator[]"), operator_20730, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20698, type_3845), Reflex::Literal("at"), method_20732, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17709, type_3845), Reflex::Literal("at"), method_20733, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20698), Reflex::Literal("front"), method_20734, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17709), Reflex::Literal("front"), method_20735, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20698), Reflex::Literal("back"), method_20736, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17709), Reflex::Literal("back"), method_20737, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14444), Reflex::Literal("data"), method_20738, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17707), Reflex::Literal("data"), method_20739, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17709), Reflex::Literal("push_back"), method_20740, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_20741, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11981, type_11981, type_17709), Reflex::Literal("insert"), method_20742, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_11981, type_3845, type_17709), Reflex::Literal("insert"), method_20743, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11981, type_11981), Reflex::Literal("erase"), method_20744, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11981, type_11981, type_11981), Reflex::Literal("erase"), method_20745, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65084), Reflex::Literal("swap"), method_20746, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_20747, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Hemisphere -------------------------------
static  void operator_59931( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::Hemisphere*)o)->operator=)(*(const ::pat::Hemisphere*)arg[0]);
  else   (((::pat::Hemisphere*)o)->operator=)(*(const ::pat::Hemisphere*)arg[0]);
}

static void constructor_59932( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Hemisphere(*(const ::pat::Hemisphere*)arg[0]);
  else ::new(mem) ::pat::Hemisphere(*(const ::pat::Hemisphere*)arg[0]);
}

static void constructor_59933( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Hemisphere();
  else ::new(mem) ::pat::Hemisphere();
}

static void constructor_59934( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Hemisphere(*(const ::math::XYZTLorentzVector*)arg[0]);
  else ::new(mem) ::pat::Hemisphere(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static void destructor_59935(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::Hemisphere*)o)->::pat::Hemisphere::~Hemisphere)();
}
static void method_newdel_13517( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::Hemisphere >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::Hemisphere >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::Hemisphere >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::Hemisphere >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::Hemisphere >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::CompositePtrCandidate")), ::Reflex::BaseOffset< ::pat::Hemisphere,::reco::CompositePtrCandidate >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::Hemisphere,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::Hemisphere,::reco::Candidate >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Hemisphere -------------------------------
void __pat__Hemisphere_db_datamem(Reflex::Class*);
void __pat__Hemisphere_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__Hemisphere_datamem_bld(&__pat__Hemisphere_db_datamem);
Reflex::GenreflexMemberBuilder __pat__Hemisphere_funcmem_bld(&__pat__Hemisphere_db_funcmem);
void __pat__Hemisphere_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::Hemisphere"), typeid(::pat::Hemisphere), sizeof(::pat::Hemisphere), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_11590, ::Reflex::BaseOffset< ::pat::Hemisphere, ::reco::CompositePtrCandidate >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20761, type_17720), Reflex::Literal("operator="), operator_59931, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17720), Reflex::Literal("Hemisphere"), constructor_59932, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Hemisphere"), constructor_59933, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45676), Reflex::Literal("Hemisphere"), constructor_59934, 0, "p4", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Hemisphere"), destructor_59935, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13517, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Hemisphere -------------------
void __pat__Hemisphere_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Hemisphere -------------------
void __pat__Hemisphere_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<pat::Hemisphere,std::allocator<pat::Hemisphere> > -------------------------------
static void constructor_20771( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Hemisphere>();
  else ::new(mem) ::std::vector<pat::Hemisphere>();
}

static void constructor_20772( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Hemisphere>(*(const ::std::allocator<pat::Hemisphere>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Hemisphere>(*(const ::std::allocator<pat::Hemisphere>*)arg[0]);
}

static void constructor_20773( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Hemisphere>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::Hemisphere>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Hemisphere>(*(::std::size_t*)arg[0],
      *(const ::pat::Hemisphere*)arg[1]);
  else ::new(mem) ::std::vector<pat::Hemisphere>(*(::std::size_t*)arg[0],
      *(const ::pat::Hemisphere*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Hemisphere>(*(::std::size_t*)arg[0],
      *(const ::pat::Hemisphere*)arg[1],
      *(const ::std::allocator<pat::Hemisphere>*)arg[2]);
  else ::new(mem) ::std::vector<pat::Hemisphere>(*(::std::size_t*)arg[0],
      *(const ::pat::Hemisphere*)arg[1],
      *(const ::std::allocator<pat::Hemisphere>*)arg[2]);
  }
}

static void constructor_20774( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Hemisphere>(*(const ::std::vector<pat::Hemisphere>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Hemisphere>(*(const ::std::vector<pat::Hemisphere>*)arg[0]);
}

static void destructor_20775(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::Hemisphere>*)o)->::std::vector<pat::Hemisphere>::~vector)();
}
static  void operator_20776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Hemisphere>*)o)->operator=)(*(const ::std::vector<pat::Hemisphere>*)arg[0]);
  else   (((::std::vector<pat::Hemisphere>*)o)->operator=)(*(const ::std::vector<pat::Hemisphere>*)arg[0]);
}

static  void method_20777( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Hemisphere>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::Hemisphere*)arg[1]);
}

static  void method_20778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> >)((((::std::vector<pat::Hemisphere>*)o)->begin)());
  else   (((::std::vector<pat::Hemisphere>*)o)->begin)();
}

static  void method_20779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >)((((const ::std::vector<pat::Hemisphere>*)o)->begin)());
  else   (((const ::std::vector<pat::Hemisphere>*)o)->begin)();
}

static  void method_20780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> >)((((::std::vector<pat::Hemisphere>*)o)->end)());
  else   (((::std::vector<pat::Hemisphere>*)o)->end)();
}

static  void method_20781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >)((((const ::std::vector<pat::Hemisphere>*)o)->end)());
  else   (((const ::std::vector<pat::Hemisphere>*)o)->end)();
}

static  void method_20786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Hemisphere>*)o)->size)());
  else   (((const ::std::vector<pat::Hemisphere>*)o)->size)();
}

static  void method_20787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Hemisphere>*)o)->max_size)());
  else   (((const ::std::vector<pat::Hemisphere>*)o)->max_size)();
}

static  void method_20788( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::Hemisphere>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::Hemisphere>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::Hemisphere*)arg[1]);
  }
}

static  void method_20789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Hemisphere>*)o)->capacity)());
  else   (((const ::std::vector<pat::Hemisphere>*)o)->capacity)();
}

static  void method_20790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::Hemisphere>*)o)->empty)());
  else   (((const ::std::vector<pat::Hemisphere>*)o)->empty)();
}

static  void method_20791( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Hemisphere>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Hemisphere>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Hemisphere>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20793( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Hemisphere>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Hemisphere>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Hemisphere>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Hemisphere>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Hemisphere>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Hemisphere>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Hemisphere>*)o)->front)();
  else   (((::std::vector<pat::Hemisphere>*)o)->front)();
}

static  void method_20798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Hemisphere>*)o)->front)();
  else   (((const ::std::vector<pat::Hemisphere>*)o)->front)();
}

static  void method_20799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Hemisphere>*)o)->back)();
  else   (((::std::vector<pat::Hemisphere>*)o)->back)();
}

static  void method_20800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Hemisphere>*)o)->back)();
  else   (((const ::std::vector<pat::Hemisphere>*)o)->back)();
}

static  void method_20801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::Hemisphere>*)o)->data)());
  else   (((::std::vector<pat::Hemisphere>*)o)->data)();
}

static  void method_20802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::Hemisphere>*)o)->data)());
  else   (((const ::std::vector<pat::Hemisphere>*)o)->data)();
}

static  void method_20803( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Hemisphere>*)o)->push_back)(*(const ::pat::Hemisphere*)arg[0]);
}

static  void method_20804( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Hemisphere>*)o)->pop_back)();
}

static  void method_20805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> >)((((::std::vector<pat::Hemisphere>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> >*)arg[0],
    *(const ::pat::Hemisphere*)arg[1]));
  else   (((::std::vector<pat::Hemisphere>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> >*)arg[0],
    *(const ::pat::Hemisphere*)arg[1]);
}

static  void method_20806( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Hemisphere>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::Hemisphere*)arg[2]);
}

static  void method_20807( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> >)((((::std::vector<pat::Hemisphere>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> >*)arg[0]));
  else   (((::std::vector<pat::Hemisphere>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> >*)arg[0]);
}

static  void method_20808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> >)((((::std::vector<pat::Hemisphere>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> >*)arg[1]));
  else   (((::std::vector<pat::Hemisphere>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Hemisphere*,std::vector<pat::Hemisphere> >*)arg[1]);
}

static  void method_20809( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Hemisphere>*)o)->swap)(*(::std::vector<pat::Hemisphere>*)arg[0]);
}

static  void method_20810( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Hemisphere>*)o)->clear)();
}

static void method_newdel_3510( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Hemisphere> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Hemisphere> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Hemisphere> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Hemisphere> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Hemisphere> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Hemisphere,std::allocator<pat::Hemisphere> >")), ::Reflex::BaseOffset< ::std::vector<pat::Hemisphere>,::std::_Vector_base<pat::Hemisphere,std::allocator<pat::Hemisphere> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::Hemisphere> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::Hemisphere> >::Generate();
}

//------Dictionary for class vector<pat::Hemisphere,std::allocator<pat::Hemisphere> > -------------------------------
void __std__vector_pat__Hemisphere__db_datamem(Reflex::Class*);
void __std__vector_pat__Hemisphere__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__Hemisphere__datamem_bld(&__std__vector_pat__Hemisphere__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__Hemisphere__funcmem_bld(&__std__vector_pat__Hemisphere__db_funcmem);
void __std__vector_pat__Hemisphere__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::Hemisphere>"), typeid(::std::vector<pat::Hemisphere>), sizeof(::std::vector<pat::Hemisphere>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2832, ::Reflex::BaseOffset< ::std::vector<pat::Hemisphere>, ::std::_Vector_base<pat::Hemisphere,std::allocator<pat::Hemisphere> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13517, Reflex::Literal("std::vector<pat::Hemisphere>::_Alloc_value_type"))
  .AddTypedef(type_2832, Reflex::Literal("std::vector<pat::Hemisphere>::_Base"))
  .AddTypedef(type_3868, Reflex::Literal("std::vector<pat::Hemisphere>::_Tp_alloc_type"))
  .AddTypedef(type_12364, Reflex::Literal("std::vector<pat::Hemisphere>::_Alloc_traits"))
  .AddTypedef(type_13517, Reflex::Literal("std::vector<pat::Hemisphere>::value_type"))
  .AddTypedef(type_14463, Reflex::Literal("std::vector<pat::Hemisphere>::pointer"))
  .AddTypedef(type_17718, Reflex::Literal("std::vector<pat::Hemisphere>::const_pointer"))
  .AddTypedef(type_20761, Reflex::Literal("std::vector<pat::Hemisphere>::reference"))
  .AddTypedef(type_17720, Reflex::Literal("std::vector<pat::Hemisphere>::const_reference"))
  .AddTypedef(type_11982, Reflex::Literal("std::vector<pat::Hemisphere>::iterator"))
  .AddTypedef(type_11967, Reflex::Literal("std::vector<pat::Hemisphere>::const_iterator"))
  .AddTypedef(type_4298, Reflex::Literal("std::vector<pat::Hemisphere>::const_reverse_iterator"))
  .AddTypedef(type_4299, Reflex::Literal("std::vector<pat::Hemisphere>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::Hemisphere>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::Hemisphere>::difference_type"))
  .AddTypedef(type_3868, Reflex::Literal("std::vector<pat::Hemisphere>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_20771, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62413), Reflex::Literal("vector"), constructor_20772, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_17720, type_62413), Reflex::Literal("vector"), constructor_20773, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35525), Reflex::Literal("vector"), constructor_20774, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20775, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3510, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__Hemisphere__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::Hemisphere,std::allocator<pat::Hemisphere> > -------------------
void __std__vector_pat__Hemisphere__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::Hemisphere,std::allocator<pat::Hemisphere> > -------------------
void __std__vector_pat__Hemisphere__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65085, type_35525), Reflex::Literal("operator="), operator_20776, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_17720), Reflex::Literal("assign"), method_20777, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11982), Reflex::Literal("begin"), method_20778, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11967), Reflex::Literal("begin"), method_20779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11982), Reflex::Literal("end"), method_20780, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11967), Reflex::Literal("end"), method_20781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_20786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_20787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_13517), Reflex::Literal("resize"), method_20788, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_20789, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_20790, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_20791, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20761, type_3845), Reflex::Literal("operator[]"), operator_20792, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17720, type_3845), Reflex::Literal("operator[]"), operator_20793, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20761, type_3845), Reflex::Literal("at"), method_20795, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17720, type_3845), Reflex::Literal("at"), method_20796, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20761), Reflex::Literal("front"), method_20797, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17720), Reflex::Literal("front"), method_20798, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20761), Reflex::Literal("back"), method_20799, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17720), Reflex::Literal("back"), method_20800, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14463), Reflex::Literal("data"), method_20801, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17718), Reflex::Literal("data"), method_20802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17720), Reflex::Literal("push_back"), method_20803, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_20804, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11982, type_11982, type_17720), Reflex::Literal("insert"), method_20805, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_11982, type_3845, type_17720), Reflex::Literal("insert"), method_20806, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11982, type_11982), Reflex::Literal("erase"), method_20807, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11982, type_11982, type_11982), Reflex::Literal("erase"), method_20808, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65085), Reflex::Literal("swap"), method_20809, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_20810, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class GenericParticle -------------------------------
static  void operator_60467( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::GenericParticle*)o)->operator=)(*(const ::pat::GenericParticle*)arg[0]);
  else   (((::pat::GenericParticle*)o)->operator=)(*(const ::pat::GenericParticle*)arg[0]);
}

static void constructor_60468( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::GenericParticle(*(const ::pat::GenericParticle*)arg[0]);
  else ::new(mem) ::pat::GenericParticle(*(const ::pat::GenericParticle*)arg[0]);
}

static void constructor_60469( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::GenericParticle();
  else ::new(mem) ::pat::GenericParticle();
}

static void constructor_60470( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::GenericParticle(*(const ::reco::Candidate*)arg[0]);
  else ::new(mem) ::pat::GenericParticle(*(const ::reco::Candidate*)arg[0]);
}

static void constructor_60471( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::GenericParticle(*(const ::edm::RefToBase<reco::Candidate>*)arg[0]);
  else ::new(mem) ::pat::GenericParticle(*(const ::edm::RefToBase<reco::Candidate>*)arg[0]);
}

static void constructor_60472( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::GenericParticle(*(const ::edm::Ptr<reco::Candidate>*)arg[0]);
  else ::new(mem) ::pat::GenericParticle(*(const ::edm::Ptr<reco::Candidate>*)arg[0]);
}

static void destructor_60473(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::GenericParticle*)o)->::pat::GenericParticle::~GenericParticle)();
}
static  void method_60474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::GenericParticle*)o)->clone)());
  else   (((const ::pat::GenericParticle*)o)->clone)();
}

static  void method_60475( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::GenericParticle*)o)->overlap)(*(const ::reco::Candidate*)arg[0]));
  else   (((const ::pat::GenericParticle*)o)->overlap)(*(const ::reco::Candidate*)arg[0]);
}

static  void method_60476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::GenericParticle*)o)->track)());
  else   (((const ::pat::GenericParticle*)o)->track)();
}

static  void method_60477( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::GenericParticle*)o)->track)(*(::size_t*)arg[0]));
  else   (((const ::pat::GenericParticle*)o)->track)(*(::size_t*)arg[0]);
}

static  void method_60478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::GenericParticle*)o)->numberOfTracks)());
  else   (((const ::pat::GenericParticle*)o)->numberOfTracks)();
}

static  void method_60479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::GsfTrackRef)((((const ::pat::GenericParticle*)o)->gsfTrack)());
  else   (((const ::pat::GenericParticle*)o)->gsfTrack)();
}

static  void method_60480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::GenericParticle*)o)->standAloneMuon)());
  else   (((const ::pat::GenericParticle*)o)->standAloneMuon)();
}

static  void method_60481( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::GenericParticle*)o)->combinedMuon)());
  else   (((const ::pat::GenericParticle*)o)->combinedMuon)();
}

static  void method_60482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::SuperClusterRef)((((const ::pat::GenericParticle*)o)->superCluster)());
  else   (((const ::pat::GenericParticle*)o)->superCluster)();
}

static  void method_60483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CaloTowerRef)((((const ::pat::GenericParticle*)o)->caloTower)());
  else   (((const ::pat::GenericParticle*)o)->caloTower)();
}

static  void method_60484( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::GenericParticle*)o)->setTrack)(*(const ::reco::TrackRef*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::GenericParticle*)o)->setTrack)(*(const ::reco::TrackRef*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_60485( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::GenericParticle*)o)->setTracks)(*(const ::reco::TrackRefVector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::GenericParticle*)o)->setTracks)(*(const ::reco::TrackRefVector*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_60486( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::GenericParticle*)o)->setStandAloneMuon)(*(const ::reco::TrackRef*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::GenericParticle*)o)->setStandAloneMuon)(*(const ::reco::TrackRef*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_60487( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::GenericParticle*)o)->setCombinedMuon)(*(const ::reco::TrackRef*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::GenericParticle*)o)->setCombinedMuon)(*(const ::reco::TrackRef*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_60488( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::GenericParticle*)o)->setGsfTrack)(*(const ::reco::GsfTrackRef*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::GenericParticle*)o)->setGsfTrack)(*(const ::reco::GsfTrackRef*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_60489( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::GenericParticle*)o)->setSuperCluster)(*(const ::reco::SuperClusterRef*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::GenericParticle*)o)->setSuperCluster)(*(const ::reco::SuperClusterRef*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_60490( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::GenericParticle*)o)->setCaloTower)(*(const ::CaloTowerRef*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::GenericParticle*)o)->setCaloTower)(*(const ::CaloTowerRef*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_60491( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::GenericParticle*)o)->embedTrack)();
}

static  void method_60492( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::GenericParticle*)o)->embedTracks)();
}

static  void method_60493( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::GenericParticle*)o)->embedStandalone)();
}

static  void method_60494( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::GenericParticle*)o)->embedCombined)();
}

static  void method_60495( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::GenericParticle*)o)->embedGsfTrack)();
}

static  void method_60496( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::GenericParticle*)o)->embedSuperCluster)();
}

static  void method_60497( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::GenericParticle*)o)->embedCaloTower)();
}

static  void method_60498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((::pat::GenericParticle*)o)->quality)());
  else   (((::pat::GenericParticle*)o)->quality)();
}

static  void method_60499( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::GenericParticle*)o)->setQuality)(*(float*)arg[0]);
}

static  void method_60500( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::GenericParticle*)o)->userIsolation)(*(::pat::IsolationKeys*)arg[0]));
  else   (((const ::pat::GenericParticle*)o)->userIsolation)(*(::pat::IsolationKeys*)arg[0]);
}

static  void method_60501( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::GenericParticle*)o)->userIsolation)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::GenericParticle*)o)->userIsolation)(*(const ::std::string*)arg[0]);
}

static  void method_60502( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::GenericParticle*)o)->setIsolation)(*(::pat::IsolationKeys*)arg[0],
    *(float*)arg[1]);
}

static  void method_60503( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::GenericParticle*)o)->trackIso)());
  else   (((const ::pat::GenericParticle*)o)->trackIso)();
}

static  void method_60504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::GenericParticle*)o)->caloIso)());
  else   (((const ::pat::GenericParticle*)o)->caloIso)();
}

static  void method_60505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::GenericParticle*)o)->ecalIso)());
  else   (((const ::pat::GenericParticle*)o)->ecalIso)();
}

static  void method_60506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::GenericParticle*)o)->hcalIso)());
  else   (((const ::pat::GenericParticle*)o)->hcalIso)();
}

static  void method_60507( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::GenericParticle*)o)->setTrackIso)(*(float*)arg[0]);
}

static  void method_60508( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::GenericParticle*)o)->setEcalIso)(*(float*)arg[0]);
}

static  void method_60509( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::GenericParticle*)o)->setHcalIso)(*(float*)arg[0]);
}

static  void method_60510( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::GenericParticle*)o)->setUserIso)(*(float*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::GenericParticle*)o)->setUserIso)(*(float*)arg[0],
      *(::uint8_t*)arg[1]);
  }
}

static  void method_60511( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::GenericParticle*)o)->isoDeposit)(*(::pat::IsolationKeys*)arg[0]));
  else   (((const ::pat::GenericParticle*)o)->isoDeposit)(*(::pat::IsolationKeys*)arg[0]);
}

static  void method_60512( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::GenericParticle*)o)->setIsoDeposit)(*(::pat::IsolationKeys*)arg[0],
    *(const ::pat::IsoDeposit*)arg[1]);
}

static  void method_60513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::GenericParticle*)o)->trackIsoDeposit)());
  else   (((const ::pat::GenericParticle*)o)->trackIsoDeposit)();
}

static  void method_60514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::GenericParticle*)o)->ecalIsoDeposit)());
  else   (((const ::pat::GenericParticle*)o)->ecalIsoDeposit)();
}

static  void method_60515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::GenericParticle*)o)->hcalIsoDeposit)());
  else   (((const ::pat::GenericParticle*)o)->hcalIsoDeposit)();
}

static  void method_60516( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::GenericParticle*)o)->userIsoDeposit)());
    else     (((const ::pat::GenericParticle*)o)->userIsoDeposit)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::GenericParticle*)o)->userIsoDeposit)(*(::uint8_t*)arg[0]));
    else     (((const ::pat::GenericParticle*)o)->userIsoDeposit)(*(::uint8_t*)arg[0]);
  }
}

static  void method_60517( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::GenericParticle*)o)->trackIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
}

static  void method_60518( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::GenericParticle*)o)->ecalIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
}

static  void method_60519( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::GenericParticle*)o)->hcalIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
}

static  void method_60520( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::GenericParticle*)o)->userIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::GenericParticle*)o)->userIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0],
      *(::uint8_t*)arg[1]);
  }
}

static  void method_60521( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::GenericParticle*)o)->vertexAssociation)());
    else     (((const ::pat::GenericParticle*)o)->vertexAssociation)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::GenericParticle*)o)->vertexAssociation)(*(::size_t*)arg[0]));
    else     (((const ::pat::GenericParticle*)o)->vertexAssociation)(*(::size_t*)arg[0]);
  }
}

static  void method_60522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::GenericParticle*)o)->vertexAssociations)();
  else   (((const ::pat::GenericParticle*)o)->vertexAssociations)();
}

static  void method_60523( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::GenericParticle*)o)->setVertexAssociation)(*(const ::pat::VertexAssociation*)arg[0]);
}

static  void method_60524( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::GenericParticle*)o)->setVertexAssociations)(*(const ::std::vector<pat::VertexAssociation>*)arg[0]);
}

static void method_newdel_13540( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::GenericParticle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::GenericParticle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::GenericParticle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::GenericParticle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::GenericParticle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::RecoCandidate>")), ::Reflex::BaseOffset< ::pat::GenericParticle,::pat::PATObject<reco::RecoCandidate> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::pat::GenericParticle,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::GenericParticle,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::GenericParticle,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GenericParticle -------------------------------
void __pat__GenericParticle_db_datamem(Reflex::Class*);
void __pat__GenericParticle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__GenericParticle_datamem_bld(&__pat__GenericParticle_db_datamem);
Reflex::GenreflexMemberBuilder __pat__GenericParticle_funcmem_bld(&__pat__GenericParticle_db_funcmem);
void __pat__GenericParticle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::GenericParticle"), typeid(::pat::GenericParticle), sizeof(::pat::GenericParticle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_13546, ::Reflex::BaseOffset< ::pat::GenericParticle, ::pat::PATObject<reco::RecoCandidate> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3523, Reflex::Literal("pat::GenericParticle::IsoDepositPairs"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20824, type_17731), Reflex::Literal("operator="), operator_60467, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17731), Reflex::Literal("GenericParticle"), constructor_60468, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenericParticle"), constructor_60469, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_44753), Reflex::Literal("GenericParticle"), constructor_60470, 0, "aGenericParticle", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22542), Reflex::Literal("GenericParticle"), constructor_60471, 0, "aGenericParticleRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22032), Reflex::Literal("GenericParticle"), constructor_60472, 0, "aGenericParticleRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenericParticle"), destructor_60473, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13540, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__GenericParticle_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__GenericParticle_funcmem_bld);
}

//------Delayed data member builder for class GenericParticle -------------------
void __pat__GenericParticle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_11589, Reflex::Literal("trackRef_"), OffsetOf(__shadow__::__pat__GenericParticle, trackRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_11589, Reflex::Literal("standaloneTrackRef_"), OffsetOf(__shadow__::__pat__GenericParticle, standaloneTrackRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_11589, Reflex::Literal("combinedTrackRef_"), OffsetOf(__shadow__::__pat__GenericParticle, combinedTrackRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_11604, Reflex::Literal("track_"), OffsetOf(__shadow__::__pat__GenericParticle, track_), ::Reflex::PROTECTED)
  .AddDataMember(type_11604, Reflex::Literal("standaloneTrack_"), OffsetOf(__shadow__::__pat__GenericParticle, standaloneTrack_), ::Reflex::PROTECTED)
  .AddDataMember(type_11604, Reflex::Literal("combinedTrack_"), OffsetOf(__shadow__::__pat__GenericParticle, combinedTrack_), ::Reflex::PROTECTED)
  .AddDataMember(type_11616, Reflex::Literal("gsfTrackRef_"), OffsetOf(__shadow__::__pat__GenericParticle, gsfTrackRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_11617, Reflex::Literal("gsfTrack_"), OffsetOf(__shadow__::__pat__GenericParticle, gsfTrack_), ::Reflex::PROTECTED)
  .AddDataMember(type_1019, Reflex::Literal("caloTowerRef_"), OffsetOf(__shadow__::__pat__GenericParticle, caloTowerRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_870, Reflex::Literal("caloTower_"), OffsetOf(__shadow__::__pat__GenericParticle, caloTower_), ::Reflex::PROTECTED)
  .AddDataMember(type_11485, Reflex::Literal("superClusterRef_"), OffsetOf(__shadow__::__pat__GenericParticle, superClusterRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_11553, Reflex::Literal("superCluster_"), OffsetOf(__shadow__::__pat__GenericParticle, superCluster_), ::Reflex::PROTECTED)
  .AddDataMember(type_11498, Reflex::Literal("trackRefs_"), OffsetOf(__shadow__::__pat__GenericParticle, trackRefs_), ::Reflex::PROTECTED)
  .AddDataMember(type_11604, Reflex::Literal("tracks_"), OffsetOf(__shadow__::__pat__GenericParticle, tracks_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("quality_"), OffsetOf(__shadow__::__pat__GenericParticle, quality_), ::Reflex::PROTECTED)
  .AddDataMember(type_3523, Reflex::Literal("isoDeposits_"), OffsetOf(__shadow__::__pat__GenericParticle, isoDeposits_), ::Reflex::PROTECTED)
  .AddDataMember(type_3527, Reflex::Literal("isolations_"), OffsetOf(__shadow__::__pat__GenericParticle, isolations_), ::Reflex::PROTECTED)
  .AddDataMember(type_3522, Reflex::Literal("vtxAss_"), OffsetOf(__shadow__::__pat__GenericParticle, vtxAss_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class GenericParticle -------------------
void __pat__GenericParticle_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14501), Reflex::Literal("clone"), method_60474, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_44753), Reflex::Literal("overlap"), method_60475, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("track"), method_60476, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589, type_2393), Reflex::Literal("track"), method_60477, 0, "idx", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("numberOfTracks"), method_60478, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11616), Reflex::Literal("gsfTrack"), method_60479, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("standAloneMuon"), method_60480, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("combinedMuon"), method_60481, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11485), Reflex::Literal("superCluster"), method_60482, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1019), Reflex::Literal("caloTower"), method_60483, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_72994, type_1810), Reflex::Literal("setTrack"), method_60484, 0, "ref;embed=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_73028, type_1810), Reflex::Literal("setTracks"), method_60485, 0, "refs;embed=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_72994, type_1810), Reflex::Literal("setStandAloneMuon"), method_60486, 0, "ref;embed=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_72994, type_1810), Reflex::Literal("setCombinedMuon"), method_60487, 0, "ref;embed=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_73008, type_1810), Reflex::Literal("setGsfTrack"), method_60488, 0, "ref;embed=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_73176, type_1810), Reflex::Literal("setSuperCluster"), method_60489, 0, "ref;embed=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75146, type_1810), Reflex::Literal("setCaloTower"), method_60490, 0, "ref;embed=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedTrack"), method_60491, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedTracks"), method_60492, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedStandalone"), method_60493, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedCombined"), method_60494, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedGsfTrack"), method_60495, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedSuperCluster"), method_60496, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedCaloTower"), method_60497, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("quality"), method_60498, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setQuality"), method_60499, 0, "quality", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_13493), Reflex::Literal("userIsolation"), method_60500, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_30686), Reflex::Literal("userIsolation"), method_60501, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_13493, type_990), Reflex::Literal("setIsolation"), method_60502, 0, "key;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("trackIso"), method_60503, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("caloIso"), method_60504, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("ecalIso"), method_60505, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("hcalIso"), method_60506, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setTrackIso"), method_60507, 0, "trackIso", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setEcalIso"), method_60508, 0, "caloIso", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setHcalIso"), method_60509, 0, "caloIso", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990, type_2051), Reflex::Literal("setUserIso"), method_60510, 0, "value;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131, type_13493), Reflex::Literal("isoDeposit"), method_60511, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_13493, type_75132), Reflex::Literal("setIsoDeposit"), method_60512, 0, "key;dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131), Reflex::Literal("trackIsoDeposit"), method_60513, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131), Reflex::Literal("ecalIsoDeposit"), method_60514, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131), Reflex::Literal("hcalIsoDeposit"), method_60515, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131, type_2051), Reflex::Literal("userIsoDeposit"), method_60516, 0, "index=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132), Reflex::Literal("trackIsoDeposit"), method_60517, 0, "dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132), Reflex::Literal("ecalIsoDeposit"), method_60518, 0, "dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132), Reflex::Literal("hcalIsoDeposit"), method_60519, 0, "dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132, type_2051), Reflex::Literal("userIsoDeposit"), method_60520, 0, "dep;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21516, type_2393), Reflex::Literal("vertexAssociation"), method_60521, 0, "index=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65099), Reflex::Literal("vertexAssociations"), method_60522, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_21520), Reflex::Literal("setVertexAssociation"), method_60523, 0, "assoc", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65099), Reflex::Literal("setVertexAssociations"), method_60524, 0, "assocs", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<pat::GenericParticle,std::allocator<pat::GenericParticle> > -------------------------------
static void constructor_20834( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::GenericParticle>();
  else ::new(mem) ::std::vector<pat::GenericParticle>();
}

static void constructor_20835( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::GenericParticle>(*(const ::std::allocator<pat::GenericParticle>*)arg[0]);
  else ::new(mem) ::std::vector<pat::GenericParticle>(*(const ::std::allocator<pat::GenericParticle>*)arg[0]);
}

static void constructor_20836( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::GenericParticle>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::GenericParticle>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::GenericParticle>(*(::std::size_t*)arg[0],
      *(const ::pat::GenericParticle*)arg[1]);
  else ::new(mem) ::std::vector<pat::GenericParticle>(*(::std::size_t*)arg[0],
      *(const ::pat::GenericParticle*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::GenericParticle>(*(::std::size_t*)arg[0],
      *(const ::pat::GenericParticle*)arg[1],
      *(const ::std::allocator<pat::GenericParticle>*)arg[2]);
  else ::new(mem) ::std::vector<pat::GenericParticle>(*(::std::size_t*)arg[0],
      *(const ::pat::GenericParticle*)arg[1],
      *(const ::std::allocator<pat::GenericParticle>*)arg[2]);
  }
}

static void constructor_20837( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::GenericParticle>(*(const ::std::vector<pat::GenericParticle>*)arg[0]);
  else ::new(mem) ::std::vector<pat::GenericParticle>(*(const ::std::vector<pat::GenericParticle>*)arg[0]);
}

static void destructor_20838(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::GenericParticle>*)o)->::std::vector<pat::GenericParticle>::~vector)();
}
static  void operator_20839( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::GenericParticle>*)o)->operator=)(*(const ::std::vector<pat::GenericParticle>*)arg[0]);
  else   (((::std::vector<pat::GenericParticle>*)o)->operator=)(*(const ::std::vector<pat::GenericParticle>*)arg[0]);
}

static  void method_20840( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::GenericParticle>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::GenericParticle*)arg[1]);
}

static  void method_20841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> >)((((::std::vector<pat::GenericParticle>*)o)->begin)());
  else   (((::std::vector<pat::GenericParticle>*)o)->begin)();
}

static  void method_20842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >)((((const ::std::vector<pat::GenericParticle>*)o)->begin)());
  else   (((const ::std::vector<pat::GenericParticle>*)o)->begin)();
}

static  void method_20843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> >)((((::std::vector<pat::GenericParticle>*)o)->end)());
  else   (((::std::vector<pat::GenericParticle>*)o)->end)();
}

static  void method_20844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >)((((const ::std::vector<pat::GenericParticle>*)o)->end)());
  else   (((const ::std::vector<pat::GenericParticle>*)o)->end)();
}

static  void method_20849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::GenericParticle>*)o)->size)());
  else   (((const ::std::vector<pat::GenericParticle>*)o)->size)();
}

static  void method_20850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::GenericParticle>*)o)->max_size)());
  else   (((const ::std::vector<pat::GenericParticle>*)o)->max_size)();
}

static  void method_20851( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::GenericParticle>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::GenericParticle>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::GenericParticle*)arg[1]);
  }
}

static  void method_20852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::GenericParticle>*)o)->capacity)());
  else   (((const ::std::vector<pat::GenericParticle>*)o)->capacity)();
}

static  void method_20853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::GenericParticle>*)o)->empty)());
  else   (((const ::std::vector<pat::GenericParticle>*)o)->empty)();
}

static  void method_20854( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::GenericParticle>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20855( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::GenericParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::GenericParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20856( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::GenericParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::GenericParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20858( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::GenericParticle>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::GenericParticle>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20859( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::GenericParticle>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::GenericParticle>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::GenericParticle>*)o)->front)();
  else   (((::std::vector<pat::GenericParticle>*)o)->front)();
}

static  void method_20861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::GenericParticle>*)o)->front)();
  else   (((const ::std::vector<pat::GenericParticle>*)o)->front)();
}

static  void method_20862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::GenericParticle>*)o)->back)();
  else   (((::std::vector<pat::GenericParticle>*)o)->back)();
}

static  void method_20863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::GenericParticle>*)o)->back)();
  else   (((const ::std::vector<pat::GenericParticle>*)o)->back)();
}

static  void method_20864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::GenericParticle>*)o)->data)());
  else   (((::std::vector<pat::GenericParticle>*)o)->data)();
}

static  void method_20865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::GenericParticle>*)o)->data)());
  else   (((const ::std::vector<pat::GenericParticle>*)o)->data)();
}

static  void method_20866( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::GenericParticle>*)o)->push_back)(*(const ::pat::GenericParticle*)arg[0]);
}

static  void method_20867( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::GenericParticle>*)o)->pop_back)();
}

static  void method_20868( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> >)((((::std::vector<pat::GenericParticle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> >*)arg[0],
    *(const ::pat::GenericParticle*)arg[1]));
  else   (((::std::vector<pat::GenericParticle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> >*)arg[0],
    *(const ::pat::GenericParticle*)arg[1]);
}

static  void method_20869( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::GenericParticle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::GenericParticle*)arg[2]);
}

static  void method_20870( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> >)((((::std::vector<pat::GenericParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> >*)arg[0]));
  else   (((::std::vector<pat::GenericParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> >*)arg[0]);
}

static  void method_20871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> >)((((::std::vector<pat::GenericParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> >*)arg[1]));
  else   (((::std::vector<pat::GenericParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::GenericParticle*,std::vector<pat::GenericParticle> >*)arg[1]);
}

static  void method_20872( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::GenericParticle>*)o)->swap)(*(::std::vector<pat::GenericParticle>*)arg[0]);
}

static  void method_20873( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::GenericParticle>*)o)->clear)();
}

static void method_newdel_3511( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::GenericParticle> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::GenericParticle> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::GenericParticle> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::GenericParticle> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::GenericParticle> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::GenericParticle,std::allocator<pat::GenericParticle> >")), ::Reflex::BaseOffset< ::std::vector<pat::GenericParticle>,::std::_Vector_base<pat::GenericParticle,std::allocator<pat::GenericParticle> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x23( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::GenericParticle> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::GenericParticle> >::Generate();
}

//------Dictionary for class vector<pat::GenericParticle,std::allocator<pat::GenericParticle> > -------------------------------
void __std__vector_pat__GenericParticle__db_datamem(Reflex::Class*);
void __std__vector_pat__GenericParticle__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__GenericParticle__datamem_bld(&__std__vector_pat__GenericParticle__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__GenericParticle__funcmem_bld(&__std__vector_pat__GenericParticle__db_funcmem);
void __std__vector_pat__GenericParticle__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::GenericParticle>"), typeid(::std::vector<pat::GenericParticle>), sizeof(::std::vector<pat::GenericParticle>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2834, ::Reflex::BaseOffset< ::std::vector<pat::GenericParticle>, ::std::_Vector_base<pat::GenericParticle,std::allocator<pat::GenericParticle> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13540, Reflex::Literal("std::vector<pat::GenericParticle>::_Alloc_value_type"))
  .AddTypedef(type_2834, Reflex::Literal("std::vector<pat::GenericParticle>::_Base"))
  .AddTypedef(type_3869, Reflex::Literal("std::vector<pat::GenericParticle>::_Tp_alloc_type"))
  .AddTypedef(type_12366, Reflex::Literal("std::vector<pat::GenericParticle>::_Alloc_traits"))
  .AddTypedef(type_13540, Reflex::Literal("std::vector<pat::GenericParticle>::value_type"))
  .AddTypedef(type_14501, Reflex::Literal("std::vector<pat::GenericParticle>::pointer"))
  .AddTypedef(type_17729, Reflex::Literal("std::vector<pat::GenericParticle>::const_pointer"))
  .AddTypedef(type_20824, Reflex::Literal("std::vector<pat::GenericParticle>::reference"))
  .AddTypedef(type_17731, Reflex::Literal("std::vector<pat::GenericParticle>::const_reference"))
  .AddTypedef(type_11987, Reflex::Literal("std::vector<pat::GenericParticle>::iterator"))
  .AddTypedef(type_11968, Reflex::Literal("std::vector<pat::GenericParticle>::const_iterator"))
  .AddTypedef(type_4302, Reflex::Literal("std::vector<pat::GenericParticle>::const_reverse_iterator"))
  .AddTypedef(type_4303, Reflex::Literal("std::vector<pat::GenericParticle>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::GenericParticle>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::GenericParticle>::difference_type"))
  .AddTypedef(type_3869, Reflex::Literal("std::vector<pat::GenericParticle>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_20834, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62439), Reflex::Literal("vector"), constructor_20835, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_17731, type_62439), Reflex::Literal("vector"), constructor_20836, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35537), Reflex::Literal("vector"), constructor_20837, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20838, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3511, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__GenericParticle__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::GenericParticle,std::allocator<pat::GenericParticle> > -------------------
void __std__vector_pat__GenericParticle__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::GenericParticle,std::allocator<pat::GenericParticle> > -------------------
void __std__vector_pat__GenericParticle__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65086, type_35537), Reflex::Literal("operator="), operator_20839, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_17731), Reflex::Literal("assign"), method_20840, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11987), Reflex::Literal("begin"), method_20841, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11968), Reflex::Literal("begin"), method_20842, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11987), Reflex::Literal("end"), method_20843, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11968), Reflex::Literal("end"), method_20844, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_20849, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_20850, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_13540), Reflex::Literal("resize"), method_20851, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_20852, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_20853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_20854, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20824, type_3845), Reflex::Literal("operator[]"), operator_20855, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17731, type_3845), Reflex::Literal("operator[]"), operator_20856, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20824, type_3845), Reflex::Literal("at"), method_20858, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17731, type_3845), Reflex::Literal("at"), method_20859, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20824), Reflex::Literal("front"), method_20860, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17731), Reflex::Literal("front"), method_20861, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20824), Reflex::Literal("back"), method_20862, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17731), Reflex::Literal("back"), method_20863, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14501), Reflex::Literal("data"), method_20864, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17729), Reflex::Literal("data"), method_20865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17731), Reflex::Literal("push_back"), method_20866, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_20867, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11987, type_11987, type_17731), Reflex::Literal("insert"), method_20868, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_11987, type_3845, type_17731), Reflex::Literal("insert"), method_20869, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11987, type_11987), Reflex::Literal("erase"), method_20870, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11987, type_11987, type_11987), Reflex::Literal("erase"), method_20871, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65086), Reflex::Literal("swap"), method_20872, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_20873, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PFParticle -------------------------------
static  void operator_59449( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::PFParticle*)o)->operator=)(*(const ::pat::PFParticle*)arg[0]);
  else   (((::pat::PFParticle*)o)->operator=)(*(const ::pat::PFParticle*)arg[0]);
}

static void constructor_59450( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PFParticle(*(const ::pat::PFParticle*)arg[0]);
  else ::new(mem) ::pat::PFParticle(*(const ::pat::PFParticle*)arg[0]);
}

static void constructor_59451( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PFParticle();
  else ::new(mem) ::pat::PFParticle();
}

static void constructor_59452( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PFParticle(*(const ::edm::RefToBase<reco::PFCandidate>*)arg[0]);
  else ::new(mem) ::pat::PFParticle(*(const ::edm::RefToBase<reco::PFCandidate>*)arg[0]);
}

static void destructor_59453(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::PFParticle*)o)->::pat::PFParticle::~PFParticle)();
}
static  void method_59454( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PFParticle*)o)->clone)());
  else   (((const ::pat::PFParticle*)o)->clone)();
}

static void method_newdel_13478( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::PFParticle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::PFParticle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::PFParticle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::PFParticle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::PFParticle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x25( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::PFCandidate>")), ::Reflex::BaseOffset< ::pat::PFParticle,::pat::PATObject<reco::PFCandidate> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::PFCandidate")), ::Reflex::BaseOffset< ::pat::PFParticle,::reco::PFCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::CompositeCandidate")), ::Reflex::BaseOffset< ::pat::PFParticle,::reco::CompositeCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::PFParticle,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::PFParticle,::reco::Candidate >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PFParticle -------------------------------
void __pat__PFParticle_db_datamem(Reflex::Class*);
void __pat__PFParticle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__PFParticle_datamem_bld(&__pat__PFParticle_db_datamem);
Reflex::GenreflexMemberBuilder __pat__PFParticle_funcmem_bld(&__pat__PFParticle_db_funcmem);
void __pat__PFParticle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::PFParticle"), typeid(::pat::PFParticle), sizeof(::pat::PFParticle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_13547, ::Reflex::BaseOffset< ::pat::PFParticle, ::pat::PATObject<reco::PFCandidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20887, type_17742), Reflex::Literal("operator="), operator_59449, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17742), Reflex::Literal("PFParticle"), constructor_59450, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PFParticle"), constructor_59451, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71877), Reflex::Literal("PFParticle"), constructor_59452, 0, "aPFParticle", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PFParticle"), destructor_59453, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13478, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x25, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__pat__PFParticle_funcmem_bld);
}

//------Delayed data member builder for class PFParticle -------------------
void __pat__PFParticle_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PFParticle -------------------
void __pat__PFParticle_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14520), Reflex::Literal("clone"), method_59454, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<pat::PFParticle,std::allocator<pat::PFParticle> > -------------------------------
static void constructor_20897( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PFParticle>();
  else ::new(mem) ::std::vector<pat::PFParticle>();
}

static void constructor_20898( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PFParticle>(*(const ::std::allocator<pat::PFParticle>*)arg[0]);
  else ::new(mem) ::std::vector<pat::PFParticle>(*(const ::std::allocator<pat::PFParticle>*)arg[0]);
}

static void constructor_20899( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PFParticle>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::PFParticle>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PFParticle>(*(::std::size_t*)arg[0],
      *(const ::pat::PFParticle*)arg[1]);
  else ::new(mem) ::std::vector<pat::PFParticle>(*(::std::size_t*)arg[0],
      *(const ::pat::PFParticle*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PFParticle>(*(::std::size_t*)arg[0],
      *(const ::pat::PFParticle*)arg[1],
      *(const ::std::allocator<pat::PFParticle>*)arg[2]);
  else ::new(mem) ::std::vector<pat::PFParticle>(*(::std::size_t*)arg[0],
      *(const ::pat::PFParticle*)arg[1],
      *(const ::std::allocator<pat::PFParticle>*)arg[2]);
  }
}

static void constructor_20900( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::PFParticle>(*(const ::std::vector<pat::PFParticle>*)arg[0]);
  else ::new(mem) ::std::vector<pat::PFParticle>(*(const ::std::vector<pat::PFParticle>*)arg[0]);
}

static void destructor_20901(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::PFParticle>*)o)->::std::vector<pat::PFParticle>::~vector)();
}
static  void operator_20902( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::PFParticle>*)o)->operator=)(*(const ::std::vector<pat::PFParticle>*)arg[0]);
  else   (((::std::vector<pat::PFParticle>*)o)->operator=)(*(const ::std::vector<pat::PFParticle>*)arg[0]);
}

static  void method_20903( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::PFParticle>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::PFParticle*)arg[1]);
}

static  void method_20904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> >)((((::std::vector<pat::PFParticle>*)o)->begin)());
  else   (((::std::vector<pat::PFParticle>*)o)->begin)();
}

static  void method_20905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >)((((const ::std::vector<pat::PFParticle>*)o)->begin)());
  else   (((const ::std::vector<pat::PFParticle>*)o)->begin)();
}

static  void method_20906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> >)((((::std::vector<pat::PFParticle>*)o)->end)());
  else   (((::std::vector<pat::PFParticle>*)o)->end)();
}

static  void method_20907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >)((((const ::std::vector<pat::PFParticle>*)o)->end)());
  else   (((const ::std::vector<pat::PFParticle>*)o)->end)();
}

static  void method_20912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::PFParticle>*)o)->size)());
  else   (((const ::std::vector<pat::PFParticle>*)o)->size)();
}

static  void method_20913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::PFParticle>*)o)->max_size)());
  else   (((const ::std::vector<pat::PFParticle>*)o)->max_size)();
}

static  void method_20914( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::PFParticle>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::PFParticle>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::PFParticle*)arg[1]);
  }
}

static  void method_20915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::PFParticle>*)o)->capacity)());
  else   (((const ::std::vector<pat::PFParticle>*)o)->capacity)();
}

static  void method_20916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::PFParticle>*)o)->empty)());
  else   (((const ::std::vector<pat::PFParticle>*)o)->empty)();
}

static  void method_20917( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::PFParticle>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::PFParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::PFParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::PFParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::PFParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::PFParticle>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::PFParticle>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::PFParticle>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::PFParticle>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::PFParticle>*)o)->front)();
  else   (((::std::vector<pat::PFParticle>*)o)->front)();
}

static  void method_20924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::PFParticle>*)o)->front)();
  else   (((const ::std::vector<pat::PFParticle>*)o)->front)();
}

static  void method_20925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::PFParticle>*)o)->back)();
  else   (((::std::vector<pat::PFParticle>*)o)->back)();
}

static  void method_20926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::PFParticle>*)o)->back)();
  else   (((const ::std::vector<pat::PFParticle>*)o)->back)();
}

static  void method_20927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::PFParticle>*)o)->data)());
  else   (((::std::vector<pat::PFParticle>*)o)->data)();
}

static  void method_20928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::PFParticle>*)o)->data)());
  else   (((const ::std::vector<pat::PFParticle>*)o)->data)();
}

static  void method_20929( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::PFParticle>*)o)->push_back)(*(const ::pat::PFParticle*)arg[0]);
}

static  void method_20930( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::PFParticle>*)o)->pop_back)();
}

static  void method_20931( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> >)((((::std::vector<pat::PFParticle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> >*)arg[0],
    *(const ::pat::PFParticle*)arg[1]));
  else   (((::std::vector<pat::PFParticle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> >*)arg[0],
    *(const ::pat::PFParticle*)arg[1]);
}

static  void method_20932( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::PFParticle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::PFParticle*)arg[2]);
}

static  void method_20933( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> >)((((::std::vector<pat::PFParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> >*)arg[0]));
  else   (((::std::vector<pat::PFParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> >*)arg[0]);
}

static  void method_20934( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> >)((((::std::vector<pat::PFParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> >*)arg[1]));
  else   (((::std::vector<pat::PFParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::PFParticle*,std::vector<pat::PFParticle> >*)arg[1]);
}

static  void method_20935( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::PFParticle>*)o)->swap)(*(::std::vector<pat::PFParticle>*)arg[0]);
}

static  void method_20936( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::PFParticle>*)o)->clear)();
}

static void method_newdel_3512( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::PFParticle> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::PFParticle> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::PFParticle> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::PFParticle> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::PFParticle> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::PFParticle,std::allocator<pat::PFParticle> >")), ::Reflex::BaseOffset< ::std::vector<pat::PFParticle>,::std::_Vector_base<pat::PFParticle,std::allocator<pat::PFParticle> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::PFParticle> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::PFParticle> >::Generate();
}

//------Dictionary for class vector<pat::PFParticle,std::allocator<pat::PFParticle> > -------------------------------
void __std__vector_pat__PFParticle__db_datamem(Reflex::Class*);
void __std__vector_pat__PFParticle__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__PFParticle__datamem_bld(&__std__vector_pat__PFParticle__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__PFParticle__funcmem_bld(&__std__vector_pat__PFParticle__db_funcmem);
void __std__vector_pat__PFParticle__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::PFParticle>"), typeid(::std::vector<pat::PFParticle>), sizeof(::std::vector<pat::PFParticle>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2835, ::Reflex::BaseOffset< ::std::vector<pat::PFParticle>, ::std::_Vector_base<pat::PFParticle,std::allocator<pat::PFParticle> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13478, Reflex::Literal("std::vector<pat::PFParticle>::_Alloc_value_type"))
  .AddTypedef(type_2835, Reflex::Literal("std::vector<pat::PFParticle>::_Base"))
  .AddTypedef(type_3870, Reflex::Literal("std::vector<pat::PFParticle>::_Tp_alloc_type"))
  .AddTypedef(type_12367, Reflex::Literal("std::vector<pat::PFParticle>::_Alloc_traits"))
  .AddTypedef(type_13478, Reflex::Literal("std::vector<pat::PFParticle>::value_type"))
  .AddTypedef(type_14520, Reflex::Literal("std::vector<pat::PFParticle>::pointer"))
  .AddTypedef(type_17740, Reflex::Literal("std::vector<pat::PFParticle>::const_pointer"))
  .AddTypedef(type_20887, Reflex::Literal("std::vector<pat::PFParticle>::reference"))
  .AddTypedef(type_17742, Reflex::Literal("std::vector<pat::PFParticle>::const_reference"))
  .AddTypedef(type_11988, Reflex::Literal("std::vector<pat::PFParticle>::iterator"))
  .AddTypedef(type_11969, Reflex::Literal("std::vector<pat::PFParticle>::const_iterator"))
  .AddTypedef(type_4304, Reflex::Literal("std::vector<pat::PFParticle>::const_reverse_iterator"))
  .AddTypedef(type_4305, Reflex::Literal("std::vector<pat::PFParticle>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::PFParticle>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::PFParticle>::difference_type"))
  .AddTypedef(type_3870, Reflex::Literal("std::vector<pat::PFParticle>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_20897, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62452), Reflex::Literal("vector"), constructor_20898, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_17742, type_62452), Reflex::Literal("vector"), constructor_20899, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35549), Reflex::Literal("vector"), constructor_20900, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20901, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3512, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__PFParticle__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::PFParticle,std::allocator<pat::PFParticle> > -------------------
void __std__vector_pat__PFParticle__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::PFParticle,std::allocator<pat::PFParticle> > -------------------
void __std__vector_pat__PFParticle__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65087, type_35549), Reflex::Literal("operator="), operator_20902, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_17742), Reflex::Literal("assign"), method_20903, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11988), Reflex::Literal("begin"), method_20904, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11969), Reflex::Literal("begin"), method_20905, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11988), Reflex::Literal("end"), method_20906, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11969), Reflex::Literal("end"), method_20907, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_20912, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_20913, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_13478), Reflex::Literal("resize"), method_20914, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_20915, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_20916, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_20917, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20887, type_3845), Reflex::Literal("operator[]"), operator_20918, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17742, type_3845), Reflex::Literal("operator[]"), operator_20919, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20887, type_3845), Reflex::Literal("at"), method_20921, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17742, type_3845), Reflex::Literal("at"), method_20922, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20887), Reflex::Literal("front"), method_20923, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17742), Reflex::Literal("front"), method_20924, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20887), Reflex::Literal("back"), method_20925, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17742), Reflex::Literal("back"), method_20926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14520), Reflex::Literal("data"), method_20927, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17740), Reflex::Literal("data"), method_20928, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17742), Reflex::Literal("push_back"), method_20929, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_20930, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11988, type_11988, type_17742), Reflex::Literal("insert"), method_20931, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_11988, type_3845, type_17742), Reflex::Literal("insert"), method_20932, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11988, type_11988), Reflex::Literal("erase"), method_20933, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11988, type_11988, type_11988), Reflex::Literal("erase"), method_20934, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65087), Reflex::Literal("swap"), method_20935, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_20936, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class CompositeCandidate -------------------------------
static  void operator_61786( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::CompositeCandidate*)o)->operator=)(*(const ::pat::CompositeCandidate*)arg[0]);
  else   (((::pat::CompositeCandidate*)o)->operator=)(*(const ::pat::CompositeCandidate*)arg[0]);
}

static void constructor_61787( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::CompositeCandidate(*(const ::pat::CompositeCandidate*)arg[0]);
  else ::new(mem) ::pat::CompositeCandidate(*(const ::pat::CompositeCandidate*)arg[0]);
}

static void constructor_61788( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::CompositeCandidate();
  else ::new(mem) ::pat::CompositeCandidate();
}

static void constructor_61789( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::CompositeCandidate(*(const ::reco::CompositeCandidate*)arg[0]);
  else ::new(mem) ::pat::CompositeCandidate(*(const ::reco::CompositeCandidate*)arg[0]);
}

static void destructor_61790(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::CompositeCandidate*)o)->::pat::CompositeCandidate::~CompositeCandidate)();
}
static  void method_61791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::CompositeCandidate*)o)->clone)());
  else   (((const ::pat::CompositeCandidate*)o)->clone)();
}

static void method_newdel_13564( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::CompositeCandidate >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::CompositeCandidate >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::CompositeCandidate >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::CompositeCandidate >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::CompositeCandidate >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::CompositeCandidate>")), ::Reflex::BaseOffset< ::pat::CompositeCandidate,::pat::PATObject<reco::CompositeCandidate> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::CompositeCandidate")), ::Reflex::BaseOffset< ::pat::CompositeCandidate,::reco::CompositeCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::CompositeCandidate,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::CompositeCandidate,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class CompositeCandidate -------------------------------
void __pat__CompositeCandidate_db_datamem(Reflex::Class*);
void __pat__CompositeCandidate_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__CompositeCandidate_datamem_bld(&__pat__CompositeCandidate_db_datamem);
Reflex::GenreflexMemberBuilder __pat__CompositeCandidate_funcmem_bld(&__pat__CompositeCandidate_db_funcmem);
void __pat__CompositeCandidate_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::CompositeCandidate"), typeid(::pat::CompositeCandidate), sizeof(::pat::CompositeCandidate), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_13548, ::Reflex::BaseOffset< ::pat::CompositeCandidate, ::pat::PATObject<reco::CompositeCandidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20950, type_17753), Reflex::Literal("operator="), operator_61786, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17753), Reflex::Literal("CompositeCandidate"), constructor_61787, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CompositeCandidate"), constructor_61788, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28501), Reflex::Literal("CompositeCandidate"), constructor_61789, 0, "aCompositeCandidate", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CompositeCandidate"), destructor_61790, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13564, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__pat__CompositeCandidate_funcmem_bld);
}

//------Delayed data member builder for class CompositeCandidate -------------------
void __pat__CompositeCandidate_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class CompositeCandidate -------------------
void __pat__CompositeCandidate_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14539), Reflex::Literal("clone"), method_61791, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<pat::CompositeCandidate,std::allocator<pat::CompositeCandidate> > -------------------------------
static void constructor_20960( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::CompositeCandidate>();
  else ::new(mem) ::std::vector<pat::CompositeCandidate>();
}

static void constructor_20961( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::CompositeCandidate>(*(const ::std::allocator<pat::CompositeCandidate>*)arg[0]);
  else ::new(mem) ::std::vector<pat::CompositeCandidate>(*(const ::std::allocator<pat::CompositeCandidate>*)arg[0]);
}

static void constructor_20962( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::CompositeCandidate>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::CompositeCandidate>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::CompositeCandidate>(*(::std::size_t*)arg[0],
      *(const ::pat::CompositeCandidate*)arg[1]);
  else ::new(mem) ::std::vector<pat::CompositeCandidate>(*(::std::size_t*)arg[0],
      *(const ::pat::CompositeCandidate*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::CompositeCandidate>(*(::std::size_t*)arg[0],
      *(const ::pat::CompositeCandidate*)arg[1],
      *(const ::std::allocator<pat::CompositeCandidate>*)arg[2]);
  else ::new(mem) ::std::vector<pat::CompositeCandidate>(*(::std::size_t*)arg[0],
      *(const ::pat::CompositeCandidate*)arg[1],
      *(const ::std::allocator<pat::CompositeCandidate>*)arg[2]);
  }
}

static void constructor_20963( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::CompositeCandidate>(*(const ::std::vector<pat::CompositeCandidate>*)arg[0]);
  else ::new(mem) ::std::vector<pat::CompositeCandidate>(*(const ::std::vector<pat::CompositeCandidate>*)arg[0]);
}

static void destructor_20964(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::CompositeCandidate>*)o)->::std::vector<pat::CompositeCandidate>::~vector)();
}
static  void operator_20965( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::CompositeCandidate>*)o)->operator=)(*(const ::std::vector<pat::CompositeCandidate>*)arg[0]);
  else   (((::std::vector<pat::CompositeCandidate>*)o)->operator=)(*(const ::std::vector<pat::CompositeCandidate>*)arg[0]);
}

static  void method_20966( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::CompositeCandidate>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::CompositeCandidate*)arg[1]);
}

static  void method_20967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >)((((::std::vector<pat::CompositeCandidate>*)o)->begin)());
  else   (((::std::vector<pat::CompositeCandidate>*)o)->begin)();
}

static  void method_20968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >)((((const ::std::vector<pat::CompositeCandidate>*)o)->begin)());
  else   (((const ::std::vector<pat::CompositeCandidate>*)o)->begin)();
}

static  void method_20969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >)((((::std::vector<pat::CompositeCandidate>*)o)->end)());
  else   (((::std::vector<pat::CompositeCandidate>*)o)->end)();
}

static  void method_20970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >)((((const ::std::vector<pat::CompositeCandidate>*)o)->end)());
  else   (((const ::std::vector<pat::CompositeCandidate>*)o)->end)();
}

static  void method_20975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::CompositeCandidate>*)o)->size)());
  else   (((const ::std::vector<pat::CompositeCandidate>*)o)->size)();
}

static  void method_20976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::CompositeCandidate>*)o)->max_size)());
  else   (((const ::std::vector<pat::CompositeCandidate>*)o)->max_size)();
}

static  void method_20977( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::CompositeCandidate>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::CompositeCandidate>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::CompositeCandidate*)arg[1]);
  }
}

static  void method_20978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::CompositeCandidate>*)o)->capacity)());
  else   (((const ::std::vector<pat::CompositeCandidate>*)o)->capacity)();
}

static  void method_20979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::CompositeCandidate>*)o)->empty)());
  else   (((const ::std::vector<pat::CompositeCandidate>*)o)->empty)();
}

static  void method_20980( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::CompositeCandidate>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::CompositeCandidate>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::CompositeCandidate>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::CompositeCandidate>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::CompositeCandidate>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::CompositeCandidate>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::CompositeCandidate>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20985( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::CompositeCandidate>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::CompositeCandidate>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::CompositeCandidate>*)o)->front)();
  else   (((::std::vector<pat::CompositeCandidate>*)o)->front)();
}

static  void method_20987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::CompositeCandidate>*)o)->front)();
  else   (((const ::std::vector<pat::CompositeCandidate>*)o)->front)();
}

static  void method_20988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::CompositeCandidate>*)o)->back)();
  else   (((::std::vector<pat::CompositeCandidate>*)o)->back)();
}

static  void method_20989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::CompositeCandidate>*)o)->back)();
  else   (((const ::std::vector<pat::CompositeCandidate>*)o)->back)();
}

static  void method_20990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::CompositeCandidate>*)o)->data)());
  else   (((::std::vector<pat::CompositeCandidate>*)o)->data)();
}

static  void method_20991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::CompositeCandidate>*)o)->data)());
  else   (((const ::std::vector<pat::CompositeCandidate>*)o)->data)();
}

static  void method_20992( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::CompositeCandidate>*)o)->push_back)(*(const ::pat::CompositeCandidate*)arg[0]);
}

static  void method_20993( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::CompositeCandidate>*)o)->pop_back)();
}

static  void method_20994( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >)((((::std::vector<pat::CompositeCandidate>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)arg[0],
    *(const ::pat::CompositeCandidate*)arg[1]));
  else   (((::std::vector<pat::CompositeCandidate>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)arg[0],
    *(const ::pat::CompositeCandidate*)arg[1]);
}

static  void method_20995( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::CompositeCandidate>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::CompositeCandidate*)arg[2]);
}

static  void method_20996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >)((((::std::vector<pat::CompositeCandidate>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)arg[0]));
  else   (((::std::vector<pat::CompositeCandidate>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)arg[0]);
}

static  void method_20997( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >)((((::std::vector<pat::CompositeCandidate>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)arg[1]));
  else   (((::std::vector<pat::CompositeCandidate>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)arg[1]);
}

static  void method_20998( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::CompositeCandidate>*)o)->swap)(*(::std::vector<pat::CompositeCandidate>*)arg[0]);
}

static  void method_20999( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::CompositeCandidate>*)o)->clear)();
}

static void method_newdel_3513( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::CompositeCandidate> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::CompositeCandidate> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::CompositeCandidate> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::CompositeCandidate> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::CompositeCandidate> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x32( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::CompositeCandidate,std::allocator<pat::CompositeCandidate> >")), ::Reflex::BaseOffset< ::std::vector<pat::CompositeCandidate>,::std::_Vector_base<pat::CompositeCandidate,std::allocator<pat::CompositeCandidate> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::CompositeCandidate> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::CompositeCandidate> >::Generate();
}

//------Dictionary for class vector<pat::CompositeCandidate,std::allocator<pat::CompositeCandidate> > -------------------------------
void __std__vector_pat__CompositeCandidate__db_datamem(Reflex::Class*);
void __std__vector_pat__CompositeCandidate__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__CompositeCandidate__datamem_bld(&__std__vector_pat__CompositeCandidate__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__CompositeCandidate__funcmem_bld(&__std__vector_pat__CompositeCandidate__db_funcmem);
void __std__vector_pat__CompositeCandidate__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::CompositeCandidate>"), typeid(::std::vector<pat::CompositeCandidate>), sizeof(::std::vector<pat::CompositeCandidate>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2836, ::Reflex::BaseOffset< ::std::vector<pat::CompositeCandidate>, ::std::_Vector_base<pat::CompositeCandidate,std::allocator<pat::CompositeCandidate> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13564, Reflex::Literal("std::vector<pat::CompositeCandidate>::_Alloc_value_type"))
  .AddTypedef(type_2836, Reflex::Literal("std::vector<pat::CompositeCandidate>::_Base"))
  .AddTypedef(type_3871, Reflex::Literal("std::vector<pat::CompositeCandidate>::_Tp_alloc_type"))
  .AddTypedef(type_12368, Reflex::Literal("std::vector<pat::CompositeCandidate>::_Alloc_traits"))
  .AddTypedef(type_13564, Reflex::Literal("std::vector<pat::CompositeCandidate>::value_type"))
  .AddTypedef(type_14539, Reflex::Literal("std::vector<pat::CompositeCandidate>::pointer"))
  .AddTypedef(type_17751, Reflex::Literal("std::vector<pat::CompositeCandidate>::const_pointer"))
  .AddTypedef(type_20950, Reflex::Literal("std::vector<pat::CompositeCandidate>::reference"))
  .AddTypedef(type_17753, Reflex::Literal("std::vector<pat::CompositeCandidate>::const_reference"))
  .AddTypedef(type_11989, Reflex::Literal("std::vector<pat::CompositeCandidate>::iterator"))
  .AddTypedef(type_11970, Reflex::Literal("std::vector<pat::CompositeCandidate>::const_iterator"))
  .AddTypedef(type_4306, Reflex::Literal("std::vector<pat::CompositeCandidate>::const_reverse_iterator"))
  .AddTypedef(type_4307, Reflex::Literal("std::vector<pat::CompositeCandidate>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::CompositeCandidate>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::CompositeCandidate>::difference_type"))
  .AddTypedef(type_3871, Reflex::Literal("std::vector<pat::CompositeCandidate>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_20960, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62465), Reflex::Literal("vector"), constructor_20961, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_17753, type_62465), Reflex::Literal("vector"), constructor_20962, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35561), Reflex::Literal("vector"), constructor_20963, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20964, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3513, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x32, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__CompositeCandidate__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::CompositeCandidate,std::allocator<pat::CompositeCandidate> > -------------------
void __std__vector_pat__CompositeCandidate__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::CompositeCandidate,std::allocator<pat::CompositeCandidate> > -------------------
void __std__vector_pat__CompositeCandidate__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65088, type_35561), Reflex::Literal("operator="), operator_20965, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_17753), Reflex::Literal("assign"), method_20966, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11989), Reflex::Literal("begin"), method_20967, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11970), Reflex::Literal("begin"), method_20968, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11989), Reflex::Literal("end"), method_20969, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11970), Reflex::Literal("end"), method_20970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_20975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_20976, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_13564), Reflex::Literal("resize"), method_20977, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_20978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_20979, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_20980, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20950, type_3845), Reflex::Literal("operator[]"), operator_20981, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17753, type_3845), Reflex::Literal("operator[]"), operator_20982, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20950, type_3845), Reflex::Literal("at"), method_20984, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17753, type_3845), Reflex::Literal("at"), method_20985, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20950), Reflex::Literal("front"), method_20986, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17753), Reflex::Literal("front"), method_20987, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20950), Reflex::Literal("back"), method_20988, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17753), Reflex::Literal("back"), method_20989, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14539), Reflex::Literal("data"), method_20990, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17751), Reflex::Literal("data"), method_20991, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17753), Reflex::Literal("push_back"), method_20992, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_20993, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11989, type_11989, type_17753), Reflex::Literal("insert"), method_20994, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_11989, type_3845, type_17753), Reflex::Literal("insert"), method_20995, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11989, type_11989), Reflex::Literal("erase"), method_20996, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11989, type_11989, type_11989), Reflex::Literal("erase"), method_20997, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65088), Reflex::Literal("swap"), method_20998, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_20999, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Particle -------------------------------
static  void operator_60149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::Particle*)o)->operator=)(*(const ::pat::Particle*)arg[0]);
  else   (((::pat::Particle*)o)->operator=)(*(const ::pat::Particle*)arg[0]);
}

static void constructor_60150( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Particle(*(const ::pat::Particle*)arg[0]);
  else ::new(mem) ::pat::Particle(*(const ::pat::Particle*)arg[0]);
}

static void constructor_60151( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Particle();
  else ::new(mem) ::pat::Particle();
}

static void constructor_60152( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Particle(*(const ::reco::LeafCandidate*)arg[0]);
  else ::new(mem) ::pat::Particle(*(const ::reco::LeafCandidate*)arg[0]);
}

static void destructor_60153(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::Particle*)o)->::pat::Particle::~Particle)();
}
static  void method_60154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Particle*)o)->clone)());
  else   (((const ::pat::Particle*)o)->clone)();
}

static void method_newdel_13527( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::Particle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::Particle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::Particle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::Particle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::Particle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x35( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::pat::Particle,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::Particle,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::Particle,::reco::Candidate >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Particle -------------------------------
void __pat__Particle_db_datamem(Reflex::Class*);
void __pat__Particle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__Particle_datamem_bld(&__pat__Particle_db_datamem);
Reflex::GenreflexMemberBuilder __pat__Particle_funcmem_bld(&__pat__Particle_db_funcmem);
void __pat__Particle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::Particle"), typeid(::pat::Particle), sizeof(::pat::Particle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_13549, ::Reflex::BaseOffset< ::pat::Particle, ::pat::PATObject<reco::LeafCandidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21013, type_17764), Reflex::Literal("operator="), operator_60149, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17764), Reflex::Literal("Particle"), constructor_60150, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Particle"), constructor_60151, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71891), Reflex::Literal("Particle"), constructor_60152, 0, "aParticle", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Particle"), destructor_60153, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13527, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x35, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__pat__Particle_funcmem_bld);
}

//------Delayed data member builder for class Particle -------------------
void __pat__Particle_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Particle -------------------
void __pat__Particle_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14558), Reflex::Literal("clone"), method_60154, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<pat::Particle,std::allocator<pat::Particle> > -------------------------------
static void constructor_21023( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Particle>();
  else ::new(mem) ::std::vector<pat::Particle>();
}

static void constructor_21024( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Particle>(*(const ::std::allocator<pat::Particle>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Particle>(*(const ::std::allocator<pat::Particle>*)arg[0]);
}

static void constructor_21025( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Particle>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::Particle>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Particle>(*(::std::size_t*)arg[0],
      *(const ::pat::Particle*)arg[1]);
  else ::new(mem) ::std::vector<pat::Particle>(*(::std::size_t*)arg[0],
      *(const ::pat::Particle*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Particle>(*(::std::size_t*)arg[0],
      *(const ::pat::Particle*)arg[1],
      *(const ::std::allocator<pat::Particle>*)arg[2]);
  else ::new(mem) ::std::vector<pat::Particle>(*(::std::size_t*)arg[0],
      *(const ::pat::Particle*)arg[1],
      *(const ::std::allocator<pat::Particle>*)arg[2]);
  }
}

static void constructor_21026( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Particle>(*(const ::std::vector<pat::Particle>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Particle>(*(const ::std::vector<pat::Particle>*)arg[0]);
}

static void destructor_21027(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::Particle>*)o)->::std::vector<pat::Particle>::~vector)();
}
static  void operator_21028( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Particle>*)o)->operator=)(*(const ::std::vector<pat::Particle>*)arg[0]);
  else   (((::std::vector<pat::Particle>*)o)->operator=)(*(const ::std::vector<pat::Particle>*)arg[0]);
}

static  void method_21029( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Particle>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::Particle*)arg[1]);
}

static  void method_21030( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> >)((((::std::vector<pat::Particle>*)o)->begin)());
  else   (((::std::vector<pat::Particle>*)o)->begin)();
}

static  void method_21031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >)((((const ::std::vector<pat::Particle>*)o)->begin)());
  else   (((const ::std::vector<pat::Particle>*)o)->begin)();
}

static  void method_21032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> >)((((::std::vector<pat::Particle>*)o)->end)());
  else   (((::std::vector<pat::Particle>*)o)->end)();
}

static  void method_21033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >)((((const ::std::vector<pat::Particle>*)o)->end)());
  else   (((const ::std::vector<pat::Particle>*)o)->end)();
}

static  void method_21038( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Particle>*)o)->size)());
  else   (((const ::std::vector<pat::Particle>*)o)->size)();
}

static  void method_21039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Particle>*)o)->max_size)());
  else   (((const ::std::vector<pat::Particle>*)o)->max_size)();
}

static  void method_21040( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::Particle>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::Particle>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::Particle*)arg[1]);
  }
}

static  void method_21041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Particle>*)o)->capacity)());
  else   (((const ::std::vector<pat::Particle>*)o)->capacity)();
}

static  void method_21042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::Particle>*)o)->empty)());
  else   (((const ::std::vector<pat::Particle>*)o)->empty)();
}

static  void method_21043( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Particle>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_21044( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Particle>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Particle>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_21045( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Particle>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Particle>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_21047( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Particle>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Particle>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21048( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Particle>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Particle>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Particle>*)o)->front)();
  else   (((::std::vector<pat::Particle>*)o)->front)();
}

static  void method_21050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Particle>*)o)->front)();
  else   (((const ::std::vector<pat::Particle>*)o)->front)();
}

static  void method_21051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Particle>*)o)->back)();
  else   (((::std::vector<pat::Particle>*)o)->back)();
}

static  void method_21052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Particle>*)o)->back)();
  else   (((const ::std::vector<pat::Particle>*)o)->back)();
}

static  void method_21053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::Particle>*)o)->data)());
  else   (((::std::vector<pat::Particle>*)o)->data)();
}

static  void method_21054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::Particle>*)o)->data)());
  else   (((const ::std::vector<pat::Particle>*)o)->data)();
}

static  void method_21055( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Particle>*)o)->push_back)(*(const ::pat::Particle*)arg[0]);
}

static  void method_21056( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Particle>*)o)->pop_back)();
}

static  void method_21057( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> >)((((::std::vector<pat::Particle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> >*)arg[0],
    *(const ::pat::Particle*)arg[1]));
  else   (((::std::vector<pat::Particle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> >*)arg[0],
    *(const ::pat::Particle*)arg[1]);
}

static  void method_21058( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Particle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::Particle*)arg[2]);
}

static  void method_21059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> >)((((::std::vector<pat::Particle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> >*)arg[0]));
  else   (((::std::vector<pat::Particle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> >*)arg[0]);
}

static  void method_21060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> >)((((::std::vector<pat::Particle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> >*)arg[1]));
  else   (((::std::vector<pat::Particle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Particle*,std::vector<pat::Particle> >*)arg[1]);
}

static  void method_21061( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Particle>*)o)->swap)(*(::std::vector<pat::Particle>*)arg[0]);
}

static  void method_21062( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Particle>*)o)->clear)();
}

static void method_newdel_3514( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Particle> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Particle> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Particle> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Particle> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Particle> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x37( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Particle,std::allocator<pat::Particle> >")), ::Reflex::BaseOffset< ::std::vector<pat::Particle>,::std::_Vector_base<pat::Particle,std::allocator<pat::Particle> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x38( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::Particle> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::Particle> >::Generate();
}

//------Dictionary for class vector<pat::Particle,std::allocator<pat::Particle> > -------------------------------
void __std__vector_pat__Particle__db_datamem(Reflex::Class*);
void __std__vector_pat__Particle__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__Particle__datamem_bld(&__std__vector_pat__Particle__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__Particle__funcmem_bld(&__std__vector_pat__Particle__db_funcmem);
void __std__vector_pat__Particle__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::Particle>"), typeid(::std::vector<pat::Particle>), sizeof(::std::vector<pat::Particle>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2837, ::Reflex::BaseOffset< ::std::vector<pat::Particle>, ::std::_Vector_base<pat::Particle,std::allocator<pat::Particle> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13527, Reflex::Literal("std::vector<pat::Particle>::_Alloc_value_type"))
  .AddTypedef(type_2837, Reflex::Literal("std::vector<pat::Particle>::_Base"))
  .AddTypedef(type_3872, Reflex::Literal("std::vector<pat::Particle>::_Tp_alloc_type"))
  .AddTypedef(type_12369, Reflex::Literal("std::vector<pat::Particle>::_Alloc_traits"))
  .AddTypedef(type_13527, Reflex::Literal("std::vector<pat::Particle>::value_type"))
  .AddTypedef(type_14558, Reflex::Literal("std::vector<pat::Particle>::pointer"))
  .AddTypedef(type_17762, Reflex::Literal("std::vector<pat::Particle>::const_pointer"))
  .AddTypedef(type_21013, Reflex::Literal("std::vector<pat::Particle>::reference"))
  .AddTypedef(type_17764, Reflex::Literal("std::vector<pat::Particle>::const_reference"))
  .AddTypedef(type_11990, Reflex::Literal("std::vector<pat::Particle>::iterator"))
  .AddTypedef(type_11971, Reflex::Literal("std::vector<pat::Particle>::const_iterator"))
  .AddTypedef(type_4308, Reflex::Literal("std::vector<pat::Particle>::const_reverse_iterator"))
  .AddTypedef(type_4309, Reflex::Literal("std::vector<pat::Particle>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::Particle>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::Particle>::difference_type"))
  .AddTypedef(type_3872, Reflex::Literal("std::vector<pat::Particle>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_21023, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62478), Reflex::Literal("vector"), constructor_21024, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_17764, type_62478), Reflex::Literal("vector"), constructor_21025, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35573), Reflex::Literal("vector"), constructor_21026, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_21027, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3514, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x37, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x38, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__Particle__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::Particle,std::allocator<pat::Particle> > -------------------
void __std__vector_pat__Particle__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::Particle,std::allocator<pat::Particle> > -------------------
void __std__vector_pat__Particle__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65089, type_35573), Reflex::Literal("operator="), operator_21028, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_17764), Reflex::Literal("assign"), method_21029, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11990), Reflex::Literal("begin"), method_21030, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11971), Reflex::Literal("begin"), method_21031, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11990), Reflex::Literal("end"), method_21032, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11971), Reflex::Literal("end"), method_21033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_21038, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_21039, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_13527), Reflex::Literal("resize"), method_21040, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_21041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_21042, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_21043, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21013, type_3845), Reflex::Literal("operator[]"), operator_21044, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17764, type_3845), Reflex::Literal("operator[]"), operator_21045, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21013, type_3845), Reflex::Literal("at"), method_21047, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17764, type_3845), Reflex::Literal("at"), method_21048, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21013), Reflex::Literal("front"), method_21049, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17764), Reflex::Literal("front"), method_21050, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21013), Reflex::Literal("back"), method_21051, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17764), Reflex::Literal("back"), method_21052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14558), Reflex::Literal("data"), method_21053, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17762), Reflex::Literal("data"), method_21054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17764), Reflex::Literal("push_back"), method_21055, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_21056, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11990, type_11990, type_17764), Reflex::Literal("insert"), method_21057, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_11990, type_3845, type_17764), Reflex::Literal("insert"), method_21058, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11990, type_11990), Reflex::Literal("erase"), method_21059, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11990, type_11990, type_11990), Reflex::Literal("erase"), method_21060, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65089), Reflex::Literal("swap"), method_21061, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_21062, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class MET -------------------------------
static void constructor_60539( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::MET();
  else ::new(mem) ::pat::MET();
}

static void constructor_60540( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::MET(*(const ::reco::MET*)arg[0]);
  else ::new(mem) ::pat::MET(*(const ::reco::MET*)arg[0]);
}

static void constructor_60541( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::MET(*(const ::edm::RefToBase<reco::MET>*)arg[0]);
  else ::new(mem) ::pat::MET(*(const ::edm::RefToBase<reco::MET>*)arg[0]);
}

static void constructor_60542( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::MET(*(const ::edm::Ptr<reco::MET>*)arg[0]);
  else ::new(mem) ::pat::MET(*(const ::edm::Ptr<reco::MET>*)arg[0]);
}

static void constructor_60543( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::MET(*(const ::pat::MET*)arg[0]);
  else ::new(mem) ::pat::MET(*(const ::pat::MET*)arg[0]);
}

static void destructor_60544(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::MET*)o)->::pat::MET::~MET)();
}
static  void operator_60545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::MET*)o)->operator=)(*(const ::pat::MET*)arg[0]);
  else   (((::pat::MET*)o)->operator=)(*(const ::pat::MET*)arg[0]);
}

static  void method_60546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::MET*)o)->clone)());
  else   (((const ::pat::MET*)o)->clone)();
}

static  void method_60547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::MET*)o)->genMET)());
  else   (((const ::pat::MET*)o)->genMET)();
}

static  void method_60548( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::MET*)o)->setGenMET)(*(const ::reco::GenMET*)arg[0]);
}

static  void method_60549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::pat::MET*)o)->nCorrections)());
  else   (((const ::pat::MET*)o)->nCorrections)();
}

static  void method_60550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::pat::MET*)o)->corEx)());
    else     (((const ::pat::MET*)o)->corEx)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::MET*)o)->corEx)(*(::pat::MET::UncorrectionType*)arg[0]));
    else     (((const ::pat::MET*)o)->corEx)(*(::pat::MET::UncorrectionType*)arg[0]);
  }
}

static  void method_60551( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::pat::MET*)o)->corEy)());
    else     (((const ::pat::MET*)o)->corEy)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::MET*)o)->corEy)(*(::pat::MET::UncorrectionType*)arg[0]));
    else     (((const ::pat::MET*)o)->corEy)(*(::pat::MET::UncorrectionType*)arg[0]);
  }
}

static  void method_60552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::pat::MET*)o)->corSumEt)());
    else     (((const ::pat::MET*)o)->corSumEt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::MET*)o)->corSumEt)(*(::pat::MET::UncorrectionType*)arg[0]));
    else     (((const ::pat::MET*)o)->corSumEt)(*(::pat::MET::UncorrectionType*)arg[0]);
  }
}

static  void method_60553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::pat::MET*)o)->uncorrectedPt)());
    else     (((const ::pat::MET*)o)->uncorrectedPt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::MET*)o)->uncorrectedPt)(*(::pat::MET::UncorrectionType*)arg[0]));
    else     (((const ::pat::MET*)o)->uncorrectedPt)(*(::pat::MET::UncorrectionType*)arg[0]);
  }
}

static  void method_60554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::pat::MET*)o)->uncorrectedPhi)());
    else     (((const ::pat::MET*)o)->uncorrectedPhi)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::MET*)o)->uncorrectedPhi)(*(::pat::MET::UncorrectionType*)arg[0]));
    else     (((const ::pat::MET*)o)->uncorrectedPhi)(*(::pat::MET::UncorrectionType*)arg[0]);
  }
}

static  void method_60555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::MET*)o)->isCaloMET)());
  else   (((const ::pat::MET*)o)->isCaloMET)();
}

static  void method_60556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::MET*)o)->isPFMET)());
  else   (((const ::pat::MET*)o)->isPFMET)();
}

static  void method_60557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::MET*)o)->isRecoMET)());
  else   (((const ::pat::MET*)o)->isRecoMET)();
}

static  void method_60558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->maxEtInEmTowers)());
  else   (((const ::pat::MET*)o)->maxEtInEmTowers)();
}

static  void method_60559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->maxEtInHadTowers)());
  else   (((const ::pat::MET*)o)->maxEtInHadTowers)();
}

static  void method_60560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->etFractionHadronic)());
  else   (((const ::pat::MET*)o)->etFractionHadronic)();
}

static  void method_60561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->emEtFraction)());
  else   (((const ::pat::MET*)o)->emEtFraction)();
}

static  void method_60562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->hadEtInHB)());
  else   (((const ::pat::MET*)o)->hadEtInHB)();
}

static  void method_60563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->hadEtInHO)());
  else   (((const ::pat::MET*)o)->hadEtInHO)();
}

static  void method_60564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->hadEtInHE)());
  else   (((const ::pat::MET*)o)->hadEtInHE)();
}

static  void method_60565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->hadEtInHF)());
  else   (((const ::pat::MET*)o)->hadEtInHF)();
}

static  void method_60566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->emEtInEB)());
  else   (((const ::pat::MET*)o)->emEtInEB)();
}

static  void method_60567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->emEtInEE)());
  else   (((const ::pat::MET*)o)->emEtInEE)();
}

static  void method_60568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->emEtInHF)());
  else   (((const ::pat::MET*)o)->emEtInHF)();
}

static  void method_60569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->metSignificance)());
  else   (((const ::pat::MET*)o)->metSignificance)();
}

static  void method_60570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->CaloSETInpHF)());
  else   (((const ::pat::MET*)o)->CaloSETInpHF)();
}

static  void method_60571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->CaloSETInmHF)());
  else   (((const ::pat::MET*)o)->CaloSETInmHF)();
}

static  void method_60572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->CaloMETInpHF)());
  else   (((const ::pat::MET*)o)->CaloMETInpHF)();
}

static  void method_60573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->CaloMETInmHF)());
  else   (((const ::pat::MET*)o)->CaloMETInmHF)();
}

static  void method_60574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->CaloMETPhiInpHF)());
  else   (((const ::pat::MET*)o)->CaloMETPhiInpHF)();
}

static  void method_60575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->CaloMETPhiInmHF)());
  else   (((const ::pat::MET*)o)->CaloMETPhiInmHF)();
}

static  void method_60576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::MET*)o)->caloSpecific)();
  else   (((const ::pat::MET*)o)->caloSpecific)();
}

static  void method_60577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->NeutralEMFraction)());
  else   (((const ::pat::MET*)o)->NeutralEMFraction)();
}

static  void method_60578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->NeutralHadEtFraction)());
  else   (((const ::pat::MET*)o)->NeutralHadEtFraction)();
}

static  void method_60579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->ChargedEMEtFraction)());
  else   (((const ::pat::MET*)o)->ChargedEMEtFraction)();
}

static  void method_60580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->ChargedHadEtFraction)());
  else   (((const ::pat::MET*)o)->ChargedHadEtFraction)();
}

static  void method_60581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->MuonEtFraction)());
  else   (((const ::pat::MET*)o)->MuonEtFraction)();
}

static  void method_60582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->Type6EtFraction)());
  else   (((const ::pat::MET*)o)->Type6EtFraction)();
}

static  void method_60583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->Type7EtFraction)());
  else   (((const ::pat::MET*)o)->Type7EtFraction)();
}

static  void method_60584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::MET*)o)->pfSpecific)();
  else   (((const ::pat::MET*)o)->pfSpecific)();
}

static  void method_60585( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (pat::MET::Vector2)((((const ::pat::MET*)o)->shiftedP2)(*(::pat::MET::METUncertainty*)arg[0]));
    else     (((const ::pat::MET*)o)->shiftedP2)(*(::pat::MET::METUncertainty*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (pat::MET::Vector2)((((const ::pat::MET*)o)->shiftedP2)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]));
    else     (((const ::pat::MET*)o)->shiftedP2)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]);
  }
}

static  void method_60586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (math::XYZVector)((((const ::pat::MET*)o)->shiftedP3)(*(::pat::MET::METUncertainty*)arg[0]));
    else     (((const ::pat::MET*)o)->shiftedP3)(*(::pat::MET::METUncertainty*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (math::XYZVector)((((const ::pat::MET*)o)->shiftedP3)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]));
    else     (((const ::pat::MET*)o)->shiftedP3)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]);
  }
}

static  void method_60587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (math::XYZTLorentzVector)((((const ::pat::MET*)o)->shiftedP4)(*(::pat::MET::METUncertainty*)arg[0]));
    else     (((const ::pat::MET*)o)->shiftedP4)(*(::pat::MET::METUncertainty*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (math::XYZTLorentzVector)((((const ::pat::MET*)o)->shiftedP4)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]));
    else     (((const ::pat::MET*)o)->shiftedP4)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]);
  }
}

static  void method_60588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->shiftedPx)(*(::pat::MET::METUncertainty*)arg[0]));
    else     (((const ::pat::MET*)o)->shiftedPx)(*(::pat::MET::METUncertainty*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->shiftedPx)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]));
    else     (((const ::pat::MET*)o)->shiftedPx)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]);
  }
}

static  void method_60589( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->shiftedPy)(*(::pat::MET::METUncertainty*)arg[0]));
    else     (((const ::pat::MET*)o)->shiftedPy)(*(::pat::MET::METUncertainty*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->shiftedPy)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]));
    else     (((const ::pat::MET*)o)->shiftedPy)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]);
  }
}

static  void method_60590( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->shiftedPt)(*(::pat::MET::METUncertainty*)arg[0]));
    else     (((const ::pat::MET*)o)->shiftedPt)(*(::pat::MET::METUncertainty*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->shiftedPt)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]));
    else     (((const ::pat::MET*)o)->shiftedPt)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]);
  }
}

static  void method_60591( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->shiftedPhi)(*(::pat::MET::METUncertainty*)arg[0]));
    else     (((const ::pat::MET*)o)->shiftedPhi)(*(::pat::MET::METUncertainty*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->shiftedPhi)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]));
    else     (((const ::pat::MET*)o)->shiftedPhi)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]);
  }
}

static  void method_60592( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->shiftedSumEt)(*(::pat::MET::METUncertainty*)arg[0]));
    else     (((const ::pat::MET*)o)->shiftedSumEt)(*(::pat::MET::METUncertainty*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::MET*)o)->shiftedSumEt)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]));
    else     (((const ::pat::MET*)o)->shiftedSumEt)(*(::pat::MET::METUncertainty*)arg[0],
      *(::pat::MET::METUncertaintyLevel*)arg[1]);
  }
}

static  void method_60593( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    (((::pat::MET*)o)->setShift)(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::pat::MET::METUncertainty*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::pat::MET*)o)->setShift)(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::pat::MET::METUncertainty*)arg[3],
      *(::pat::MET::METUncertaintyLevel*)arg[4]);
  }
}

static void method_newdel_13544( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::MET >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::MET >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::MET >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::MET >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::MET >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x40( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::MET>")), ::Reflex::BaseOffset< ::pat::MET,::pat::PATObject<reco::MET> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::MET")), ::Reflex::BaseOffset< ::pat::MET,::reco::MET >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::pat::MET,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::MET,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::MET,::reco::Candidate >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class MET -------------------------------
void __pat__MET_db_datamem(Reflex::Class*);
void __pat__MET_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__MET_datamem_bld(&__pat__MET_db_datamem);
Reflex::GenreflexMemberBuilder __pat__MET_funcmem_bld(&__pat__MET_db_funcmem);
void __pat__MET_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::MET"), typeid(::pat::MET), sizeof(::pat::MET), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "11")
  .AddBase(type_13550, ::Reflex::BaseOffset< ::pat::MET, ::pat::PATObject<reco::MET> >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("pat::MET::UncorrectionType"), Reflex::Literal("uncorrNONE=-1;uncorrALL=0;uncorrJES=1;uncorrMUON=2;uncorrTAU=3;uncorrMAXN=4"), &typeid(pat::MET::UncorrectionType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("pat::MET::METUncertainty"), Reflex::Literal("JetEnUp=0;JetEnDown=1;JetResUp=2;JetResDown=3;MuonEnUp=4;MuonEnDown=5;ElectronEnUp=6;ElectronEnDown=7;TauEnUp=8;TauEnDown=9;UnclusteredEnUp=10;UnclusteredEnDown=11;METUncertaintySize=12"), &typeid(pat::MET::METUncertainty), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("pat::MET::METUncertaintyLevel"), Reflex::Literal("Raw=0;Type1=1;Type1p2=2"), &typeid(pat::MET::METUncertaintyLevel), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MET"), constructor_60539, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71898), Reflex::Literal("MET"), constructor_60540, 0, "aMET", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71894), Reflex::Literal("MET"), constructor_60541, 0, "aMETRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71965), Reflex::Literal("MET"), constructor_60542, 0, "aMETRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17786), Reflex::Literal("MET"), constructor_60543, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MET"), destructor_60544, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13544, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x40, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__MET_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__MET_funcmem_bld);
}

//------Delayed data member builder for class MET -------------------
void __pat__MET_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3543, Reflex::Literal("genMET_"), OffsetOf(__shadow__::__pat__MET, genMET_), ::Reflex::PRIVATE)
  .AddDataMember(type_3540, Reflex::Literal("caloMET_"), OffsetOf(__shadow__::__pat__MET, caloMET_), ::Reflex::PRIVATE)
  .AddDataMember(type_3539, Reflex::Literal("pfMET_"), OffsetOf(__shadow__::__pat__MET, pfMET_), ::Reflex::PRIVATE)
  .AddDataMember(type_75147, Reflex::Literal("uncorInfo_"), OffsetOf(__shadow__::__pat__MET, uncorInfo_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_227, Reflex::Literal("nCorrections_"), OffsetOf(__shadow__::__pat__MET, nCorrections_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3541, Reflex::Literal("uncertaintiesRaw_"), OffsetOf(__shadow__::__pat__MET, uncertaintiesRaw_), ::Reflex::PROTECTED)
  .AddDataMember(type_3541, Reflex::Literal("uncertaintiesType1_"), OffsetOf(__shadow__::__pat__MET, uncertaintiesType1_), ::Reflex::PROTECTED)
  .AddDataMember(type_3541, Reflex::Literal("uncertaintiesType1p2_"), OffsetOf(__shadow__::__pat__MET, uncertaintiesType1p2_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class MET -------------------
void __pat__MET_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21076, type_17786), Reflex::Literal("operator="), operator_60545, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14672), Reflex::Literal("clone"), method_60546, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22799), Reflex::Literal("genMET"), method_60547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22803), Reflex::Literal("setGenMET"), method_60548, 0, "gm", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("nCorrections"), method_60549, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_60534), Reflex::Literal("corEx"), method_60550, 0, "ix=uncorrALL", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_60534), Reflex::Literal("corEy"), method_60551, 0, "ix=uncorrALL", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_60534), Reflex::Literal("corSumEt"), method_60552, 0, "ix=uncorrALL", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_60534), Reflex::Literal("uncorrectedPt"), method_60553, 0, "ix=uncorrALL", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_60534), Reflex::Literal("uncorrectedPhi"), method_60554, 0, "ix=uncorrALL", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isCaloMET"), method_60555, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPFMET"), method_60556, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isRecoMET"), method_60557, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("maxEtInEmTowers"), method_60558, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("maxEtInHadTowers"), method_60559, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("etFractionHadronic"), method_60560, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("emEtFraction"), method_60561, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("hadEtInHB"), method_60562, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("hadEtInHO"), method_60563, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("hadEtInHE"), method_60564, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("hadEtInHF"), method_60565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("emEtInEB"), method_60566, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("emEtInEE"), method_60567, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("emEtInHF"), method_60568, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("metSignificance"), method_60569, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("CaloSETInpHF"), method_60570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("CaloSETInmHF"), method_60571, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("CaloMETInpHF"), method_60572, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("CaloMETInmHF"), method_60573, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("CaloMETPhiInpHF"), method_60574, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("CaloMETPhiInmHF"), method_60575, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22672), Reflex::Literal("caloSpecific"), method_60576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("NeutralEMFraction"), method_60577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("NeutralHadEtFraction"), method_60578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("ChargedEMEtFraction"), method_60579, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("ChargedHadEtFraction"), method_60580, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("MuonEtFraction"), method_60581, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("Type6EtFraction"), method_60582, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("Type7EtFraction"), method_60583, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22607), Reflex::Literal("pfSpecific"), method_60584, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60538, type_60536, type_60537), Reflex::Literal("shiftedP2"), method_60585, 0, "shift;level=Type1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10222, type_60536, type_60537), Reflex::Literal("shiftedP3"), method_60586, 0, "shift;level=Type1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10223, type_60536, type_60537), Reflex::Literal("shiftedP4"), method_60587, 0, "shift;level=Type1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_60536, type_60537), Reflex::Literal("shiftedPx"), method_60588, 0, "shift;level=Type1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_60536, type_60537), Reflex::Literal("shiftedPy"), method_60589, 0, "shift;level=Type1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_60536, type_60537), Reflex::Literal("shiftedPt"), method_60590, 0, "shift;level=Type1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_60536, type_60537), Reflex::Literal("shiftedPhi"), method_60591, 0, "shift;level=Type1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_60536, type_60537), Reflex::Literal("shiftedSumEt"), method_60592, 0, "shift;level=Type1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112, type_112, type_112, type_60536, type_60537), Reflex::Literal("setShift"), method_60593, 0, "px;py;sumEt;shift;level=Type1", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<pat::MET,std::allocator<pat::MET> > -------------------------------
static void constructor_21086( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MET>();
  else ::new(mem) ::std::vector<pat::MET>();
}

static void constructor_21087( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MET>(*(const ::std::allocator<pat::MET>*)arg[0]);
  else ::new(mem) ::std::vector<pat::MET>(*(const ::std::allocator<pat::MET>*)arg[0]);
}

static void constructor_21088( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MET>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::MET>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MET>(*(::std::size_t*)arg[0],
      *(const ::pat::MET*)arg[1]);
  else ::new(mem) ::std::vector<pat::MET>(*(::std::size_t*)arg[0],
      *(const ::pat::MET*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MET>(*(::std::size_t*)arg[0],
      *(const ::pat::MET*)arg[1],
      *(const ::std::allocator<pat::MET>*)arg[2]);
  else ::new(mem) ::std::vector<pat::MET>(*(::std::size_t*)arg[0],
      *(const ::pat::MET*)arg[1],
      *(const ::std::allocator<pat::MET>*)arg[2]);
  }
}

static void constructor_21089( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MET>(*(const ::std::vector<pat::MET>*)arg[0]);
  else ::new(mem) ::std::vector<pat::MET>(*(const ::std::vector<pat::MET>*)arg[0]);
}

static void destructor_21090(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::MET>*)o)->::std::vector<pat::MET>::~vector)();
}
static  void operator_21091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::MET>*)o)->operator=)(*(const ::std::vector<pat::MET>*)arg[0]);
  else   (((::std::vector<pat::MET>*)o)->operator=)(*(const ::std::vector<pat::MET>*)arg[0]);
}

static  void method_21092( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::MET>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::MET*)arg[1]);
}

static  void method_21093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> >)((((::std::vector<pat::MET>*)o)->begin)());
  else   (((::std::vector<pat::MET>*)o)->begin)();
}

static  void method_21094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >)((((const ::std::vector<pat::MET>*)o)->begin)());
  else   (((const ::std::vector<pat::MET>*)o)->begin)();
}

static  void method_21095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> >)((((::std::vector<pat::MET>*)o)->end)());
  else   (((::std::vector<pat::MET>*)o)->end)();
}

static  void method_21096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >)((((const ::std::vector<pat::MET>*)o)->end)());
  else   (((const ::std::vector<pat::MET>*)o)->end)();
}

static  void method_21101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::MET>*)o)->size)());
  else   (((const ::std::vector<pat::MET>*)o)->size)();
}

static  void method_21102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::MET>*)o)->max_size)());
  else   (((const ::std::vector<pat::MET>*)o)->max_size)();
}

static  void method_21103( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::MET>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::MET>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::MET*)arg[1]);
  }
}

static  void method_21104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::MET>*)o)->capacity)());
  else   (((const ::std::vector<pat::MET>*)o)->capacity)();
}

static  void method_21105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::MET>*)o)->empty)());
  else   (((const ::std::vector<pat::MET>*)o)->empty)();
}

static  void method_21106( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::MET>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_21107( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::MET>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::MET>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_21108( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::MET>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::MET>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_21110( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::MET>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::MET>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21111( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::MET>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::MET>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::MET>*)o)->front)();
  else   (((::std::vector<pat::MET>*)o)->front)();
}

static  void method_21113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::MET>*)o)->front)();
  else   (((const ::std::vector<pat::MET>*)o)->front)();
}

static  void method_21114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::MET>*)o)->back)();
  else   (((::std::vector<pat::MET>*)o)->back)();
}

static  void method_21115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::MET>*)o)->back)();
  else   (((const ::std::vector<pat::MET>*)o)->back)();
}

static  void method_21116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::MET>*)o)->data)());
  else   (((::std::vector<pat::MET>*)o)->data)();
}

static  void method_21117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::MET>*)o)->data)());
  else   (((const ::std::vector<pat::MET>*)o)->data)();
}

static  void method_21118( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::MET>*)o)->push_back)(*(const ::pat::MET*)arg[0]);
}

static  void method_21119( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::MET>*)o)->pop_back)();
}

static  void method_21120( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> >)((((::std::vector<pat::MET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> >*)arg[0],
    *(const ::pat::MET*)arg[1]));
  else   (((::std::vector<pat::MET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> >*)arg[0],
    *(const ::pat::MET*)arg[1]);
}

static  void method_21121( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::MET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::MET*)arg[2]);
}

static  void method_21122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> >)((((::std::vector<pat::MET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> >*)arg[0]));
  else   (((::std::vector<pat::MET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> >*)arg[0]);
}

static  void method_21123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> >)((((::std::vector<pat::MET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> >*)arg[1]));
  else   (((::std::vector<pat::MET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::MET*,std::vector<pat::MET> >*)arg[1]);
}

static  void method_21124( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::MET>*)o)->swap)(*(::std::vector<pat::MET>*)arg[0]);
}

static  void method_21125( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::MET>*)o)->clear)();
}

static void method_newdel_3515( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::MET> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::MET> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::MET> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::MET> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::MET> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::MET,std::allocator<pat::MET> >")), ::Reflex::BaseOffset< ::std::vector<pat::MET>,::std::_Vector_base<pat::MET,std::allocator<pat::MET> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x43( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::MET> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::MET> >::Generate();
}

//------Dictionary for class vector<pat::MET,std::allocator<pat::MET> > -------------------------------
void __std__vector_pat__MET__db_datamem(Reflex::Class*);
void __std__vector_pat__MET__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__MET__datamem_bld(&__std__vector_pat__MET__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__MET__funcmem_bld(&__std__vector_pat__MET__db_funcmem);
void __std__vector_pat__MET__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::MET>"), typeid(::std::vector<pat::MET>), sizeof(::std::vector<pat::MET>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2843, ::Reflex::BaseOffset< ::std::vector<pat::MET>, ::std::_Vector_base<pat::MET,std::allocator<pat::MET> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13544, Reflex::Literal("std::vector<pat::MET>::_Alloc_value_type"))
  .AddTypedef(type_2843, Reflex::Literal("std::vector<pat::MET>::_Base"))
  .AddTypedef(type_3873, Reflex::Literal("std::vector<pat::MET>::_Tp_alloc_type"))
  .AddTypedef(type_12375, Reflex::Literal("std::vector<pat::MET>::_Alloc_traits"))
  .AddTypedef(type_13544, Reflex::Literal("std::vector<pat::MET>::value_type"))
  .AddTypedef(type_14672, Reflex::Literal("std::vector<pat::MET>::pointer"))
  .AddTypedef(type_17784, Reflex::Literal("std::vector<pat::MET>::const_pointer"))
  .AddTypedef(type_21076, Reflex::Literal("std::vector<pat::MET>::reference"))
  .AddTypedef(type_17786, Reflex::Literal("std::vector<pat::MET>::const_reference"))
  .AddTypedef(type_12001, Reflex::Literal("std::vector<pat::MET>::iterator"))
  .AddTypedef(type_11974, Reflex::Literal("std::vector<pat::MET>::const_iterator"))
  .AddTypedef(type_4320, Reflex::Literal("std::vector<pat::MET>::const_reverse_iterator"))
  .AddTypedef(type_4321, Reflex::Literal("std::vector<pat::MET>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::MET>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::MET>::difference_type"))
  .AddTypedef(type_3873, Reflex::Literal("std::vector<pat::MET>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_21086, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62556), Reflex::Literal("vector"), constructor_21087, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_17786, type_62556), Reflex::Literal("vector"), constructor_21088, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35585), Reflex::Literal("vector"), constructor_21089, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_21090, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3515, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x43, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__MET__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::MET,std::allocator<pat::MET> > -------------------
void __std__vector_pat__MET__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::MET,std::allocator<pat::MET> > -------------------
void __std__vector_pat__MET__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65090, type_35585), Reflex::Literal("operator="), operator_21091, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_17786), Reflex::Literal("assign"), method_21092, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12001), Reflex::Literal("begin"), method_21093, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11974), Reflex::Literal("begin"), method_21094, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12001), Reflex::Literal("end"), method_21095, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11974), Reflex::Literal("end"), method_21096, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_21101, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_21102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_13544), Reflex::Literal("resize"), method_21103, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_21104, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_21105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_21106, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21076, type_3845), Reflex::Literal("operator[]"), operator_21107, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17786, type_3845), Reflex::Literal("operator[]"), operator_21108, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21076, type_3845), Reflex::Literal("at"), method_21110, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17786, type_3845), Reflex::Literal("at"), method_21111, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21076), Reflex::Literal("front"), method_21112, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17786), Reflex::Literal("front"), method_21113, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21076), Reflex::Literal("back"), method_21114, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17786), Reflex::Literal("back"), method_21115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14672), Reflex::Literal("data"), method_21116, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17784), Reflex::Literal("data"), method_21117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17786), Reflex::Literal("push_back"), method_21118, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_21119, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12001, type_12001, type_17786), Reflex::Literal("insert"), method_21120, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_12001, type_3845, type_17786), Reflex::Literal("insert"), method_21121, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12001, type_12001), Reflex::Literal("erase"), method_21122, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12001, type_12001, type_12001), Reflex::Literal("erase"), method_21123, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65090), Reflex::Literal("swap"), method_21124, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_21125, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Jet -------------------------------
static  void operator_59531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::Jet*)o)->operator=)(*(const ::pat::Jet*)arg[0]);
  else   (((::pat::Jet*)o)->operator=)(*(const ::pat::Jet*)arg[0]);
}

static void constructor_59532( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Jet(*(const ::pat::Jet*)arg[0]);
  else ::new(mem) ::pat::Jet(*(const ::pat::Jet*)arg[0]);
}

static void constructor_59533( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Jet();
  else ::new(mem) ::pat::Jet();
}

static void constructor_59534( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Jet(*(const ::reco::Jet*)arg[0]);
  else ::new(mem) ::pat::Jet(*(const ::reco::Jet*)arg[0]);
}

static void constructor_59535( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Jet(*(const ::edm::RefToBase<reco::Jet>*)arg[0]);
  else ::new(mem) ::pat::Jet(*(const ::edm::RefToBase<reco::Jet>*)arg[0]);
}

static void constructor_59536( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Jet(*(const ::edm::Ptr<reco::Jet>*)arg[0]);
  else ::new(mem) ::pat::Jet(*(const ::edm::Ptr<reco::Jet>*)arg[0]);
}

static void destructor_59537(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::Jet*)o)->::pat::Jet::~Jet)();
}
static  void method_59538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Jet*)o)->clone)());
  else   (((const ::pat::Jet*)o)->clone)();
}

static  void method_59539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Jet*)o)->genParton)());
  else   (((const ::pat::Jet*)o)->genParton)();
}

static  void method_59540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Jet*)o)->genJet)());
  else   (((const ::pat::Jet*)o)->genJet)();
}

static  void method_59541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Jet*)o)->partonFlavour)());
  else   (((const ::pat::Jet*)o)->partonFlavour)();
}

static  void method_59542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Jet*)o)->hadronFlavour)());
  else   (((const ::pat::Jet*)o)->hadronFlavour)();
}

static  void method_59543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->jetFlavourInfo)();
  else   (((const ::pat::Jet*)o)->jetFlavourInfo)();
}

static  void method_59544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::Jet*)o)->availableJECSets)());
  else   (((const ::pat::Jet*)o)->availableJECSets)();
}

static  void method_59545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::Jet*)o)->availableJECLevels)());
    else     (((const ::pat::Jet*)o)->availableJECLevels)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::Jet*)o)->availableJECLevels)(*(const int*)arg[0]));
    else     (((const ::pat::Jet*)o)->availableJECLevels)(*(const int*)arg[0]);
  }
}

static  void method_59546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::Jet*)o)->availableJECLevels)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::Jet*)o)->availableJECLevels)(*(const ::std::string*)arg[0]);
}

static  void method_59547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Jet*)o)->jecSetsAvailable)());
  else   (((const ::pat::Jet*)o)->jecSetsAvailable)();
}

static  void method_59548( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Jet*)o)->jecSetAvailable)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::Jet*)o)->jecSetAvailable)(*(const ::std::string*)arg[0]);
}

static  void method_59549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Jet*)o)->jecSetAvailable)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::Jet*)o)->jecSetAvailable)(*(const unsigned int*)arg[0]);
}

static  void method_59550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::pat::Jet*)o)->currentJECSet)());
  else   (((const ::pat::Jet*)o)->currentJECSet)();
}

static  void method_59551( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::pat::Jet*)o)->currentJECLevel)());
  else   (((const ::pat::Jet*)o)->currentJECLevel)();
}

static  void method_59552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Jet*)o)->currentJECFlavor)());
  else   (((const ::pat::Jet*)o)->currentJECFlavor)();
}

static  void method_59553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->jecFactor)(*(const ::std::string*)arg[0]));
    else     (((const ::pat::Jet*)o)->jecFactor)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->jecFactor)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::pat::Jet*)o)->jecFactor)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->jecFactor)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::pat::Jet*)o)->jecFactor)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_59554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->jecFactor)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::Jet*)o)->jecFactor)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->jecFactor)(*(const unsigned int*)arg[0],
      *(const ::pat::JetCorrFactors::Flavor*)arg[1]));
    else     (((const ::pat::Jet*)o)->jecFactor)(*(const unsigned int*)arg[0],
      *(const ::pat::JetCorrFactors::Flavor*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->jecFactor)(*(const unsigned int*)arg[0],
      *(const ::pat::JetCorrFactors::Flavor*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::Jet*)o)->jecFactor)(*(const unsigned int*)arg[0],
      *(const ::pat::JetCorrFactors::Flavor*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_59555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (pat::Jet)((((const ::pat::Jet*)o)->correctedJet)(*(const ::std::string*)arg[0]));
    else     (((const ::pat::Jet*)o)->correctedJet)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (pat::Jet)((((const ::pat::Jet*)o)->correctedJet)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::pat::Jet*)o)->correctedJet)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (pat::Jet)((((const ::pat::Jet*)o)->correctedJet)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::pat::Jet*)o)->correctedJet)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_59556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (pat::Jet)((((const ::pat::Jet*)o)->correctedJet)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::Jet*)o)->correctedJet)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (pat::Jet)((((const ::pat::Jet*)o)->correctedJet)(*(const unsigned int*)arg[0],
      *(const ::pat::JetCorrFactors::Flavor*)arg[1]));
    else     (((const ::pat::Jet*)o)->correctedJet)(*(const unsigned int*)arg[0],
      *(const ::pat::JetCorrFactors::Flavor*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (pat::Jet)((((const ::pat::Jet*)o)->correctedJet)(*(const unsigned int*)arg[0],
      *(const ::pat::JetCorrFactors::Flavor*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::Jet*)o)->correctedJet)(*(const unsigned int*)arg[0],
      *(const ::pat::JetCorrFactors::Flavor*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_59557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->correctedP4)(*(const ::std::string*)arg[0]);
    else     (((const ::pat::Jet*)o)->correctedP4)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->correctedP4)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
    else     (((const ::pat::Jet*)o)->correctedP4)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->correctedP4)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
    else     (((const ::pat::Jet*)o)->correctedP4)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_59558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->correctedP4)(*(const unsigned int*)arg[0]);
    else     (((const ::pat::Jet*)o)->correctedP4)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->correctedP4)(*(const unsigned int*)arg[0],
      *(const ::pat::JetCorrFactors::Flavor*)arg[1]);
    else     (((const ::pat::Jet*)o)->correctedP4)(*(const unsigned int*)arg[0],
      *(const ::pat::JetCorrFactors::Flavor*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->correctedP4)(*(const unsigned int*)arg[0],
      *(const ::pat::JetCorrFactors::Flavor*)arg[1],
      *(const unsigned int*)arg[2]);
    else     (((const ::pat::Jet*)o)->correctedP4)(*(const unsigned int*)arg[0],
      *(const ::pat::JetCorrFactors::Flavor*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_59565( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->bDiscriminator)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::Jet*)o)->bDiscriminator)(*(const ::std::string*)arg[0]);
}

static  void method_59566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->getPairDiscri)();
  else   (((const ::pat::Jet*)o)->getPairDiscri)();
}

static  void method_59567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Jet*)o)->hasTagInfo)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::Jet*)o)->hasTagInfo)(*(const ::std::string*)arg[0]);
}

static  void method_59568( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Jet*)o)->tagInfo)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::Jet*)o)->tagInfo)(*(const ::std::string*)arg[0]);
}

static  void method_59569( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Jet*)o)->tagInfoTrackIP)());
    else     (((const ::pat::Jet*)o)->tagInfoTrackIP)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Jet*)o)->tagInfoTrackIP)(*(const ::std::string*)arg[0]));
    else     (((const ::pat::Jet*)o)->tagInfoTrackIP)(*(const ::std::string*)arg[0]);
  }
}

static  void method_59570( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Jet*)o)->tagInfoSoftLepton)());
    else     (((const ::pat::Jet*)o)->tagInfoSoftLepton)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Jet*)o)->tagInfoSoftLepton)(*(const ::std::string*)arg[0]));
    else     (((const ::pat::Jet*)o)->tagInfoSoftLepton)(*(const ::std::string*)arg[0]);
  }
}

static  void method_59571( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Jet*)o)->tagInfoSecondaryVertex)());
    else     (((const ::pat::Jet*)o)->tagInfoSecondaryVertex)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Jet*)o)->tagInfoSecondaryVertex)(*(const ::std::string*)arg[0]));
    else     (((const ::pat::Jet*)o)->tagInfoSecondaryVertex)(*(const ::std::string*)arg[0]);
  }
}

static  void method_59572( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->addBDiscriminatorPair)(*(const ::std::pair<std::basic_string<char>,float>*)arg[0]);
}

static  void method_59573( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->addTagInfo)(*(const ::std::string*)arg[0],
    *(const ::edm::FwdPtr<reco::BaseTagInfo>*)arg[1]);
}

static  void method_59574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->jetCharge)());
  else   (((const ::pat::Jet*)o)->jetCharge)();
}

static  void method_59575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->associatedTracks)();
  else   (((const ::pat::Jet*)o)->associatedTracks)();
}

static  void method_59576( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->setJetCharge)(*(float*)arg[0]);
}

static  void method_59577( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->setAssociatedTracks)(*(const ::reco::TrackRefVector*)arg[0]);
}

static  void method_59578( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->setCaloTowers)(*(const ::pat::CaloTowerFwdPtrCollection*)arg[0]);
}

static  void method_59579( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->setPFCandidates)(*(const ::pat::PFCandidateFwdPtrCollection*)arg[0]);
}

static  void method_59580( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::Jet*)o)->setGenParton)(*(const ::reco::GenParticleRef*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::Jet*)o)->setGenParton)(*(const ::reco::GenParticleRef*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_59581( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->setGenJetRef)(*(const ::edm::FwdRef<std::vector<reco::GenJet>,reco::GenJet,edm::refhelper::FindUsingAdvance<std::vector<reco::GenJet>,reco::GenJet> >*)arg[0]);
}

static  void method_59582( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->setPartonFlavour)(*(int*)arg[0]);
}

static  void method_59583( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->setHadronFlavour)(*(int*)arg[0]);
}

static  void method_59584( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->setJetFlavourInfo)(*(const ::reco::JetFlavourInfo*)arg[0]);
}

static  void method_59585( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->setJetID)(*(const ::reco::JetID*)arg[0]);
}

static  void method_59586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Jet*)o)->isCaloJet)());
  else   (((const ::pat::Jet*)o)->isCaloJet)();
}

static  void method_59587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Jet*)o)->isJPTJet)());
  else   (((const ::pat::Jet*)o)->isJPTJet)();
}

static  void method_59588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Jet*)o)->isPFJet)());
  else   (((const ::pat::Jet*)o)->isPFJet)();
}

static  void method_59589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Jet*)o)->isBasicJet)());
  else   (((const ::pat::Jet*)o)->isBasicJet)();
}

static  void method_59590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->caloSpecific)();
  else   (((const ::pat::Jet*)o)->caloSpecific)();
}

static  void method_59591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->jptSpecific)();
  else   (((const ::pat::Jet*)o)->jptSpecific)();
}

static  void method_59592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->pfSpecific)();
  else   (((const ::pat::Jet*)o)->pfSpecific)();
}

static  void method_59593( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->setCaloSpecific)(*(const ::pat::CaloSpecific*)arg[0]);
}

static  void method_59594( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->setJPTSpecific)(*(const ::pat::JPTSpecific*)arg[0]);
}

static  void method_59595( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->setPFSpecific)(*(const ::pat::PFSpecific*)arg[0]);
}

static  void method_59596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->maxEInEmTowers)());
  else   (((const ::pat::Jet*)o)->maxEInEmTowers)();
}

static  void method_59597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->maxEInHadTowers)());
  else   (((const ::pat::Jet*)o)->maxEInHadTowers)();
}

static  void method_59598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->energyFractionHadronic)());
  else   (((const ::pat::Jet*)o)->energyFractionHadronic)();
}

static  void method_59599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->emEnergyFraction)());
  else   (((const ::pat::Jet*)o)->emEnergyFraction)();
}

static  void method_59600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->hadEnergyInHB)());
  else   (((const ::pat::Jet*)o)->hadEnergyInHB)();
}

static  void method_59601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->hadEnergyInHO)());
  else   (((const ::pat::Jet*)o)->hadEnergyInHO)();
}

static  void method_59602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->hadEnergyInHE)());
  else   (((const ::pat::Jet*)o)->hadEnergyInHE)();
}

static  void method_59603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->hadEnergyInHF)());
  else   (((const ::pat::Jet*)o)->hadEnergyInHF)();
}

static  void method_59604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->emEnergyInEB)());
  else   (((const ::pat::Jet*)o)->emEnergyInEB)();
}

static  void method_59605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->emEnergyInEE)());
  else   (((const ::pat::Jet*)o)->emEnergyInEE)();
}

static  void method_59606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->emEnergyInHF)());
  else   (((const ::pat::Jet*)o)->emEnergyInHF)();
}

static  void method_59607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->towersArea)());
  else   (((const ::pat::Jet*)o)->towersArea)();
}

static  void method_59608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Jet*)o)->n90)());
  else   (((const ::pat::Jet*)o)->n90)();
}

static  void method_59609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Jet*)o)->n60)());
  else   (((const ::pat::Jet*)o)->n60)();
}

static  void method_59610( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (CaloTowerPtr)((((const ::pat::Jet*)o)->getCaloConstituent)(*(unsigned int*)arg[0]));
  else   (((const ::pat::Jet*)o)->getCaloConstituent)(*(unsigned int*)arg[0]);
}

static  void method_59611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->getCaloConstituents)();
  else   (((const ::pat::Jet*)o)->getCaloConstituents)();
}

static  void method_59612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->pionsInVertexInCalo)();
  else   (((const ::pat::Jet*)o)->pionsInVertexInCalo)();
}

static  void method_59613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->pionsInVertexOutCalo)();
  else   (((const ::pat::Jet*)o)->pionsInVertexOutCalo)();
}

static  void method_59614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->pionsOutVertexInCalo)();
  else   (((const ::pat::Jet*)o)->pionsOutVertexInCalo)();
}

static  void method_59615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->muonsInVertexInCalo)();
  else   (((const ::pat::Jet*)o)->muonsInVertexInCalo)();
}

static  void method_59616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->muonsInVertexOutCalo)();
  else   (((const ::pat::Jet*)o)->muonsInVertexOutCalo)();
}

static  void method_59617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->muonsOutVertexInCalo)();
  else   (((const ::pat::Jet*)o)->muonsOutVertexInCalo)();
}

static  void method_59618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->elecsInVertexInCalo)();
  else   (((const ::pat::Jet*)o)->elecsInVertexInCalo)();
}

static  void method_59619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->elecsInVertexOutCalo)();
  else   (((const ::pat::Jet*)o)->elecsInVertexOutCalo)();
}

static  void method_59620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->elecsOutVertexInCalo)();
  else   (((const ::pat::Jet*)o)->elecsOutVertexInCalo)();
}

static  void method_59621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->zspCorrection)();
  else   (((const ::pat::Jet*)o)->zspCorrection)();
}

static  void method_59622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->elecMultiplicity)());
  else   (((const ::pat::Jet*)o)->elecMultiplicity)();
}

static  void method_59623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Jet*)o)->muonMultiplicity)());
  else   (((const ::pat::Jet*)o)->muonMultiplicity)();
}

static  void method_59624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Jet*)o)->chargedMultiplicity)());
  else   (((const ::pat::Jet*)o)->chargedMultiplicity)();
}

static  void method_59625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->chargedEmEnergy)());
  else   (((const ::pat::Jet*)o)->chargedEmEnergy)();
}

static  void method_59626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->neutralEmEnergy)());
  else   (((const ::pat::Jet*)o)->neutralEmEnergy)();
}

static  void method_59627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->chargedHadronEnergy)());
  else   (((const ::pat::Jet*)o)->chargedHadronEnergy)();
}

static  void method_59628( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->neutralHadronEnergy)());
  else   (((const ::pat::Jet*)o)->neutralHadronEnergy)();
}

static  void method_59629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->chargedHadronEnergyFraction)());
  else   (((const ::pat::Jet*)o)->chargedHadronEnergyFraction)();
}

static  void method_59630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->neutralHadronEnergyFraction)());
  else   (((const ::pat::Jet*)o)->neutralHadronEnergyFraction)();
}

static  void method_59631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->chargedEmEnergyFraction)());
  else   (((const ::pat::Jet*)o)->chargedEmEnergyFraction)();
}

static  void method_59632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->neutralEmEnergyFraction)());
  else   (((const ::pat::Jet*)o)->neutralEmEnergyFraction)();
}

static  void method_59633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->photonEnergy)());
  else   (((const ::pat::Jet*)o)->photonEnergy)();
}

static  void method_59634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->photonEnergyFraction)());
  else   (((const ::pat::Jet*)o)->photonEnergyFraction)();
}

static  void method_59635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->electronEnergy)());
  else   (((const ::pat::Jet*)o)->electronEnergy)();
}

static  void method_59636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->electronEnergyFraction)());
  else   (((const ::pat::Jet*)o)->electronEnergyFraction)();
}

static  void method_59637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->muonEnergy)());
  else   (((const ::pat::Jet*)o)->muonEnergy)();
}

static  void method_59638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->muonEnergyFraction)());
  else   (((const ::pat::Jet*)o)->muonEnergyFraction)();
}

static  void method_59639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->HFHadronEnergy)());
  else   (((const ::pat::Jet*)o)->HFHadronEnergy)();
}

static  void method_59640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->HFHadronEnergyFraction)());
  else   (((const ::pat::Jet*)o)->HFHadronEnergyFraction)();
}

static  void method_59641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->HFEMEnergy)());
  else   (((const ::pat::Jet*)o)->HFEMEnergy)();
}

static  void method_59642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->HFEMEnergyFraction)());
  else   (((const ::pat::Jet*)o)->HFEMEnergyFraction)();
}

static  void method_59643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Jet*)o)->chargedHadronMultiplicity)());
  else   (((const ::pat::Jet*)o)->chargedHadronMultiplicity)();
}

static  void method_59644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Jet*)o)->neutralHadronMultiplicity)());
  else   (((const ::pat::Jet*)o)->neutralHadronMultiplicity)();
}

static  void method_59645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Jet*)o)->photonMultiplicity)());
  else   (((const ::pat::Jet*)o)->photonMultiplicity)();
}

static  void method_59646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Jet*)o)->electronMultiplicity)());
  else   (((const ::pat::Jet*)o)->electronMultiplicity)();
}

static  void method_59647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Jet*)o)->HFHadronMultiplicity)());
  else   (((const ::pat::Jet*)o)->HFHadronMultiplicity)();
}

static  void method_59648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Jet*)o)->HFEMMultiplicity)());
  else   (((const ::pat::Jet*)o)->HFEMMultiplicity)();
}

static  void method_59649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->chargedMuEnergy)());
  else   (((const ::pat::Jet*)o)->chargedMuEnergy)();
}

static  void method_59650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Jet*)o)->chargedMuEnergyFraction)());
  else   (((const ::pat::Jet*)o)->chargedMuEnergyFraction)();
}

static  void method_59651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Jet*)o)->neutralMultiplicity)());
  else   (((const ::pat::Jet*)o)->neutralMultiplicity)();
}

static  void method_59652( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::PFCandidatePtr)((((const ::pat::Jet*)o)->getPFConstituent)(*(unsigned int*)arg[0]));
  else   (((const ::pat::Jet*)o)->getPFConstituent)(*(unsigned int*)arg[0]);
}

static  void method_59653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->getPFConstituents)();
  else   (((const ::pat::Jet*)o)->getPFConstituents)();
}

static  void method_59654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Jet*)o)->daughter)(*(::size_t*)arg[0]));
  else   (((const ::pat::Jet*)o)->daughter)(*(::size_t*)arg[0]);
}

static  void method_59655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::Jet*)o)->numberOfDaughters)());
  else   (((const ::pat::Jet*)o)->numberOfDaughters)();
}

static  void method_59656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->jetID)();
  else   (((const ::pat::Jet*)o)->jetID)();
}

static  void method_59657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->caloTowersFwdPtr)();
  else   (((const ::pat::Jet*)o)->caloTowersFwdPtr)();
}

static  void method_59658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->pfCandidatesFwdPtr)();
  else   (((const ::pat::Jet*)o)->pfCandidatesFwdPtr)();
}

static  void method_59659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->genJetFwdRef)();
  else   (((const ::pat::Jet*)o)->genJetFwdRef)();
}

static  void method_59660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Jet*)o)->tagInfosFwdPtr)();
  else   (((const ::pat::Jet*)o)->tagInfosFwdPtr)();
}

static  void method_59661( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->updateFwdCaloTowerFwdPtr)(*(unsigned int*)arg[0],
    *(const ::edm::Ptr<CaloTower>*)arg[1]);
}

static  void method_59662( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->updateFwdPFCandidateFwdPtr)(*(unsigned int*)arg[0],
    *(const ::edm::Ptr<reco::PFCandidate>*)arg[1]);
}

static  void method_59663( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->updateFwdTagInfoFwdPtr)(*(unsigned int*)arg[0],
    *(const ::edm::Ptr<reco::BaseTagInfo>*)arg[1]);
}

static  void method_59664( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Jet*)o)->updateFwdGenJetFwdRef)(*(::edm::Ref<std::vector<reco::GenJet>,reco::GenJet,edm::refhelper::FindUsingAdvance<std::vector<reco::GenJet>,reco::GenJet> >*)arg[0]);
}

static void method_newdel_13487( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::Jet >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::Jet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::Jet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::Jet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::Jet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x45( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::Jet>")), ::Reflex::BaseOffset< ::pat::Jet,::pat::PATObject<reco::Jet> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Jet")), ::Reflex::BaseOffset< ::pat::Jet,::reco::Jet >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::CompositePtrCandidate")), ::Reflex::BaseOffset< ::pat::Jet,::reco::CompositePtrCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::Jet,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::Jet,::reco::Candidate >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

void read___pat__Jet_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_partonFlavour_ = oldObj->GetId("partonFlavour_");
#endif
  struct __pat__Jet_Onfile {
    int &partonFlavour_;
    __pat__Jet_Onfile( int &onfile_partonFlavour_ ): partonFlavour_(onfile_partonFlavour_){}
  };
  static Long_t offset_Onfile___pat__Jet_partonFlavour_ = oldObj->GetClass()->GetDataMemberOffset("partonFlavour_");
  char *onfile_add = (char*)oldObj->GetObject();
  __pat__Jet_Onfile onfile(
         *(int*)(onfile_add+offset_Onfile___pat__Jet_partonFlavour_) );

  reco::JetFlavourInfo &jetFlavourInfo_ = *(reco::JetFlavourInfo*)(target + OffsetOf(__shadow__::__pat__Jet, jetFlavourInfo_));

  if( oldObj ) {}
  //--- User's code ---
    jetFlavourInfo_ = reco::JetFlavourInfo(0,onfile.partonFlavour_);
  
}

//------Dictionary for class Jet -------------------------------
void __pat__Jet_db_datamem(Reflex::Class*);
void __pat__Jet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__Jet_datamem_bld(&__pat__Jet_db_datamem);
Reflex::GenreflexMemberBuilder __pat__Jet_funcmem_bld(&__pat__Jet_db_funcmem);
void __pat__Jet_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(1);
  rule = &readrules[0];
  rule->fSourceClass = "pat::Jet";
  rule->fTarget      = "jetFlavourInfo_";
  rule->fSource      = "int partonFlavour_";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__Jet_0);
  rule->fCode        = "\n    jetFlavourInfo_ = reco::JetFlavourInfo(0,onfile.partonFlavour_);\n  ";
  rule->fVersion     = "[1-11]";


  ::Reflex::ClassBuilder(Reflex::Literal("pat::Jet"), typeid(::pat::Jet), sizeof(::pat::Jet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "12")
  .AddProperty("ioread", readrules )
  .AddBase(type_13551, ::Reflex::BaseOffset< ::pat::Jet, ::pat::PATObject<reco::Jet> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21139, type_17797), Reflex::Literal("operator="), operator_59531, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17797), Reflex::Literal("Jet"), constructor_59532, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Jet"), constructor_59533, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71902), Reflex::Literal("Jet"), constructor_59534, 0, "aJet", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_65058), Reflex::Literal("Jet"), constructor_59535, 0, "aJetRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71968), Reflex::Literal("Jet"), constructor_59536, 0, "aJetRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Jet"), destructor_59537, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13487, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x45, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__Jet_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__Jet_funcmem_bld);
}

//------Delayed data member builder for class Jet -------------------
void __pat__Jet_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("embeddedCaloTowers_"), OffsetOf(__shadow__::__pat__Jet, embeddedCaloTowers_), ::Reflex::PROTECTED)
  .AddDataMember(type_7116, Reflex::Literal("caloTowersTemp_"), OffsetOf(__shadow__::__pat__Jet, caloTowersTemp_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT)
  .AddDataMember(type_870, Reflex::Literal("caloTowers_"), OffsetOf(__shadow__::__pat__Jet, caloTowers_), ::Reflex::PROTECTED)
  .AddDataMember(type_2743, Reflex::Literal("caloTowersFwdPtr_"), OffsetOf(__shadow__::__pat__Jet, caloTowersFwdPtr_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedPFCandidates_"), OffsetOf(__shadow__::__pat__Jet, embeddedPFCandidates_), ::Reflex::PROTECTED)
  .AddDataMember(type_7115, Reflex::Literal("pfCandidatesTemp_"), OffsetOf(__shadow__::__pat__Jet, pfCandidatesTemp_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT)
  .AddDataMember(type_11471, Reflex::Literal("pfCandidates_"), OffsetOf(__shadow__::__pat__Jet, pfCandidates_), ::Reflex::PROTECTED)
  .AddDataMember(type_11435, Reflex::Literal("pfCandidatesFwdPtr_"), OffsetOf(__shadow__::__pat__Jet, pfCandidatesFwdPtr_), ::Reflex::PROTECTED)
  .AddDataMember(type_3556, Reflex::Literal("genJet_"), OffsetOf(__shadow__::__pat__Jet, genJet_), ::Reflex::PROTECTED)
  .AddDataMember(type_11487, Reflex::Literal("genJetRef_"), OffsetOf(__shadow__::__pat__Jet, genJetRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_6838, Reflex::Literal("genJetFwdRef_"), OffsetOf(__shadow__::__pat__Jet, genJetFwdRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_11626, Reflex::Literal("jetFlavourInfo_"), OffsetOf(__shadow__::__pat__Jet, jetFlavourInfo_), ::Reflex::PROTECTED)
  .AddDataMember(type_3552, Reflex::Literal("jec_"), OffsetOf(__shadow__::__pat__Jet, jec_), ::Reflex::PROTECTED)
  .AddDataMember(type_227, Reflex::Literal("currentJECSet_"), OffsetOf(__shadow__::__pat__Jet, currentJECSet_), ::Reflex::PROTECTED)
  .AddDataMember(type_227, Reflex::Literal("currentJECLevel_"), OffsetOf(__shadow__::__pat__Jet, currentJECLevel_), ::Reflex::PROTECTED)
  .AddDataMember(type_59674, Reflex::Literal("currentJECFlavor_"), OffsetOf(__shadow__::__pat__Jet, currentJECFlavor_), ::Reflex::PROTECTED)
  .AddDataMember(type_3555, Reflex::Literal("pairDiscriVector_"), OffsetOf(__shadow__::__pat__Jet, pairDiscriVector_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("tagInfoLabels_"), OffsetOf(__shadow__::__pat__Jet, tagInfoLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_7464, Reflex::Literal("tagInfos_"), OffsetOf(__shadow__::__pat__Jet, tagInfos_), ::Reflex::PROTECTED)
  .AddDataMember(type_13467, Reflex::Literal("tagInfosFwdPtr_"), OffsetOf(__shadow__::__pat__Jet, tagInfosFwdPtr_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("jetCharge_"), OffsetOf(__shadow__::__pat__Jet, jetCharge_), ::Reflex::PROTECTED)
  .AddDataMember(type_11498, Reflex::Literal("associatedTracks_"), OffsetOf(__shadow__::__pat__Jet, associatedTracks_), ::Reflex::PROTECTED)
  .AddDataMember(type_3551, Reflex::Literal("specificCalo_"), OffsetOf(__shadow__::__pat__Jet, specificCalo_), ::Reflex::PROTECTED)
  .AddDataMember(type_3550, Reflex::Literal("specificJPT_"), OffsetOf(__shadow__::__pat__Jet, specificJPT_), ::Reflex::PROTECTED)
  .AddDataMember(type_3549, Reflex::Literal("specificPF_"), OffsetOf(__shadow__::__pat__Jet, specificPF_), ::Reflex::PROTECTED)
  .AddDataMember(type_11342, Reflex::Literal("jetID_"), OffsetOf(__shadow__::__pat__Jet, jetID_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Jet -------------------
void __pat__Jet_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14861), Reflex::Literal("clone"), method_59538, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22220), Reflex::Literal("genParton"), method_59539, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23638), Reflex::Literal("genJet"), method_59540, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("partonFlavour"), method_59541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("hadronFlavour"), method_59542, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73489), Reflex::Literal("jetFlavourInfo"), method_59543, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3528c), Reflex::Literal("availableJECSets"), method_59544, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3528c, type_18030), Reflex::Literal("availableJECLevels"), method_59545, 0, "set=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3528c, type_30686), Reflex::Literal("availableJECLevels"), method_59546, 0, "set", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("jecSetsAvailable"), method_59547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_30686), Reflex::Literal("jecSetAvailable"), method_59548, 0, "set", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18009), Reflex::Literal("jecSetAvailable"), method_59549, 0, "set", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3000), Reflex::Literal("currentJECSet"), method_59550, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3000), Reflex::Literal("currentJECLevel"), method_59551, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_59674), Reflex::Literal("currentJECFlavor"), method_59552, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_30686, type_30686, type_30686), Reflex::Literal("jecFactor"), method_59553, 0, "level;flavor=\"none\";set=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_18009, type_75117, type_18009), Reflex::Literal("jecFactor"), method_59554, 0, "level;flavor=NONE;set=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13487, type_30686, type_30686, type_30686), Reflex::Literal("correctedJet"), method_59555, 0, "level;flavor=\"none\";set=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13487, type_18009, type_75117, type_18009), Reflex::Literal("correctedJet"), method_59556, 0, "level;flavor=NONE;set=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45676, type_30686, type_30686, type_30686), Reflex::Literal("correctedP4"), method_59557, 0, "level;flavor=\"none\";set=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45676, type_18009, type_75117, type_18009), Reflex::Literal("correctedP4"), method_59558, 0, "level;flavor=NONE;set=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_30686), Reflex::Literal("bDiscriminator"), method_59565, 0, "theLabel", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65188), Reflex::Literal("getPairDiscri"), method_59566, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_3000c), Reflex::Literal("hasTagInfo"), method_59567, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24613, type_30686), Reflex::Literal("tagInfo"), method_59568, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24029, type_30686), Reflex::Literal("tagInfoTrackIP"), method_59569, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24094, type_30686), Reflex::Literal("tagInfoSoftLepton"), method_59570, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23833, type_30686), Reflex::Literal("tagInfoSecondaryVertex"), method_59571, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_23577), Reflex::Literal("addBDiscriminatorPair"), method_59572, 0, "thePair", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_30686, type_22994), Reflex::Literal("addTagInfo"), method_59573, 0, "label;info", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("jetCharge"), method_59574, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73028), Reflex::Literal("associatedTracks"), method_59575, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setJetCharge"), method_59576, 0, "jetCharge", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_73028), Reflex::Literal("setAssociatedTracks"), method_59577, 0, "tracks", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75118), Reflex::Literal("setCaloTowers"), method_59578, 0, "caloTowers", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75119), Reflex::Literal("setPFCandidates"), method_59579, 0, "pfCandidates", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75120, type_1810), Reflex::Literal("setGenParton"), method_59580, 0, "gp;embed=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_71068), Reflex::Literal("setGenJetRef"), method_59581, 0, "gj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_72), Reflex::Literal("setPartonFlavour"), method_59582, 0, "partonFl", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_72), Reflex::Literal("setHadronFlavour"), method_59583, 0, "hadronFl", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_73489), Reflex::Literal("setJetFlavourInfo"), method_59584, 0, "jetFlavourInfo", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_73049), Reflex::Literal("setJetID"), method_59585, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isCaloJet"), method_59586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isJPTJet"), method_59587, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPFJet"), method_59588, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isBasicJet"), method_59589, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75121), Reflex::Literal("caloSpecific"), method_59590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75122), Reflex::Literal("jptSpecific"), method_59591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75123), Reflex::Literal("pfSpecific"), method_59592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75121), Reflex::Literal("setCaloSpecific"), method_59593, 0, "newCaloSpecific", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75122), Reflex::Literal("setJPTSpecific"), method_59594, 0, "newJPTSpecific", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75123), Reflex::Literal("setPFSpecific"), method_59595, 0, "newPFSpecific", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("maxEInEmTowers"), method_59596, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("maxEInHadTowers"), method_59597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("energyFractionHadronic"), method_59598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("emEnergyFraction"), method_59599, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("hadEnergyInHB"), method_59600, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("hadEnergyInHO"), method_59601, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("hadEnergyInHE"), method_59602, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("hadEnergyInHF"), method_59603, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("emEnergyInEB"), method_59604, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("emEnergyInEE"), method_59605, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("emEnergyInHF"), method_59606, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("towersArea"), method_59607, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("n90"), method_59608, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("n60"), method_59609, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667, type_227), Reflex::Literal("getCaloConstituent"), method_59610, 0, "fIndex", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71768), Reflex::Literal("getCaloConstituents"), method_59611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73028), Reflex::Literal("pionsInVertexInCalo"), method_59612, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73028), Reflex::Literal("pionsInVertexOutCalo"), method_59613, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73028), Reflex::Literal("pionsOutVertexInCalo"), method_59614, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73028), Reflex::Literal("muonsInVertexInCalo"), method_59615, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73028), Reflex::Literal("muonsInVertexOutCalo"), method_59616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73028), Reflex::Literal("muonsOutVertexInCalo"), method_59617, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73028), Reflex::Literal("elecsInVertexInCalo"), method_59618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73028), Reflex::Literal("elecsInVertexOutCalo"), method_59619, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73028), Reflex::Literal("elecsOutVertexInCalo"), method_59620, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10145), Reflex::Literal("zspCorrection"), method_59621, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("elecMultiplicity"), method_59622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("muonMultiplicity"), method_59623, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("chargedMultiplicity"), method_59624, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("chargedEmEnergy"), method_59625, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("neutralEmEnergy"), method_59626, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("chargedHadronEnergy"), method_59627, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("neutralHadronEnergy"), method_59628, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("chargedHadronEnergyFraction"), method_59629, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("neutralHadronEnergyFraction"), method_59630, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("chargedEmEnergyFraction"), method_59631, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("neutralEmEnergyFraction"), method_59632, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("photonEnergy"), method_59633, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("photonEnergyFraction"), method_59634, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("electronEnergy"), method_59635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("electronEnergyFraction"), method_59636, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("muonEnergy"), method_59637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("muonEnergyFraction"), method_59638, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("HFHadronEnergy"), method_59639, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("HFHadronEnergyFraction"), method_59640, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("HFEMEnergy"), method_59641, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("HFEMEnergyFraction"), method_59642, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("chargedHadronMultiplicity"), method_59643, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("neutralHadronMultiplicity"), method_59644, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("photonMultiplicity"), method_59645, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("electronMultiplicity"), method_59646, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("HFHadronMultiplicity"), method_59647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("HFEMMultiplicity"), method_59648, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("chargedMuEnergy"), method_59649, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("chargedMuEnergyFraction"), method_59650, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("neutralMultiplicity"), method_59651, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11263, type_227), Reflex::Literal("getPFConstituent"), method_59652, 0, "fIndex", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65193), Reflex::Literal("getPFConstituents"), method_59653, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865, type_2393), Reflex::Literal("daughter"), method_59654, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("numberOfDaughters"), method_59655, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73049), Reflex::Literal("jetID"), method_59656, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75124), Reflex::Literal("caloTowersFwdPtr"), method_59657, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75125), Reflex::Literal("pfCandidatesFwdPtr"), method_59658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71068), Reflex::Literal("genJetFwdRef"), method_59659, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75126), Reflex::Literal("tagInfosFwdPtr"), method_59660, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_227, type_35225), Reflex::Literal("updateFwdCaloTowerFwdPtr"), method_59661, 0, "index;updateFwd", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_227, type_23707), Reflex::Literal("updateFwdPFCandidateFwdPtr"), method_59662, 0, "index;updateFwd", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_227, type_70692), Reflex::Literal("updateFwdTagInfoFwdPtr"), method_59663, 0, "index;updateFwd", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_7382), Reflex::Literal("updateFwdGenJetFwdRef"), method_59664, 0, "updateRef", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<pat::Jet,std::allocator<pat::Jet> > -------------------------------
static void constructor_21149( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Jet>();
  else ::new(mem) ::std::vector<pat::Jet>();
}

static void constructor_21150( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Jet>(*(const ::std::allocator<pat::Jet>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Jet>(*(const ::std::allocator<pat::Jet>*)arg[0]);
}

static void constructor_21151( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Jet>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::Jet>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Jet>(*(::std::size_t*)arg[0],
      *(const ::pat::Jet*)arg[1]);
  else ::new(mem) ::std::vector<pat::Jet>(*(::std::size_t*)arg[0],
      *(const ::pat::Jet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Jet>(*(::std::size_t*)arg[0],
      *(const ::pat::Jet*)arg[1],
      *(const ::std::allocator<pat::Jet>*)arg[2]);
  else ::new(mem) ::std::vector<pat::Jet>(*(::std::size_t*)arg[0],
      *(const ::pat::Jet*)arg[1],
      *(const ::std::allocator<pat::Jet>*)arg[2]);
  }
}

static void constructor_21152( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Jet>(*(const ::std::vector<pat::Jet>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Jet>(*(const ::std::vector<pat::Jet>*)arg[0]);
}

static void destructor_21153(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::Jet>*)o)->::std::vector<pat::Jet>::~vector)();
}
static  void operator_21154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Jet>*)o)->operator=)(*(const ::std::vector<pat::Jet>*)arg[0]);
  else   (((::std::vector<pat::Jet>*)o)->operator=)(*(const ::std::vector<pat::Jet>*)arg[0]);
}

static  void method_21155( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Jet>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::Jet*)arg[1]);
}

static  void method_21156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> >)((((::std::vector<pat::Jet>*)o)->begin)());
  else   (((::std::vector<pat::Jet>*)o)->begin)();
}

static  void method_21157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >)((((const ::std::vector<pat::Jet>*)o)->begin)());
  else   (((const ::std::vector<pat::Jet>*)o)->begin)();
}

static  void method_21158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> >)((((::std::vector<pat::Jet>*)o)->end)());
  else   (((::std::vector<pat::Jet>*)o)->end)();
}

static  void method_21159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >)((((const ::std::vector<pat::Jet>*)o)->end)());
  else   (((const ::std::vector<pat::Jet>*)o)->end)();
}

static  void method_21164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Jet>*)o)->size)());
  else   (((const ::std::vector<pat::Jet>*)o)->size)();
}

static  void method_21165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Jet>*)o)->max_size)());
  else   (((const ::std::vector<pat::Jet>*)o)->max_size)();
}

static  void method_21166( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::Jet>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::Jet>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::Jet*)arg[1]);
  }
}

static  void method_21167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Jet>*)o)->capacity)());
  else   (((const ::std::vector<pat::Jet>*)o)->capacity)();
}

static  void method_21168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::Jet>*)o)->empty)());
  else   (((const ::std::vector<pat::Jet>*)o)->empty)();
}

static  void method_21169( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Jet>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_21170( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Jet>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Jet>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_21171( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Jet>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Jet>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_21173( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Jet>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Jet>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21174( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Jet>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Jet>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Jet>*)o)->front)();
  else   (((::std::vector<pat::Jet>*)o)->front)();
}

static  void method_21176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Jet>*)o)->front)();
  else   (((const ::std::vector<pat::Jet>*)o)->front)();
}

static  void method_21177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Jet>*)o)->back)();
  else   (((::std::vector<pat::Jet>*)o)->back)();
}

static  void method_21178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Jet>*)o)->back)();
  else   (((const ::std::vector<pat::Jet>*)o)->back)();
}

static  void method_21179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::Jet>*)o)->data)());
  else   (((::std::vector<pat::Jet>*)o)->data)();
}

static  void method_21180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::Jet>*)o)->data)());
  else   (((const ::std::vector<pat::Jet>*)o)->data)();
}

static  void method_21181( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Jet>*)o)->push_back)(*(const ::pat::Jet*)arg[0]);
}

static  void method_21182( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Jet>*)o)->pop_back)();
}

static  void method_21183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> >)((((::std::vector<pat::Jet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> >*)arg[0],
    *(const ::pat::Jet*)arg[1]));
  else   (((::std::vector<pat::Jet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> >*)arg[0],
    *(const ::pat::Jet*)arg[1]);
}

static  void method_21184( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Jet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::Jet*)arg[2]);
}

static  void method_21185( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> >)((((::std::vector<pat::Jet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> >*)arg[0]));
  else   (((::std::vector<pat::Jet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> >*)arg[0]);
}

static  void method_21186( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> >)((((::std::vector<pat::Jet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> >*)arg[1]));
  else   (((::std::vector<pat::Jet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Jet*,std::vector<pat::Jet> >*)arg[1]);
}

static  void method_21187( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Jet>*)o)->swap)(*(::std::vector<pat::Jet>*)arg[0]);
}

static  void method_21188( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Jet>*)o)->clear)();
}

static void method_newdel_3516( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Jet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Jet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Jet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Jet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Jet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x47( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Jet,std::allocator<pat::Jet> >")), ::Reflex::BaseOffset< ::std::vector<pat::Jet>,::std::_Vector_base<pat::Jet,std::allocator<pat::Jet> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x48( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::Jet> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::Jet> >::Generate();
}

//------Dictionary for class vector<pat::Jet,std::allocator<pat::Jet> > -------------------------------
void __std__vector_pat__Jet__db_datamem(Reflex::Class*);
void __std__vector_pat__Jet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__Jet__datamem_bld(&__std__vector_pat__Jet__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__Jet__funcmem_bld(&__std__vector_pat__Jet__db_funcmem);
void __std__vector_pat__Jet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::Jet>"), typeid(::std::vector<pat::Jet>), sizeof(::std::vector<pat::Jet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2853, ::Reflex::BaseOffset< ::std::vector<pat::Jet>, ::std::_Vector_base<pat::Jet,std::allocator<pat::Jet> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13487, Reflex::Literal("std::vector<pat::Jet>::_Alloc_value_type"))
  .AddTypedef(type_2853, Reflex::Literal("std::vector<pat::Jet>::_Base"))
  .AddTypedef(type_3874, Reflex::Literal("std::vector<pat::Jet>::_Tp_alloc_type"))
  .AddTypedef(type_12385, Reflex::Literal("std::vector<pat::Jet>::_Alloc_traits"))
  .AddTypedef(type_13487, Reflex::Literal("std::vector<pat::Jet>::value_type"))
  .AddTypedef(type_14861, Reflex::Literal("std::vector<pat::Jet>::pointer"))
  .AddTypedef(type_17795, Reflex::Literal("std::vector<pat::Jet>::const_pointer"))
  .AddTypedef(type_21139, Reflex::Literal("std::vector<pat::Jet>::reference"))
  .AddTypedef(type_17797, Reflex::Literal("std::vector<pat::Jet>::const_reference"))
  .AddTypedef(type_12020, Reflex::Literal("std::vector<pat::Jet>::iterator"))
  .AddTypedef(type_11975, Reflex::Literal("std::vector<pat::Jet>::const_iterator"))
  .AddTypedef(type_4340, Reflex::Literal("std::vector<pat::Jet>::const_reverse_iterator"))
  .AddTypedef(type_4341, Reflex::Literal("std::vector<pat::Jet>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::Jet>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::Jet>::difference_type"))
  .AddTypedef(type_3874, Reflex::Literal("std::vector<pat::Jet>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_21149, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62685), Reflex::Literal("vector"), constructor_21150, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_17797, type_62685), Reflex::Literal("vector"), constructor_21151, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35597), Reflex::Literal("vector"), constructor_21152, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_21153, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3516, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x47, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x48, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__Jet__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::Jet,std::allocator<pat::Jet> > -------------------
void __std__vector_pat__Jet__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::Jet,std::allocator<pat::Jet> > -------------------
void __std__vector_pat__Jet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65091, type_35597), Reflex::Literal("operator="), operator_21154, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_17797), Reflex::Literal("assign"), method_21155, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12020), Reflex::Literal("begin"), method_21156, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11975), Reflex::Literal("begin"), method_21157, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12020), Reflex::Literal("end"), method_21158, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11975), Reflex::Literal("end"), method_21159, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_21164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_21165, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_13487), Reflex::Literal("resize"), method_21166, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_21167, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_21168, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_21169, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21139, type_3845), Reflex::Literal("operator[]"), operator_21170, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17797, type_3845), Reflex::Literal("operator[]"), operator_21171, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21139, type_3845), Reflex::Literal("at"), method_21173, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17797, type_3845), Reflex::Literal("at"), method_21174, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21139), Reflex::Literal("front"), method_21175, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17797), Reflex::Literal("front"), method_21176, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21139), Reflex::Literal("back"), method_21177, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17797), Reflex::Literal("back"), method_21178, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14861), Reflex::Literal("data"), method_21179, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17795), Reflex::Literal("data"), method_21180, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17797), Reflex::Literal("push_back"), method_21181, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_21182, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12020, type_12020, type_17797), Reflex::Literal("insert"), method_21183, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_12020, type_3845, type_17797), Reflex::Literal("insert"), method_21184, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12020, type_12020), Reflex::Literal("erase"), method_21185, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12020, type_12020, type_12020), Reflex::Literal("erase"), method_21186, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65091), Reflex::Literal("swap"), method_21187, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_21188, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Photon -------------------------------
static  void operator_60017( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::Photon*)o)->operator=)(*(const ::pat::Photon*)arg[0]);
  else   (((::pat::Photon*)o)->operator=)(*(const ::pat::Photon*)arg[0]);
}

static void constructor_60018( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Photon(*(const ::pat::Photon*)arg[0]);
  else ::new(mem) ::pat::Photon(*(const ::pat::Photon*)arg[0]);
}

static void constructor_60019( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Photon();
  else ::new(mem) ::pat::Photon();
}

static void constructor_60020( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Photon(*(const ::reco::Photon*)arg[0]);
  else ::new(mem) ::pat::Photon(*(const ::reco::Photon*)arg[0]);
}

static void constructor_60021( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Photon(*(const ::edm::RefToBase<reco::Photon>*)arg[0]);
  else ::new(mem) ::pat::Photon(*(const ::edm::RefToBase<reco::Photon>*)arg[0]);
}

static void constructor_60022( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Photon(*(const ::edm::Ptr<reco::Photon>*)arg[0]);
  else ::new(mem) ::pat::Photon(*(const ::edm::Ptr<reco::Photon>*)arg[0]);
}

static void destructor_60023(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::Photon*)o)->::pat::Photon::~Photon)();
}
static  void method_60024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Photon*)o)->clone)());
  else   (((const ::pat::Photon*)o)->clone)();
}

static  void method_60025( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::SuperClusterRef)((((const ::pat::Photon*)o)->superCluster)());
  else   (((const ::pat::Photon*)o)->superCluster)();
}

static  void method_60026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::CaloClusterPtr)((((const ::pat::Photon*)o)->seed)());
  else   (((const ::pat::Photon*)o)->seed)();
}

static  void method_60027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Photon*)o)->basicClusters)();
  else   (((const ::pat::Photon*)o)->basicClusters)();
}

static  void method_60028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Photon*)o)->preshowerClusters)();
  else   (((const ::pat::Photon*)o)->preshowerClusters)();
}

static  void method_60029( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Photon*)o)->recHits)());
  else   (((const ::pat::Photon*)o)->recHits)();
}

static  void method_60030( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Photon*)o)->embedSuperCluster)();
}

static  void method_60031( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Photon*)o)->embedSeedCluster)();
}

static  void method_60032( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Photon*)o)->embedBasicClusters)();
}

static  void method_60033( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Photon*)o)->embedPreshowerClusters)();
}

static  void method_60034( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->embedRecHits)((const ::EcalRecHitCollection*)arg[0]);
}

static  void method_60035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Photon*)o)->genPhoton)());
  else   (((const ::pat::Photon*)o)->genPhoton)();
}

static  void method_60036( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::Photon*)o)->setGenPhoton)(*(const ::reco::GenParticleRef*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::Photon*)o)->setGenPhoton)(*(const ::reco::GenParticleRef*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_60037( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::pat::Photon*)o)->photonID)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::Photon*)o)->photonID)(*(const ::std::string*)arg[0]);
}

static  void method_60038( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Photon*)o)->isPhotonIDAvailable)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::Photon*)o)->isPhotonIDAvailable)(*(const ::std::string*)arg[0]);
}

static  void method_60039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Photon*)o)->photonIDs)();
  else   (((const ::pat::Photon*)o)->photonIDs)();
}

static  void method_60040( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setPhotonIDs)(*(const ::std::vector<std::pair<std::basic_string<char>,bool> >*)arg[0]);
}

static  void method_60041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->trackIso)());
  else   (((const ::pat::Photon*)o)->trackIso)();
}

static  void method_60042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->ecalIso)());
  else   (((const ::pat::Photon*)o)->ecalIso)();
}

static  void method_60043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->hcalIso)());
  else   (((const ::pat::Photon*)o)->hcalIso)();
}

static  void method_60044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->caloIso)());
  else   (((const ::pat::Photon*)o)->caloIso)();
}

static  void method_60045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->particleIso)());
  else   (((const ::pat::Photon*)o)->particleIso)();
}

static  void method_60046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->chargedHadronIso)());
  else   (((const ::pat::Photon*)o)->chargedHadronIso)();
}

static  void method_60047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->neutralHadronIso)());
  else   (((const ::pat::Photon*)o)->neutralHadronIso)();
}

static  void method_60048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->photonIso)());
  else   (((const ::pat::Photon*)o)->photonIso)();
}

static  void method_60049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->puChargedHadronIso)());
  else   (((const ::pat::Photon*)o)->puChargedHadronIso)();
}

static  void method_60050( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->userIso)());
    else     (((const ::pat::Photon*)o)->userIso)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->userIso)(*(::uint8_t*)arg[0]));
    else     (((const ::pat::Photon*)o)->userIso)(*(::uint8_t*)arg[0]);
  }
}

static  void method_60051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->userIsolation)(*(::pat::IsolationKeys*)arg[0]));
  else   (((const ::pat::Photon*)o)->userIsolation)(*(::pat::IsolationKeys*)arg[0]);
}

static  void method_60052( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setIsolation)(*(::pat::IsolationKeys*)arg[0],
    *(float*)arg[1]);
}

static  void method_60053( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setTrackIso)(*(float*)arg[0]);
}

static  void method_60054( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setEcalIso)(*(float*)arg[0]);
}

static  void method_60055( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setHcalIso)(*(float*)arg[0]);
}

static  void method_60056( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::Photon*)o)->setUserIso)(*(float*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::Photon*)o)->setUserIso)(*(float*)arg[0],
      *(::uint8_t*)arg[1]);
  }
}

static  void method_60057( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Photon*)o)->isoDeposit)(*(::pat::IsolationKeys*)arg[0]));
  else   (((const ::pat::Photon*)o)->isoDeposit)(*(::pat::IsolationKeys*)arg[0]);
}

static  void method_60058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Photon*)o)->trackIsoDeposit)());
  else   (((const ::pat::Photon*)o)->trackIsoDeposit)();
}

static  void method_60059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Photon*)o)->ecalIsoDeposit)());
  else   (((const ::pat::Photon*)o)->ecalIsoDeposit)();
}

static  void method_60060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Photon*)o)->hcalIsoDeposit)());
  else   (((const ::pat::Photon*)o)->hcalIsoDeposit)();
}

static  void method_60061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Photon*)o)->userIsoDeposit)());
    else     (((const ::pat::Photon*)o)->userIsoDeposit)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Photon*)o)->userIsoDeposit)(*(::uint8_t*)arg[0]));
    else     (((const ::pat::Photon*)o)->userIsoDeposit)(*(::uint8_t*)arg[0]);
  }
}

static  void method_60062( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setIsoDeposit)(*(::pat::IsolationKeys*)arg[0],
    *(const ::pat::IsoDeposit*)arg[1]);
}

static  void method_60063( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->trackIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
}

static  void method_60064( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->ecalIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
}

static  void method_60065( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->hcalIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
}

static  void method_60066( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::Photon*)o)->userIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::Photon*)o)->userIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0],
      *(::uint8_t*)arg[1]);
  }
}

static  void method_60067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Photon*)o)->passElectronVeto)());
  else   (((const ::pat::Photon*)o)->passElectronVeto)();
}

static  void method_60068( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setPassElectronVeto)(*(bool*)arg[0]);
}

static  void method_60069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Photon*)o)->hasPixelSeed)());
  else   (((const ::pat::Photon*)o)->hasPixelSeed)();
}

static  void method_60070( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setHasPixelSeed)(*(bool*)arg[0]);
}

static  void method_60071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->seedEnergy)());
  else   (((const ::pat::Photon*)o)->seedEnergy)();
}

static  void method_60072( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setSeedEnergy)(*(float*)arg[0]);
}

static  void method_60073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->eMax)());
  else   (((const ::pat::Photon*)o)->eMax)();
}

static  void method_60074( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setEMax)(*(float*)arg[0]);
}

static  void method_60075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->e2nd)());
  else   (((const ::pat::Photon*)o)->e2nd)();
}

static  void method_60076( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setE2nd)(*(float*)arg[0]);
}

static  void method_60077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->e3x3)());
  else   (((const ::pat::Photon*)o)->e3x3)();
}

static  void method_60078( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setE3x3)(*(float*)arg[0]);
}

static  void method_60079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->eTop)());
  else   (((const ::pat::Photon*)o)->eTop)();
}

static  void method_60080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setETop)(*(float*)arg[0]);
}

static  void method_60081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->eBottom)());
  else   (((const ::pat::Photon*)o)->eBottom)();
}

static  void method_60082( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setEBottom)(*(float*)arg[0]);
}

static  void method_60083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->eLeft)());
  else   (((const ::pat::Photon*)o)->eLeft)();
}

static  void method_60084( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setELeft)(*(float*)arg[0]);
}

static  void method_60085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->eRight)());
  else   (((const ::pat::Photon*)o)->eRight)();
}

static  void method_60086( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setERight)(*(float*)arg[0]);
}

static  void method_60087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->see)());
  else   (((const ::pat::Photon*)o)->see)();
}

static  void method_60088( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setSee)(*(float*)arg[0]);
}

static  void method_60089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->spp)());
  else   (((const ::pat::Photon*)o)->spp)();
}

static  void method_60090( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setSpp)(*(float*)arg[0]);
}

static  void method_60091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->sep)());
  else   (((const ::pat::Photon*)o)->sep)();
}

static  void method_60092( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setSep)(*(float*)arg[0]);
}

static  void method_60093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->maxDR)());
  else   (((const ::pat::Photon*)o)->maxDR)();
}

static  void method_60094( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setMaxDR)(*(float*)arg[0]);
}

static  void method_60095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->maxDRDPhi)());
  else   (((const ::pat::Photon*)o)->maxDRDPhi)();
}

static  void method_60096( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setMaxDRDPhi)(*(float*)arg[0]);
}

static  void method_60097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->maxDRDEta)());
  else   (((const ::pat::Photon*)o)->maxDRDEta)();
}

static  void method_60098( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setMaxDRDEta)(*(float*)arg[0]);
}

static  void method_60099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->maxDRRawEnergy)());
  else   (((const ::pat::Photon*)o)->maxDRRawEnergy)();
}

static  void method_60100( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setMaxDRRawEnergy)(*(float*)arg[0]);
}

static  void method_60101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->subClusRawE1)());
  else   (((const ::pat::Photon*)o)->subClusRawE1)();
}

static  void method_60102( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setSubClusRawE1)(*(float*)arg[0]);
}

static  void method_60103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->subClusRawE2)());
  else   (((const ::pat::Photon*)o)->subClusRawE2)();
}

static  void method_60104( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setSubClusRawE2)(*(float*)arg[0]);
}

static  void method_60105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->subClusRawE3)());
  else   (((const ::pat::Photon*)o)->subClusRawE3)();
}

static  void method_60106( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setSubClusRawE3)(*(float*)arg[0]);
}

static  void method_60107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->subClusDPhi1)());
  else   (((const ::pat::Photon*)o)->subClusDPhi1)();
}

static  void method_60108( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setSubClusDPhi1)(*(float*)arg[0]);
}

static  void method_60109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->subClusDPhi2)());
  else   (((const ::pat::Photon*)o)->subClusDPhi2)();
}

static  void method_60110( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setSubClusDPhi2)(*(float*)arg[0]);
}

static  void method_60111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->subClusDPhi3)());
  else   (((const ::pat::Photon*)o)->subClusDPhi3)();
}

static  void method_60112( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setSubClusDPhi3)(*(float*)arg[0]);
}

static  void method_60113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->subClusDEta1)());
  else   (((const ::pat::Photon*)o)->subClusDEta1)();
}

static  void method_60114( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setSubClusDEta1)(*(float*)arg[0]);
}

static  void method_60115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->subClusDEta2)());
  else   (((const ::pat::Photon*)o)->subClusDEta2)();
}

static  void method_60116( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setSubClusDEta2)(*(float*)arg[0]);
}

static  void method_60117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->subClusDEta3)());
  else   (((const ::pat::Photon*)o)->subClusDEta3)();
}

static  void method_60118( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setSubClusDEta3)(*(float*)arg[0]);
}

static  void method_60119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->cryPhi)());
  else   (((const ::pat::Photon*)o)->cryPhi)();
}

static  void method_60120( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setCryPhi)(*(float*)arg[0]);
}

static  void method_60121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->cryEta)());
  else   (((const ::pat::Photon*)o)->cryEta)();
}

static  void method_60122( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setCryEta)(*(float*)arg[0]);
}

static  void method_60123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->iPhi)());
  else   (((const ::pat::Photon*)o)->iPhi)();
}

static  void method_60124( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setIPhi)(*(float*)arg[0]);
}

static  void method_60125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->iEta)());
  else   (((const ::pat::Photon*)o)->iEta)();
}

static  void method_60126( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setIEta)(*(float*)arg[0]);
}

static  void method_60127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full5x5_e1x5)());
  else   (((const ::pat::Photon*)o)->full5x5_e1x5)();
}

static  void method_60128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full5x5_e2x5)());
  else   (((const ::pat::Photon*)o)->full5x5_e2x5)();
}

static  void method_60129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full3x3_e3x3)());
  else   (((const ::pat::Photon*)o)->full3x3_e3x3)();
}

static  void method_60130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full5x5_e5x5)());
  else   (((const ::pat::Photon*)o)->full5x5_e5x5)();
}

static  void method_60131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full5x5_maxEnergyXtal)());
  else   (((const ::pat::Photon*)o)->full5x5_maxEnergyXtal)();
}

static  void method_60132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full5x5_sigmaEtaEta)());
  else   (((const ::pat::Photon*)o)->full5x5_sigmaEtaEta)();
}

static  void method_60133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full5x5_sigmaIetaIeta)());
  else   (((const ::pat::Photon*)o)->full5x5_sigmaIetaIeta)();
}

static  void method_60134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full5x5_r1x5)());
  else   (((const ::pat::Photon*)o)->full5x5_r1x5)();
}

static  void method_60135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full5x5_r2x5)());
  else   (((const ::pat::Photon*)o)->full5x5_r2x5)();
}

static  void method_60136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full5x5_r9)());
  else   (((const ::pat::Photon*)o)->full5x5_r9)();
}

static  void method_60137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full5x5_hadronicDepth1OverEm)());
  else   (((const ::pat::Photon*)o)->full5x5_hadronicDepth1OverEm)();
}

static  void method_60138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full5x5_hadronicDepth2OverEm)());
  else   (((const ::pat::Photon*)o)->full5x5_hadronicDepth2OverEm)();
}

static  void method_60139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full5x5_hadronicOverEm)());
  else   (((const ::pat::Photon*)o)->full5x5_hadronicOverEm)();
}

static  void method_60140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full5x5_hadTowDepth1OverEm)());
  else   (((const ::pat::Photon*)o)->full5x5_hadTowDepth1OverEm)();
}

static  void method_60141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full5x5_hadTowDepth2OverEm)());
  else   (((const ::pat::Photon*)o)->full5x5_hadTowDepth2OverEm)();
}

static  void method_60142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Photon*)o)->full5x5_hadTowOverEm)());
  else   (((const ::pat::Photon*)o)->full5x5_hadTowOverEm)();
}

static  void method_60143( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->full5x5_setShowerShape)(*(const ::reco::Photon::ShowerShape*)arg[0]);
}

static  void method_60144( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setPackedPFCandidateCollection)(*(const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)arg[0]);
}

static  void method_60145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >)((((const ::pat::Photon*)o)->associatedPackedPFCandidates)());
  else   (((const ::pat::Photon*)o)->associatedPackedPFCandidates)();
}

static  void method_60146( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Photon*)o)->setAssociatedPackedPFCandidates)(*(const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0]);
}

static  void method_60147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::Photon*)o)->numberOfSourceCandidatePtrs)());
  else   (((const ::pat::Photon*)o)->numberOfSourceCandidatePtrs)();
}

static  void method_60148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtr)((((const ::pat::Photon*)o)->sourceCandidatePtr)(*(::size_t*)arg[0]));
  else   (((const ::pat::Photon*)o)->sourceCandidatePtr)(*(::size_t*)arg[0]);
}

static void method_newdel_13525( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::Photon >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::Photon >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::Photon >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::Photon >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::Photon >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x50( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::Photon>")), ::Reflex::BaseOffset< ::pat::Photon,::pat::PATObject<reco::Photon> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Photon")), ::Reflex::BaseOffset< ::pat::Photon,::reco::Photon >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::pat::Photon,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::Photon,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::Photon,::reco::Candidate >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

void read___pat__Photon_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  edm::AtomicPtrCache<std::vector<reco::SuperCluster> > &superClusterRelinked_ = *(edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)(target + OffsetOf(__shadow__::__pat__Photon, superClusterRelinked_));

  if( oldObj ) {}
  //--- User's code ---
    superClusterRelinked_.reset();
  
}

//------Dictionary for class Photon -------------------------------
void __pat__Photon_db_datamem(Reflex::Class*);
void __pat__Photon_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__Photon_datamem_bld(&__pat__Photon_db_datamem);
Reflex::GenreflexMemberBuilder __pat__Photon_funcmem_bld(&__pat__Photon_db_funcmem);
void __pat__Photon_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(1);
  rule = &readrules[0];
  rule->fSourceClass = "pat::Photon";
  rule->fTarget      = "superClusterRelinked_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__Photon_0);
  rule->fCode        = "\n    superClusterRelinked_.reset();\n  ";
  rule->fVersion     = "[1-]";


  ::Reflex::ClassBuilder(Reflex::Literal("pat::Photon"), typeid(::pat::Photon), sizeof(::pat::Photon), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "14")
  .AddProperty("ioread", readrules )
  .AddBase(type_13552, ::Reflex::BaseOffset< ::pat::Photon, ::pat::PATObject<reco::Photon> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3449, Reflex::Literal("pat::Photon::IdPair"))
  .AddTypedef(type_3523, Reflex::Literal("pat::Photon::IsoDepositPairs"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21202, type_17808), Reflex::Literal("operator="), operator_60017, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17808), Reflex::Literal("Photon"), constructor_60018, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Photon"), constructor_60019, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27469), Reflex::Literal("Photon"), constructor_60020, 0, "aPhoton", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71905), Reflex::Literal("Photon"), constructor_60021, 0, "aPhotonRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71970), Reflex::Literal("Photon"), constructor_60022, 0, "aPhotonRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Photon"), destructor_60023, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13525, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x50, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__Photon_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__Photon_funcmem_bld);
}

//------Delayed data member builder for class Photon -------------------
void __pat__Photon_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("embeddedSuperCluster_"), OffsetOf(__shadow__::__pat__Photon, embeddedSuperCluster_), ::Reflex::PROTECTED)
  .AddDataMember(type_3524, Reflex::Literal("superCluster_"), OffsetOf(__shadow__::__pat__Photon, superCluster_), ::Reflex::PROTECTED)
  .AddDataMember(type_7117, Reflex::Literal("superClusterRelinked_"), OffsetOf(__shadow__::__pat__Photon, superClusterRelinked_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT)
  .AddDataMember(type_3585, Reflex::Literal("basicClusters_"), OffsetOf(__shadow__::__pat__Photon, basicClusters_), ::Reflex::PROTECTED)
  .AddDataMember(type_3585, Reflex::Literal("preshowerClusters_"), OffsetOf(__shadow__::__pat__Photon, preshowerClusters_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedSeedCluster_"), OffsetOf(__shadow__::__pat__Photon, embeddedSeedCluster_), ::Reflex::PROTECTED)
  .AddDataMember(type_3585, Reflex::Literal("seedCluster_"), OffsetOf(__shadow__::__pat__Photon, seedCluster_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedRecHits_"), OffsetOf(__shadow__::__pat__Photon, embeddedRecHits_), ::Reflex::PROTECTED)
  .AddDataMember(type_831, Reflex::Literal("recHits_"), OffsetOf(__shadow__::__pat__Photon, recHits_), ::Reflex::PROTECTED)
  .AddDataMember(type_3583, Reflex::Literal("photonIDs_"), OffsetOf(__shadow__::__pat__Photon, photonIDs_), ::Reflex::PROTECTED)
  .AddDataMember(type_3523, Reflex::Literal("isoDeposits_"), OffsetOf(__shadow__::__pat__Photon, isoDeposits_), ::Reflex::PROTECTED)
  .AddDataMember(type_3527, Reflex::Literal("isolations_"), OffsetOf(__shadow__::__pat__Photon, isolations_), ::Reflex::PROTECTED)
  .AddDataMember(type_7221, Reflex::Literal("packedPFCandidates_"), OffsetOf(__shadow__::__pat__Photon, packedPFCandidates_), ::Reflex::PROTECTED)
  .AddDataMember(type_3584, Reflex::Literal("associatedPackedFCandidateIndices_"), OffsetOf(__shadow__::__pat__Photon, associatedPackedFCandidateIndices_), ::Reflex::PROTECTED)
  .AddDataMember(type_48127, Reflex::Literal("full5x5_showerShape_"), OffsetOf(__shadow__::__pat__Photon, full5x5_showerShape_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("passElectronVeto_"), OffsetOf(__shadow__::__pat__Photon, passElectronVeto_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("hasPixelSeed_"), OffsetOf(__shadow__::__pat__Photon, hasPixelSeed_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("seedEnergy_"), OffsetOf(__shadow__::__pat__Photon, seedEnergy_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("eMax_"), OffsetOf(__shadow__::__pat__Photon, eMax_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("e2nd_"), OffsetOf(__shadow__::__pat__Photon, e2nd_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("e3x3_"), OffsetOf(__shadow__::__pat__Photon, e3x3_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("eTop_"), OffsetOf(__shadow__::__pat__Photon, eTop_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("eBottom_"), OffsetOf(__shadow__::__pat__Photon, eBottom_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("eLeft_"), OffsetOf(__shadow__::__pat__Photon, eLeft_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("eRight_"), OffsetOf(__shadow__::__pat__Photon, eRight_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("see_"), OffsetOf(__shadow__::__pat__Photon, see_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("spp_"), OffsetOf(__shadow__::__pat__Photon, spp_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("sep_"), OffsetOf(__shadow__::__pat__Photon, sep_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("maxDR_"), OffsetOf(__shadow__::__pat__Photon, maxDR_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("maxDRDPhi_"), OffsetOf(__shadow__::__pat__Photon, maxDRDPhi_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("maxDRDEta_"), OffsetOf(__shadow__::__pat__Photon, maxDRDEta_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("maxDRRawEnergy_"), OffsetOf(__shadow__::__pat__Photon, maxDRRawEnergy_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("subClusRawE1_"), OffsetOf(__shadow__::__pat__Photon, subClusRawE1_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("subClusRawE2_"), OffsetOf(__shadow__::__pat__Photon, subClusRawE2_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("subClusRawE3_"), OffsetOf(__shadow__::__pat__Photon, subClusRawE3_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("subClusDPhi1_"), OffsetOf(__shadow__::__pat__Photon, subClusDPhi1_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("subClusDPhi2_"), OffsetOf(__shadow__::__pat__Photon, subClusDPhi2_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("subClusDPhi3_"), OffsetOf(__shadow__::__pat__Photon, subClusDPhi3_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("subClusDEta1_"), OffsetOf(__shadow__::__pat__Photon, subClusDEta1_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("subClusDEta2_"), OffsetOf(__shadow__::__pat__Photon, subClusDEta2_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("subClusDEta3_"), OffsetOf(__shadow__::__pat__Photon, subClusDEta3_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("cryEta_"), OffsetOf(__shadow__::__pat__Photon, cryEta_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("cryPhi_"), OffsetOf(__shadow__::__pat__Photon, cryPhi_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("iEta_"), OffsetOf(__shadow__::__pat__Photon, iEta_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("iPhi_"), OffsetOf(__shadow__::__pat__Photon, iPhi_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Photon -------------------
void __pat__Photon_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15279), Reflex::Literal("clone"), method_60024, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11485), Reflex::Literal("superCluster"), method_60025, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11624), Reflex::Literal("seed"), method_60026, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35752), Reflex::Literal("basicClusters"), method_60027, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35752), Reflex::Literal("preshowerClusters"), method_60028, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75130), Reflex::Literal("recHits"), method_60029, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedSuperCluster"), method_60030, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedSeedCluster"), method_60031, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedBasicClusters"), method_60032, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedPreshowerClusters"), method_60033, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75130), Reflex::Literal("embedRecHits"), method_60034, 0, "rechits", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("genPhoton"), method_60035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75120, type_1810), Reflex::Literal("setGenPhoton"), method_60036, 0, "gp;embed=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1811, type_30686), Reflex::Literal("photonID"), method_60037, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_30686), Reflex::Literal("isPhotonIDAvailable"), method_60038, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65275), Reflex::Literal("photonIDs"), method_60039, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65275), Reflex::Literal("setPhotonIDs"), method_60040, 0, "ids", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("trackIso"), method_60041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("ecalIso"), method_60042, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("hcalIso"), method_60043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("caloIso"), method_60044, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("particleIso"), method_60045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("chargedHadronIso"), method_60046, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("neutralHadronIso"), method_60047, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("photonIso"), method_60048, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("puChargedHadronIso"), method_60049, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_2051), Reflex::Literal("userIso"), method_60050, 0, "index=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_13493), Reflex::Literal("userIsolation"), method_60051, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_13493, type_990), Reflex::Literal("setIsolation"), method_60052, 0, "key;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setTrackIso"), method_60053, 0, "trackIso", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setEcalIso"), method_60054, 0, "caloIso", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setHcalIso"), method_60055, 0, "caloIso", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990, type_2051), Reflex::Literal("setUserIso"), method_60056, 0, "value;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131, type_13493), Reflex::Literal("isoDeposit"), method_60057, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131), Reflex::Literal("trackIsoDeposit"), method_60058, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131), Reflex::Literal("ecalIsoDeposit"), method_60059, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131), Reflex::Literal("hcalIsoDeposit"), method_60060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131, type_2051), Reflex::Literal("userIsoDeposit"), method_60061, 0, "index=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_13493, type_75132), Reflex::Literal("setIsoDeposit"), method_60062, 0, "key;dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132), Reflex::Literal("trackIsoDeposit"), method_60063, 0, "dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132), Reflex::Literal("ecalIsoDeposit"), method_60064, 0, "dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132), Reflex::Literal("hcalIsoDeposit"), method_60065, 0, "dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132, type_2051), Reflex::Literal("userIsoDeposit"), method_60066, 0, "dep;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("passElectronVeto"), method_60067, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_1810), Reflex::Literal("setPassElectronVeto"), method_60068, 0, "flag", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasPixelSeed"), method_60069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_1810), Reflex::Literal("setHasPixelSeed"), method_60070, 0, "flag", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("seedEnergy"), method_60071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setSeedEnergy"), method_60072, 0, "e", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("eMax"), method_60073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setEMax"), method_60074, 0, "e", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("e2nd"), method_60075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setE2nd"), method_60076, 0, "e", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("e3x3"), method_60077, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setE3x3"), method_60078, 0, "e", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("eTop"), method_60079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setETop"), method_60080, 0, "e", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("eBottom"), method_60081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setEBottom"), method_60082, 0, "e", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("eLeft"), method_60083, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setELeft"), method_60084, 0, "e", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("eRight"), method_60085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setERight"), method_60086, 0, "e", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("see"), method_60087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setSee"), method_60088, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("spp"), method_60089, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setSpp"), method_60090, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("sep"), method_60091, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setSep"), method_60092, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("maxDR"), method_60093, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setMaxDR"), method_60094, 0, "m", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("maxDRDPhi"), method_60095, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setMaxDRDPhi"), method_60096, 0, "m", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("maxDRDEta"), method_60097, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setMaxDRDEta"), method_60098, 0, "m", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("maxDRRawEnergy"), method_60099, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setMaxDRRawEnergy"), method_60100, 0, "m", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("subClusRawE1"), method_60101, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setSubClusRawE1"), method_60102, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("subClusRawE2"), method_60103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setSubClusRawE2"), method_60104, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("subClusRawE3"), method_60105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setSubClusRawE3"), method_60106, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("subClusDPhi1"), method_60107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setSubClusDPhi1"), method_60108, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("subClusDPhi2"), method_60109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setSubClusDPhi2"), method_60110, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("subClusDPhi3"), method_60111, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setSubClusDPhi3"), method_60112, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("subClusDEta1"), method_60113, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setSubClusDEta1"), method_60114, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("subClusDEta2"), method_60115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setSubClusDEta2"), method_60116, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("subClusDEta3"), method_60117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setSubClusDEta3"), method_60118, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("cryPhi"), method_60119, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setCryPhi"), method_60120, 0, "c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("cryEta"), method_60121, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setCryEta"), method_60122, 0, "c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("iPhi"), method_60123, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setIPhi"), method_60124, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("iEta"), method_60125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setIEta"), method_60126, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_e1x5"), method_60127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_e2x5"), method_60128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full3x3_e3x3"), method_60129, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_e5x5"), method_60130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_maxEnergyXtal"), method_60131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_sigmaEtaEta"), method_60132, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_sigmaIetaIeta"), method_60133, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_r1x5"), method_60134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_r2x5"), method_60135, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_r9"), method_60136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_hadronicDepth1OverEm"), method_60137, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_hadronicDepth2OverEm"), method_60138, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_hadronicOverEm"), method_60139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_hadTowDepth1OverEm"), method_60140, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_hadTowDepth2OverEm"), method_60141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_hadTowOverEm"), method_60142, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_73313), Reflex::Literal("full5x5_setShowerShape"), method_60143, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_71851), Reflex::Literal("setPackedPFCandidateCollection"), method_60144, 0, "refprod", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6477), Reflex::Literal("associatedPackedPFCandidates"), method_60145, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70702), Reflex::Literal("setAssociatedPackedPFCandidates"), method_60146, 0, "refvector", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("numberOfSourceCandidatePtrs"), method_60147, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11562, type_2393), Reflex::Literal("sourceCandidatePtr"), method_60148, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<pat::Photon,std::allocator<pat::Photon> > -------------------------------
static void constructor_21212( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Photon>();
  else ::new(mem) ::std::vector<pat::Photon>();
}

static void constructor_21213( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Photon>(*(const ::std::allocator<pat::Photon>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Photon>(*(const ::std::allocator<pat::Photon>*)arg[0]);
}

static void constructor_21214( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Photon>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::Photon>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Photon>(*(::std::size_t*)arg[0],
      *(const ::pat::Photon*)arg[1]);
  else ::new(mem) ::std::vector<pat::Photon>(*(::std::size_t*)arg[0],
      *(const ::pat::Photon*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Photon>(*(::std::size_t*)arg[0],
      *(const ::pat::Photon*)arg[1],
      *(const ::std::allocator<pat::Photon>*)arg[2]);
  else ::new(mem) ::std::vector<pat::Photon>(*(::std::size_t*)arg[0],
      *(const ::pat::Photon*)arg[1],
      *(const ::std::allocator<pat::Photon>*)arg[2]);
  }
}

static void constructor_21215( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Photon>(*(const ::std::vector<pat::Photon>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Photon>(*(const ::std::vector<pat::Photon>*)arg[0]);
}

static void destructor_21216(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::Photon>*)o)->::std::vector<pat::Photon>::~vector)();
}
static  void operator_21217( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Photon>*)o)->operator=)(*(const ::std::vector<pat::Photon>*)arg[0]);
  else   (((::std::vector<pat::Photon>*)o)->operator=)(*(const ::std::vector<pat::Photon>*)arg[0]);
}

static  void method_21218( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Photon>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::Photon*)arg[1]);
}

static  void method_21219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> >)((((::std::vector<pat::Photon>*)o)->begin)());
  else   (((::std::vector<pat::Photon>*)o)->begin)();
}

static  void method_21220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >)((((const ::std::vector<pat::Photon>*)o)->begin)());
  else   (((const ::std::vector<pat::Photon>*)o)->begin)();
}

static  void method_21221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> >)((((::std::vector<pat::Photon>*)o)->end)());
  else   (((::std::vector<pat::Photon>*)o)->end)();
}

static  void method_21222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >)((((const ::std::vector<pat::Photon>*)o)->end)());
  else   (((const ::std::vector<pat::Photon>*)o)->end)();
}

static  void method_21227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Photon>*)o)->size)());
  else   (((const ::std::vector<pat::Photon>*)o)->size)();
}

static  void method_21228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Photon>*)o)->max_size)());
  else   (((const ::std::vector<pat::Photon>*)o)->max_size)();
}

static  void method_21229( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::Photon>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::Photon>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::Photon*)arg[1]);
  }
}

static  void method_21230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Photon>*)o)->capacity)());
  else   (((const ::std::vector<pat::Photon>*)o)->capacity)();
}

static  void method_21231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::Photon>*)o)->empty)());
  else   (((const ::std::vector<pat::Photon>*)o)->empty)();
}

static  void method_21232( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Photon>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_21233( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Photon>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Photon>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_21234( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Photon>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Photon>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_21236( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Photon>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Photon>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21237( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Photon>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Photon>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Photon>*)o)->front)();
  else   (((::std::vector<pat::Photon>*)o)->front)();
}

static  void method_21239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Photon>*)o)->front)();
  else   (((const ::std::vector<pat::Photon>*)o)->front)();
}

static  void method_21240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Photon>*)o)->back)();
  else   (((::std::vector<pat::Photon>*)o)->back)();
}

static  void method_21241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Photon>*)o)->back)();
  else   (((const ::std::vector<pat::Photon>*)o)->back)();
}

static  void method_21242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::Photon>*)o)->data)());
  else   (((::std::vector<pat::Photon>*)o)->data)();
}

static  void method_21243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::Photon>*)o)->data)());
  else   (((const ::std::vector<pat::Photon>*)o)->data)();
}

static  void method_21244( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Photon>*)o)->push_back)(*(const ::pat::Photon*)arg[0]);
}

static  void method_21245( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Photon>*)o)->pop_back)();
}

static  void method_21246( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> >)((((::std::vector<pat::Photon>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> >*)arg[0],
    *(const ::pat::Photon*)arg[1]));
  else   (((::std::vector<pat::Photon>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> >*)arg[0],
    *(const ::pat::Photon*)arg[1]);
}

static  void method_21247( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Photon>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::Photon*)arg[2]);
}

static  void method_21248( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> >)((((::std::vector<pat::Photon>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> >*)arg[0]));
  else   (((::std::vector<pat::Photon>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> >*)arg[0]);
}

static  void method_21249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> >)((((::std::vector<pat::Photon>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> >*)arg[1]));
  else   (((::std::vector<pat::Photon>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Photon*,std::vector<pat::Photon> >*)arg[1]);
}

static  void method_21250( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Photon>*)o)->swap)(*(::std::vector<pat::Photon>*)arg[0]);
}

static  void method_21251( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Photon>*)o)->clear)();
}

static void method_newdel_3517( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x52( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Photon,std::allocator<pat::Photon> >")), ::Reflex::BaseOffset< ::std::vector<pat::Photon>,::std::_Vector_base<pat::Photon,std::allocator<pat::Photon> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x53( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::Photon> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::Photon> >::Generate();
}

//------Dictionary for class vector<pat::Photon,std::allocator<pat::Photon> > -------------------------------
void __std__vector_pat__Photon__db_datamem(Reflex::Class*);
void __std__vector_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__Photon__datamem_bld(&__std__vector_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__Photon__funcmem_bld(&__std__vector_pat__Photon__db_funcmem);
void __std__vector_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::Photon>"), typeid(::std::vector<pat::Photon>), sizeof(::std::vector<pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2875, ::Reflex::BaseOffset< ::std::vector<pat::Photon>, ::std::_Vector_base<pat::Photon,std::allocator<pat::Photon> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13525, Reflex::Literal("std::vector<pat::Photon>::_Alloc_value_type"))
  .AddTypedef(type_2875, Reflex::Literal("std::vector<pat::Photon>::_Base"))
  .AddTypedef(type_3875, Reflex::Literal("std::vector<pat::Photon>::_Tp_alloc_type"))
  .AddTypedef(type_12407, Reflex::Literal("std::vector<pat::Photon>::_Alloc_traits"))
  .AddTypedef(type_13525, Reflex::Literal("std::vector<pat::Photon>::value_type"))
  .AddTypedef(type_15279, Reflex::Literal("std::vector<pat::Photon>::pointer"))
  .AddTypedef(type_17806, Reflex::Literal("std::vector<pat::Photon>::const_pointer"))
  .AddTypedef(type_21202, Reflex::Literal("std::vector<pat::Photon>::reference"))
  .AddTypedef(type_17808, Reflex::Literal("std::vector<pat::Photon>::const_reference"))
  .AddTypedef(type_12064, Reflex::Literal("std::vector<pat::Photon>::iterator"))
  .AddTypedef(type_11976, Reflex::Literal("std::vector<pat::Photon>::const_iterator"))
  .AddTypedef(type_4384, Reflex::Literal("std::vector<pat::Photon>::const_reverse_iterator"))
  .AddTypedef(type_4385, Reflex::Literal("std::vector<pat::Photon>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::Photon>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::Photon>::difference_type"))
  .AddTypedef(type_3875, Reflex::Literal("std::vector<pat::Photon>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_21212, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62971), Reflex::Literal("vector"), constructor_21213, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_17808, type_62971), Reflex::Literal("vector"), constructor_21214, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35609), Reflex::Literal("vector"), constructor_21215, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_21216, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3517, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x52, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x53, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::Photon,std::allocator<pat::Photon> > -------------------
void __std__vector_pat__Photon__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::Photon,std::allocator<pat::Photon> > -------------------
void __std__vector_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65092, type_35609), Reflex::Literal("operator="), operator_21217, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_17808), Reflex::Literal("assign"), method_21218, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12064), Reflex::Literal("begin"), method_21219, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11976), Reflex::Literal("begin"), method_21220, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12064), Reflex::Literal("end"), method_21221, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11976), Reflex::Literal("end"), method_21222, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_21227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_21228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_13525), Reflex::Literal("resize"), method_21229, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_21230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_21231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_21232, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21202, type_3845), Reflex::Literal("operator[]"), operator_21233, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17808, type_3845), Reflex::Literal("operator[]"), operator_21234, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21202, type_3845), Reflex::Literal("at"), method_21236, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17808, type_3845), Reflex::Literal("at"), method_21237, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21202), Reflex::Literal("front"), method_21238, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17808), Reflex::Literal("front"), method_21239, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21202), Reflex::Literal("back"), method_21240, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17808), Reflex::Literal("back"), method_21241, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15279), Reflex::Literal("data"), method_21242, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17806), Reflex::Literal("data"), method_21243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17808), Reflex::Literal("push_back"), method_21244, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_21245, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12064, type_12064, type_17808), Reflex::Literal("insert"), method_21246, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_12064, type_3845, type_17808), Reflex::Literal("insert"), method_21247, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12064, type_12064), Reflex::Literal("erase"), method_21248, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12064, type_12064, type_12064), Reflex::Literal("erase"), method_21249, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65092), Reflex::Literal("swap"), method_21250, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_21251, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Tau -------------------------------
static  void operator_61845( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::Tau*)o)->operator=)(*(const ::pat::Tau*)arg[0]);
  else   (((::pat::Tau*)o)->operator=)(*(const ::pat::Tau*)arg[0]);
}

static void constructor_61846( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Tau(*(const ::pat::Tau*)arg[0]);
  else ::new(mem) ::pat::Tau(*(const ::pat::Tau*)arg[0]);
}

static void constructor_61847( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Tau();
  else ::new(mem) ::pat::Tau();
}

static void constructor_61848( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Tau(*(const ::reco::BaseTau*)arg[0]);
  else ::new(mem) ::pat::Tau(*(const ::reco::BaseTau*)arg[0]);
}

static void constructor_61849( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Tau(*(const ::edm::RefToBase<reco::BaseTau>*)arg[0]);
  else ::new(mem) ::pat::Tau(*(const ::edm::RefToBase<reco::BaseTau>*)arg[0]);
}

static void constructor_61850( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Tau(*(const ::edm::Ptr<reco::BaseTau>*)arg[0]);
  else ::new(mem) ::pat::Tau(*(const ::edm::Ptr<reco::BaseTau>*)arg[0]);
}

static void destructor_61851(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::Tau*)o)->::pat::Tau::~Tau)();
}
static  void method_61852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Tau*)o)->clone)());
  else   (((const ::pat::Tau*)o)->clone)();
}

static  void method_61853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->isolationTracks)();
  else   (((const ::pat::Tau*)o)->isolationTracks)();
}

static  void method_61854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Tau*)o)->leadTrack)());
  else   (((const ::pat::Tau*)o)->leadTrack)();
}

static  void method_61855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->signalTracks)();
  else   (((const ::pat::Tau*)o)->signalTracks)();
}

static  void method_61856( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Tau*)o)->embedIsolationTracks)();
}

static  void method_61857( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Tau*)o)->embedLeadTrack)();
}

static  void method_61858( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Tau*)o)->embedSignalTracks)();
}

static  void method_61859( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Tau*)o)->embedLeadPFCand)();
}

static  void method_61860( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Tau*)o)->embedLeadPFChargedHadrCand)();
}

static  void method_61861( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Tau*)o)->embedLeadPFNeutralCand)();
}

static  void method_61862( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Tau*)o)->embedSignalPFCands)();
}

static  void method_61863( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Tau*)o)->embedSignalPFChargedHadrCands)();
}

static  void method_61864( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Tau*)o)->embedSignalPFNeutralHadrCands)();
}

static  void method_61865( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Tau*)o)->embedSignalPFGammaCands)();
}

static  void method_61866( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Tau*)o)->embedIsolationPFCands)();
}

static  void method_61867( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Tau*)o)->embedIsolationPFChargedHadrCands)();
}

static  void method_61868( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Tau*)o)->embedIsolationPFNeutralHadrCands)();
}

static  void method_61869( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Tau*)o)->embedIsolationPFGammaCands)();
}

static  void method_61870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Tau*)o)->genJet)());
  else   (((const ::pat::Tau*)o)->genJet)();
}

static  void method_61871( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Tau*)o)->setGenJet)(*(const ::reco::GenJetRef*)arg[0]);
}

static  void method_61872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Tau*)o)->isCaloTau)());
  else   (((const ::pat::Tau*)o)->isCaloTau)();
}

static  void method_61873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->caloSpecific)();
  else   (((const ::pat::Tau*)o)->caloSpecific)();
}

static  void method_61874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::CaloTauTagInfoRef)((((const ::pat::Tau*)o)->caloTauTagInfoRef)());
  else   (((const ::pat::Tau*)o)->caloTauTagInfoRef)();
}

static  void method_61875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->leadTracksignedSipt)());
  else   (((const ::pat::Tau*)o)->leadTracksignedSipt)();
}

static  void method_61876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->leadTrackHCAL3x3hitsEtSum)());
  else   (((const ::pat::Tau*)o)->leadTrackHCAL3x3hitsEtSum)();
}

static  void method_61877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->leadTrackHCAL3x3hottesthitDEta)());
  else   (((const ::pat::Tau*)o)->leadTrackHCAL3x3hottesthitDEta)();
}

static  void method_61878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->signalTracksInvariantMass)());
  else   (((const ::pat::Tau*)o)->signalTracksInvariantMass)();
}

static  void method_61879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->TracksInvariantMass)());
  else   (((const ::pat::Tau*)o)->TracksInvariantMass)();
}

static  void method_61880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->isolationTracksPtSum)());
  else   (((const ::pat::Tau*)o)->isolationTracksPtSum)();
}

static  void method_61881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->isolationECALhitsEtSum)());
  else   (((const ::pat::Tau*)o)->isolationECALhitsEtSum)();
}

static  void method_61882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->maximumHCALhitEt)());
  else   (((const ::pat::Tau*)o)->maximumHCALhitEt)();
}

static  void method_61883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Tau*)o)->isPFTau)());
  else   (((const ::pat::Tau*)o)->isPFTau)();
}

static  void method_61884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->pfSpecific)();
  else   (((const ::pat::Tau*)o)->pfSpecific)();
}

static  void method_61885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->pfEssential)();
  else   (((const ::pat::Tau*)o)->pfEssential)();
}

static  void method_61886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->pfJetRef)();
  else   (((const ::pat::Tau*)o)->pfJetRef)();
}

static  void method_61887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::PFRecoTauChargedHadronRef)((((const ::pat::Tau*)o)->leadTauChargedHadronCandidate)());
  else   (((const ::pat::Tau*)o)->leadTauChargedHadronCandidate)();
}

static  void method_61888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::PFCandidatePtr)((((const ::pat::Tau*)o)->leadPFChargedHadrCand)());
  else   (((const ::pat::Tau*)o)->leadPFChargedHadrCand)();
}

static  void method_61889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->leadPFChargedHadrCandsignedSipt)());
  else   (((const ::pat::Tau*)o)->leadPFChargedHadrCandsignedSipt)();
}

static  void method_61890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::PFCandidatePtr)((((const ::pat::Tau*)o)->leadPFNeutralCand)());
  else   (((const ::pat::Tau*)o)->leadPFNeutralCand)();
}

static  void method_61891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::PFCandidatePtr)((((const ::pat::Tau*)o)->leadPFCand)());
  else   (((const ::pat::Tau*)o)->leadPFCand)();
}

static  void method_61892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->signalPFCands)();
  else   (((const ::pat::Tau*)o)->signalPFCands)();
}

static  void method_61893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->signalPFChargedHadrCands)();
  else   (((const ::pat::Tau*)o)->signalPFChargedHadrCands)();
}

static  void method_61894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->signalPFNeutrHadrCands)();
  else   (((const ::pat::Tau*)o)->signalPFNeutrHadrCands)();
}

static  void method_61895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->signalPFGammaCands)();
  else   (((const ::pat::Tau*)o)->signalPFGammaCands)();
}

static  void method_61896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->signalTauChargedHadronCandidates)();
  else   (((const ::pat::Tau*)o)->signalTauChargedHadronCandidates)();
}

static  void method_61897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->signalPiZeroCandidates)();
  else   (((const ::pat::Tau*)o)->signalPiZeroCandidates)();
}

static  void method_61898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->isolationPFCands)();
  else   (((const ::pat::Tau*)o)->isolationPFCands)();
}

static  void method_61899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->isolationPFChargedHadrCands)();
  else   (((const ::pat::Tau*)o)->isolationPFChargedHadrCands)();
}

static  void method_61900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->isolationPFNeutrHadrCands)();
  else   (((const ::pat::Tau*)o)->isolationPFNeutrHadrCands)();
}

static  void method_61901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->isolationPFGammaCands)();
  else   (((const ::pat::Tau*)o)->isolationPFGammaCands)();
}

static  void method_61902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->isolationTauChargedHadronCandidates)();
  else   (((const ::pat::Tau*)o)->isolationTauChargedHadronCandidates)();
}

static  void method_61903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->isolationPiZeroCandidates)();
  else   (((const ::pat::Tau*)o)->isolationPiZeroCandidates)();
}

static  void method_61904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->isolationPFChargedHadrCandsPtSum)());
  else   (((const ::pat::Tau*)o)->isolationPFChargedHadrCandsPtSum)();
}

static  void method_61905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->isolationPFGammaCandsEtSum)());
  else   (((const ::pat::Tau*)o)->isolationPFGammaCandsEtSum)();
}

static  void method_61906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->maximumHCALPFClusterEt)());
  else   (((const ::pat::Tau*)o)->maximumHCALPFClusterEt)();
}

static  void method_61907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->emFraction)());
  else   (((const ::pat::Tau*)o)->emFraction)();
}

static  void method_61908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->hcalTotOverPLead)());
  else   (((const ::pat::Tau*)o)->hcalTotOverPLead)();
}

static  void method_61909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->hcalMaxOverPLead)());
  else   (((const ::pat::Tau*)o)->hcalMaxOverPLead)();
}

static  void method_61910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->hcal3x3OverPLead)());
  else   (((const ::pat::Tau*)o)->hcal3x3OverPLead)();
}

static  void method_61911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->ecalStripSumEOverPLead)());
  else   (((const ::pat::Tau*)o)->ecalStripSumEOverPLead)();
}

static  void method_61912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->bremsRecoveryEOverPLead)());
  else   (((const ::pat::Tau*)o)->bremsRecoveryEOverPLead)();
}

static  void method_61913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->electronPreIDTrack)();
  else   (((const ::pat::Tau*)o)->electronPreIDTrack)();
}

static  void method_61914( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->electronPreIDOutput)());
  else   (((const ::pat::Tau*)o)->electronPreIDOutput)();
}

static  void method_61915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Tau*)o)->electronPreIDDecision)());
  else   (((const ::pat::Tau*)o)->electronPreIDDecision)();
}

static  void method_61916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->caloComp)());
  else   (((const ::pat::Tau*)o)->caloComp)();
}

static  void method_61917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->segComp)());
  else   (((const ::pat::Tau*)o)->segComp)();
}

static  void method_61918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Tau*)o)->muonDecision)());
  else   (((const ::pat::Tau*)o)->muonDecision)();
}

static  void method_61919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtr)((((const ::pat::Tau*)o)->leadChargedHadrCand)());
  else   (((const ::pat::Tau*)o)->leadChargedHadrCand)();
}

static  void method_61920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtr)((((const ::pat::Tau*)o)->leadNeutralCand)());
  else   (((const ::pat::Tau*)o)->leadNeutralCand)();
}

static  void method_61921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtr)((((const ::pat::Tau*)o)->leadCand)());
  else   (((const ::pat::Tau*)o)->leadCand)();
}

static  void method_61922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Tau*)o)->ExistSignalCands)());
  else   (((const ::pat::Tau*)o)->ExistSignalCands)();
}

static  void method_61923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Tau*)o)->ExistIsolationCands)());
  else   (((const ::pat::Tau*)o)->ExistIsolationCands)();
}

static  void method_61924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtrVector)((((const ::pat::Tau*)o)->signalCands)());
  else   (((const ::pat::Tau*)o)->signalCands)();
}

static  void method_61925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtrVector)((((const ::pat::Tau*)o)->signalChargedHadrCands)());
  else   (((const ::pat::Tau*)o)->signalChargedHadrCands)();
}

static  void method_61926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtrVector)((((const ::pat::Tau*)o)->signalNeutrHadrCands)());
  else   (((const ::pat::Tau*)o)->signalNeutrHadrCands)();
}

static  void method_61927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtrVector)((((const ::pat::Tau*)o)->signalGammaCands)());
  else   (((const ::pat::Tau*)o)->signalGammaCands)();
}

static  void method_61928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtrVector)((((const ::pat::Tau*)o)->isolationCands)());
  else   (((const ::pat::Tau*)o)->isolationCands)();
}

static  void method_61929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtrVector)((((const ::pat::Tau*)o)->isolationChargedHadrCands)());
  else   (((const ::pat::Tau*)o)->isolationChargedHadrCands)();
}

static  void method_61930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtrVector)((((const ::pat::Tau*)o)->isolationNeutrHadrCands)());
  else   (((const ::pat::Tau*)o)->isolationNeutrHadrCands)();
}

static  void method_61931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtrVector)((((const ::pat::Tau*)o)->isolationGammaCands)());
  else   (((const ::pat::Tau*)o)->isolationGammaCands)();
}

static  void method_61932( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Tau*)o)->setSignalChargedHadrCands)(*(const ::reco::CandidatePtrVector*)arg[0]);
}

static  void method_61933( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Tau*)o)->setSignalNeutralHadrCands)(*(const ::reco::CandidatePtrVector*)arg[0]);
}

static  void method_61934( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Tau*)o)->setSignalGammaCands)(*(const ::reco::CandidatePtrVector*)arg[0]);
}

static  void method_61935( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Tau*)o)->setIsolationChargedHadrCands)(*(const ::reco::CandidatePtrVector*)arg[0]);
}

static  void method_61936( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Tau*)o)->setIsolationNeutralHadrCands)(*(const ::reco::CandidatePtrVector*)arg[0]);
}

static  void method_61937( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Tau*)o)->setIsolationGammaCands)(*(const ::reco::CandidatePtrVector*)arg[0]);
}

static  void method_61938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::Tau*)o)->numberOfSourceCandidatePtrs)());
  else   (((const ::pat::Tau*)o)->numberOfSourceCandidatePtrs)();
}

static  void method_61939( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtr)((((const ::pat::Tau*)o)->sourceCandidatePtr)(*(::size_t*)arg[0]));
  else   (((const ::pat::Tau*)o)->sourceCandidatePtr)(*(::size_t*)arg[0]);
}

static  void method_61940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->dxy_PCA)();
  else   (((const ::pat::Tau*)o)->dxy_PCA)();
}

static  void method_61941( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Tau*)o)->dxy)());
  else   (((const ::pat::Tau*)o)->dxy)();
}

static  void method_61942( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Tau*)o)->dxy_error)());
  else   (((const ::pat::Tau*)o)->dxy_error)();
}

static  void method_61943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Tau*)o)->dxy_Sig)());
  else   (((const ::pat::Tau*)o)->dxy_Sig)();
}

static  void method_61944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->primaryVertex)();
  else   (((const ::pat::Tau*)o)->primaryVertex)();
}

static  void method_61945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->primaryVertexPos)();
  else   (((const ::pat::Tau*)o)->primaryVertexPos)();
}

static  void method_61946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->primaryVertexCov)();
  else   (((const ::pat::Tau*)o)->primaryVertexCov)();
}

static  void method_61947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Tau*)o)->hasSecondaryVertex)());
  else   (((const ::pat::Tau*)o)->hasSecondaryVertex)();
}

static  void method_61948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->flightLength)();
  else   (((const ::pat::Tau*)o)->flightLength)();
}

static  void method_61949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Tau*)o)->flightLengthSig)());
  else   (((const ::pat::Tau*)o)->flightLengthSig)();
}

static  void method_61950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >)((((const ::pat::Tau*)o)->flightLengthCov)());
  else   (((const ::pat::Tau*)o)->flightLengthCov)();
}

static  void method_61951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->secondaryVertex)();
  else   (((const ::pat::Tau*)o)->secondaryVertex)();
}

static  void method_61952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->secondaryVertexPos)();
  else   (((const ::pat::Tau*)o)->secondaryVertexPos)();
}

static  void method_61953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->secondaryVertexCov)();
  else   (((const ::pat::Tau*)o)->secondaryVertexCov)();
}

static  void method_61954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->p4Jet)();
  else   (((const ::pat::Tau*)o)->p4Jet)();
}

static  void method_61955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->etaetaMoment)());
  else   (((const ::pat::Tau*)o)->etaetaMoment)();
}

static  void method_61956( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->phiphiMoment)());
  else   (((const ::pat::Tau*)o)->phiphiMoment)();
}

static  void method_61957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->etaphiMoment)());
  else   (((const ::pat::Tau*)o)->etaphiMoment)();
}

static  void method_61958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::Tau*)o)->decayMode)());
  else   (((const ::pat::Tau*)o)->decayMode)();
}

static  void method_61959( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Tau*)o)->setDecayMode)(*(int*)arg[0]);
}

static  void method_61960( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->tauID)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::Tau*)o)->tauID)(*(const ::std::string*)arg[0]);
}

static  void method_61961( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->tauID)((const char*)arg[0]));
  else   (((const ::pat::Tau*)o)->tauID)((const char*)arg[0]);
}

static  void method_61962( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Tau*)o)->isTauIDAvailable)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::Tau*)o)->isTauIDAvailable)(*(const ::std::string*)arg[0]);
}

static  void method_61963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->tauIDs)();
  else   (((const ::pat::Tau*)o)->tauIDs)();
}

static  void method_61964( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Tau*)o)->setTauIDs)(*(const ::std::vector<std::pair<std::basic_string<char>,float> >*)arg[0]);
}

static  void method_61965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::Tau*)o)->availableJECSets)());
  else   (((const ::pat::Tau*)o)->availableJECSets)();
}

static  void method_61966( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::Tau*)o)->availableJECLevels)());
    else     (((const ::pat::Tau*)o)->availableJECLevels)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::Tau*)o)->availableJECLevels)(*(const int*)arg[0]));
    else     (((const ::pat::Tau*)o)->availableJECLevels)(*(const int*)arg[0]);
  }
}

static  void method_61967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::pat::Tau*)o)->availableJECLevels)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::Tau*)o)->availableJECLevels)(*(const ::std::string*)arg[0]);
}

static  void method_61968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Tau*)o)->jecSetsAvailable)());
  else   (((const ::pat::Tau*)o)->jecSetsAvailable)();
}

static  void method_61969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Tau*)o)->jecSetAvailable)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::Tau*)o)->jecSetAvailable)(*(const ::std::string*)arg[0]);
}

static  void method_61970( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Tau*)o)->jecSetAvailable)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::Tau*)o)->jecSetAvailable)(*(const unsigned int*)arg[0]);
}

static  void method_61971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::pat::Tau*)o)->currentJECSet)());
  else   (((const ::pat::Tau*)o)->currentJECSet)();
}

static  void method_61972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::pat::Tau*)o)->currentJECLevel)());
  else   (((const ::pat::Tau*)o)->currentJECLevel)();
}

static  void method_61973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->jecFactor)(*(const ::std::string*)arg[0]));
    else     (((const ::pat::Tau*)o)->jecFactor)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->jecFactor)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::pat::Tau*)o)->jecFactor)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_61974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->jecFactor)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::Tau*)o)->jecFactor)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::Tau*)o)->jecFactor)(*(const unsigned int*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::Tau*)o)->jecFactor)(*(const unsigned int*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_61975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (pat::Tau)((((const ::pat::Tau*)o)->correctedTauJet)(*(const ::std::string*)arg[0]));
    else     (((const ::pat::Tau*)o)->correctedTauJet)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (pat::Tau)((((const ::pat::Tau*)o)->correctedTauJet)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::pat::Tau*)o)->correctedTauJet)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_61976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (pat::Tau)((((const ::pat::Tau*)o)->correctedTauJet)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::Tau*)o)->correctedTauJet)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (pat::Tau)((((const ::pat::Tau*)o)->correctedTauJet)(*(const unsigned int*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::Tau*)o)->correctedTauJet)(*(const unsigned int*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_61977( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->correctedP4)(*(const ::std::string*)arg[0]);
    else     (((const ::pat::Tau*)o)->correctedP4)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->correctedP4)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
    else     (((const ::pat::Tau*)o)->correctedP4)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_61978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->correctedP4)(*(const unsigned int*)arg[0]);
    else     (((const ::pat::Tau*)o)->correctedP4)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Tau*)o)->correctedP4)(*(const unsigned int*)arg[0],
      *(const unsigned int*)arg[1]);
    else     (((const ::pat::Tau*)o)->correctedP4)(*(const unsigned int*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static void method_newdel_13568( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::Tau >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::Tau >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::Tau >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::Tau >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::Tau >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x55( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::Lepton<reco::BaseTau>")), ::Reflex::BaseOffset< ::pat::Tau,::pat::Lepton<reco::BaseTau> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::BaseTau>")), ::Reflex::BaseOffset< ::pat::Tau,::pat::PATObject<reco::BaseTau> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::BaseTau")), ::Reflex::BaseOffset< ::pat::Tau,::reco::BaseTau >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::pat::Tau,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::Tau,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::Tau,::reco::Candidate >::Get(),::Reflex::PUBLIC), 5));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

void read___pat__Tau_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > > &isolationTracksTransientRefVector_ = *(edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)(target + OffsetOf(__shadow__::__pat__Tau, isolationTracksTransientRefVector_));

  if( oldObj ) {}
  //--- User's code ---
  isolationTracksTransientRefVector_.reset();
  
}

void read___pat__Tau_1( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > > &signalTracksTransientRefVector_ = *(edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)(target + OffsetOf(__shadow__::__pat__Tau, signalTracksTransientRefVector_));

  if( oldObj ) {}
  //--- User's code ---
  signalTracksTransientRefVector_.reset();
  
}

void read___pat__Tau_2( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > &signalPFCandsTransientPtrs_ = *(edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)(target + OffsetOf(__shadow__::__pat__Tau, signalPFCandsTransientPtrs_));

  if( oldObj ) {}
  //--- User's code ---
  signalPFCandsTransientPtrs_.reset();
  
}

void read___pat__Tau_3( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > &signalPFChargedHadrCandsTransientPtrs_ = *(edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)(target + OffsetOf(__shadow__::__pat__Tau, signalPFChargedHadrCandsTransientPtrs_));

  if( oldObj ) {}
  //--- User's code ---
  signalPFChargedHadrCandsTransientPtrs_.reset();
  
}

void read___pat__Tau_4( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > &signalPFNeutralHadrCandsTransientPtrs_ = *(edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)(target + OffsetOf(__shadow__::__pat__Tau, signalPFNeutralHadrCandsTransientPtrs_));

  if( oldObj ) {}
  //--- User's code ---
  signalPFNeutralHadrCandsTransientPtrs_.reset();
  
}

void read___pat__Tau_5( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > &signalPFGammaCandsTransientPtrs_ = *(edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)(target + OffsetOf(__shadow__::__pat__Tau, signalPFGammaCandsTransientPtrs_));

  if( oldObj ) {}
  //--- User's code ---
  signalPFGammaCandsTransientPtrs_.reset();
  
}

void read___pat__Tau_6( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > &isolationPFCandsTransientPtrs_ = *(edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)(target + OffsetOf(__shadow__::__pat__Tau, isolationPFCandsTransientPtrs_));

  if( oldObj ) {}
  //--- User's code ---
  isolationPFCandsTransientPtrs_.reset();
  
}

void read___pat__Tau_7( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > &isolationPFChargedHadrCandsTransientPtrs_ = *(edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)(target + OffsetOf(__shadow__::__pat__Tau, isolationPFChargedHadrCandsTransientPtrs_));

  if( oldObj ) {}
  //--- User's code ---
  isolationPFChargedHadrCandsTransientPtrs_.reset();
  
}

void read___pat__Tau_8( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > &isolationPFNeutralHadrCandsTransientPtrs_ = *(edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)(target + OffsetOf(__shadow__::__pat__Tau, isolationPFNeutralHadrCandsTransientPtrs_));

  if( oldObj ) {}
  //--- User's code ---
  isolationPFNeutralHadrCandsTransientPtrs_.reset();
  
}

void read___pat__Tau_9( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > &isolationPFGammaCandsTransientPtrs_ = *(edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)(target + OffsetOf(__shadow__::__pat__Tau, isolationPFGammaCandsTransientPtrs_));

  if( oldObj ) {}
  //--- User's code ---
  isolationPFGammaCandsTransientPtrs_.reset();
  
}

//------Dictionary for class Tau -------------------------------
void __pat__Tau_db_datamem(Reflex::Class*);
void __pat__Tau_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__Tau_datamem_bld(&__pat__Tau_db_datamem);
Reflex::GenreflexMemberBuilder __pat__Tau_funcmem_bld(&__pat__Tau_db_funcmem);
void __pat__Tau_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(10);
  rule = &readrules[0];
  rule->fSourceClass = "pat::Tau";
  rule->fTarget      = "isolationTracksTransientRefVector_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__Tau_0);
  rule->fCode        = "\n  isolationTracksTransientRefVector_.reset();\n  ";
  rule->fVersion     = "[1-]";
  rule = &readrules[1];
  rule->fSourceClass = "pat::Tau";
  rule->fTarget      = "signalTracksTransientRefVector_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__Tau_1);
  rule->fCode        = "\n  signalTracksTransientRefVector_.reset();\n  ";
  rule->fVersion     = "[1-]";
  rule = &readrules[2];
  rule->fSourceClass = "pat::Tau";
  rule->fTarget      = "signalPFCandsTransientPtrs_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__Tau_2);
  rule->fCode        = "\n  signalPFCandsTransientPtrs_.reset();\n  ";
  rule->fVersion     = "[1-]";
  rule = &readrules[3];
  rule->fSourceClass = "pat::Tau";
  rule->fTarget      = "signalPFChargedHadrCandsTransientPtrs_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__Tau_3);
  rule->fCode        = "\n  signalPFChargedHadrCandsTransientPtrs_.reset();\n  ";
  rule->fVersion     = "[1-]";
  rule = &readrules[4];
  rule->fSourceClass = "pat::Tau";
  rule->fTarget      = "signalPFNeutralHadrCandsTransientPtrs_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__Tau_4);
  rule->fCode        = "\n  signalPFNeutralHadrCandsTransientPtrs_.reset();\n  ";
  rule->fVersion     = "[1-]";
  rule = &readrules[5];
  rule->fSourceClass = "pat::Tau";
  rule->fTarget      = "signalPFGammaCandsTransientPtrs_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__Tau_5);
  rule->fCode        = "\n  signalPFGammaCandsTransientPtrs_.reset();\n  ";
  rule->fVersion     = "[1-]";
  rule = &readrules[6];
  rule->fSourceClass = "pat::Tau";
  rule->fTarget      = "isolationPFCandsTransientPtrs_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__Tau_6);
  rule->fCode        = "\n  isolationPFCandsTransientPtrs_.reset();\n  ";
  rule->fVersion     = "[1-]";
  rule = &readrules[7];
  rule->fSourceClass = "pat::Tau";
  rule->fTarget      = "isolationPFChargedHadrCandsTransientPtrs_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__Tau_7);
  rule->fCode        = "\n  isolationPFChargedHadrCandsTransientPtrs_.reset();\n  ";
  rule->fVersion     = "[1-]";
  rule = &readrules[8];
  rule->fSourceClass = "pat::Tau";
  rule->fTarget      = "isolationPFNeutralHadrCandsTransientPtrs_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__Tau_8);
  rule->fCode        = "\n  isolationPFNeutralHadrCandsTransientPtrs_.reset();\n  ";
  rule->fVersion     = "[1-]";
  rule = &readrules[9];
  rule->fSourceClass = "pat::Tau";
  rule->fTarget      = "isolationPFGammaCandsTransientPtrs_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__Tau_9);
  rule->fCode        = "\n  isolationPFGammaCandsTransientPtrs_.reset();\n  ";
  rule->fVersion     = "[1-]";


  ::Reflex::ClassBuilder(Reflex::Literal("pat::Tau"), typeid(::pat::Tau), sizeof(::pat::Tau), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "15")
  .AddProperty("ioread", readrules )
  .AddBase(type_13528, ::Reflex::BaseOffset< ::pat::Tau, ::pat::Lepton<reco::BaseTau> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3441, Reflex::Literal("pat::Tau::IdPair"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21265, type_17819), Reflex::Literal("operator="), operator_61845, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17819), Reflex::Literal("Tau"), constructor_61846, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Tau"), constructor_61847, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26889), Reflex::Literal("Tau"), constructor_61848, 0, "aTau", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71915), Reflex::Literal("Tau"), constructor_61849, 0, "aTauRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71972), Reflex::Literal("Tau"), constructor_61850, 0, "aTauRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Tau"), destructor_61851, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13568, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x55, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__Tau_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__Tau_funcmem_bld);
}

//------Delayed data member builder for class Tau -------------------
void __pat__Tau_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("embeddedIsolationTracks_"), OffsetOf(__shadow__::__pat__Tau, embeddedIsolationTracks_), ::Reflex::PRIVATE)
  .AddDataMember(type_3526, Reflex::Literal("isolationTracks_"), OffsetOf(__shadow__::__pat__Tau, isolationTracks_), ::Reflex::PRIVATE)
  .AddDataMember(type_7118, Reflex::Literal("isolationTracksTransientRefVector_"), OffsetOf(__shadow__::__pat__Tau, isolationTracksTransientRefVector_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_1810, Reflex::Literal("embeddedLeadTrack_"), OffsetOf(__shadow__::__pat__Tau, embeddedLeadTrack_), ::Reflex::PRIVATE)
  .AddDataMember(type_3526, Reflex::Literal("leadTrack_"), OffsetOf(__shadow__::__pat__Tau, leadTrack_), ::Reflex::PRIVATE)
  .AddDataMember(type_1810, Reflex::Literal("embeddedSignalTracks_"), OffsetOf(__shadow__::__pat__Tau, embeddedSignalTracks_), ::Reflex::PRIVATE)
  .AddDataMember(type_3526, Reflex::Literal("signalTracks_"), OffsetOf(__shadow__::__pat__Tau, signalTracks_), ::Reflex::PRIVATE)
  .AddDataMember(type_7118, Reflex::Literal("signalTracksTransientRefVector_"), OffsetOf(__shadow__::__pat__Tau, signalTracksTransientRefVector_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_3548, Reflex::Literal("leadPFCand_"), OffsetOf(__shadow__::__pat__Tau, leadPFCand_), ::Reflex::PRIVATE)
  .AddDataMember(type_1810, Reflex::Literal("embeddedLeadPFCand_"), OffsetOf(__shadow__::__pat__Tau, embeddedLeadPFCand_), ::Reflex::PRIVATE)
  .AddDataMember(type_3548, Reflex::Literal("leadPFChargedHadrCand_"), OffsetOf(__shadow__::__pat__Tau, leadPFChargedHadrCand_), ::Reflex::PRIVATE)
  .AddDataMember(type_1810, Reflex::Literal("embeddedLeadPFChargedHadrCand_"), OffsetOf(__shadow__::__pat__Tau, embeddedLeadPFChargedHadrCand_), ::Reflex::PRIVATE)
  .AddDataMember(type_3548, Reflex::Literal("leadPFNeutralCand_"), OffsetOf(__shadow__::__pat__Tau, leadPFNeutralCand_), ::Reflex::PRIVATE)
  .AddDataMember(type_1810, Reflex::Literal("embeddedLeadPFNeutralCand_"), OffsetOf(__shadow__::__pat__Tau, embeddedLeadPFNeutralCand_), ::Reflex::PRIVATE)
  .AddDataMember(type_3548, Reflex::Literal("signalPFCands_"), OffsetOf(__shadow__::__pat__Tau, signalPFCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_1810, Reflex::Literal("embeddedSignalPFCands_"), OffsetOf(__shadow__::__pat__Tau, embeddedSignalPFCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_7115, Reflex::Literal("signalPFCandsTransientPtrs_"), OffsetOf(__shadow__::__pat__Tau, signalPFCandsTransientPtrs_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_3548, Reflex::Literal("signalPFChargedHadrCands_"), OffsetOf(__shadow__::__pat__Tau, signalPFChargedHadrCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_1810, Reflex::Literal("embeddedSignalPFChargedHadrCands_"), OffsetOf(__shadow__::__pat__Tau, embeddedSignalPFChargedHadrCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_7115, Reflex::Literal("signalPFChargedHadrCandsTransientPtrs_"), OffsetOf(__shadow__::__pat__Tau, signalPFChargedHadrCandsTransientPtrs_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_3548, Reflex::Literal("signalPFNeutralHadrCands_"), OffsetOf(__shadow__::__pat__Tau, signalPFNeutralHadrCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_1810, Reflex::Literal("embeddedSignalPFNeutralHadrCands_"), OffsetOf(__shadow__::__pat__Tau, embeddedSignalPFNeutralHadrCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_7115, Reflex::Literal("signalPFNeutralHadrCandsTransientPtrs_"), OffsetOf(__shadow__::__pat__Tau, signalPFNeutralHadrCandsTransientPtrs_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_3548, Reflex::Literal("signalPFGammaCands_"), OffsetOf(__shadow__::__pat__Tau, signalPFGammaCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_1810, Reflex::Literal("embeddedSignalPFGammaCands_"), OffsetOf(__shadow__::__pat__Tau, embeddedSignalPFGammaCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_7115, Reflex::Literal("signalPFGammaCandsTransientPtrs_"), OffsetOf(__shadow__::__pat__Tau, signalPFGammaCandsTransientPtrs_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_3548, Reflex::Literal("isolationPFCands_"), OffsetOf(__shadow__::__pat__Tau, isolationPFCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_1810, Reflex::Literal("embeddedIsolationPFCands_"), OffsetOf(__shadow__::__pat__Tau, embeddedIsolationPFCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_7115, Reflex::Literal("isolationPFCandsTransientPtrs_"), OffsetOf(__shadow__::__pat__Tau, isolationPFCandsTransientPtrs_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_3548, Reflex::Literal("isolationPFChargedHadrCands_"), OffsetOf(__shadow__::__pat__Tau, isolationPFChargedHadrCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_1810, Reflex::Literal("embeddedIsolationPFChargedHadrCands_"), OffsetOf(__shadow__::__pat__Tau, embeddedIsolationPFChargedHadrCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_7115, Reflex::Literal("isolationPFChargedHadrCandsTransientPtrs_"), OffsetOf(__shadow__::__pat__Tau, isolationPFChargedHadrCandsTransientPtrs_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_3548, Reflex::Literal("isolationPFNeutralHadrCands_"), OffsetOf(__shadow__::__pat__Tau, isolationPFNeutralHadrCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_1810, Reflex::Literal("embeddedIsolationPFNeutralHadrCands_"), OffsetOf(__shadow__::__pat__Tau, embeddedIsolationPFNeutralHadrCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_7115, Reflex::Literal("isolationPFNeutralHadrCandsTransientPtrs_"), OffsetOf(__shadow__::__pat__Tau, isolationPFNeutralHadrCandsTransientPtrs_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_3548, Reflex::Literal("isolationPFGammaCands_"), OffsetOf(__shadow__::__pat__Tau, isolationPFGammaCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_1810, Reflex::Literal("embeddedIsolationPFGammaCands_"), OffsetOf(__shadow__::__pat__Tau, embeddedIsolationPFGammaCands_), ::Reflex::PRIVATE)
  .AddDataMember(type_7115, Reflex::Literal("isolationPFGammaCandsTransientPtrs_"), OffsetOf(__shadow__::__pat__Tau, isolationPFGammaCandsTransientPtrs_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_3556, Reflex::Literal("genJet_"), OffsetOf(__shadow__::__pat__Tau, genJet_), ::Reflex::PRIVATE)
  .AddDataMember(type_3555, Reflex::Literal("tauIDs_"), OffsetOf(__shadow__::__pat__Tau, tauIDs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3597, Reflex::Literal("pfSpecific_"), OffsetOf(__shadow__::__pat__Tau, pfSpecific_), ::Reflex::PRIVATE)
  .AddDataMember(type_3598, Reflex::Literal("caloSpecific_"), OffsetOf(__shadow__::__pat__Tau, caloSpecific_), ::Reflex::PRIVATE)
  .AddDataMember(type_3596, Reflex::Literal("jec_"), OffsetOf(__shadow__::__pat__Tau, jec_), ::Reflex::PRIVATE)
  .AddDataMember(type_227, Reflex::Literal("currentJECSet_"), OffsetOf(__shadow__::__pat__Tau, currentJECSet_), ::Reflex::PRIVATE)
  .AddDataMember(type_227, Reflex::Literal("currentJECLevel_"), OffsetOf(__shadow__::__pat__Tau, currentJECLevel_), ::Reflex::PRIVATE)
  .AddDataMember(type_11460, Reflex::Literal("signalChargedHadrCandPtrs_"), OffsetOf(__shadow__::__pat__Tau, signalChargedHadrCandPtrs_), ::Reflex::PRIVATE)
  .AddDataMember(type_11460, Reflex::Literal("signalNeutralHadrCandPtrs_"), OffsetOf(__shadow__::__pat__Tau, signalNeutralHadrCandPtrs_), ::Reflex::PRIVATE)
  .AddDataMember(type_11460, Reflex::Literal("signalGammaCandPtrs_"), OffsetOf(__shadow__::__pat__Tau, signalGammaCandPtrs_), ::Reflex::PRIVATE)
  .AddDataMember(type_11460, Reflex::Literal("isolationChargedHadrCandPtrs_"), OffsetOf(__shadow__::__pat__Tau, isolationChargedHadrCandPtrs_), ::Reflex::PRIVATE)
  .AddDataMember(type_11460, Reflex::Literal("isolationNeutralHadrCandPtrs_"), OffsetOf(__shadow__::__pat__Tau, isolationNeutralHadrCandPtrs_), ::Reflex::PRIVATE)
  .AddDataMember(type_11460, Reflex::Literal("isolationGammaCandPtrs_"), OffsetOf(__shadow__::__pat__Tau, isolationGammaCandPtrs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3599, Reflex::Literal("pfEssential_"), OffsetOf(__shadow__::__pat__Tau, pfEssential_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Tau -------------------
void __pat__Tau_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15488), Reflex::Literal("clone"), method_61852, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73028), Reflex::Literal("isolationTracks"), method_61853, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("leadTrack"), method_61854, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73028), Reflex::Literal("signalTracks"), method_61855, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedIsolationTracks"), method_61856, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedLeadTrack"), method_61857, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedSignalTracks"), method_61858, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedLeadPFCand"), method_61859, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedLeadPFChargedHadrCand"), method_61860, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedLeadPFNeutralCand"), method_61861, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedSignalPFCands"), method_61862, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedSignalPFChargedHadrCands"), method_61863, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedSignalPFNeutralHadrCands"), method_61864, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedSignalPFGammaCands"), method_61865, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedIsolationPFCands"), method_61866, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedIsolationPFChargedHadrCands"), method_61867, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedIsolationPFNeutralHadrCands"), method_61868, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedIsolationPFGammaCands"), method_61869, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23638), Reflex::Literal("genJet"), method_61870, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75186), Reflex::Literal("setGenJet"), method_61871, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isCaloTau"), method_61872, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26043), Reflex::Literal("caloSpecific"), method_61873, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11425), Reflex::Literal("caloTauTagInfoRef"), method_61874, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("leadTracksignedSipt"), method_61875, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("leadTrackHCAL3x3hitsEtSum"), method_61876, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("leadTrackHCAL3x3hottesthitDEta"), method_61877, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("signalTracksInvariantMass"), method_61878, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("TracksInvariantMass"), method_61879, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("isolationTracksPtSum"), method_61880, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("isolationECALhitsEtSum"), method_61881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("maximumHCALhitEt"), method_61882, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPFTau"), method_61883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25977), Reflex::Literal("pfSpecific"), method_61884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26109), Reflex::Literal("pfEssential"), method_61885, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73153), Reflex::Literal("pfJetRef"), method_61886, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11287), Reflex::Literal("leadTauChargedHadronCandidate"), method_61887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11263c), Reflex::Literal("leadPFChargedHadrCand"), method_61888, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("leadPFChargedHadrCandsignedSipt"), method_61889, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11263c), Reflex::Literal("leadPFNeutralCand"), method_61890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11263c), Reflex::Literal("leadPFCand"), method_61891, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65193), Reflex::Literal("signalPFCands"), method_61892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65193), Reflex::Literal("signalPFChargedHadrCands"), method_61893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65193), Reflex::Literal("signalPFNeutrHadrCands"), method_61894, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65193), Reflex::Literal("signalPFGammaCands"), method_61895, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35776), Reflex::Literal("signalTauChargedHadronCandidates"), method_61896, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35788), Reflex::Literal("signalPiZeroCandidates"), method_61897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65193), Reflex::Literal("isolationPFCands"), method_61898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65193), Reflex::Literal("isolationPFChargedHadrCands"), method_61899, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65193), Reflex::Literal("isolationPFNeutrHadrCands"), method_61900, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65193), Reflex::Literal("isolationPFGammaCands"), method_61901, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35776), Reflex::Literal("isolationTauChargedHadronCandidates"), method_61902, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35788), Reflex::Literal("isolationPiZeroCandidates"), method_61903, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("isolationPFChargedHadrCandsPtSum"), method_61904, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("isolationPFGammaCandsEtSum"), method_61905, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("maximumHCALPFClusterEt"), method_61906, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("emFraction"), method_61907, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("hcalTotOverPLead"), method_61908, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("hcalMaxOverPLead"), method_61909, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("hcal3x3OverPLead"), method_61910, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("ecalStripSumEOverPLead"), method_61911, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("bremsRecoveryEOverPLead"), method_61912, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72994), Reflex::Literal("electronPreIDTrack"), method_61913, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("electronPreIDOutput"), method_61914, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("electronPreIDDecision"), method_61915, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("caloComp"), method_61916, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("segComp"), method_61917, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("muonDecision"), method_61918, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11562c), Reflex::Literal("leadChargedHadrCand"), method_61919, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11562c), Reflex::Literal("leadNeutralCand"), method_61920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11562c), Reflex::Literal("leadCand"), method_61921, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("ExistSignalCands"), method_61922, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("ExistIsolationCands"), method_61923, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11460), Reflex::Literal("signalCands"), method_61924, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11460), Reflex::Literal("signalChargedHadrCands"), method_61925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11460), Reflex::Literal("signalNeutrHadrCands"), method_61926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11460), Reflex::Literal("signalGammaCands"), method_61927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11460), Reflex::Literal("isolationCands"), method_61928, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11460), Reflex::Literal("isolationChargedHadrCands"), method_61929, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11460), Reflex::Literal("isolationNeutrHadrCands"), method_61930, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11460), Reflex::Literal("isolationGammaCands"), method_61931, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75189), Reflex::Literal("setSignalChargedHadrCands"), method_61932, 0, "ptrs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75189), Reflex::Literal("setSignalNeutralHadrCands"), method_61933, 0, "ptrs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75189), Reflex::Literal("setSignalGammaCands"), method_61934, 0, "ptrs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75189), Reflex::Literal("setIsolationChargedHadrCands"), method_61935, 0, "ptrs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75189), Reflex::Literal("setIsolationNeutralHadrCands"), method_61936, 0, "ptrs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75189), Reflex::Literal("setIsolationGammaCands"), method_61937, 0, "ptrs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("numberOfSourceCandidatePtrs"), method_61938, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11562, type_2393), Reflex::Literal("sourceCandidatePtr"), method_61939, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45678), Reflex::Literal("dxy_PCA"), method_61940, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("dxy"), method_61941, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("dxy_error"), method_61942, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("dxy_Sig"), method_61943, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73025), Reflex::Literal("primaryVertex"), method_61944, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45678), Reflex::Literal("primaryVertexPos"), method_61945, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35035), Reflex::Literal("primaryVertexCov"), method_61946, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasSecondaryVertex"), method_61947, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73027), Reflex::Literal("flightLength"), method_61948, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("flightLengthSig"), method_61949, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_116), Reflex::Literal("flightLengthCov"), method_61950, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73025), Reflex::Literal("secondaryVertex"), method_61951, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45678), Reflex::Literal("secondaryVertexPos"), method_61952, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35035), Reflex::Literal("secondaryVertexCov"), method_61953, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45676), Reflex::Literal("p4Jet"), method_61954, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("etaetaMoment"), method_61955, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("phiphiMoment"), method_61956, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("etaphiMoment"), method_61957, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("decayMode"), method_61958, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_72), Reflex::Literal("setDecayMode"), method_61959, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_30686), Reflex::Literal("tauID"), method_61960, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_4688), Reflex::Literal("tauID"), method_61961, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_30686), Reflex::Literal("isTauIDAvailable"), method_61962, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65188), Reflex::Literal("tauIDs"), method_61963, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65188), Reflex::Literal("setTauIDs"), method_61964, 0, "ids", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3528c), Reflex::Literal("availableJECSets"), method_61965, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3528c, type_18030), Reflex::Literal("availableJECLevels"), method_61966, 0, "set=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3528c, type_30686), Reflex::Literal("availableJECLevels"), method_61967, 0, "set", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("jecSetsAvailable"), method_61968, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_30686), Reflex::Literal("jecSetAvailable"), method_61969, 0, "set", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18009), Reflex::Literal("jecSetAvailable"), method_61970, 0, "set", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3000), Reflex::Literal("currentJECSet"), method_61971, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3000), Reflex::Literal("currentJECLevel"), method_61972, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_30686, type_30686), Reflex::Literal("jecFactor"), method_61973, 0, "level;set=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_18009, type_18009), Reflex::Literal("jecFactor"), method_61974, 0, "level;set=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13568, type_30686, type_30686), Reflex::Literal("correctedTauJet"), method_61975, 0, "level;set=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13568, type_18009, type_18009), Reflex::Literal("correctedTauJet"), method_61976, 0, "level;set=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45676, type_30686, type_30686), Reflex::Literal("correctedP4"), method_61977, 0, "level;set=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45676, type_18009, type_18009), Reflex::Literal("correctedP4"), method_61978, 0, "level;set=0", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<pat::Tau,std::allocator<pat::Tau> > -------------------------------
static void constructor_21275( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Tau>();
  else ::new(mem) ::std::vector<pat::Tau>();
}

static void constructor_21276( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Tau>(*(const ::std::allocator<pat::Tau>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Tau>(*(const ::std::allocator<pat::Tau>*)arg[0]);
}

static void constructor_21277( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Tau>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::Tau>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Tau>(*(::std::size_t*)arg[0],
      *(const ::pat::Tau*)arg[1]);
  else ::new(mem) ::std::vector<pat::Tau>(*(::std::size_t*)arg[0],
      *(const ::pat::Tau*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Tau>(*(::std::size_t*)arg[0],
      *(const ::pat::Tau*)arg[1],
      *(const ::std::allocator<pat::Tau>*)arg[2]);
  else ::new(mem) ::std::vector<pat::Tau>(*(::std::size_t*)arg[0],
      *(const ::pat::Tau*)arg[1],
      *(const ::std::allocator<pat::Tau>*)arg[2]);
  }
}

static void constructor_21278( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Tau>(*(const ::std::vector<pat::Tau>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Tau>(*(const ::std::vector<pat::Tau>*)arg[0]);
}

static void destructor_21279(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::Tau>*)o)->::std::vector<pat::Tau>::~vector)();
}
static  void operator_21280( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Tau>*)o)->operator=)(*(const ::std::vector<pat::Tau>*)arg[0]);
  else   (((::std::vector<pat::Tau>*)o)->operator=)(*(const ::std::vector<pat::Tau>*)arg[0]);
}

static  void method_21281( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Tau>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::Tau*)arg[1]);
}

static  void method_21282( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> >)((((::std::vector<pat::Tau>*)o)->begin)());
  else   (((::std::vector<pat::Tau>*)o)->begin)();
}

static  void method_21283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >)((((const ::std::vector<pat::Tau>*)o)->begin)());
  else   (((const ::std::vector<pat::Tau>*)o)->begin)();
}

static  void method_21284( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> >)((((::std::vector<pat::Tau>*)o)->end)());
  else   (((::std::vector<pat::Tau>*)o)->end)();
}

static  void method_21285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >)((((const ::std::vector<pat::Tau>*)o)->end)());
  else   (((const ::std::vector<pat::Tau>*)o)->end)();
}

static  void method_21290( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Tau>*)o)->size)());
  else   (((const ::std::vector<pat::Tau>*)o)->size)();
}

static  void method_21291( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Tau>*)o)->max_size)());
  else   (((const ::std::vector<pat::Tau>*)o)->max_size)();
}

static  void method_21292( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::Tau>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::Tau>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::Tau*)arg[1]);
  }
}

static  void method_21293( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Tau>*)o)->capacity)());
  else   (((const ::std::vector<pat::Tau>*)o)->capacity)();
}

static  void method_21294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::Tau>*)o)->empty)());
  else   (((const ::std::vector<pat::Tau>*)o)->empty)();
}

static  void method_21295( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Tau>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_21296( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Tau>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Tau>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_21297( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Tau>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Tau>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_21299( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Tau>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Tau>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21300( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Tau>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Tau>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21301( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Tau>*)o)->front)();
  else   (((::std::vector<pat::Tau>*)o)->front)();
}

static  void method_21302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Tau>*)o)->front)();
  else   (((const ::std::vector<pat::Tau>*)o)->front)();
}

static  void method_21303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Tau>*)o)->back)();
  else   (((::std::vector<pat::Tau>*)o)->back)();
}

static  void method_21304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Tau>*)o)->back)();
  else   (((const ::std::vector<pat::Tau>*)o)->back)();
}

static  void method_21305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::Tau>*)o)->data)());
  else   (((::std::vector<pat::Tau>*)o)->data)();
}

static  void method_21306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::Tau>*)o)->data)());
  else   (((const ::std::vector<pat::Tau>*)o)->data)();
}

static  void method_21307( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Tau>*)o)->push_back)(*(const ::pat::Tau*)arg[0]);
}

static  void method_21308( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Tau>*)o)->pop_back)();
}

static  void method_21309( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> >)((((::std::vector<pat::Tau>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> >*)arg[0],
    *(const ::pat::Tau*)arg[1]));
  else   (((::std::vector<pat::Tau>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> >*)arg[0],
    *(const ::pat::Tau*)arg[1]);
}

static  void method_21310( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Tau>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::Tau*)arg[2]);
}

static  void method_21311( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> >)((((::std::vector<pat::Tau>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> >*)arg[0]));
  else   (((::std::vector<pat::Tau>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> >*)arg[0]);
}

static  void method_21312( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> >)((((::std::vector<pat::Tau>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> >*)arg[1]));
  else   (((::std::vector<pat::Tau>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Tau*,std::vector<pat::Tau> >*)arg[1]);
}

static  void method_21313( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Tau>*)o)->swap)(*(::std::vector<pat::Tau>*)arg[0]);
}

static  void method_21314( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Tau>*)o)->clear)();
}

static void method_newdel_3518( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x57( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Tau,std::allocator<pat::Tau> >")), ::Reflex::BaseOffset< ::std::vector<pat::Tau>,::std::_Vector_base<pat::Tau,std::allocator<pat::Tau> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x58( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::Tau> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::Tau> >::Generate();
}

//------Dictionary for class vector<pat::Tau,std::allocator<pat::Tau> > -------------------------------
void __std__vector_pat__Tau__db_datamem(Reflex::Class*);
void __std__vector_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__Tau__datamem_bld(&__std__vector_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__Tau__funcmem_bld(&__std__vector_pat__Tau__db_funcmem);
void __std__vector_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::Tau>"), typeid(::std::vector<pat::Tau>), sizeof(::std::vector<pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2886, ::Reflex::BaseOffset< ::std::vector<pat::Tau>, ::std::_Vector_base<pat::Tau,std::allocator<pat::Tau> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13568, Reflex::Literal("std::vector<pat::Tau>::_Alloc_value_type"))
  .AddTypedef(type_2886, Reflex::Literal("std::vector<pat::Tau>::_Base"))
  .AddTypedef(type_3876, Reflex::Literal("std::vector<pat::Tau>::_Tp_alloc_type"))
  .AddTypedef(type_12418, Reflex::Literal("std::vector<pat::Tau>::_Alloc_traits"))
  .AddTypedef(type_13568, Reflex::Literal("std::vector<pat::Tau>::value_type"))
  .AddTypedef(type_15488, Reflex::Literal("std::vector<pat::Tau>::pointer"))
  .AddTypedef(type_17817, Reflex::Literal("std::vector<pat::Tau>::const_pointer"))
  .AddTypedef(type_21265, Reflex::Literal("std::vector<pat::Tau>::reference"))
  .AddTypedef(type_17819, Reflex::Literal("std::vector<pat::Tau>::const_reference"))
  .AddTypedef(type_12085, Reflex::Literal("std::vector<pat::Tau>::iterator"))
  .AddTypedef(type_11977, Reflex::Literal("std::vector<pat::Tau>::const_iterator"))
  .AddTypedef(type_4406, Reflex::Literal("std::vector<pat::Tau>::const_reverse_iterator"))
  .AddTypedef(type_4407, Reflex::Literal("std::vector<pat::Tau>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::Tau>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::Tau>::difference_type"))
  .AddTypedef(type_3876, Reflex::Literal("std::vector<pat::Tau>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_21275, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63114), Reflex::Literal("vector"), constructor_21276, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_17819, type_63114), Reflex::Literal("vector"), constructor_21277, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35621), Reflex::Literal("vector"), constructor_21278, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_21279, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3518, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x57, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x58, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::Tau,std::allocator<pat::Tau> > -------------------
void __std__vector_pat__Tau__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::Tau,std::allocator<pat::Tau> > -------------------
void __std__vector_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65093, type_35621), Reflex::Literal("operator="), operator_21280, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_17819), Reflex::Literal("assign"), method_21281, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12085), Reflex::Literal("begin"), method_21282, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11977), Reflex::Literal("begin"), method_21283, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12085), Reflex::Literal("end"), method_21284, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11977), Reflex::Literal("end"), method_21285, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_21290, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_21291, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_13568), Reflex::Literal("resize"), method_21292, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_21293, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_21294, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_21295, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21265, type_3845), Reflex::Literal("operator[]"), operator_21296, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17819, type_3845), Reflex::Literal("operator[]"), operator_21297, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21265, type_3845), Reflex::Literal("at"), method_21299, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17819, type_3845), Reflex::Literal("at"), method_21300, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21265), Reflex::Literal("front"), method_21301, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17819), Reflex::Literal("front"), method_21302, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21265), Reflex::Literal("back"), method_21303, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17819), Reflex::Literal("back"), method_21304, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15488), Reflex::Literal("data"), method_21305, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17817), Reflex::Literal("data"), method_21306, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17819), Reflex::Literal("push_back"), method_21307, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_21308, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12085, type_12085, type_17819), Reflex::Literal("insert"), method_21309, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_12085, type_3845, type_17819), Reflex::Literal("insert"), method_21310, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12085, type_12085), Reflex::Literal("erase"), method_21311, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12085, type_12085, type_12085), Reflex::Literal("erase"), method_21312, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65093), Reflex::Literal("swap"), method_21313, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_21314, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Muon -------------------------------
static  void operator_59332( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::Muon*)o)->operator=)(*(const ::pat::Muon*)arg[0]);
  else   (((::pat::Muon*)o)->operator=)(*(const ::pat::Muon*)arg[0]);
}

static void constructor_59333( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Muon(*(const ::pat::Muon*)arg[0]);
  else ::new(mem) ::pat::Muon(*(const ::pat::Muon*)arg[0]);
}

static void constructor_59334( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Muon();
  else ::new(mem) ::pat::Muon();
}

static void constructor_59335( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Muon(*(const ::reco::Muon*)arg[0]);
  else ::new(mem) ::pat::Muon(*(const ::reco::Muon*)arg[0]);
}

static void constructor_59336( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Muon(*(const ::edm::RefToBase<reco::Muon>*)arg[0]);
  else ::new(mem) ::pat::Muon(*(const ::edm::RefToBase<reco::Muon>*)arg[0]);
}

static void constructor_59337( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Muon(*(const ::edm::Ptr<reco::Muon>*)arg[0]);
  else ::new(mem) ::pat::Muon(*(const ::edm::Ptr<reco::Muon>*)arg[0]);
}

static void destructor_59338(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::Muon*)o)->::pat::Muon::~Muon)();
}
static  void method_59339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Muon*)o)->clone)());
  else   (((const ::pat::Muon*)o)->clone)();
}

static  void method_59340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Muon*)o)->track)());
  else   (((const ::pat::Muon*)o)->track)();
}

static  void method_59341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Muon*)o)->innerTrack)());
  else   (((const ::pat::Muon*)o)->innerTrack)();
}

static  void method_59342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Muon*)o)->standAloneMuon)());
  else   (((const ::pat::Muon*)o)->standAloneMuon)();
}

static  void method_59343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Muon*)o)->outerTrack)());
  else   (((const ::pat::Muon*)o)->outerTrack)();
}

static  void method_59344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Muon*)o)->combinedMuon)());
  else   (((const ::pat::Muon*)o)->combinedMuon)();
}

static  void method_59345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Muon*)o)->globalTrack)());
  else   (((const ::pat::Muon*)o)->globalTrack)();
}

static  void method_59346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Muon*)o)->bestTrack)());
  else   (((const ::pat::Muon*)o)->bestTrack)();
}

static  void method_59347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Muon*)o)->muonBestTrack)());
  else   (((const ::pat::Muon*)o)->muonBestTrack)();
}

static  void method_59348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Muon*)o)->tunePMuonBestTrack)());
  else   (((const ::pat::Muon*)o)->tunePMuonBestTrack)();
}

static  void method_59349( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::pat::Muon*)o)->embedMuonBestTrack)();
  }
  else if ( arg.size() == 1 ) { 
    (((::pat::Muon*)o)->embedMuonBestTrack)(*(bool*)arg[0]);
  }
}

static  void method_59350( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::pat::Muon*)o)->embedTunePMuonBestTrack)();
  }
  else if ( arg.size() == 1 ) { 
    (((::pat::Muon*)o)->embedTunePMuonBestTrack)(*(bool*)arg[0]);
  }
}

static  void method_59351( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Muon*)o)->embedTrack)();
}

static  void method_59352( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Muon*)o)->embedStandAloneMuon)();
}

static  void method_59353( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Muon*)o)->embedCombinedMuon)();
}

static  void method_59354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::MuonMETCorrectionData)((((const ::pat::Muon*)o)->caloMETMuonCorrs)());
  else   (((const ::pat::Muon*)o)->caloMETMuonCorrs)();
}

static  void method_59355( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Muon*)o)->embedCaloMETMuonCorrs)(*(const ::reco::MuonMETCorrectionData*)arg[0]);
}

static  void method_59356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::MuonMETCorrectionData)((((const ::pat::Muon*)o)->tcMETMuonCorrs)());
  else   (((const ::pat::Muon*)o)->tcMETMuonCorrs)();
}

static  void method_59357( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Muon*)o)->embedTcMETMuonCorrs)(*(const ::reco::MuonMETCorrectionData*)arg[0]);
}

static  void method_59358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Muon*)o)->pickyTrack)());
  else   (((const ::pat::Muon*)o)->pickyTrack)();
}

static  void method_59359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Muon*)o)->tpfmsTrack)());
  else   (((const ::pat::Muon*)o)->tpfmsTrack)();
}

static  void method_59360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Muon*)o)->dytTrack)());
  else   (((const ::pat::Muon*)o)->dytTrack)();
}

static  void method_59361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Muon*)o)->pickyMuon)());
  else   (((const ::pat::Muon*)o)->pickyMuon)();
}

static  void method_59362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Muon*)o)->tpfmsMuon)());
  else   (((const ::pat::Muon*)o)->tpfmsMuon)();
}

static  void method_59363( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Muon*)o)->embedPickyMuon)();
}

static  void method_59364( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Muon*)o)->embedTpfmsMuon)();
}

static  void method_59365( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Muon*)o)->embedDytMuon)();
}

static  void method_59366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::PFCandidateRef)((((const ::pat::Muon*)o)->pfCandidateRef)());
  else   (((const ::pat::Muon*)o)->pfCandidateRef)();
}

static  void method_59367( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Muon*)o)->setPFCandidateRef)(*(const ::reco::PFCandidateRef*)arg[0]);
}

static  void method_59368( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Muon*)o)->embedPFCandidate)();
}

static  void method_59369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::Muon*)o)->numberOfSourceCandidatePtrs)());
  else   (((const ::pat::Muon*)o)->numberOfSourceCandidatePtrs)();
}

static  void method_59370( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtr)((((const ::pat::Muon*)o)->sourceCandidatePtr)(*(::size_t*)arg[0]));
  else   (((const ::pat::Muon*)o)->sourceCandidatePtr)(*(::size_t*)arg[0]);
}

static  void method_59371( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Muon*)o)->muonID)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::Muon*)o)->muonID)(*(const ::std::string*)arg[0]);
}

static  void method_59372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Muon*)o)->isGood)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::Muon*)o)->isGood)(*(const ::std::string*)arg[0]);
}

static  void method_59373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Muon*)o)->isTightMuon)(*(const ::reco::Vertex*)arg[0]));
  else   (((const ::pat::Muon*)o)->isTightMuon)(*(const ::reco::Vertex*)arg[0]);
}

static  void method_59374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Muon*)o)->isLooseMuon)());
  else   (((const ::pat::Muon*)o)->isLooseMuon)();
}

static  void method_59375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Muon*)o)->isSoftMuon)(*(const ::reco::Vertex*)arg[0]));
  else   (((const ::pat::Muon*)o)->isSoftMuon)(*(const ::reco::Vertex*)arg[0]);
}

static  void method_59376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Muon*)o)->isHighPtMuon)(*(const ::reco::Vertex*)arg[0]));
  else   (((const ::pat::Muon*)o)->isHighPtMuon)(*(const ::reco::Vertex*)arg[0]);
}

static  void method_59377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Muon*)o)->trackIso)());
  else   (((const ::pat::Muon*)o)->trackIso)();
}

static  void method_59378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Muon*)o)->ecalIso)());
  else   (((const ::pat::Muon*)o)->ecalIso)();
}

static  void method_59379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Muon*)o)->hcalIso)());
  else   (((const ::pat::Muon*)o)->hcalIso)();
}

static  void method_59380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Muon*)o)->caloIso)());
  else   (((const ::pat::Muon*)o)->caloIso)();
}

static  void method_59381( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Muon*)o)->initImpactParameters)();
}

static  void method_59382( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::Muon*)o)->dB)());
    else     (((const ::pat::Muon*)o)->dB)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::Muon*)o)->dB)(*(::pat::Muon::IPTYPE*)arg[0]));
    else     (((const ::pat::Muon*)o)->dB)(*(::pat::Muon::IPTYPE*)arg[0]);
  }
}

static  void method_59383( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::Muon*)o)->edB)());
    else     (((const ::pat::Muon*)o)->edB)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::Muon*)o)->edB)(*(::pat::Muon::IPTYPE*)arg[0]));
    else     (((const ::pat::Muon*)o)->edB)(*(::pat::Muon::IPTYPE*)arg[0]);
  }
}

static  void method_59384( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::pat::Muon*)o)->setDB)(*(double*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::pat::Muon*)o)->setDB)(*(double*)arg[0],
      *(double*)arg[1],
      *(::pat::Muon::IPTYPE*)arg[2]);
  }
}

static  void method_59385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::pat::Muon*)o)->numberOfValidHits)());
  else   (((const ::pat::Muon*)o)->numberOfValidHits)();
}

static  void method_59386( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Muon*)o)->setNumberOfValidHits)(*(unsigned int*)arg[0]);
}

static  void method_59387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Muon*)o)->normChi2)());
  else   (((const ::pat::Muon*)o)->normChi2)();
}

static  void method_59388( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Muon*)o)->setNormChi2)(*(double*)arg[0]);
}

static  void method_59389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::Muon*)o)->segmentCompatibility)());
    else     (((const ::pat::Muon*)o)->segmentCompatibility)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::Muon*)o)->segmentCompatibility)(*(::reco::Muon::ArbitrationType*)arg[0]));
    else     (((const ::pat::Muon*)o)->segmentCompatibility)(*(::reco::Muon::ArbitrationType*)arg[0]);
  }
}

static void method_newdel_13465( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::Muon >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::Muon >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::Muon >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::Muon >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::Muon >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x60( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::Lepton<reco::Muon>")), ::Reflex::BaseOffset< ::pat::Muon,::pat::Lepton<reco::Muon> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::Muon>")), ::Reflex::BaseOffset< ::pat::Muon,::pat::PATObject<reco::Muon> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Muon")), ::Reflex::BaseOffset< ::pat::Muon,::reco::Muon >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::pat::Muon,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::Muon,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::Muon,::reco::Candidate >::Get(),::Reflex::PUBLIC), 5));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Muon -------------------------------
void __pat__Muon_db_datamem(Reflex::Class*);
void __pat__Muon_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__Muon_datamem_bld(&__pat__Muon_db_datamem);
Reflex::GenreflexMemberBuilder __pat__Muon_funcmem_bld(&__pat__Muon_db_funcmem);
void __pat__Muon_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::Muon"), typeid(::pat::Muon), sizeof(::pat::Muon), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "13")
  .AddBase(type_13529, ::Reflex::BaseOffset< ::pat::Muon, ::pat::Lepton<reco::Muon> >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("pat::Muon::IPTYPE"), Reflex::Literal("None=0;PV2D=1;PV3D=2;BS2D=3;BS3D=4"), &typeid(pat::Muon::IPTYPE), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_59330, Reflex::Literal("pat::Muon::IpType"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21328, type_17830), Reflex::Literal("operator="), operator_59332, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17830), Reflex::Literal("Muon"), constructor_59333, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Muon"), constructor_59334, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27924), Reflex::Literal("Muon"), constructor_59335, 0, "aMuon", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71920), Reflex::Literal("Muon"), constructor_59336, 0, "aMuonRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71976), Reflex::Literal("Muon"), constructor_59337, 0, "aMuonRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Muon"), destructor_59338, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13465, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x60, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__Muon_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__Muon_funcmem_bld);
}

//------Delayed data member builder for class Muon -------------------
void __pat__Muon_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("embeddedMuonBestTrack_"), OffsetOf(__shadow__::__pat__Muon, embeddedMuonBestTrack_), ::Reflex::PROTECTED)
  .AddDataMember(type_3526, Reflex::Literal("muonBestTrack_"), OffsetOf(__shadow__::__pat__Muon, muonBestTrack_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedTunePMuonBestTrack_"), OffsetOf(__shadow__::__pat__Muon, embeddedTunePMuonBestTrack_), ::Reflex::PROTECTED)
  .AddDataMember(type_3526, Reflex::Literal("tunePMuonBestTrack_"), OffsetOf(__shadow__::__pat__Muon, tunePMuonBestTrack_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedTrack_"), OffsetOf(__shadow__::__pat__Muon, embeddedTrack_), ::Reflex::PROTECTED)
  .AddDataMember(type_3526, Reflex::Literal("track_"), OffsetOf(__shadow__::__pat__Muon, track_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedStandAloneMuon_"), OffsetOf(__shadow__::__pat__Muon, embeddedStandAloneMuon_), ::Reflex::PROTECTED)
  .AddDataMember(type_3526, Reflex::Literal("standAloneMuon_"), OffsetOf(__shadow__::__pat__Muon, standAloneMuon_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedCombinedMuon_"), OffsetOf(__shadow__::__pat__Muon, embeddedCombinedMuon_), ::Reflex::PROTECTED)
  .AddDataMember(type_3526, Reflex::Literal("combinedMuon_"), OffsetOf(__shadow__::__pat__Muon, combinedMuon_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedTCMETMuonCorrs_"), OffsetOf(__shadow__::__pat__Muon, embeddedTCMETMuonCorrs_), ::Reflex::PROTECTED)
  .AddDataMember(type_3620, Reflex::Literal("tcMETMuonCorrs_"), OffsetOf(__shadow__::__pat__Muon, tcMETMuonCorrs_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedCaloMETMuonCorrs_"), OffsetOf(__shadow__::__pat__Muon, embeddedCaloMETMuonCorrs_), ::Reflex::PROTECTED)
  .AddDataMember(type_3620, Reflex::Literal("caloMETMuonCorrs_"), OffsetOf(__shadow__::__pat__Muon, caloMETMuonCorrs_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedPickyMuon_"), OffsetOf(__shadow__::__pat__Muon, embeddedPickyMuon_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedTpfmsMuon_"), OffsetOf(__shadow__::__pat__Muon, embeddedTpfmsMuon_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedDytMuon_"), OffsetOf(__shadow__::__pat__Muon, embeddedDytMuon_), ::Reflex::PROTECTED)
  .AddDataMember(type_3526, Reflex::Literal("pickyMuon_"), OffsetOf(__shadow__::__pat__Muon, pickyMuon_), ::Reflex::PROTECTED)
  .AddDataMember(type_3526, Reflex::Literal("tpfmsMuon_"), OffsetOf(__shadow__::__pat__Muon, tpfmsMuon_), ::Reflex::PROTECTED)
  .AddDataMember(type_3526, Reflex::Literal("dytMuon_"), OffsetOf(__shadow__::__pat__Muon, dytMuon_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedPFCandidate_"), OffsetOf(__shadow__::__pat__Muon, embeddedPFCandidate_), ::Reflex::PROTECTED)
  .AddDataMember(type_11471, Reflex::Literal("pfCandidate_"), OffsetOf(__shadow__::__pat__Muon, pfCandidate_), ::Reflex::PROTECTED)
  .AddDataMember(type_11325, Reflex::Literal("pfCandidateRef_"), OffsetOf(__shadow__::__pat__Muon, pfCandidateRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("cachedNormChi2_"), OffsetOf(__shadow__::__pat__Muon, cachedNormChi2_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("cachedDB_"), OffsetOf(__shadow__::__pat__Muon, cachedDB_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("cachedNumberOfValidHits_"), OffsetOf(__shadow__::__pat__Muon, cachedNumberOfValidHits_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("normChi2_"), OffsetOf(__shadow__::__pat__Muon, normChi2_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("dB_"), OffsetOf(__shadow__::__pat__Muon, dB_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("edB_"), OffsetOf(__shadow__::__pat__Muon, edB_), ::Reflex::PROTECTED)
  .AddDataMember(type_3570, Reflex::Literal("cachedIP_"), OffsetOf(__shadow__::__pat__Muon, cachedIP_), ::Reflex::PROTECTED)
  .AddDataMember(type_3545, Reflex::Literal("ip_"), OffsetOf(__shadow__::__pat__Muon, ip_), ::Reflex::PROTECTED)
  .AddDataMember(type_3545, Reflex::Literal("eip_"), OffsetOf(__shadow__::__pat__Muon, eip_), ::Reflex::PROTECTED)
  .AddDataMember(type_227, Reflex::Literal("numberOfValidHits_"), OffsetOf(__shadow__::__pat__Muon, numberOfValidHits_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Muon -------------------
void __pat__Muon_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15792), Reflex::Literal("clone"), method_59339, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("track"), method_59340, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("innerTrack"), method_59341, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("standAloneMuon"), method_59342, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("outerTrack"), method_59343, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("combinedMuon"), method_59344, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("globalTrack"), method_59345, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21773), Reflex::Literal("bestTrack"), method_59346, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("muonBestTrack"), method_59347, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("tunePMuonBestTrack"), method_59348, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_1810), Reflex::Literal("embedMuonBestTrack"), method_59349, 0, "force=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_1810), Reflex::Literal("embedTunePMuonBestTrack"), method_59350, 0, "force=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedTrack"), method_59351, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedStandAloneMuon"), method_59352, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedCombinedMuon"), method_59353, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11248), Reflex::Literal("caloMETMuonCorrs"), method_59354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_26954), Reflex::Literal("embedCaloMETMuonCorrs"), method_59355, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11248), Reflex::Literal("tcMETMuonCorrs"), method_59356, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_26954), Reflex::Literal("embedTcMETMuonCorrs"), method_59357, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("pickyTrack"), method_59358, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("tpfmsTrack"), method_59359, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("dytTrack"), method_59360, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("pickyMuon"), method_59361, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("tpfmsMuon"), method_59362, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedPickyMuon"), method_59363, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedTpfmsMuon"), method_59364, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedDytMuon"), method_59365, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11325), Reflex::Literal("pfCandidateRef"), method_59366, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75111), Reflex::Literal("setPFCandidateRef"), method_59367, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedPFCandidate"), method_59368, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("numberOfSourceCandidatePtrs"), method_59369, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11562, type_2393), Reflex::Literal("sourceCandidatePtr"), method_59370, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_30686), Reflex::Literal("muonID"), method_59371, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_30686), Reflex::Literal("isGood"), method_59372, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_27274), Reflex::Literal("isTightMuon"), method_59373, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isLooseMuon"), method_59374, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_27274), Reflex::Literal("isSoftMuon"), method_59375, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_27274), Reflex::Literal("isHighPtMuon"), method_59376, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("trackIso"), method_59377, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("ecalIso"), method_59378, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("hcalIso"), method_59379, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("caloIso"), method_59380, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("initImpactParameters"), method_59381, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_59330), Reflex::Literal("dB"), method_59382, 0, "type=None", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_59330), Reflex::Literal("edB"), method_59383, 0, "type=None", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112, type_112, type_59330), Reflex::Literal("setDB"), method_59384, 0, "dB;edB;type=None", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("numberOfValidHits"), method_59385, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_227), Reflex::Literal("setNumberOfValidHits"), method_59386, 0, "numberOfValidHits", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("normChi2"), method_59387, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112), Reflex::Literal("setNormChi2"), method_59388, 0, "normChi2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_46872), Reflex::Literal("segmentCompatibility"), method_59389, 0, "arbitrationType=SegmentAndTrackArbitration", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<pat::Muon,std::allocator<pat::Muon> > -------------------------------
static void constructor_21338( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Muon>();
  else ::new(mem) ::std::vector<pat::Muon>();
}

static void constructor_21339( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Muon>(*(const ::std::allocator<pat::Muon>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Muon>(*(const ::std::allocator<pat::Muon>*)arg[0]);
}

static void constructor_21340( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Muon>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::Muon>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Muon>(*(::std::size_t*)arg[0],
      *(const ::pat::Muon*)arg[1]);
  else ::new(mem) ::std::vector<pat::Muon>(*(::std::size_t*)arg[0],
      *(const ::pat::Muon*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Muon>(*(::std::size_t*)arg[0],
      *(const ::pat::Muon*)arg[1],
      *(const ::std::allocator<pat::Muon>*)arg[2]);
  else ::new(mem) ::std::vector<pat::Muon>(*(::std::size_t*)arg[0],
      *(const ::pat::Muon*)arg[1],
      *(const ::std::allocator<pat::Muon>*)arg[2]);
  }
}

static void constructor_21341( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Muon>(*(const ::std::vector<pat::Muon>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Muon>(*(const ::std::vector<pat::Muon>*)arg[0]);
}

static void destructor_21342(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::Muon>*)o)->::std::vector<pat::Muon>::~vector)();
}
static  void operator_21343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Muon>*)o)->operator=)(*(const ::std::vector<pat::Muon>*)arg[0]);
  else   (((::std::vector<pat::Muon>*)o)->operator=)(*(const ::std::vector<pat::Muon>*)arg[0]);
}

static  void method_21344( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Muon>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::Muon*)arg[1]);
}

static  void method_21345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> >)((((::std::vector<pat::Muon>*)o)->begin)());
  else   (((::std::vector<pat::Muon>*)o)->begin)();
}

static  void method_21346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >)((((const ::std::vector<pat::Muon>*)o)->begin)());
  else   (((const ::std::vector<pat::Muon>*)o)->begin)();
}

static  void method_21347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> >)((((::std::vector<pat::Muon>*)o)->end)());
  else   (((::std::vector<pat::Muon>*)o)->end)();
}

static  void method_21348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >)((((const ::std::vector<pat::Muon>*)o)->end)());
  else   (((const ::std::vector<pat::Muon>*)o)->end)();
}

static  void method_21353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Muon>*)o)->size)());
  else   (((const ::std::vector<pat::Muon>*)o)->size)();
}

static  void method_21354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Muon>*)o)->max_size)());
  else   (((const ::std::vector<pat::Muon>*)o)->max_size)();
}

static  void method_21355( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::Muon>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::Muon>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::Muon*)arg[1]);
  }
}

static  void method_21356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Muon>*)o)->capacity)());
  else   (((const ::std::vector<pat::Muon>*)o)->capacity)();
}

static  void method_21357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::Muon>*)o)->empty)());
  else   (((const ::std::vector<pat::Muon>*)o)->empty)();
}

static  void method_21358( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Muon>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_21359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Muon>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Muon>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_21360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Muon>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Muon>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_21362( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Muon>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Muon>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21363( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Muon>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Muon>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Muon>*)o)->front)();
  else   (((::std::vector<pat::Muon>*)o)->front)();
}

static  void method_21365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Muon>*)o)->front)();
  else   (((const ::std::vector<pat::Muon>*)o)->front)();
}

static  void method_21366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Muon>*)o)->back)();
  else   (((::std::vector<pat::Muon>*)o)->back)();
}

static  void method_21367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Muon>*)o)->back)();
  else   (((const ::std::vector<pat::Muon>*)o)->back)();
}

static  void method_21368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::Muon>*)o)->data)());
  else   (((::std::vector<pat::Muon>*)o)->data)();
}

static  void method_21369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::Muon>*)o)->data)());
  else   (((const ::std::vector<pat::Muon>*)o)->data)();
}

static  void method_21370( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Muon>*)o)->push_back)(*(const ::pat::Muon*)arg[0]);
}

static  void method_21371( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Muon>*)o)->pop_back)();
}

static  void method_21372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> >)((((::std::vector<pat::Muon>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> >*)arg[0],
    *(const ::pat::Muon*)arg[1]));
  else   (((::std::vector<pat::Muon>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> >*)arg[0],
    *(const ::pat::Muon*)arg[1]);
}

static  void method_21373( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Muon>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::Muon*)arg[2]);
}

static  void method_21374( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> >)((((::std::vector<pat::Muon>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> >*)arg[0]));
  else   (((::std::vector<pat::Muon>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> >*)arg[0]);
}

static  void method_21375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> >)((((::std::vector<pat::Muon>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> >*)arg[1]));
  else   (((::std::vector<pat::Muon>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Muon*,std::vector<pat::Muon> >*)arg[1]);
}

static  void method_21376( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Muon>*)o)->swap)(*(::std::vector<pat::Muon>*)arg[0]);
}

static  void method_21377( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Muon>*)o)->clear)();
}

static void method_newdel_3519( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Muon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Muon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Muon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Muon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Muon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x62( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Muon,std::allocator<pat::Muon> >")), ::Reflex::BaseOffset< ::std::vector<pat::Muon>,::std::_Vector_base<pat::Muon,std::allocator<pat::Muon> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x63( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::Muon> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::Muon> >::Generate();
}

//------Dictionary for class vector<pat::Muon,std::allocator<pat::Muon> > -------------------------------
void __std__vector_pat__Muon__db_datamem(Reflex::Class*);
void __std__vector_pat__Muon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__Muon__datamem_bld(&__std__vector_pat__Muon__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__Muon__funcmem_bld(&__std__vector_pat__Muon__db_funcmem);
void __std__vector_pat__Muon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::Muon>"), typeid(::std::vector<pat::Muon>), sizeof(::std::vector<pat::Muon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2902, ::Reflex::BaseOffset< ::std::vector<pat::Muon>, ::std::_Vector_base<pat::Muon,std::allocator<pat::Muon> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13465, Reflex::Literal("std::vector<pat::Muon>::_Alloc_value_type"))
  .AddTypedef(type_2902, Reflex::Literal("std::vector<pat::Muon>::_Base"))
  .AddTypedef(type_3877, Reflex::Literal("std::vector<pat::Muon>::_Tp_alloc_type"))
  .AddTypedef(type_12434, Reflex::Literal("std::vector<pat::Muon>::_Alloc_traits"))
  .AddTypedef(type_13465, Reflex::Literal("std::vector<pat::Muon>::value_type"))
  .AddTypedef(type_15792, Reflex::Literal("std::vector<pat::Muon>::pointer"))
  .AddTypedef(type_17828, Reflex::Literal("std::vector<pat::Muon>::const_pointer"))
  .AddTypedef(type_21328, Reflex::Literal("std::vector<pat::Muon>::reference"))
  .AddTypedef(type_17830, Reflex::Literal("std::vector<pat::Muon>::const_reference"))
  .AddTypedef(type_12116, Reflex::Literal("std::vector<pat::Muon>::iterator"))
  .AddTypedef(type_11978, Reflex::Literal("std::vector<pat::Muon>::const_iterator"))
  .AddTypedef(type_4438, Reflex::Literal("std::vector<pat::Muon>::const_reverse_iterator"))
  .AddTypedef(type_4439, Reflex::Literal("std::vector<pat::Muon>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::Muon>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::Muon>::difference_type"))
  .AddTypedef(type_3877, Reflex::Literal("std::vector<pat::Muon>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_21338, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63322), Reflex::Literal("vector"), constructor_21339, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_17830, type_63322), Reflex::Literal("vector"), constructor_21340, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35633), Reflex::Literal("vector"), constructor_21341, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_21342, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3519, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x62, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x63, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__Muon__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::Muon,std::allocator<pat::Muon> > -------------------
void __std__vector_pat__Muon__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::Muon,std::allocator<pat::Muon> > -------------------
void __std__vector_pat__Muon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65094, type_35633), Reflex::Literal("operator="), operator_21343, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_17830), Reflex::Literal("assign"), method_21344, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12116), Reflex::Literal("begin"), method_21345, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11978), Reflex::Literal("begin"), method_21346, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12116), Reflex::Literal("end"), method_21347, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11978), Reflex::Literal("end"), method_21348, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_21353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_21354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_13465), Reflex::Literal("resize"), method_21355, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_21356, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_21357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_21358, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21328, type_3845), Reflex::Literal("operator[]"), operator_21359, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17830, type_3845), Reflex::Literal("operator[]"), operator_21360, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21328, type_3845), Reflex::Literal("at"), method_21362, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17830, type_3845), Reflex::Literal("at"), method_21363, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21328), Reflex::Literal("front"), method_21364, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17830), Reflex::Literal("front"), method_21365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21328), Reflex::Literal("back"), method_21366, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17830), Reflex::Literal("back"), method_21367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15792), Reflex::Literal("data"), method_21368, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17828), Reflex::Literal("data"), method_21369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17830), Reflex::Literal("push_back"), method_21370, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_21371, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12116, type_12116, type_17830), Reflex::Literal("insert"), method_21372, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_12116, type_3845, type_17830), Reflex::Literal("insert"), method_21373, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12116, type_12116), Reflex::Literal("erase"), method_21374, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12116, type_12116, type_12116), Reflex::Literal("erase"), method_21375, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65094), Reflex::Literal("swap"), method_21376, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_21377, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Electron -------------------------------
static  void operator_62055( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::Electron*)o)->operator=)(*(const ::pat::Electron*)arg[0]);
  else   (((::pat::Electron*)o)->operator=)(*(const ::pat::Electron*)arg[0]);
}

static void constructor_62056( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Electron(*(const ::pat::Electron*)arg[0]);
  else ::new(mem) ::pat::Electron(*(const ::pat::Electron*)arg[0]);
}

static void constructor_62057( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Electron();
  else ::new(mem) ::pat::Electron();
}

static void constructor_62058( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Electron(*(const ::reco::GsfElectron*)arg[0]);
  else ::new(mem) ::pat::Electron(*(const ::reco::GsfElectron*)arg[0]);
}

static void constructor_62059( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Electron(*(const ::edm::RefToBase<reco::GsfElectron>*)arg[0]);
  else ::new(mem) ::pat::Electron(*(const ::edm::RefToBase<reco::GsfElectron>*)arg[0]);
}

static void constructor_62060( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Electron(*(const ::edm::Ptr<reco::GsfElectron>*)arg[0]);
  else ::new(mem) ::pat::Electron(*(const ::edm::Ptr<reco::GsfElectron>*)arg[0]);
}

static void destructor_62061(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::Electron*)o)->::pat::Electron::~Electron)();
}
static  void method_62062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Electron*)o)->clone)());
  else   (((const ::pat::Electron*)o)->clone)();
}

static  void method_62063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::GsfElectronCoreRef)((((const ::pat::Electron*)o)->core)());
  else   (((const ::pat::Electron*)o)->core)();
}

static  void method_62064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::GsfTrackRef)((((const ::pat::Electron*)o)->gsfTrack)());
  else   (((const ::pat::Electron*)o)->gsfTrack)();
}

static  void method_62065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::SuperClusterRef)((((const ::pat::Electron*)o)->superCluster)());
  else   (((const ::pat::Electron*)o)->superCluster)();
}

static  void method_62066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::SuperClusterRef)((((const ::pat::Electron*)o)->parentSuperCluster)());
  else   (((const ::pat::Electron*)o)->parentSuperCluster)();
}

static  void method_62067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Electron*)o)->track)());
  else   (((const ::pat::Electron*)o)->track)();
}

static  void method_62068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::TrackRef)((((const ::pat::Electron*)o)->closestCtfTrackRef)());
  else   (((const ::pat::Electron*)o)->closestCtfTrackRef)();
}

static  void method_62069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::CaloClusterPtr)((((const ::pat::Electron*)o)->seed)());
  else   (((const ::pat::Electron*)o)->seed)();
}

static  void method_62070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Electron*)o)->basicClusters)();
  else   (((const ::pat::Electron*)o)->basicClusters)();
}

static  void method_62071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Electron*)o)->preshowerClusters)();
  else   (((const ::pat::Electron*)o)->preshowerClusters)();
}

static  void method_62072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Electron*)o)->pflowBasicClusters)();
  else   (((const ::pat::Electron*)o)->pflowBasicClusters)();
}

static  void method_62073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Electron*)o)->pflowPreshowerClusters)();
  else   (((const ::pat::Electron*)o)->pflowPreshowerClusters)();
}

static  void method_62074( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Electron*)o)->embedGsfElectronCore)();
}

static  void method_62075( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Electron*)o)->embedGsfTrack)();
}

static  void method_62076( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Electron*)o)->embedSuperCluster)();
}

static  void method_62077( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Electron*)o)->embedPflowSuperCluster)();
}

static  void method_62078( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Electron*)o)->embedSeedCluster)();
}

static  void method_62079( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Electron*)o)->embedBasicClusters)();
}

static  void method_62080( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Electron*)o)->embedPreshowerClusters)();
}

static  void method_62081( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Electron*)o)->embedPflowBasicClusters)();
}

static  void method_62082( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Electron*)o)->embedPflowPreshowerClusters)();
}

static  void method_62083( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Electron*)o)->embedTrack)();
}

static  void method_62084( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->embedRecHits)((const ::EcalRecHitCollection*)arg[0]);
}

static  void method_62085( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->electronID)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::Electron*)o)->electronID)(*(const ::std::string*)arg[0]);
}

static  void method_62086( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->electronID)((const char*)arg[0]));
  else   (((const ::pat::Electron*)o)->electronID)((const char*)arg[0]);
}

static  void method_62087( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Electron*)o)->isElectronIDAvailable)(*(const ::std::string*)arg[0]));
  else   (((const ::pat::Electron*)o)->isElectronIDAvailable)(*(const ::std::string*)arg[0]);
}

static  void method_62088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Electron*)o)->isElectronIDAvailable)((const char*)arg[0]));
  else   (((const ::pat::Electron*)o)->isElectronIDAvailable)((const char*)arg[0]);
}

static  void method_62089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Electron*)o)->electronIDs)();
  else   (((const ::pat::Electron*)o)->electronIDs)();
}

static  void method_62090( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setElectronIDs)(*(const ::std::vector<std::pair<std::basic_string<char>,float> >*)arg[0]);
}

static  void method_62091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->trackIso)());
  else   (((const ::pat::Electron*)o)->trackIso)();
}

static  void method_62092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->ecalIso)());
  else   (((const ::pat::Electron*)o)->ecalIso)();
}

static  void method_62093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->hcalIso)());
  else   (((const ::pat::Electron*)o)->hcalIso)();
}

static  void method_62094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->caloIso)());
  else   (((const ::pat::Electron*)o)->caloIso)();
}

static  void method_62095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Electron*)o)->isPF)());
  else   (((const ::pat::Electron*)o)->isPF)();
}

static  void method_62096( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setIsPF)(*(bool*)arg[0]);
}

static  void method_62097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::PFCandidateRef)((((const ::pat::Electron*)o)->pfCandidateRef)());
  else   (((const ::pat::Electron*)o)->pfCandidateRef)();
}

static  void method_62098( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setPFCandidateRef)(*(const ::reco::PFCandidateRef*)arg[0]);
}

static  void method_62099( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::Electron*)o)->embedPFCandidate)();
}

static  void method_62100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::Electron*)o)->numberOfSourceCandidatePtrs)());
  else   (((const ::pat::Electron*)o)->numberOfSourceCandidatePtrs)();
}

static  void method_62101( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtr)((((const ::pat::Electron*)o)->sourceCandidatePtr)(*(::size_t*)arg[0]));
  else   (((const ::pat::Electron*)o)->sourceCandidatePtr)(*(::size_t*)arg[0]);
}

static  void method_62102( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::Electron*)o)->dB)());
    else     (((const ::pat::Electron*)o)->dB)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::Electron*)o)->dB)(*(::pat::Electron::IPTYPE*)arg[0]));
    else     (((const ::pat::Electron*)o)->dB)(*(::pat::Electron::IPTYPE*)arg[0]);
  }
}

static  void method_62103( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::Electron*)o)->edB)());
    else     (((const ::pat::Electron*)o)->edB)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::Electron*)o)->edB)(*(::pat::Electron::IPTYPE*)arg[0]));
    else     (((const ::pat::Electron*)o)->edB)(*(::pat::Electron::IPTYPE*)arg[0]);
  }
}

static  void method_62104( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::pat::Electron*)o)->setDB)(*(double*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::pat::Electron*)o)->setDB)(*(double*)arg[0],
      *(double*)arg[1],
      *(::pat::Electron::IPTYPE*)arg[2]);
  }
}

static  void method_62105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Electron*)o)->ecalDrivenMomentum)();
  else   (((const ::pat::Electron*)o)->ecalDrivenMomentum)();
}

static  void method_62106( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setEcalDrivenMomentum)(*(const ::math::XYZTLorentzVector*)arg[0]);
}

static  void method_62107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->sigmaIetaIphi)());
  else   (((const ::pat::Electron*)o)->sigmaIetaIphi)();
}

static  void method_62108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Electron*)o)->ip3d)());
  else   (((const ::pat::Electron*)o)->ip3d)();
}

static  void method_62109( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setMvaVariables)(*(double*)arg[0],
    *(double*)arg[1]);
}

static  void method_62110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Electron*)o)->recHits)());
  else   (((const ::pat::Electron*)o)->recHits)();
}

static  void method_62111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Electron*)o)->ecalRegressionEnergy)());
  else   (((const ::pat::Electron*)o)->ecalRegressionEnergy)();
}

static  void method_62112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Electron*)o)->ecalRegressionError)());
  else   (((const ::pat::Electron*)o)->ecalRegressionError)();
}

static  void method_62113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Electron*)o)->ecalTrackRegressionEnergy)());
  else   (((const ::pat::Electron*)o)->ecalTrackRegressionEnergy)();
}

static  void method_62114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Electron*)o)->ecalTrackRegressionError)());
  else   (((const ::pat::Electron*)o)->ecalTrackRegressionError)();
}

static  void method_62115( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setEcalRegressionEnergy)(*(double*)arg[0],
    *(double*)arg[1]);
}

static  void method_62116( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setEcalTrackRegressionEnergy)(*(double*)arg[0],
    *(double*)arg[1]);
}

static  void method_62117( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setEcalScale)(*(double*)arg[0]);
}

static  void method_62118( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setEcalSmear)(*(double*)arg[0]);
}

static  void method_62119( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setEcalRegressionScale)(*(double*)arg[0]);
}

static  void method_62120( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setEcalRegressionSmear)(*(double*)arg[0]);
}

static  void method_62121( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setEcalTrackRegressionScale)(*(double*)arg[0]);
}

static  void method_62122( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setEcalTrackRegressionSmear)(*(double*)arg[0]);
}

static  void method_62123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Electron*)o)->ecalScale)());
  else   (((const ::pat::Electron*)o)->ecalScale)();
}

static  void method_62124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Electron*)o)->ecalSmear)());
  else   (((const ::pat::Electron*)o)->ecalSmear)();
}

static  void method_62125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Electron*)o)->ecalRegressionScale)());
  else   (((const ::pat::Electron*)o)->ecalRegressionScale)();
}

static  void method_62126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Electron*)o)->ecalRegressionSmear)());
  else   (((const ::pat::Electron*)o)->ecalRegressionSmear)();
}

static  void method_62127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Electron*)o)->ecalTrackRegressionScale)());
  else   (((const ::pat::Electron*)o)->ecalTrackRegressionScale)();
}

static  void method_62128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::Electron*)o)->ecalTrackRegressionSmear)());
  else   (((const ::pat::Electron*)o)->ecalTrackRegressionSmear)();
}

static  void method_62129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::Electron*)o)->passConversionVeto)());
  else   (((const ::pat::Electron*)o)->passConversionVeto)();
}

static  void method_62130( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setPassConversionVeto)(*(bool*)arg[0]);
}

static  void method_62131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->full5x5_sigmaEtaEta)());
  else   (((const ::pat::Electron*)o)->full5x5_sigmaEtaEta)();
}

static  void method_62132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->full5x5_sigmaIetaIeta)());
  else   (((const ::pat::Electron*)o)->full5x5_sigmaIetaIeta)();
}

static  void method_62133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->full5x5_sigmaIphiIphi)());
  else   (((const ::pat::Electron*)o)->full5x5_sigmaIphiIphi)();
}

static  void method_62134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->full5x5_sigmaIetaIphi)());
  else   (((const ::pat::Electron*)o)->full5x5_sigmaIetaIphi)();
}

static  void method_62135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->full5x5_e1x5)());
  else   (((const ::pat::Electron*)o)->full5x5_e1x5)();
}

static  void method_62136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->full5x5_e2x5Max)());
  else   (((const ::pat::Electron*)o)->full5x5_e2x5Max)();
}

static  void method_62137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->full5x5_e5x5)());
  else   (((const ::pat::Electron*)o)->full5x5_e5x5)();
}

static  void method_62138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->full5x5_r9)());
  else   (((const ::pat::Electron*)o)->full5x5_r9)();
}

static  void method_62139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->full5x5_hcalDepth1OverEcal)());
  else   (((const ::pat::Electron*)o)->full5x5_hcalDepth1OverEcal)();
}

static  void method_62140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->full5x5_hcalDepth2OverEcal)());
  else   (((const ::pat::Electron*)o)->full5x5_hcalDepth2OverEcal)();
}

static  void method_62141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->full5x5_hcalOverEcal)());
  else   (((const ::pat::Electron*)o)->full5x5_hcalOverEcal)();
}

static  void method_62142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->full5x5_hcalDepth1OverEcalBc)());
  else   (((const ::pat::Electron*)o)->full5x5_hcalDepth1OverEcalBc)();
}

static  void method_62143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->full5x5_hcalDepth2OverEcalBc)());
  else   (((const ::pat::Electron*)o)->full5x5_hcalDepth2OverEcalBc)();
}

static  void method_62144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Electron*)o)->full5x5_hcalOverEcalBc)());
  else   (((const ::pat::Electron*)o)->full5x5_hcalOverEcalBc)();
}

static  void method_62145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::Electron*)o)->full5x5_showerShape)();
  else   (((const ::pat::Electron*)o)->full5x5_showerShape)();
}

static  void method_62146( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->full5x5_setShowerShape)(*(const ::reco::GsfElectron::ShowerShape*)arg[0]);
}

static  void method_62147( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->full5x5_setSigmaIetaIphi)(*(float*)arg[0]);
}

static  void method_62148( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setPackedPFCandidateCollection)(*(const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)arg[0]);
}

static  void method_62149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >)((((const ::pat::Electron*)o)->associatedPackedPFCandidates)());
  else   (((const ::pat::Electron*)o)->associatedPackedPFCandidates)();
}

static  void method_62150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Electron*)o)->setAssociatedPackedPFCandidates)(*(const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0]);
}

static void method_newdel_13576( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::Electron >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::Electron >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::Electron >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::Electron >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::Electron >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x65( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::Lepton<reco::GsfElectron>")), ::Reflex::BaseOffset< ::pat::Electron,::pat::Lepton<reco::GsfElectron> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::GsfElectron>")), ::Reflex::BaseOffset< ::pat::Electron,::pat::PATObject<reco::GsfElectron> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::GsfElectron")), ::Reflex::BaseOffset< ::pat::Electron,::reco::GsfElectron >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::pat::Electron,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::Electron,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::Electron,::reco::Candidate >::Get(),::Reflex::PUBLIC), 5));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

void read___pat__Electron_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  edm::AtomicPtrCache<std::vector<reco::SuperCluster> > &superClusterRelinked_ = *(edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)(target + OffsetOf(__shadow__::__pat__Electron, superClusterRelinked_));

  if( oldObj ) {}
  //--- User's code ---
    superClusterRelinked_.reset();
  
}

//------Dictionary for class Electron -------------------------------
void __pat__Electron_db_datamem(Reflex::Class*);
void __pat__Electron_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__Electron_datamem_bld(&__pat__Electron_db_datamem);
Reflex::GenreflexMemberBuilder __pat__Electron_funcmem_bld(&__pat__Electron_db_funcmem);
void __pat__Electron_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(1);
  rule = &readrules[0];
  rule->fSourceClass = "pat::Electron";
  rule->fTarget      = "superClusterRelinked_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___pat__Electron_0);
  rule->fCode        = "\n    superClusterRelinked_.reset();\n  ";
  rule->fVersion     = "[1-]";


  ::Reflex::ClassBuilder(Reflex::Literal("pat::Electron"), typeid(::pat::Electron), sizeof(::pat::Electron), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "24")
  .AddProperty("ioread", readrules )
  .AddBase(type_13530, ::Reflex::BaseOffset< ::pat::Electron, ::pat::Lepton<reco::GsfElectron> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3441, Reflex::Literal("pat::Electron::IdPair"))
  .AddEnum(Reflex::Literal("pat::Electron::IPTYPE"), Reflex::Literal("None=0;PV2D=1;PV3D=2;BS2D=3;BS3D=4"), &typeid(pat::Electron::IPTYPE), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_62053, Reflex::Literal("pat::Electron::IpType"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21391, type_17841), Reflex::Literal("operator="), operator_62055, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17841), Reflex::Literal("Electron"), constructor_62056, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Electron"), constructor_62057, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29540), Reflex::Literal("Electron"), constructor_62058, 0, "anElectron", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71925), Reflex::Literal("Electron"), constructor_62059, 0, "anElectronRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71978), Reflex::Literal("Electron"), constructor_62060, 0, "anElectronRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Electron"), destructor_62061, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13576, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x65, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__Electron_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__Electron_funcmem_bld);
}

//------Delayed data member builder for class Electron -------------------
void __pat__Electron_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("embeddedGsfElectronCore_"), OffsetOf(__shadow__::__pat__Electron, embeddedGsfElectronCore_), ::Reflex::PROTECTED)
  .AddDataMember(type_3624, Reflex::Literal("gsfElectronCore_"), OffsetOf(__shadow__::__pat__Electron, gsfElectronCore_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedGsfTrack_"), OffsetOf(__shadow__::__pat__Electron, embeddedGsfTrack_), ::Reflex::PROTECTED)
  .AddDataMember(type_3525, Reflex::Literal("gsfTrack_"), OffsetOf(__shadow__::__pat__Electron, gsfTrack_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedSuperCluster_"), OffsetOf(__shadow__::__pat__Electron, embeddedSuperCluster_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedPflowSuperCluster_"), OffsetOf(__shadow__::__pat__Electron, embeddedPflowSuperCluster_), ::Reflex::PROTECTED)
  .AddDataMember(type_3524, Reflex::Literal("superCluster_"), OffsetOf(__shadow__::__pat__Electron, superCluster_), ::Reflex::PROTECTED)
  .AddDataMember(type_7117, Reflex::Literal("superClusterRelinked_"), OffsetOf(__shadow__::__pat__Electron, superClusterRelinked_), ::Reflex::PROTECTED | ::Reflex::TRANSIENT)
  .AddDataMember(type_3585, Reflex::Literal("basicClusters_"), OffsetOf(__shadow__::__pat__Electron, basicClusters_), ::Reflex::PROTECTED)
  .AddDataMember(type_3585, Reflex::Literal("preshowerClusters_"), OffsetOf(__shadow__::__pat__Electron, preshowerClusters_), ::Reflex::PROTECTED)
  .AddDataMember(type_3585, Reflex::Literal("pflowBasicClusters_"), OffsetOf(__shadow__::__pat__Electron, pflowBasicClusters_), ::Reflex::PROTECTED)
  .AddDataMember(type_3585, Reflex::Literal("pflowPreshowerClusters_"), OffsetOf(__shadow__::__pat__Electron, pflowPreshowerClusters_), ::Reflex::PROTECTED)
  .AddDataMember(type_3524, Reflex::Literal("pflowSuperCluster_"), OffsetOf(__shadow__::__pat__Electron, pflowSuperCluster_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedTrack_"), OffsetOf(__shadow__::__pat__Electron, embeddedTrack_), ::Reflex::PROTECTED)
  .AddDataMember(type_3526, Reflex::Literal("track_"), OffsetOf(__shadow__::__pat__Electron, track_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedSeedCluster_"), OffsetOf(__shadow__::__pat__Electron, embeddedSeedCluster_), ::Reflex::PROTECTED)
  .AddDataMember(type_3585, Reflex::Literal("seedCluster_"), OffsetOf(__shadow__::__pat__Electron, seedCluster_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedRecHits_"), OffsetOf(__shadow__::__pat__Electron, embeddedRecHits_), ::Reflex::PROTECTED)
  .AddDataMember(type_831, Reflex::Literal("recHits_"), OffsetOf(__shadow__::__pat__Electron, recHits_), ::Reflex::PROTECTED)
  .AddDataMember(type_3555, Reflex::Literal("electronIDs_"), OffsetOf(__shadow__::__pat__Electron, electronIDs_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("isPF_"), OffsetOf(__shadow__::__pat__Electron, isPF_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("embeddedPFCandidate_"), OffsetOf(__shadow__::__pat__Electron, embeddedPFCandidate_), ::Reflex::PROTECTED)
  .AddDataMember(type_11471, Reflex::Literal("pfCandidate_"), OffsetOf(__shadow__::__pat__Electron, pfCandidate_), ::Reflex::PROTECTED)
  .AddDataMember(type_11325, Reflex::Literal("pfCandidateRef_"), OffsetOf(__shadow__::__pat__Electron, pfCandidateRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_10223, Reflex::Literal("ecalDrivenMomentum_"), OffsetOf(__shadow__::__pat__Electron, ecalDrivenMomentum_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("cachedDB_"), OffsetOf(__shadow__::__pat__Electron, cachedDB_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("dB_"), OffsetOf(__shadow__::__pat__Electron, dB_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("edB_"), OffsetOf(__shadow__::__pat__Electron, edB_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("sigmaIetaIphi_"), OffsetOf(__shadow__::__pat__Electron, sigmaIetaIphi_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("full5x5_sigmaIetaIphi_"), OffsetOf(__shadow__::__pat__Electron, full5x5_sigmaIetaIphi_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("ip3d_"), OffsetOf(__shadow__::__pat__Electron, ip3d_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("ecalRegressionEnergy_"), OffsetOf(__shadow__::__pat__Electron, ecalRegressionEnergy_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("ecalTrackRegressionEnergy_"), OffsetOf(__shadow__::__pat__Electron, ecalTrackRegressionEnergy_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("ecalRegressionError_"), OffsetOf(__shadow__::__pat__Electron, ecalRegressionError_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("ecalTrackRegressionError_"), OffsetOf(__shadow__::__pat__Electron, ecalTrackRegressionError_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("ecalScale_"), OffsetOf(__shadow__::__pat__Electron, ecalScale_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("ecalSmear_"), OffsetOf(__shadow__::__pat__Electron, ecalSmear_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("ecalRegressionScale_"), OffsetOf(__shadow__::__pat__Electron, ecalRegressionScale_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("ecalRegressionSmear_"), OffsetOf(__shadow__::__pat__Electron, ecalRegressionSmear_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("ecalTrackRegressionScale_"), OffsetOf(__shadow__::__pat__Electron, ecalTrackRegressionScale_), ::Reflex::PROTECTED)
  .AddDataMember(type_112, Reflex::Literal("ecalTrackRegressionSmear_"), OffsetOf(__shadow__::__pat__Electron, ecalTrackRegressionSmear_), ::Reflex::PROTECTED)
  .AddDataMember(type_46617, Reflex::Literal("full5x5_showerShape_"), OffsetOf(__shadow__::__pat__Electron, full5x5_showerShape_), ::Reflex::PROTECTED)
  .AddDataMember(type_1810, Reflex::Literal("passConversionVeto_"), OffsetOf(__shadow__::__pat__Electron, passConversionVeto_), ::Reflex::PROTECTED)
  .AddDataMember(type_3570, Reflex::Literal("cachedIP_"), OffsetOf(__shadow__::__pat__Electron, cachedIP_), ::Reflex::PROTECTED)
  .AddDataMember(type_3545, Reflex::Literal("ip_"), OffsetOf(__shadow__::__pat__Electron, ip_), ::Reflex::PROTECTED)
  .AddDataMember(type_3545, Reflex::Literal("eip_"), OffsetOf(__shadow__::__pat__Electron, eip_), ::Reflex::PROTECTED)
  .AddDataMember(type_7221, Reflex::Literal("packedPFCandidates_"), OffsetOf(__shadow__::__pat__Electron, packedPFCandidates_), ::Reflex::PROTECTED)
  .AddDataMember(type_3584, Reflex::Literal("associatedPackedFCandidateIndices_"), OffsetOf(__shadow__::__pat__Electron, associatedPackedFCandidateIndices_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Electron -------------------
void __pat__Electron_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15868), Reflex::Literal("clone"), method_62062, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11383), Reflex::Literal("core"), method_62063, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11616), Reflex::Literal("gsfTrack"), method_62064, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11485), Reflex::Literal("superCluster"), method_62065, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11485), Reflex::Literal("parentSuperCluster"), method_62066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("track"), method_62067, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11589), Reflex::Literal("closestCtfTrackRef"), method_62068, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11624), Reflex::Literal("seed"), method_62069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35752), Reflex::Literal("basicClusters"), method_62070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35752), Reflex::Literal("preshowerClusters"), method_62071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35752), Reflex::Literal("pflowBasicClusters"), method_62072, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35752), Reflex::Literal("pflowPreshowerClusters"), method_62073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedGsfElectronCore"), method_62074, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedGsfTrack"), method_62075, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedSuperCluster"), method_62076, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedPflowSuperCluster"), method_62077, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedSeedCluster"), method_62078, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedBasicClusters"), method_62079, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedPreshowerClusters"), method_62080, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedPflowBasicClusters"), method_62081, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedPflowPreshowerClusters"), method_62082, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedTrack"), method_62083, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75130), Reflex::Literal("embedRecHits"), method_62084, 0, "rechits", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_30686), Reflex::Literal("electronID"), method_62085, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_4688), Reflex::Literal("electronID"), method_62086, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_30686), Reflex::Literal("isElectronIDAvailable"), method_62087, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_4688), Reflex::Literal("isElectronIDAvailable"), method_62088, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65188), Reflex::Literal("electronIDs"), method_62089, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65188), Reflex::Literal("setElectronIDs"), method_62090, 0, "ids", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("trackIso"), method_62091, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("ecalIso"), method_62092, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("hcalIso"), method_62093, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("caloIso"), method_62094, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPF"), method_62095, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_1810), Reflex::Literal("setIsPF"), method_62096, 0, "hasPFCandidate", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11325), Reflex::Literal("pfCandidateRef"), method_62097, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75111), Reflex::Literal("setPFCandidateRef"), method_62098, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedPFCandidate"), method_62099, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("numberOfSourceCandidatePtrs"), method_62100, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11562, type_2393), Reflex::Literal("sourceCandidatePtr"), method_62101, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_62053), Reflex::Literal("dB"), method_62102, 0, "type=None", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_62053), Reflex::Literal("edB"), method_62103, 0, "type=None", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112, type_112, type_62053), Reflex::Literal("setDB"), method_62104, 0, "dB;edB;type=None", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45676), Reflex::Literal("ecalDrivenMomentum"), method_62105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_45676), Reflex::Literal("setEcalDrivenMomentum"), method_62106, 0, "mom", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("sigmaIetaIphi"), method_62107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("ip3d"), method_62108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112, type_112), Reflex::Literal("setMvaVariables"), method_62109, 0, "sigmaIetaIphi;ip3d", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75130), Reflex::Literal("recHits"), method_62110, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("ecalRegressionEnergy"), method_62111, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("ecalRegressionError"), method_62112, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("ecalTrackRegressionEnergy"), method_62113, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("ecalTrackRegressionError"), method_62114, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112, type_112), Reflex::Literal("setEcalRegressionEnergy"), method_62115, 0, "val;err", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112, type_112), Reflex::Literal("setEcalTrackRegressionEnergy"), method_62116, 0, "val;err", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112), Reflex::Literal("setEcalScale"), method_62117, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112), Reflex::Literal("setEcalSmear"), method_62118, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112), Reflex::Literal("setEcalRegressionScale"), method_62119, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112), Reflex::Literal("setEcalRegressionSmear"), method_62120, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112), Reflex::Literal("setEcalTrackRegressionScale"), method_62121, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_112), Reflex::Literal("setEcalTrackRegressionSmear"), method_62122, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("ecalScale"), method_62123, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("ecalSmear"), method_62124, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("ecalRegressionScale"), method_62125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("ecalRegressionSmear"), method_62126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("ecalTrackRegressionScale"), method_62127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("ecalTrackRegressionSmear"), method_62128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("passConversionVeto"), method_62129, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_1810), Reflex::Literal("setPassConversionVeto"), method_62130, 0, "flag", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_sigmaEtaEta"), method_62131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_sigmaIetaIeta"), method_62132, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_sigmaIphiIphi"), method_62133, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_sigmaIetaIphi"), method_62134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_e1x5"), method_62135, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_e2x5Max"), method_62136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_e5x5"), method_62137, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_r9"), method_62138, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_hcalDepth1OverEcal"), method_62139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_hcalDepth2OverEcal"), method_62140, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_hcalOverEcal"), method_62141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_hcalDepth1OverEcalBc"), method_62142, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_hcalDepth2OverEcalBc"), method_62143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("full5x5_hcalOverEcalBc"), method_62144, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73002), Reflex::Literal("full5x5_showerShape"), method_62145, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_73002), Reflex::Literal("full5x5_setShowerShape"), method_62146, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("full5x5_setSigmaIetaIphi"), method_62147, 0, "sigmaIetaIphi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_71851), Reflex::Literal("setPackedPFCandidateCollection"), method_62148, 0, "refprod", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6477), Reflex::Literal("associatedPackedPFCandidates"), method_62149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70702), Reflex::Literal("setAssociatedPackedPFCandidates"), method_62150, 0, "refvector", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<pat::Electron,std::allocator<pat::Electron> > -------------------------------
static void constructor_21401( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Electron>();
  else ::new(mem) ::std::vector<pat::Electron>();
}

static void constructor_21402( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Electron>(*(const ::std::allocator<pat::Electron>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Electron>(*(const ::std::allocator<pat::Electron>*)arg[0]);
}

static void constructor_21403( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Electron>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::Electron>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Electron>(*(::std::size_t*)arg[0],
      *(const ::pat::Electron*)arg[1]);
  else ::new(mem) ::std::vector<pat::Electron>(*(::std::size_t*)arg[0],
      *(const ::pat::Electron*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Electron>(*(::std::size_t*)arg[0],
      *(const ::pat::Electron*)arg[1],
      *(const ::std::allocator<pat::Electron>*)arg[2]);
  else ::new(mem) ::std::vector<pat::Electron>(*(::std::size_t*)arg[0],
      *(const ::pat::Electron*)arg[1],
      *(const ::std::allocator<pat::Electron>*)arg[2]);
  }
}

static void constructor_21404( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::Electron>(*(const ::std::vector<pat::Electron>*)arg[0]);
  else ::new(mem) ::std::vector<pat::Electron>(*(const ::std::vector<pat::Electron>*)arg[0]);
}

static void destructor_21405(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::Electron>*)o)->::std::vector<pat::Electron>::~vector)();
}
static  void operator_21406( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Electron>*)o)->operator=)(*(const ::std::vector<pat::Electron>*)arg[0]);
  else   (((::std::vector<pat::Electron>*)o)->operator=)(*(const ::std::vector<pat::Electron>*)arg[0]);
}

static  void method_21407( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Electron>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::Electron*)arg[1]);
}

static  void method_21408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> >)((((::std::vector<pat::Electron>*)o)->begin)());
  else   (((::std::vector<pat::Electron>*)o)->begin)();
}

static  void method_21409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >)((((const ::std::vector<pat::Electron>*)o)->begin)());
  else   (((const ::std::vector<pat::Electron>*)o)->begin)();
}

static  void method_21410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> >)((((::std::vector<pat::Electron>*)o)->end)());
  else   (((::std::vector<pat::Electron>*)o)->end)();
}

static  void method_21411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >)((((const ::std::vector<pat::Electron>*)o)->end)());
  else   (((const ::std::vector<pat::Electron>*)o)->end)();
}

static  void method_21416( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Electron>*)o)->size)());
  else   (((const ::std::vector<pat::Electron>*)o)->size)();
}

static  void method_21417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Electron>*)o)->max_size)());
  else   (((const ::std::vector<pat::Electron>*)o)->max_size)();
}

static  void method_21418( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::Electron>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::Electron>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::Electron*)arg[1]);
  }
}

static  void method_21419( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::Electron>*)o)->capacity)());
  else   (((const ::std::vector<pat::Electron>*)o)->capacity)();
}

static  void method_21420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::Electron>*)o)->empty)());
  else   (((const ::std::vector<pat::Electron>*)o)->empty)();
}

static  void method_21421( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Electron>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_21422( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Electron>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Electron>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_21423( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Electron>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Electron>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_21425( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Electron>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::Electron>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Electron>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::Electron>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21427( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Electron>*)o)->front)();
  else   (((::std::vector<pat::Electron>*)o)->front)();
}

static  void method_21428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Electron>*)o)->front)();
  else   (((const ::std::vector<pat::Electron>*)o)->front)();
}

static  void method_21429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::Electron>*)o)->back)();
  else   (((::std::vector<pat::Electron>*)o)->back)();
}

static  void method_21430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::Electron>*)o)->back)();
  else   (((const ::std::vector<pat::Electron>*)o)->back)();
}

static  void method_21431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::Electron>*)o)->data)());
  else   (((::std::vector<pat::Electron>*)o)->data)();
}

static  void method_21432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::Electron>*)o)->data)());
  else   (((const ::std::vector<pat::Electron>*)o)->data)();
}

static  void method_21433( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Electron>*)o)->push_back)(*(const ::pat::Electron*)arg[0]);
}

static  void method_21434( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Electron>*)o)->pop_back)();
}

static  void method_21435( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> >)((((::std::vector<pat::Electron>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> >*)arg[0],
    *(const ::pat::Electron*)arg[1]));
  else   (((::std::vector<pat::Electron>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> >*)arg[0],
    *(const ::pat::Electron*)arg[1]);
}

static  void method_21436( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Electron>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::Electron*)arg[2]);
}

static  void method_21437( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> >)((((::std::vector<pat::Electron>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> >*)arg[0]));
  else   (((::std::vector<pat::Electron>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> >*)arg[0]);
}

static  void method_21438( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> >)((((::std::vector<pat::Electron>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> >*)arg[1]));
  else   (((::std::vector<pat::Electron>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::Electron*,std::vector<pat::Electron> >*)arg[1]);
}

static  void method_21439( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::Electron>*)o)->swap)(*(::std::vector<pat::Electron>*)arg[0]);
}

static  void method_21440( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::Electron>*)o)->clear)();
}

static void method_newdel_3520( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Electron> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Electron> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Electron> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Electron> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::Electron> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x67( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::Electron,std::allocator<pat::Electron> >")), ::Reflex::BaseOffset< ::std::vector<pat::Electron>,::std::_Vector_base<pat::Electron,std::allocator<pat::Electron> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x68( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::Electron> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::Electron> >::Generate();
}

//------Dictionary for class vector<pat::Electron,std::allocator<pat::Electron> > -------------------------------
void __std__vector_pat__Electron__db_datamem(Reflex::Class*);
void __std__vector_pat__Electron__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__Electron__datamem_bld(&__std__vector_pat__Electron__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__Electron__funcmem_bld(&__std__vector_pat__Electron__db_funcmem);
void __std__vector_pat__Electron__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::Electron>"), typeid(::std::vector<pat::Electron>), sizeof(::std::vector<pat::Electron>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2906, ::Reflex::BaseOffset< ::std::vector<pat::Electron>, ::std::_Vector_base<pat::Electron,std::allocator<pat::Electron> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13576, Reflex::Literal("std::vector<pat::Electron>::_Alloc_value_type"))
  .AddTypedef(type_2906, Reflex::Literal("std::vector<pat::Electron>::_Base"))
  .AddTypedef(type_3878, Reflex::Literal("std::vector<pat::Electron>::_Tp_alloc_type"))
  .AddTypedef(type_12438, Reflex::Literal("std::vector<pat::Electron>::_Alloc_traits"))
  .AddTypedef(type_13576, Reflex::Literal("std::vector<pat::Electron>::value_type"))
  .AddTypedef(type_15868, Reflex::Literal("std::vector<pat::Electron>::pointer"))
  .AddTypedef(type_17839, Reflex::Literal("std::vector<pat::Electron>::const_pointer"))
  .AddTypedef(type_21391, Reflex::Literal("std::vector<pat::Electron>::reference"))
  .AddTypedef(type_17841, Reflex::Literal("std::vector<pat::Electron>::const_reference"))
  .AddTypedef(type_12121, Reflex::Literal("std::vector<pat::Electron>::iterator"))
  .AddTypedef(type_11979, Reflex::Literal("std::vector<pat::Electron>::const_iterator"))
  .AddTypedef(type_4446, Reflex::Literal("std::vector<pat::Electron>::const_reverse_iterator"))
  .AddTypedef(type_4447, Reflex::Literal("std::vector<pat::Electron>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::Electron>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::Electron>::difference_type"))
  .AddTypedef(type_3878, Reflex::Literal("std::vector<pat::Electron>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_21401, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63374), Reflex::Literal("vector"), constructor_21402, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_17841, type_63374), Reflex::Literal("vector"), constructor_21403, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35645), Reflex::Literal("vector"), constructor_21404, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_21405, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3520, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x67, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x68, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__Electron__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::Electron,std::allocator<pat::Electron> > -------------------
void __std__vector_pat__Electron__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::Electron,std::allocator<pat::Electron> > -------------------
void __std__vector_pat__Electron__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65095, type_35645), Reflex::Literal("operator="), operator_21406, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_17841), Reflex::Literal("assign"), method_21407, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12121), Reflex::Literal("begin"), method_21408, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11979), Reflex::Literal("begin"), method_21409, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12121), Reflex::Literal("end"), method_21410, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11979), Reflex::Literal("end"), method_21411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_21416, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_21417, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_13576), Reflex::Literal("resize"), method_21418, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_21419, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_21420, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_21421, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21391, type_3845), Reflex::Literal("operator[]"), operator_21422, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17841, type_3845), Reflex::Literal("operator[]"), operator_21423, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21391, type_3845), Reflex::Literal("at"), method_21425, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17841, type_3845), Reflex::Literal("at"), method_21426, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21391), Reflex::Literal("front"), method_21427, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17841), Reflex::Literal("front"), method_21428, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21391), Reflex::Literal("back"), method_21429, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17841), Reflex::Literal("back"), method_21430, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15868), Reflex::Literal("data"), method_21431, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17839), Reflex::Literal("data"), method_21432, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17841), Reflex::Literal("push_back"), method_21433, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_21434, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12121, type_12121, type_17841), Reflex::Literal("insert"), method_21435, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_12121, type_3845, type_17841), Reflex::Literal("insert"), method_21436, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12121, type_12121), Reflex::Literal("erase"), method_21437, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12121, type_12121, type_12121), Reflex::Literal("erase"), method_21438, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65095), Reflex::Literal("swap"), method_21439, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_21440, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class MHT -------------------------------
static  void operator_61989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::MHT*)o)->operator=)(*(const ::pat::MHT*)arg[0]);
  else   (((::pat::MHT*)o)->operator=)(*(const ::pat::MHT*)arg[0]);
}

static void constructor_61990( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::MHT(*(const ::pat::MHT*)arg[0]);
  else ::new(mem) ::pat::MHT(*(const ::pat::MHT*)arg[0]);
}

static void constructor_61991( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::MHT();
  else ::new(mem) ::pat::MHT();
}

static void constructor_61992( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::MHT(*(const ::math::XYZTLorentzVector*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::pat::MHT(*(const ::math::XYZTLorentzVector*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
}

static void destructor_61993(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::MHT*)o)->::pat::MHT::~MHT)();
}
static  void method_61994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MHT*)o)->mht)());
  else   (((const ::pat::MHT*)o)->mht)();
}

static  void method_61995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MHT*)o)->ht)());
  else   (((const ::pat::MHT*)o)->ht)();
}

static  void method_61996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MHT*)o)->significance)());
  else   (((const ::pat::MHT*)o)->significance)();
}

static  void method_61997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MHT*)o)->error)());
  else   (((const ::pat::MHT*)o)->error)();
}

static  void method_61998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MHT*)o)->getNumberOfJets)());
  else   (((const ::pat::MHT*)o)->getNumberOfJets)();
}

static  void method_61999( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::MHT*)o)->setNumberOfJets)(*(const double*)arg[0]);
}

static  void method_62000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MHT*)o)->getNumberOfElectrons)());
  else   (((const ::pat::MHT*)o)->getNumberOfElectrons)();
}

static  void method_62001( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::MHT*)o)->setNumberOfElectrons)(*(const double*)arg[0]);
}

static  void method_62002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MHT*)o)->getNumberOfMuons)());
  else   (((const ::pat::MHT*)o)->getNumberOfMuons)();
}

static  void method_62003( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::MHT*)o)->setNumberOfMuons)(*(const double*)arg[0]);
}

static void method_newdel_13575( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::MHT >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::MHT >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::MHT >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::MHT >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::MHT >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x70( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::CompositeRefBaseCandidate")), ::Reflex::BaseOffset< ::pat::MHT,::reco::CompositeRefBaseCandidate >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::MHT,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::MHT,::reco::Candidate >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class MHT -------------------------------
void __pat__MHT_db_datamem(Reflex::Class*);
void __pat__MHT_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__MHT_datamem_bld(&__pat__MHT_db_datamem);
Reflex::GenreflexMemberBuilder __pat__MHT_funcmem_bld(&__pat__MHT_db_funcmem);
void __pat__MHT_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::MHT"), typeid(::pat::MHT), sizeof(::pat::MHT), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_11228, ::Reflex::BaseOffset< ::pat::MHT, ::reco::CompositeRefBaseCandidate >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21454, type_17775), Reflex::Literal("operator="), operator_61989, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17775), Reflex::Literal("MHT"), constructor_61990, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MHT"), constructor_61991, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45676, type_112, type_112), Reflex::Literal("MHT"), constructor_61992, 0, "p4;ht;signif", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MHT"), destructor_61993, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13575, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x70, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__MHT_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__MHT_funcmem_bld);
}

//------Delayed data member builder for class MHT -------------------
void __pat__MHT_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_112, Reflex::Literal("ht_"), OffsetOf(__shadow__::__pat__MHT, ht_), ::Reflex::PRIVATE)
  .AddDataMember(type_112, Reflex::Literal("significance_"), OffsetOf(__shadow__::__pat__MHT, significance_), ::Reflex::PRIVATE)
  .AddDataMember(type_112, Reflex::Literal("number_of_jets_"), OffsetOf(__shadow__::__pat__MHT, number_of_jets_), ::Reflex::PRIVATE)
  .AddDataMember(type_112, Reflex::Literal("number_of_electrons_"), OffsetOf(__shadow__::__pat__MHT, number_of_electrons_), ::Reflex::PRIVATE)
  .AddDataMember(type_112, Reflex::Literal("number_of_muons_"), OffsetOf(__shadow__::__pat__MHT, number_of_muons_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class MHT -------------------
void __pat__MHT_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("mht"), method_61994, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("ht"), method_61995, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("significance"), method_61996, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("error"), method_61997, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("getNumberOfJets"), method_61998, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_13443), Reflex::Literal("setNumberOfJets"), method_61999, 0, "numberOfJets", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("getNumberOfElectrons"), method_62000, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_13443), Reflex::Literal("setNumberOfElectrons"), method_62001, 0, "numberOfElectrons", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("getNumberOfMuons"), method_62002, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_13443), Reflex::Literal("setNumberOfMuons"), method_62003, 0, "numberOfMuons", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<pat::MHT,std::allocator<pat::MHT> > -------------------------------
static void constructor_21464( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MHT>();
  else ::new(mem) ::std::vector<pat::MHT>();
}

static void constructor_21465( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MHT>(*(const ::std::allocator<pat::MHT>*)arg[0]);
  else ::new(mem) ::std::vector<pat::MHT>(*(const ::std::allocator<pat::MHT>*)arg[0]);
}

static void constructor_21466( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MHT>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::MHT>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MHT>(*(::std::size_t*)arg[0],
      *(const ::pat::MHT*)arg[1]);
  else ::new(mem) ::std::vector<pat::MHT>(*(::std::size_t*)arg[0],
      *(const ::pat::MHT*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MHT>(*(::std::size_t*)arg[0],
      *(const ::pat::MHT*)arg[1],
      *(const ::std::allocator<pat::MHT>*)arg[2]);
  else ::new(mem) ::std::vector<pat::MHT>(*(::std::size_t*)arg[0],
      *(const ::pat::MHT*)arg[1],
      *(const ::std::allocator<pat::MHT>*)arg[2]);
  }
}

static void constructor_21467( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MHT>(*(const ::std::vector<pat::MHT>*)arg[0]);
  else ::new(mem) ::std::vector<pat::MHT>(*(const ::std::vector<pat::MHT>*)arg[0]);
}

static void destructor_21468(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::MHT>*)o)->::std::vector<pat::MHT>::~vector)();
}
static  void operator_21469( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::MHT>*)o)->operator=)(*(const ::std::vector<pat::MHT>*)arg[0]);
  else   (((::std::vector<pat::MHT>*)o)->operator=)(*(const ::std::vector<pat::MHT>*)arg[0]);
}

static  void method_21470( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::MHT>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::MHT*)arg[1]);
}

static  void method_21471( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> >)((((::std::vector<pat::MHT>*)o)->begin)());
  else   (((::std::vector<pat::MHT>*)o)->begin)();
}

static  void method_21472( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >)((((const ::std::vector<pat::MHT>*)o)->begin)());
  else   (((const ::std::vector<pat::MHT>*)o)->begin)();
}

static  void method_21473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> >)((((::std::vector<pat::MHT>*)o)->end)());
  else   (((::std::vector<pat::MHT>*)o)->end)();
}

static  void method_21474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >)((((const ::std::vector<pat::MHT>*)o)->end)());
  else   (((const ::std::vector<pat::MHT>*)o)->end)();
}

static  void method_21479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::MHT>*)o)->size)());
  else   (((const ::std::vector<pat::MHT>*)o)->size)();
}

static  void method_21480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::MHT>*)o)->max_size)());
  else   (((const ::std::vector<pat::MHT>*)o)->max_size)();
}

static  void method_21481( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::MHT>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::MHT>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::MHT*)arg[1]);
  }
}

static  void method_21482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::MHT>*)o)->capacity)());
  else   (((const ::std::vector<pat::MHT>*)o)->capacity)();
}

static  void method_21483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::MHT>*)o)->empty)());
  else   (((const ::std::vector<pat::MHT>*)o)->empty)();
}

static  void method_21484( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::MHT>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_21485( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::MHT>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::MHT>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_21486( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::MHT>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::MHT>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_21488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::MHT>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::MHT>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::MHT>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::MHT>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_21490( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::MHT>*)o)->front)();
  else   (((::std::vector<pat::MHT>*)o)->front)();
}

static  void method_21491( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::MHT>*)o)->front)();
  else   (((const ::std::vector<pat::MHT>*)o)->front)();
}

static  void method_21492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::MHT>*)o)->back)();
  else   (((::std::vector<pat::MHT>*)o)->back)();
}

static  void method_21493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::MHT>*)o)->back)();
  else   (((const ::std::vector<pat::MHT>*)o)->back)();
}

static  void method_21494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::MHT>*)o)->data)());
  else   (((::std::vector<pat::MHT>*)o)->data)();
}

static  void method_21495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::MHT>*)o)->data)());
  else   (((const ::std::vector<pat::MHT>*)o)->data)();
}

static  void method_21496( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::MHT>*)o)->push_back)(*(const ::pat::MHT*)arg[0]);
}

static  void method_21497( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::MHT>*)o)->pop_back)();
}

static  void method_21498( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> >)((((::std::vector<pat::MHT>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> >*)arg[0],
    *(const ::pat::MHT*)arg[1]));
  else   (((::std::vector<pat::MHT>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> >*)arg[0],
    *(const ::pat::MHT*)arg[1]);
}

static  void method_21499( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::MHT>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::MHT*)arg[2]);
}

static  void method_21500( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> >)((((::std::vector<pat::MHT>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> >*)arg[0]));
  else   (((::std::vector<pat::MHT>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> >*)arg[0]);
}

static  void method_21501( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> >)((((::std::vector<pat::MHT>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> >*)arg[1]));
  else   (((::std::vector<pat::MHT>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::MHT*,std::vector<pat::MHT> >*)arg[1]);
}

static  void method_21502( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::MHT>*)o)->swap)(*(::std::vector<pat::MHT>*)arg[0]);
}

static  void method_21503( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::MHT>*)o)->clear)();
}

static void method_newdel_3521( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::MHT> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::MHT> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::MHT> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::MHT> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::MHT> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x72( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::MHT,std::allocator<pat::MHT> >")), ::Reflex::BaseOffset< ::std::vector<pat::MHT>,::std::_Vector_base<pat::MHT,std::allocator<pat::MHT> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x73( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::MHT> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::MHT> >::Generate();
}

//------Dictionary for class vector<pat::MHT,std::allocator<pat::MHT> > -------------------------------
void __std__vector_pat__MHT__db_datamem(Reflex::Class*);
void __std__vector_pat__MHT__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__MHT__datamem_bld(&__std__vector_pat__MHT__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__MHT__funcmem_bld(&__std__vector_pat__MHT__db_funcmem);
void __std__vector_pat__MHT__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::MHT>"), typeid(::std::vector<pat::MHT>), sizeof(::std::vector<pat::MHT>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2829, ::Reflex::BaseOffset< ::std::vector<pat::MHT>, ::std::_Vector_base<pat::MHT,std::allocator<pat::MHT> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13575, Reflex::Literal("std::vector<pat::MHT>::_Alloc_value_type"))
  .AddTypedef(type_2829, Reflex::Literal("std::vector<pat::MHT>::_Base"))
  .AddTypedef(type_3879, Reflex::Literal("std::vector<pat::MHT>::_Tp_alloc_type"))
  .AddTypedef(type_12361, Reflex::Literal("std::vector<pat::MHT>::_Alloc_traits"))
  .AddTypedef(type_13575, Reflex::Literal("std::vector<pat::MHT>::value_type"))
  .AddTypedef(type_14406, Reflex::Literal("std::vector<pat::MHT>::pointer"))
  .AddTypedef(type_17773, Reflex::Literal("std::vector<pat::MHT>::const_pointer"))
  .AddTypedef(type_21454, Reflex::Literal("std::vector<pat::MHT>::reference"))
  .AddTypedef(type_17775, Reflex::Literal("std::vector<pat::MHT>::const_reference"))
  .AddTypedef(type_11973, Reflex::Literal("std::vector<pat::MHT>::iterator"))
  .AddTypedef(type_11972, Reflex::Literal("std::vector<pat::MHT>::const_iterator"))
  .AddTypedef(type_4292, Reflex::Literal("std::vector<pat::MHT>::const_reverse_iterator"))
  .AddTypedef(type_4293, Reflex::Literal("std::vector<pat::MHT>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::MHT>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::MHT>::difference_type"))
  .AddTypedef(type_3879, Reflex::Literal("std::vector<pat::MHT>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_21464, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62374), Reflex::Literal("vector"), constructor_21465, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_17775, type_62374), Reflex::Literal("vector"), constructor_21466, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_65096), Reflex::Literal("vector"), constructor_21467, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_21468, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3521, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x72, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x73, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__MHT__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::MHT,std::allocator<pat::MHT> > -------------------
void __std__vector_pat__MHT__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::MHT,std::allocator<pat::MHT> > -------------------
void __std__vector_pat__MHT__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65097, type_65096), Reflex::Literal("operator="), operator_21469, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_17775), Reflex::Literal("assign"), method_21470, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11973), Reflex::Literal("begin"), method_21471, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11972), Reflex::Literal("begin"), method_21472, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11973), Reflex::Literal("end"), method_21473, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11972), Reflex::Literal("end"), method_21474, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_21479, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_21480, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_13575), Reflex::Literal("resize"), method_21481, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_21482, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_21483, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_21484, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21454, type_3845), Reflex::Literal("operator[]"), operator_21485, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17775, type_3845), Reflex::Literal("operator[]"), operator_21486, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21454, type_3845), Reflex::Literal("at"), method_21488, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17775, type_3845), Reflex::Literal("at"), method_21489, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21454), Reflex::Literal("front"), method_21490, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17775), Reflex::Literal("front"), method_21491, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21454), Reflex::Literal("back"), method_21492, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17775), Reflex::Literal("back"), method_21493, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14406), Reflex::Literal("data"), method_21494, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17773), Reflex::Literal("data"), method_21495, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17775), Reflex::Literal("push_back"), method_21496, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_21497, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11973, type_11973, type_17775), Reflex::Literal("insert"), method_21498, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_11973, type_3845, type_17775), Reflex::Literal("insert"), method_21499, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11973, type_11973), Reflex::Literal("erase"), method_21500, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11973, type_11973, type_11973), Reflex::Literal("erase"), method_21501, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65097), Reflex::Literal("swap"), method_21502, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_21503, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PackedMETUncertainty -------------------------------
static void destructor_65145(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::MET::PackedMETUncertainty*)o)->::pat::MET::PackedMETUncertainty::~PackedMETUncertainty)();
}
static  void operator_65146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::MET::PackedMETUncertainty*)o)->operator=)(*(const ::pat::MET::PackedMETUncertainty*)arg[0]);
  else   (((::pat::MET::PackedMETUncertainty*)o)->operator=)(*(const ::pat::MET::PackedMETUncertainty*)arg[0]);
}

static void constructor_65147( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::MET::PackedMETUncertainty(*(const ::pat::MET::PackedMETUncertainty*)arg[0]);
  else ::new(mem) ::pat::MET::PackedMETUncertainty(*(const ::pat::MET::PackedMETUncertainty*)arg[0]);
}

static void constructor_65148( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::MET::PackedMETUncertainty();
  else ::new(mem) ::pat::MET::PackedMETUncertainty();
}

static void constructor_65149( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::MET::PackedMETUncertainty(*(float*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2]);
  else ::new(mem) ::pat::MET::PackedMETUncertainty(*(float*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2]);
}

static  void method_65150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET::PackedMETUncertainty*)o)->dpx)());
  else   (((const ::pat::MET::PackedMETUncertainty*)o)->dpx)();
}

static  void method_65151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET::PackedMETUncertainty*)o)->dpy)());
  else   (((const ::pat::MET::PackedMETUncertainty*)o)->dpy)();
}

static  void method_65152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::MET::PackedMETUncertainty*)o)->dsumEt)());
  else   (((const ::pat::MET::PackedMETUncertainty*)o)->dsumEt)();
}

static  void method_65153( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::MET::PackedMETUncertainty*)o)->set)(*(float*)arg[0],
    *(float*)arg[1],
    *(float*)arg[2]);
}

static void method_newdel_22727( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::MET::PackedMETUncertainty >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::MET::PackedMETUncertainty >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::MET::PackedMETUncertainty >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::MET::PackedMETUncertainty >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::MET::PackedMETUncertainty >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PackedMETUncertainty -------------------------------
void __pat__MET__PackedMETUncertainty_db_datamem(Reflex::Class*);
void __pat__MET__PackedMETUncertainty_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__MET__PackedMETUncertainty_datamem_bld(&__pat__MET__PackedMETUncertainty_db_datamem);
Reflex::GenreflexMemberBuilder __pat__MET__PackedMETUncertainty_funcmem_bld(&__pat__MET__PackedMETUncertainty_db_funcmem);
void __pat__MET__PackedMETUncertainty_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::MET::PackedMETUncertainty"), typeid(::pat::MET::PackedMETUncertainty), sizeof(::pat::MET::PackedMETUncertainty), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PackedMETUncertainty"), destructor_65145, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22736, type_22738), Reflex::Literal("operator="), operator_65146, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22738), Reflex::Literal("PackedMETUncertainty"), constructor_65147, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PackedMETUncertainty"), constructor_65148, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_990, type_990, type_990), Reflex::Literal("PackedMETUncertainty"), constructor_65149, 0, "dpx;dpy;dsumEt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_22727, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__MET__PackedMETUncertainty_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__MET__PackedMETUncertainty_funcmem_bld);
}

//------Delayed data member builder for class PackedMETUncertainty -------------------
void __pat__MET__PackedMETUncertainty_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_990, Reflex::Literal("dpx_"), OffsetOf(__shadow__::__pat__MET__PackedMETUncertainty, dpx_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("dpy_"), OffsetOf(__shadow__::__pat__MET__PackedMETUncertainty, dpy_), ::Reflex::PROTECTED)
  .AddDataMember(type_990, Reflex::Literal("dsumEt_"), OffsetOf(__shadow__::__pat__MET__PackedMETUncertainty, dsumEt_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class PackedMETUncertainty -------------------
void __pat__MET__PackedMETUncertainty_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("dpx"), method_65150, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("dpy"), method_65151, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("dsumEt"), method_65152, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990, type_990, type_990), Reflex::Literal("set"), method_65153, 0, "dpx;dpy;dsumEt", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<pat::MET::PackedMETUncertainty,std::allocator<pat::MET::PackedMETUncertainty> > -------------------------------
static void constructor_22747( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MET::PackedMETUncertainty>();
  else ::new(mem) ::std::vector<pat::MET::PackedMETUncertainty>();
}

static void constructor_22748( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MET::PackedMETUncertainty>(*(const ::std::allocator<pat::MET::PackedMETUncertainty>*)arg[0]);
  else ::new(mem) ::std::vector<pat::MET::PackedMETUncertainty>(*(const ::std::allocator<pat::MET::PackedMETUncertainty>*)arg[0]);
}

static void constructor_22749( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MET::PackedMETUncertainty>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::MET::PackedMETUncertainty>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MET::PackedMETUncertainty>(*(::std::size_t*)arg[0],
      *(const ::pat::MET::PackedMETUncertainty*)arg[1]);
  else ::new(mem) ::std::vector<pat::MET::PackedMETUncertainty>(*(::std::size_t*)arg[0],
      *(const ::pat::MET::PackedMETUncertainty*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MET::PackedMETUncertainty>(*(::std::size_t*)arg[0],
      *(const ::pat::MET::PackedMETUncertainty*)arg[1],
      *(const ::std::allocator<pat::MET::PackedMETUncertainty>*)arg[2]);
  else ::new(mem) ::std::vector<pat::MET::PackedMETUncertainty>(*(::std::size_t*)arg[0],
      *(const ::pat::MET::PackedMETUncertainty*)arg[1],
      *(const ::std::allocator<pat::MET::PackedMETUncertainty>*)arg[2]);
  }
}

static void constructor_22750( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::MET::PackedMETUncertainty>(*(const ::std::vector<pat::MET::PackedMETUncertainty>*)arg[0]);
  else ::new(mem) ::std::vector<pat::MET::PackedMETUncertainty>(*(const ::std::vector<pat::MET::PackedMETUncertainty>*)arg[0]);
}

static void destructor_22751(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::MET::PackedMETUncertainty>*)o)->::std::vector<pat::MET::PackedMETUncertainty>::~vector)();
}
static  void operator_22752( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::MET::PackedMETUncertainty>*)o)->operator=)(*(const ::std::vector<pat::MET::PackedMETUncertainty>*)arg[0]);
  else   (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->operator=)(*(const ::std::vector<pat::MET::PackedMETUncertainty>*)arg[0]);
}

static  void method_22753( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::MET::PackedMETUncertainty*)arg[1]);
}

static  void method_22754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >)((((::std::vector<pat::MET::PackedMETUncertainty>*)o)->begin)());
  else   (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->begin)();
}

static  void method_22755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >)((((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->begin)());
  else   (((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->begin)();
}

static  void method_22756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >)((((::std::vector<pat::MET::PackedMETUncertainty>*)o)->end)());
  else   (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->end)();
}

static  void method_22757( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >)((((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->end)());
  else   (((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->end)();
}

static  void method_22762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->size)());
  else   (((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->size)();
}

static  void method_22763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->max_size)());
  else   (((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->max_size)();
}

static  void method_22764( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::MET::PackedMETUncertainty*)arg[1]);
  }
}

static  void method_22765( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->capacity)());
  else   (((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->capacity)();
}

static  void method_22766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->empty)());
  else   (((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->empty)();
}

static  void method_22767( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_22768( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::MET::PackedMETUncertainty>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_22769( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_22771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::MET::PackedMETUncertainty>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_22772( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_22773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::MET::PackedMETUncertainty>*)o)->front)();
  else   (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->front)();
}

static  void method_22774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->front)();
  else   (((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->front)();
}

static  void method_22775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::MET::PackedMETUncertainty>*)o)->back)();
  else   (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->back)();
}

static  void method_22776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->back)();
  else   (((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->back)();
}

static  void method_22777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::MET::PackedMETUncertainty>*)o)->data)());
  else   (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->data)();
}

static  void method_22778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->data)());
  else   (((const ::std::vector<pat::MET::PackedMETUncertainty>*)o)->data)();
}

static  void method_22779( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->push_back)(*(const ::pat::MET::PackedMETUncertainty*)arg[0]);
}

static  void method_22780( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->pop_back)();
}

static  void method_22781( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >)((((::std::vector<pat::MET::PackedMETUncertainty>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >*)arg[0],
    *(const ::pat::MET::PackedMETUncertainty*)arg[1]));
  else   (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >*)arg[0],
    *(const ::pat::MET::PackedMETUncertainty*)arg[1]);
}

static  void method_22782( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::MET::PackedMETUncertainty*)arg[2]);
}

static  void method_22783( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >)((((::std::vector<pat::MET::PackedMETUncertainty>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >*)arg[0]));
  else   (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >*)arg[0]);
}

static  void method_22784( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >)((((::std::vector<pat::MET::PackedMETUncertainty>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >*)arg[1]));
  else   (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::MET::PackedMETUncertainty*,std::vector<pat::MET::PackedMETUncertainty> >*)arg[1]);
}

static  void method_22785( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->swap)(*(::std::vector<pat::MET::PackedMETUncertainty>*)arg[0]);
}

static  void method_22786( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::MET::PackedMETUncertainty>*)o)->clear)();
}

static void method_newdel_3541( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::MET::PackedMETUncertainty> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::MET::PackedMETUncertainty> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::MET::PackedMETUncertainty> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::MET::PackedMETUncertainty> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::MET::PackedMETUncertainty> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x76( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::MET::PackedMETUncertainty,std::allocator<pat::MET::PackedMETUncertainty> >")), ::Reflex::BaseOffset< ::std::vector<pat::MET::PackedMETUncertainty>,::std::_Vector_base<pat::MET::PackedMETUncertainty,std::allocator<pat::MET::PackedMETUncertainty> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x77( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::MET::PackedMETUncertainty> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::MET::PackedMETUncertainty> >::Generate();
}

//------Dictionary for class vector<pat::MET::PackedMETUncertainty,std::allocator<pat::MET::PackedMETUncertainty> > -------------------------------
void __std__vector_pat__MET__PackedMETUncertainty__db_datamem(Reflex::Class*);
void __std__vector_pat__MET__PackedMETUncertainty__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__MET__PackedMETUncertainty__datamem_bld(&__std__vector_pat__MET__PackedMETUncertainty__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__MET__PackedMETUncertainty__funcmem_bld(&__std__vector_pat__MET__PackedMETUncertainty__db_funcmem);
void __std__vector_pat__MET__PackedMETUncertainty__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>"), typeid(::std::vector<pat::MET::PackedMETUncertainty>), sizeof(::std::vector<pat::MET::PackedMETUncertainty>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2839, ::Reflex::BaseOffset< ::std::vector<pat::MET::PackedMETUncertainty>, ::std::_Vector_base<pat::MET::PackedMETUncertainty,std::allocator<pat::MET::PackedMETUncertainty> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_22727, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::_Alloc_value_type"))
  .AddTypedef(type_2839, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::_Base"))
  .AddTypedef(type_3894, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::_Tp_alloc_type"))
  .AddTypedef(type_12371, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::_Alloc_traits"))
  .AddTypedef(type_22727, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::value_type"))
  .AddTypedef(type_14596, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::pointer"))
  .AddTypedef(type_22734, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::const_pointer"))
  .AddTypedef(type_22736, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::reference"))
  .AddTypedef(type_22738, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::const_reference"))
  .AddTypedef(type_11993, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::iterator"))
  .AddTypedef(type_11994, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::const_iterator"))
  .AddTypedef(type_4312, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::const_reverse_iterator"))
  .AddTypedef(type_4313, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::difference_type"))
  .AddTypedef(type_3894, Reflex::Literal("std::vector<pat::MET::PackedMETUncertainty>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_22747, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62504), Reflex::Literal("vector"), constructor_22748, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_22738, type_62504), Reflex::Literal("vector"), constructor_22749, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_65155), Reflex::Literal("vector"), constructor_22750, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_22751, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3541, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x76, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x77, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__MET__PackedMETUncertainty__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::MET::PackedMETUncertainty,std::allocator<pat::MET::PackedMETUncertainty> > -------------------
void __std__vector_pat__MET__PackedMETUncertainty__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::MET::PackedMETUncertainty,std::allocator<pat::MET::PackedMETUncertainty> > -------------------
void __std__vector_pat__MET__PackedMETUncertainty__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65156, type_65155), Reflex::Literal("operator="), operator_22752, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_22738), Reflex::Literal("assign"), method_22753, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11993), Reflex::Literal("begin"), method_22754, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11994), Reflex::Literal("begin"), method_22755, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11993), Reflex::Literal("end"), method_22756, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11994), Reflex::Literal("end"), method_22757, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_22762, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_22763, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_22727), Reflex::Literal("resize"), method_22764, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_22765, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_22766, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_22767, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22736, type_3845), Reflex::Literal("operator[]"), operator_22768, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22738, type_3845), Reflex::Literal("operator[]"), operator_22769, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22736, type_3845), Reflex::Literal("at"), method_22771, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22738, type_3845), Reflex::Literal("at"), method_22772, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22736), Reflex::Literal("front"), method_22773, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22738), Reflex::Literal("front"), method_22774, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22736), Reflex::Literal("back"), method_22775, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22738), Reflex::Literal("back"), method_22776, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14596), Reflex::Literal("data"), method_22777, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22734), Reflex::Literal("data"), method_22778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22738), Reflex::Literal("push_back"), method_22779, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_22780, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11993, type_11993, type_22738), Reflex::Literal("insert"), method_22781, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_11993, type_3845, type_22738), Reflex::Literal("insert"), method_22782, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11993, type_11993), Reflex::Literal("erase"), method_22783, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11993, type_11993, type_11993), Reflex::Literal("erase"), method_22784, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65156), Reflex::Literal("swap"), method_22785, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_22786, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class TauPFSpecific -------------------------------
static void destructor_65343(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::tau::TauPFSpecific*)o)->::pat::tau::TauPFSpecific::~TauPFSpecific)();
}
static  void operator_65344( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::tau::TauPFSpecific*)o)->operator=)(*(const ::pat::tau::TauPFSpecific*)arg[0]);
  else   (((::pat::tau::TauPFSpecific*)o)->operator=)(*(const ::pat::tau::TauPFSpecific*)arg[0]);
}

static void constructor_65345( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::tau::TauPFSpecific(*(const ::pat::tau::TauPFSpecific*)arg[0]);
  else ::new(mem) ::pat::tau::TauPFSpecific(*(const ::pat::tau::TauPFSpecific*)arg[0]);
}

static void constructor_65346( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::tau::TauPFSpecific();
  else ::new(mem) ::pat::tau::TauPFSpecific();
}

static void constructor_65347( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::tau::TauPFSpecific(*(const ::reco::PFTau*)arg[0]);
  else ::new(mem) ::pat::tau::TauPFSpecific(*(const ::reco::PFTau*)arg[0]);
}

static void method_newdel_25966( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::tau::TauPFSpecific >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::tau::TauPFSpecific >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::tau::TauPFSpecific >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::tau::TauPFSpecific >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::tau::TauPFSpecific >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TauPFSpecific -------------------------------
void __pat__tau__TauPFSpecific_db_datamem(Reflex::Class*);
void __pat__tau__TauPFSpecific_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__tau__TauPFSpecific_datamem_bld(&__pat__tau__TauPFSpecific_db_datamem);
Reflex::GenreflexMemberBuilder __pat__tau__TauPFSpecific_funcmem_bld(&__pat__tau__TauPFSpecific_db_funcmem);
void __pat__tau__TauPFSpecific_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::tau::TauPFSpecific"), typeid(::pat::tau::TauPFSpecific), sizeof(::pat::tau::TauPFSpecific), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "14")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TauPFSpecific"), destructor_65343, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25975, type_25977), Reflex::Literal("operator="), operator_65344, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25977), Reflex::Literal("TauPFSpecific"), constructor_65345, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TauPFSpecific"), constructor_65346, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26824), Reflex::Literal("TauPFSpecific"), constructor_65347, 0, "tau", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_25966, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__tau__TauPFSpecific_datamem_bld);
}

//------Delayed data member builder for class TauPFSpecific -------------------
void __pat__tau__TauPFSpecific_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_11513, Reflex::Literal("pfJetRef_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, pfJetRef_), ::Reflex::PUBLIC)
  .AddDataMember(type_11263, Reflex::Literal("leadPFChargedHadrCand_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, leadPFChargedHadrCand_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("leadPFChargedHadrCandsignedSipt_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, leadPFChargedHadrCandsignedSipt_), ::Reflex::PUBLIC)
  .AddDataMember(type_11263, Reflex::Literal("leadPFNeutralCand_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, leadPFNeutralCand_), ::Reflex::PUBLIC)
  .AddDataMember(type_11263, Reflex::Literal("leadPFCand_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, leadPFCand_), ::Reflex::PUBLIC)
  .AddDataMember(type_3557, Reflex::Literal("selectedSignalPFCands_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, selectedSignalPFCands_), ::Reflex::PUBLIC)
  .AddDataMember(type_3557, Reflex::Literal("selectedSignalPFChargedHadrCands_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, selectedSignalPFChargedHadrCands_), ::Reflex::PUBLIC)
  .AddDataMember(type_3557, Reflex::Literal("selectedSignalPFNeutrHadrCands_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, selectedSignalPFNeutrHadrCands_), ::Reflex::PUBLIC)
  .AddDataMember(type_3557, Reflex::Literal("selectedSignalPFGammaCands_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, selectedSignalPFGammaCands_), ::Reflex::PUBLIC)
  .AddDataMember(type_3601, Reflex::Literal("signalTauChargedHadronCandidates_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, signalTauChargedHadronCandidates_), ::Reflex::PUBLIC)
  .AddDataMember(type_3600, Reflex::Literal("signalPiZeroCandidates_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, signalPiZeroCandidates_), ::Reflex::PUBLIC)
  .AddDataMember(type_3557, Reflex::Literal("selectedIsolationPFCands_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, selectedIsolationPFCands_), ::Reflex::PUBLIC)
  .AddDataMember(type_3557, Reflex::Literal("selectedIsolationPFChargedHadrCands_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, selectedIsolationPFChargedHadrCands_), ::Reflex::PUBLIC)
  .AddDataMember(type_3557, Reflex::Literal("selectedIsolationPFNeutrHadrCands_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, selectedIsolationPFNeutrHadrCands_), ::Reflex::PUBLIC)
  .AddDataMember(type_3557, Reflex::Literal("selectedIsolationPFGammaCands_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, selectedIsolationPFGammaCands_), ::Reflex::PUBLIC)
  .AddDataMember(type_3601, Reflex::Literal("isolationTauChargedHadronCandidates_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, isolationTauChargedHadronCandidates_), ::Reflex::PUBLIC)
  .AddDataMember(type_3600, Reflex::Literal("isolationPiZeroCandidates_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, isolationPiZeroCandidates_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("isolationPFChargedHadrCandsPtSum_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, isolationPFChargedHadrCandsPtSum_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("isolationPFGammaCandsEtSum_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, isolationPFGammaCandsEtSum_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("maximumHCALPFClusterEt_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, maximumHCALPFClusterEt_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("emFraction_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, emFraction_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("hcalTotOverPLead_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, hcalTotOverPLead_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("hcalMaxOverPLead_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, hcalMaxOverPLead_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("hcal3x3OverPLead_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, hcal3x3OverPLead_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("ecalStripSumEOverPLead_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, ecalStripSumEOverPLead_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("bremsRecoveryEOverPLead_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, bremsRecoveryEOverPLead_), ::Reflex::PUBLIC)
  .AddDataMember(type_11589, Reflex::Literal("electronPreIDTrack_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, electronPreIDTrack_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("electronPreIDOutput_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, electronPreIDOutput_), ::Reflex::PUBLIC)
  .AddDataMember(type_1810, Reflex::Literal("electronPreIDDecision_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, electronPreIDDecision_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("caloComp_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, caloComp_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("segComp_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, segComp_), ::Reflex::PUBLIC)
  .AddDataMember(type_1810, Reflex::Literal("muonDecision_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, muonDecision_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("etaetaMoment_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, etaetaMoment_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("phiphiMoment_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, phiphiMoment_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("etaphiMoment_"), OffsetOf(__shadow__::__pat__tau__TauPFSpecific, etaphiMoment_), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class TauPFSpecific -------------------
void __pat__tau__TauPFSpecific_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<pat::tau::TauPFSpecific,std::allocator<pat::tau::TauPFSpecific> > -------------------------------
static void constructor_25986( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauPFSpecific>();
  else ::new(mem) ::std::vector<pat::tau::TauPFSpecific>();
}

static void constructor_25987( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauPFSpecific>(*(const ::std::allocator<pat::tau::TauPFSpecific>*)arg[0]);
  else ::new(mem) ::std::vector<pat::tau::TauPFSpecific>(*(const ::std::allocator<pat::tau::TauPFSpecific>*)arg[0]);
}

static void constructor_25988( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauPFSpecific>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::tau::TauPFSpecific>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauPFSpecific>(*(::std::size_t*)arg[0],
      *(const ::pat::tau::TauPFSpecific*)arg[1]);
  else ::new(mem) ::std::vector<pat::tau::TauPFSpecific>(*(::std::size_t*)arg[0],
      *(const ::pat::tau::TauPFSpecific*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauPFSpecific>(*(::std::size_t*)arg[0],
      *(const ::pat::tau::TauPFSpecific*)arg[1],
      *(const ::std::allocator<pat::tau::TauPFSpecific>*)arg[2]);
  else ::new(mem) ::std::vector<pat::tau::TauPFSpecific>(*(::std::size_t*)arg[0],
      *(const ::pat::tau::TauPFSpecific*)arg[1],
      *(const ::std::allocator<pat::tau::TauPFSpecific>*)arg[2]);
  }
}

static void constructor_25989( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauPFSpecific>(*(const ::std::vector<pat::tau::TauPFSpecific>*)arg[0]);
  else ::new(mem) ::std::vector<pat::tau::TauPFSpecific>(*(const ::std::vector<pat::tau::TauPFSpecific>*)arg[0]);
}

static void destructor_25990(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::tau::TauPFSpecific>*)o)->::std::vector<pat::tau::TauPFSpecific>::~vector)();
}
static  void operator_25991( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::tau::TauPFSpecific>*)o)->operator=)(*(const ::std::vector<pat::tau::TauPFSpecific>*)arg[0]);
  else   (((::std::vector<pat::tau::TauPFSpecific>*)o)->operator=)(*(const ::std::vector<pat::tau::TauPFSpecific>*)arg[0]);
}

static  void method_25992( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::tau::TauPFSpecific>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::tau::TauPFSpecific*)arg[1]);
}

static  void method_25993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >)((((::std::vector<pat::tau::TauPFSpecific>*)o)->begin)());
  else   (((::std::vector<pat::tau::TauPFSpecific>*)o)->begin)();
}

static  void method_25994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >)((((const ::std::vector<pat::tau::TauPFSpecific>*)o)->begin)());
  else   (((const ::std::vector<pat::tau::TauPFSpecific>*)o)->begin)();
}

static  void method_25995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >)((((::std::vector<pat::tau::TauPFSpecific>*)o)->end)());
  else   (((::std::vector<pat::tau::TauPFSpecific>*)o)->end)();
}

static  void method_25996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >)((((const ::std::vector<pat::tau::TauPFSpecific>*)o)->end)());
  else   (((const ::std::vector<pat::tau::TauPFSpecific>*)o)->end)();
}

static  void method_26001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::tau::TauPFSpecific>*)o)->size)());
  else   (((const ::std::vector<pat::tau::TauPFSpecific>*)o)->size)();
}

static  void method_26002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::tau::TauPFSpecific>*)o)->max_size)());
  else   (((const ::std::vector<pat::tau::TauPFSpecific>*)o)->max_size)();
}

static  void method_26003( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::tau::TauPFSpecific>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::tau::TauPFSpecific>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::tau::TauPFSpecific*)arg[1]);
  }
}

static  void method_26004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::tau::TauPFSpecific>*)o)->capacity)());
  else   (((const ::std::vector<pat::tau::TauPFSpecific>*)o)->capacity)();
}

static  void method_26005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::tau::TauPFSpecific>*)o)->empty)());
  else   (((const ::std::vector<pat::tau::TauPFSpecific>*)o)->empty)();
}

static  void method_26006( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::tau::TauPFSpecific>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_26007( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::tau::TauPFSpecific>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::tau::TauPFSpecific>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_26008( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::tau::TauPFSpecific>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::tau::TauPFSpecific>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_26010( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::tau::TauPFSpecific>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::tau::TauPFSpecific>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_26011( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::tau::TauPFSpecific>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::tau::TauPFSpecific>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_26012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::tau::TauPFSpecific>*)o)->front)();
  else   (((::std::vector<pat::tau::TauPFSpecific>*)o)->front)();
}

static  void method_26013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::tau::TauPFSpecific>*)o)->front)();
  else   (((const ::std::vector<pat::tau::TauPFSpecific>*)o)->front)();
}

static  void method_26014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::tau::TauPFSpecific>*)o)->back)();
  else   (((::std::vector<pat::tau::TauPFSpecific>*)o)->back)();
}

static  void method_26015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::tau::TauPFSpecific>*)o)->back)();
  else   (((const ::std::vector<pat::tau::TauPFSpecific>*)o)->back)();
}

static  void method_26016( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::tau::TauPFSpecific>*)o)->data)());
  else   (((::std::vector<pat::tau::TauPFSpecific>*)o)->data)();
}

static  void method_26017( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::tau::TauPFSpecific>*)o)->data)());
  else   (((const ::std::vector<pat::tau::TauPFSpecific>*)o)->data)();
}

static  void method_26018( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::tau::TauPFSpecific>*)o)->push_back)(*(const ::pat::tau::TauPFSpecific*)arg[0]);
}

static  void method_26019( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::tau::TauPFSpecific>*)o)->pop_back)();
}

static  void method_26020( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >)((((::std::vector<pat::tau::TauPFSpecific>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >*)arg[0],
    *(const ::pat::tau::TauPFSpecific*)arg[1]));
  else   (((::std::vector<pat::tau::TauPFSpecific>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >*)arg[0],
    *(const ::pat::tau::TauPFSpecific*)arg[1]);
}

static  void method_26021( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::tau::TauPFSpecific>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::tau::TauPFSpecific*)arg[2]);
}

static  void method_26022( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >)((((::std::vector<pat::tau::TauPFSpecific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >*)arg[0]));
  else   (((::std::vector<pat::tau::TauPFSpecific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >*)arg[0]);
}

static  void method_26023( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >)((((::std::vector<pat::tau::TauPFSpecific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >*)arg[1]));
  else   (((::std::vector<pat::tau::TauPFSpecific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::tau::TauPFSpecific*,std::vector<pat::tau::TauPFSpecific> >*)arg[1]);
}

static  void method_26024( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::tau::TauPFSpecific>*)o)->swap)(*(::std::vector<pat::tau::TauPFSpecific>*)arg[0]);
}

static  void method_26025( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::tau::TauPFSpecific>*)o)->clear)();
}

static void method_newdel_3597( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::tau::TauPFSpecific> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::tau::TauPFSpecific> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::tau::TauPFSpecific> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::tau::TauPFSpecific> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::tau::TauPFSpecific> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x80( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::tau::TauPFSpecific,std::allocator<pat::tau::TauPFSpecific> >")), ::Reflex::BaseOffset< ::std::vector<pat::tau::TauPFSpecific>,::std::_Vector_base<pat::tau::TauPFSpecific,std::allocator<pat::tau::TauPFSpecific> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x81( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::tau::TauPFSpecific> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::tau::TauPFSpecific> >::Generate();
}

//------Dictionary for class vector<pat::tau::TauPFSpecific,std::allocator<pat::tau::TauPFSpecific> > -------------------------------
void __std__vector_pat__tau__TauPFSpecific__db_datamem(Reflex::Class*);
void __std__vector_pat__tau__TauPFSpecific__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__tau__TauPFSpecific__datamem_bld(&__std__vector_pat__tau__TauPFSpecific__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__tau__TauPFSpecific__funcmem_bld(&__std__vector_pat__tau__TauPFSpecific__db_funcmem);
void __std__vector_pat__tau__TauPFSpecific__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::tau::TauPFSpecific>"), typeid(::std::vector<pat::tau::TauPFSpecific>), sizeof(::std::vector<pat::tau::TauPFSpecific>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2885, ::Reflex::BaseOffset< ::std::vector<pat::tau::TauPFSpecific>, ::std::_Vector_base<pat::tau::TauPFSpecific,std::allocator<pat::tau::TauPFSpecific> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_25966, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::_Alloc_value_type"))
  .AddTypedef(type_2885, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::_Base"))
  .AddTypedef(type_3954, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::_Tp_alloc_type"))
  .AddTypedef(type_12417, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::_Alloc_traits"))
  .AddTypedef(type_25966, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::value_type"))
  .AddTypedef(type_15469, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::pointer"))
  .AddTypedef(type_25973, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::const_pointer"))
  .AddTypedef(type_25975, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::reference"))
  .AddTypedef(type_25977, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::const_reference"))
  .AddTypedef(type_12083, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::iterator"))
  .AddTypedef(type_12084, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::const_iterator"))
  .AddTypedef(type_4404, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::const_reverse_iterator"))
  .AddTypedef(type_4405, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::difference_type"))
  .AddTypedef(type_3954, Reflex::Literal("std::vector<pat::tau::TauPFSpecific>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_25986, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63101), Reflex::Literal("vector"), constructor_25987, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_25977, type_63101), Reflex::Literal("vector"), constructor_25988, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_65349), Reflex::Literal("vector"), constructor_25989, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_25990, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3597, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x80, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x81, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__tau__TauPFSpecific__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::tau::TauPFSpecific,std::allocator<pat::tau::TauPFSpecific> > -------------------
void __std__vector_pat__tau__TauPFSpecific__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::tau::TauPFSpecific,std::allocator<pat::tau::TauPFSpecific> > -------------------
void __std__vector_pat__tau__TauPFSpecific__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65350, type_65349), Reflex::Literal("operator="), operator_25991, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_25977), Reflex::Literal("assign"), method_25992, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12083), Reflex::Literal("begin"), method_25993, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12084), Reflex::Literal("begin"), method_25994, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12083), Reflex::Literal("end"), method_25995, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12084), Reflex::Literal("end"), method_25996, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_26001, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_26002, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_25966), Reflex::Literal("resize"), method_26003, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_26004, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_26005, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_26006, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25975, type_3845), Reflex::Literal("operator[]"), operator_26007, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25977, type_3845), Reflex::Literal("operator[]"), operator_26008, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25975, type_3845), Reflex::Literal("at"), method_26010, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25977, type_3845), Reflex::Literal("at"), method_26011, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25975), Reflex::Literal("front"), method_26012, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25977), Reflex::Literal("front"), method_26013, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25975), Reflex::Literal("back"), method_26014, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25977), Reflex::Literal("back"), method_26015, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15469), Reflex::Literal("data"), method_26016, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25973), Reflex::Literal("data"), method_26017, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_25977), Reflex::Literal("push_back"), method_26018, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_26019, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12083, type_12083, type_25977), Reflex::Literal("insert"), method_26020, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_12083, type_3845, type_25977), Reflex::Literal("insert"), method_26021, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12083, type_12083), Reflex::Literal("erase"), method_26022, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12083, type_12083, type_12083), Reflex::Literal("erase"), method_26023, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65350), Reflex::Literal("swap"), method_26024, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_26025, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class TauCaloSpecific -------------------------------
static void destructor_65364(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::tau::TauCaloSpecific*)o)->::pat::tau::TauCaloSpecific::~TauCaloSpecific)();
}
static  void operator_65365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::tau::TauCaloSpecific*)o)->operator=)(*(const ::pat::tau::TauCaloSpecific*)arg[0]);
  else   (((::pat::tau::TauCaloSpecific*)o)->operator=)(*(const ::pat::tau::TauCaloSpecific*)arg[0]);
}

static void constructor_65366( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::tau::TauCaloSpecific(*(const ::pat::tau::TauCaloSpecific*)arg[0]);
  else ::new(mem) ::pat::tau::TauCaloSpecific(*(const ::pat::tau::TauCaloSpecific*)arg[0]);
}

static void constructor_65367( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::tau::TauCaloSpecific();
  else ::new(mem) ::pat::tau::TauCaloSpecific();
}

static void constructor_65368( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::tau::TauCaloSpecific(*(const ::reco::CaloTau*)arg[0]);
  else ::new(mem) ::pat::tau::TauCaloSpecific(*(const ::reco::CaloTau*)arg[0]);
}

static void method_newdel_26032( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::tau::TauCaloSpecific >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::tau::TauCaloSpecific >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::tau::TauCaloSpecific >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::tau::TauCaloSpecific >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::tau::TauCaloSpecific >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TauCaloSpecific -------------------------------
void __pat__tau__TauCaloSpecific_db_datamem(Reflex::Class*);
void __pat__tau__TauCaloSpecific_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__tau__TauCaloSpecific_datamem_bld(&__pat__tau__TauCaloSpecific_db_datamem);
Reflex::GenreflexMemberBuilder __pat__tau__TauCaloSpecific_funcmem_bld(&__pat__tau__TauCaloSpecific_db_funcmem);
void __pat__tau__TauCaloSpecific_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::tau::TauCaloSpecific"), typeid(::pat::tau::TauCaloSpecific), sizeof(::pat::tau::TauCaloSpecific), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "11")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TauCaloSpecific"), destructor_65364, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26041, type_26043), Reflex::Literal("operator="), operator_65365, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26043), Reflex::Literal("TauCaloSpecific"), constructor_65366, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TauCaloSpecific"), constructor_65367, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26564), Reflex::Literal("TauCaloSpecific"), constructor_65368, 0, "tau", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_26032, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__tau__TauCaloSpecific_datamem_bld);
}

//------Delayed data member builder for class TauCaloSpecific -------------------
void __pat__tau__TauCaloSpecific_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_11425, Reflex::Literal("CaloTauTagInfoRef_"), OffsetOf(__shadow__::__pat__tau__TauCaloSpecific, CaloTauTagInfoRef_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("leadTracksignedSipt_"), OffsetOf(__shadow__::__pat__tau__TauCaloSpecific, leadTracksignedSipt_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("leadTrackHCAL3x3hitsEtSum_"), OffsetOf(__shadow__::__pat__tau__TauCaloSpecific, leadTrackHCAL3x3hitsEtSum_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("leadTrackHCAL3x3hottesthitDEta_"), OffsetOf(__shadow__::__pat__tau__TauCaloSpecific, leadTrackHCAL3x3hottesthitDEta_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("signalTracksInvariantMass_"), OffsetOf(__shadow__::__pat__tau__TauCaloSpecific, signalTracksInvariantMass_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("TracksInvariantMass_"), OffsetOf(__shadow__::__pat__tau__TauCaloSpecific, TracksInvariantMass_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("isolationTracksPtSum_"), OffsetOf(__shadow__::__pat__tau__TauCaloSpecific, isolationTracksPtSum_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("isolationECALhitsEtSum_"), OffsetOf(__shadow__::__pat__tau__TauCaloSpecific, isolationECALhitsEtSum_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("maximumHCALhitEt_"), OffsetOf(__shadow__::__pat__tau__TauCaloSpecific, maximumHCALhitEt_), ::Reflex::PUBLIC)
  .AddDataMember(type_10223, Reflex::Literal("p4Jet_"), OffsetOf(__shadow__::__pat__tau__TauCaloSpecific, p4Jet_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("etaetaMoment_"), OffsetOf(__shadow__::__pat__tau__TauCaloSpecific, etaetaMoment_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("phiphiMoment_"), OffsetOf(__shadow__::__pat__tau__TauCaloSpecific, phiphiMoment_), ::Reflex::PUBLIC)
  .AddDataMember(type_990, Reflex::Literal("etaphiMoment_"), OffsetOf(__shadow__::__pat__tau__TauCaloSpecific, etaphiMoment_), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class TauCaloSpecific -------------------
void __pat__tau__TauCaloSpecific_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<pat::tau::TauCaloSpecific,std::allocator<pat::tau::TauCaloSpecific> > -------------------------------
static void constructor_26052( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauCaloSpecific>();
  else ::new(mem) ::std::vector<pat::tau::TauCaloSpecific>();
}

static void constructor_26053( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauCaloSpecific>(*(const ::std::allocator<pat::tau::TauCaloSpecific>*)arg[0]);
  else ::new(mem) ::std::vector<pat::tau::TauCaloSpecific>(*(const ::std::allocator<pat::tau::TauCaloSpecific>*)arg[0]);
}

static void constructor_26054( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauCaloSpecific>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::tau::TauCaloSpecific>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauCaloSpecific>(*(::std::size_t*)arg[0],
      *(const ::pat::tau::TauCaloSpecific*)arg[1]);
  else ::new(mem) ::std::vector<pat::tau::TauCaloSpecific>(*(::std::size_t*)arg[0],
      *(const ::pat::tau::TauCaloSpecific*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauCaloSpecific>(*(::std::size_t*)arg[0],
      *(const ::pat::tau::TauCaloSpecific*)arg[1],
      *(const ::std::allocator<pat::tau::TauCaloSpecific>*)arg[2]);
  else ::new(mem) ::std::vector<pat::tau::TauCaloSpecific>(*(::std::size_t*)arg[0],
      *(const ::pat::tau::TauCaloSpecific*)arg[1],
      *(const ::std::allocator<pat::tau::TauCaloSpecific>*)arg[2]);
  }
}

static void constructor_26055( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauCaloSpecific>(*(const ::std::vector<pat::tau::TauCaloSpecific>*)arg[0]);
  else ::new(mem) ::std::vector<pat::tau::TauCaloSpecific>(*(const ::std::vector<pat::tau::TauCaloSpecific>*)arg[0]);
}

static void destructor_26056(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::tau::TauCaloSpecific>*)o)->::std::vector<pat::tau::TauCaloSpecific>::~vector)();
}
static  void operator_26057( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::tau::TauCaloSpecific>*)o)->operator=)(*(const ::std::vector<pat::tau::TauCaloSpecific>*)arg[0]);
  else   (((::std::vector<pat::tau::TauCaloSpecific>*)o)->operator=)(*(const ::std::vector<pat::tau::TauCaloSpecific>*)arg[0]);
}

static  void method_26058( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::tau::TauCaloSpecific>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::tau::TauCaloSpecific*)arg[1]);
}

static  void method_26059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >)((((::std::vector<pat::tau::TauCaloSpecific>*)o)->begin)());
  else   (((::std::vector<pat::tau::TauCaloSpecific>*)o)->begin)();
}

static  void method_26060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >)((((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->begin)());
  else   (((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->begin)();
}

static  void method_26061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >)((((::std::vector<pat::tau::TauCaloSpecific>*)o)->end)());
  else   (((::std::vector<pat::tau::TauCaloSpecific>*)o)->end)();
}

static  void method_26062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >)((((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->end)());
  else   (((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->end)();
}

static  void method_26067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->size)());
  else   (((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->size)();
}

static  void method_26068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->max_size)());
  else   (((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->max_size)();
}

static  void method_26069( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::tau::TauCaloSpecific>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::tau::TauCaloSpecific>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::tau::TauCaloSpecific*)arg[1]);
  }
}

static  void method_26070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->capacity)());
  else   (((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->capacity)();
}

static  void method_26071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->empty)());
  else   (((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->empty)();
}

static  void method_26072( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::tau::TauCaloSpecific>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_26073( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::tau::TauCaloSpecific>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::tau::TauCaloSpecific>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_26074( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_26076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::tau::TauCaloSpecific>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::tau::TauCaloSpecific>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_26077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_26078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::tau::TauCaloSpecific>*)o)->front)();
  else   (((::std::vector<pat::tau::TauCaloSpecific>*)o)->front)();
}

static  void method_26079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->front)();
  else   (((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->front)();
}

static  void method_26080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::tau::TauCaloSpecific>*)o)->back)();
  else   (((::std::vector<pat::tau::TauCaloSpecific>*)o)->back)();
}

static  void method_26081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->back)();
  else   (((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->back)();
}

static  void method_26082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::tau::TauCaloSpecific>*)o)->data)());
  else   (((::std::vector<pat::tau::TauCaloSpecific>*)o)->data)();
}

static  void method_26083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->data)());
  else   (((const ::std::vector<pat::tau::TauCaloSpecific>*)o)->data)();
}

static  void method_26084( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::tau::TauCaloSpecific>*)o)->push_back)(*(const ::pat::tau::TauCaloSpecific*)arg[0]);
}

static  void method_26085( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::tau::TauCaloSpecific>*)o)->pop_back)();
}

static  void method_26086( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >)((((::std::vector<pat::tau::TauCaloSpecific>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >*)arg[0],
    *(const ::pat::tau::TauCaloSpecific*)arg[1]));
  else   (((::std::vector<pat::tau::TauCaloSpecific>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >*)arg[0],
    *(const ::pat::tau::TauCaloSpecific*)arg[1]);
}

static  void method_26087( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::tau::TauCaloSpecific>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::tau::TauCaloSpecific*)arg[2]);
}

static  void method_26088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >)((((::std::vector<pat::tau::TauCaloSpecific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >*)arg[0]));
  else   (((::std::vector<pat::tau::TauCaloSpecific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >*)arg[0]);
}

static  void method_26089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >)((((::std::vector<pat::tau::TauCaloSpecific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >*)arg[1]));
  else   (((::std::vector<pat::tau::TauCaloSpecific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::tau::TauCaloSpecific*,std::vector<pat::tau::TauCaloSpecific> >*)arg[1]);
}

static  void method_26090( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::tau::TauCaloSpecific>*)o)->swap)(*(::std::vector<pat::tau::TauCaloSpecific>*)arg[0]);
}

static  void method_26091( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::tau::TauCaloSpecific>*)o)->clear)();
}

static void method_newdel_3598( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::tau::TauCaloSpecific> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::tau::TauCaloSpecific> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::tau::TauCaloSpecific> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::tau::TauCaloSpecific> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::tau::TauCaloSpecific> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x84( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::tau::TauCaloSpecific,std::allocator<pat::tau::TauCaloSpecific> >")), ::Reflex::BaseOffset< ::std::vector<pat::tau::TauCaloSpecific>,::std::_Vector_base<pat::tau::TauCaloSpecific,std::allocator<pat::tau::TauCaloSpecific> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x85( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::tau::TauCaloSpecific> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::tau::TauCaloSpecific> >::Generate();
}

//------Dictionary for class vector<pat::tau::TauCaloSpecific,std::allocator<pat::tau::TauCaloSpecific> > -------------------------------
void __std__vector_pat__tau__TauCaloSpecific__db_datamem(Reflex::Class*);
void __std__vector_pat__tau__TauCaloSpecific__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__tau__TauCaloSpecific__datamem_bld(&__std__vector_pat__tau__TauCaloSpecific__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__tau__TauCaloSpecific__funcmem_bld(&__std__vector_pat__tau__TauCaloSpecific__db_funcmem);
void __std__vector_pat__tau__TauCaloSpecific__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>"), typeid(::std::vector<pat::tau::TauCaloSpecific>), sizeof(::std::vector<pat::tau::TauCaloSpecific>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2884, ::Reflex::BaseOffset< ::std::vector<pat::tau::TauCaloSpecific>, ::std::_Vector_base<pat::tau::TauCaloSpecific,std::allocator<pat::tau::TauCaloSpecific> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_26032, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::_Alloc_value_type"))
  .AddTypedef(type_2884, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::_Base"))
  .AddTypedef(type_3953, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::_Tp_alloc_type"))
  .AddTypedef(type_12416, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::_Alloc_traits"))
  .AddTypedef(type_26032, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::value_type"))
  .AddTypedef(type_15450, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::pointer"))
  .AddTypedef(type_26039, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::const_pointer"))
  .AddTypedef(type_26041, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::reference"))
  .AddTypedef(type_26043, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::const_reference"))
  .AddTypedef(type_12081, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::iterator"))
  .AddTypedef(type_12082, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::const_iterator"))
  .AddTypedef(type_4402, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::const_reverse_iterator"))
  .AddTypedef(type_4403, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::difference_type"))
  .AddTypedef(type_3953, Reflex::Literal("std::vector<pat::tau::TauCaloSpecific>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_26052, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63088), Reflex::Literal("vector"), constructor_26053, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_26043, type_63088), Reflex::Literal("vector"), constructor_26054, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_65370), Reflex::Literal("vector"), constructor_26055, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_26056, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3598, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x84, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x85, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__tau__TauCaloSpecific__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::tau::TauCaloSpecific,std::allocator<pat::tau::TauCaloSpecific> > -------------------
void __std__vector_pat__tau__TauCaloSpecific__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::tau::TauCaloSpecific,std::allocator<pat::tau::TauCaloSpecific> > -------------------
void __std__vector_pat__tau__TauCaloSpecific__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65371, type_65370), Reflex::Literal("operator="), operator_26057, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_26043), Reflex::Literal("assign"), method_26058, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12081), Reflex::Literal("begin"), method_26059, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12082), Reflex::Literal("begin"), method_26060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12081), Reflex::Literal("end"), method_26061, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12082), Reflex::Literal("end"), method_26062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_26067, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_26068, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_26032), Reflex::Literal("resize"), method_26069, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_26070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_26071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_26072, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26041, type_3845), Reflex::Literal("operator[]"), operator_26073, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26043, type_3845), Reflex::Literal("operator[]"), operator_26074, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26041, type_3845), Reflex::Literal("at"), method_26076, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26043, type_3845), Reflex::Literal("at"), method_26077, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26041), Reflex::Literal("front"), method_26078, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26043), Reflex::Literal("front"), method_26079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26041), Reflex::Literal("back"), method_26080, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26043), Reflex::Literal("back"), method_26081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15450), Reflex::Literal("data"), method_26082, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26039), Reflex::Literal("data"), method_26083, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_26043), Reflex::Literal("push_back"), method_26084, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_26085, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12081, type_12081, type_26043), Reflex::Literal("insert"), method_26086, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_12081, type_3845, type_26043), Reflex::Literal("insert"), method_26087, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12081, type_12081), Reflex::Literal("erase"), method_26088, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12081, type_12081, type_12081), Reflex::Literal("erase"), method_26089, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65371), Reflex::Literal("swap"), method_26090, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_26091, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class TauPFEssential -------------------------------
static void destructor_65388(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::tau::TauPFEssential*)o)->::pat::tau::TauPFEssential::~TauPFEssential)();
}
static  void operator_65389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::tau::TauPFEssential*)o)->operator=)(*(const ::pat::tau::TauPFEssential*)arg[0]);
  else   (((::pat::tau::TauPFEssential*)o)->operator=)(*(const ::pat::tau::TauPFEssential*)arg[0]);
}

static void constructor_65390( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::tau::TauPFEssential(*(const ::pat::tau::TauPFEssential*)arg[0]);
  else ::new(mem) ::pat::tau::TauPFEssential(*(const ::pat::tau::TauPFEssential*)arg[0]);
}

static void constructor_65391( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::tau::TauPFEssential();
  else ::new(mem) ::pat::tau::TauPFEssential();
}

static void constructor_65392( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::tau::TauPFEssential(*(const ::reco::PFTau*)arg[0]);
  else ::new(mem) ::pat::tau::TauPFEssential(*(const ::reco::PFTau*)arg[0]);
}

static void method_newdel_26098( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::tau::TauPFEssential >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::tau::TauPFEssential >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::tau::TauPFEssential >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::tau::TauPFEssential >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::tau::TauPFEssential >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TauPFEssential -------------------------------
void __pat__tau__TauPFEssential_db_datamem(Reflex::Class*);
void __pat__tau__TauPFEssential_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__tau__TauPFEssential_datamem_bld(&__pat__tau__TauPFEssential_db_datamem);
Reflex::GenreflexMemberBuilder __pat__tau__TauPFEssential_funcmem_bld(&__pat__tau__TauPFEssential_db_funcmem);
void __pat__tau__TauPFEssential_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::tau::TauPFEssential"), typeid(::pat::tau::TauPFEssential), sizeof(::pat::tau::TauPFEssential), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TauPFEssential"), destructor_65388, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26107, type_26109), Reflex::Literal("operator="), operator_65389, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26109), Reflex::Literal("TauPFEssential"), constructor_65390, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TauPFEssential"), constructor_65391, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26824), Reflex::Literal("TauPFEssential"), constructor_65392, 0, "tau", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_26098, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__tau__TauPFEssential_datamem_bld);
}

//------Delayed data member builder for class TauPFEssential -------------------
void __pat__tau__TauPFEssential_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10223, Reflex::Literal("p4Jet_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, p4Jet_), ::Reflex::PUBLIC)
  .AddDataMember(type_10223, Reflex::Literal("p4CorrJet_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, p4CorrJet_), ::Reflex::PUBLIC)
  .AddDataMember(type_72, Reflex::Literal("decayMode_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, decayMode_), ::Reflex::PUBLIC)
  .AddDataMember(type_10191, Reflex::Literal("dxy_PCA_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, dxy_PCA_), ::Reflex::PUBLIC)
  .AddDataMember(type_112, Reflex::Literal("dxy_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, dxy_), ::Reflex::PUBLIC)
  .AddDataMember(type_112, Reflex::Literal("dxy_error_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, dxy_error_), ::Reflex::PUBLIC)
  .AddDataMember(type_112, Reflex::Literal("dxy_Sig_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, dxy_Sig_), ::Reflex::PUBLIC)
  .AddDataMember(type_11501, Reflex::Literal("pv_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, pv_), ::Reflex::PUBLIC)
  .AddDataMember(type_10191, Reflex::Literal("pvPos_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, pvPos_), ::Reflex::PUBLIC)
  .AddDataMember(type_116, Reflex::Literal("pvCov_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, pvCov_), ::Reflex::PUBLIC)
  .AddDataMember(type_1810, Reflex::Literal("hasSV_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, hasSV_), ::Reflex::PUBLIC)
  .AddDataMember(type_10222, Reflex::Literal("flightLength_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, flightLength_), ::Reflex::PUBLIC)
  .AddDataMember(type_112, Reflex::Literal("flightLengthSig_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, flightLengthSig_), ::Reflex::PUBLIC)
  .AddDataMember(type_11501, Reflex::Literal("sv_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, sv_), ::Reflex::PUBLIC)
  .AddDataMember(type_10191, Reflex::Literal("svPos_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, svPos_), ::Reflex::PUBLIC)
  .AddDataMember(type_116, Reflex::Literal("svCov_"), OffsetOf(__shadow__::__pat__tau__TauPFEssential, svCov_), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class TauPFEssential -------------------
void __pat__tau__TauPFEssential_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<pat::tau::TauPFEssential,std::allocator<pat::tau::TauPFEssential> > -------------------------------
static void constructor_26118( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauPFEssential>();
  else ::new(mem) ::std::vector<pat::tau::TauPFEssential>();
}

static void constructor_26119( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauPFEssential>(*(const ::std::allocator<pat::tau::TauPFEssential>*)arg[0]);
  else ::new(mem) ::std::vector<pat::tau::TauPFEssential>(*(const ::std::allocator<pat::tau::TauPFEssential>*)arg[0]);
}

static void constructor_26120( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauPFEssential>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pat::tau::TauPFEssential>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauPFEssential>(*(::std::size_t*)arg[0],
      *(const ::pat::tau::TauPFEssential*)arg[1]);
  else ::new(mem) ::std::vector<pat::tau::TauPFEssential>(*(::std::size_t*)arg[0],
      *(const ::pat::tau::TauPFEssential*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauPFEssential>(*(::std::size_t*)arg[0],
      *(const ::pat::tau::TauPFEssential*)arg[1],
      *(const ::std::allocator<pat::tau::TauPFEssential>*)arg[2]);
  else ::new(mem) ::std::vector<pat::tau::TauPFEssential>(*(::std::size_t*)arg[0],
      *(const ::pat::tau::TauPFEssential*)arg[1],
      *(const ::std::allocator<pat::tau::TauPFEssential>*)arg[2]);
  }
}

static void constructor_26121( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pat::tau::TauPFEssential>(*(const ::std::vector<pat::tau::TauPFEssential>*)arg[0]);
  else ::new(mem) ::std::vector<pat::tau::TauPFEssential>(*(const ::std::vector<pat::tau::TauPFEssential>*)arg[0]);
}

static void destructor_26122(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pat::tau::TauPFEssential>*)o)->::std::vector<pat::tau::TauPFEssential>::~vector)();
}
static  void operator_26123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::tau::TauPFEssential>*)o)->operator=)(*(const ::std::vector<pat::tau::TauPFEssential>*)arg[0]);
  else   (((::std::vector<pat::tau::TauPFEssential>*)o)->operator=)(*(const ::std::vector<pat::tau::TauPFEssential>*)arg[0]);
}

static  void method_26124( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::tau::TauPFEssential>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::pat::tau::TauPFEssential*)arg[1]);
}

static  void method_26125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >)((((::std::vector<pat::tau::TauPFEssential>*)o)->begin)());
  else   (((::std::vector<pat::tau::TauPFEssential>*)o)->begin)();
}

static  void method_26126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >)((((const ::std::vector<pat::tau::TauPFEssential>*)o)->begin)());
  else   (((const ::std::vector<pat::tau::TauPFEssential>*)o)->begin)();
}

static  void method_26127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >)((((::std::vector<pat::tau::TauPFEssential>*)o)->end)());
  else   (((::std::vector<pat::tau::TauPFEssential>*)o)->end)();
}

static  void method_26128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >)((((const ::std::vector<pat::tau::TauPFEssential>*)o)->end)());
  else   (((const ::std::vector<pat::tau::TauPFEssential>*)o)->end)();
}

static  void method_26133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::tau::TauPFEssential>*)o)->size)());
  else   (((const ::std::vector<pat::tau::TauPFEssential>*)o)->size)();
}

static  void method_26134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::tau::TauPFEssential>*)o)->max_size)());
  else   (((const ::std::vector<pat::tau::TauPFEssential>*)o)->max_size)();
}

static  void method_26135( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pat::tau::TauPFEssential>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pat::tau::TauPFEssential>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::pat::tau::TauPFEssential*)arg[1]);
  }
}

static  void method_26136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pat::tau::TauPFEssential>*)o)->capacity)());
  else   (((const ::std::vector<pat::tau::TauPFEssential>*)o)->capacity)();
}

static  void method_26137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pat::tau::TauPFEssential>*)o)->empty)());
  else   (((const ::std::vector<pat::tau::TauPFEssential>*)o)->empty)();
}

static  void method_26138( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::tau::TauPFEssential>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_26139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::tau::TauPFEssential>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::tau::TauPFEssential>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_26140( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::tau::TauPFEssential>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::tau::TauPFEssential>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_26142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::tau::TauPFEssential>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pat::tau::TauPFEssential>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_26143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::tau::TauPFEssential>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pat::tau::TauPFEssential>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_26144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::tau::TauPFEssential>*)o)->front)();
  else   (((::std::vector<pat::tau::TauPFEssential>*)o)->front)();
}

static  void method_26145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::tau::TauPFEssential>*)o)->front)();
  else   (((const ::std::vector<pat::tau::TauPFEssential>*)o)->front)();
}

static  void method_26146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pat::tau::TauPFEssential>*)o)->back)();
  else   (((::std::vector<pat::tau::TauPFEssential>*)o)->back)();
}

static  void method_26147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pat::tau::TauPFEssential>*)o)->back)();
  else   (((const ::std::vector<pat::tau::TauPFEssential>*)o)->back)();
}

static  void method_26148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pat::tau::TauPFEssential>*)o)->data)());
  else   (((::std::vector<pat::tau::TauPFEssential>*)o)->data)();
}

static  void method_26149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pat::tau::TauPFEssential>*)o)->data)());
  else   (((const ::std::vector<pat::tau::TauPFEssential>*)o)->data)();
}

static  void method_26150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::tau::TauPFEssential>*)o)->push_back)(*(const ::pat::tau::TauPFEssential*)arg[0]);
}

static  void method_26151( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::tau::TauPFEssential>*)o)->pop_back)();
}

static  void method_26152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >)((((::std::vector<pat::tau::TauPFEssential>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >*)arg[0],
    *(const ::pat::tau::TauPFEssential*)arg[1]));
  else   (((::std::vector<pat::tau::TauPFEssential>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >*)arg[0],
    *(const ::pat::tau::TauPFEssential*)arg[1]);
}

static  void method_26153( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::tau::TauPFEssential>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::pat::tau::TauPFEssential*)arg[2]);
}

static  void method_26154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >)((((::std::vector<pat::tau::TauPFEssential>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >*)arg[0]));
  else   (((::std::vector<pat::tau::TauPFEssential>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >*)arg[0]);
}

static  void method_26155( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >)((((::std::vector<pat::tau::TauPFEssential>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >*)arg[1]));
  else   (((::std::vector<pat::tau::TauPFEssential>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pat::tau::TauPFEssential*,std::vector<pat::tau::TauPFEssential> >*)arg[1]);
}

static  void method_26156( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pat::tau::TauPFEssential>*)o)->swap)(*(::std::vector<pat::tau::TauPFEssential>*)arg[0]);
}

static  void method_26157( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pat::tau::TauPFEssential>*)o)->clear)();
}

static void method_newdel_3599( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pat::tau::TauPFEssential> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pat::tau::TauPFEssential> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pat::tau::TauPFEssential> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pat::tau::TauPFEssential> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pat::tau::TauPFEssential> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x88( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pat::tau::TauPFEssential,std::allocator<pat::tau::TauPFEssential> >")), ::Reflex::BaseOffset< ::std::vector<pat::tau::TauPFEssential>,::std::_Vector_base<pat::tau::TauPFEssential,std::allocator<pat::tau::TauPFEssential> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x89( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pat::tau::TauPFEssential> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pat::tau::TauPFEssential> >::Generate();
}

//------Dictionary for class vector<pat::tau::TauPFEssential,std::allocator<pat::tau::TauPFEssential> > -------------------------------
void __std__vector_pat__tau__TauPFEssential__db_datamem(Reflex::Class*);
void __std__vector_pat__tau__TauPFEssential__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pat__tau__TauPFEssential__datamem_bld(&__std__vector_pat__tau__TauPFEssential__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pat__tau__TauPFEssential__funcmem_bld(&__std__vector_pat__tau__TauPFEssential__db_funcmem);
void __std__vector_pat__tau__TauPFEssential__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pat::tau::TauPFEssential>"), typeid(::std::vector<pat::tau::TauPFEssential>), sizeof(::std::vector<pat::tau::TauPFEssential>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2882, ::Reflex::BaseOffset< ::std::vector<pat::tau::TauPFEssential>, ::std::_Vector_base<pat::tau::TauPFEssential,std::allocator<pat::tau::TauPFEssential> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_26098, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::_Alloc_value_type"))
  .AddTypedef(type_2882, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::_Base"))
  .AddTypedef(type_3951, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::_Tp_alloc_type"))
  .AddTypedef(type_12414, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::_Alloc_traits"))
  .AddTypedef(type_26098, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::value_type"))
  .AddTypedef(type_15412, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::pointer"))
  .AddTypedef(type_26105, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::const_pointer"))
  .AddTypedef(type_26107, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::reference"))
  .AddTypedef(type_26109, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::const_reference"))
  .AddTypedef(type_12077, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::iterator"))
  .AddTypedef(type_12078, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::const_iterator"))
  .AddTypedef(type_4398, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::const_reverse_iterator"))
  .AddTypedef(type_4399, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::reverse_iterator"))
  .AddTypedef(type_3845, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::size_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::difference_type"))
  .AddTypedef(type_3951, Reflex::Literal("std::vector<pat::tau::TauPFEssential>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_26118, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63062), Reflex::Literal("vector"), constructor_26119, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3845, type_26109, type_63062), Reflex::Literal("vector"), constructor_26120, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_65394), Reflex::Literal("vector"), constructor_26121, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_26122, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3599, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x88, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x89, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pat__tau__TauPFEssential__funcmem_bld);
}

//------Delayed data member builder for class vector<pat::tau::TauPFEssential,std::allocator<pat::tau::TauPFEssential> > -------------------
void __std__vector_pat__tau__TauPFEssential__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pat::tau::TauPFEssential,std::allocator<pat::tau::TauPFEssential> > -------------------
void __std__vector_pat__tau__TauPFEssential__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65395, type_65394), Reflex::Literal("operator="), operator_26123, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_26109), Reflex::Literal("assign"), method_26124, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12077), Reflex::Literal("begin"), method_26125, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12078), Reflex::Literal("begin"), method_26126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12077), Reflex::Literal("end"), method_26127, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12078), Reflex::Literal("end"), method_26128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_26133, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("max_size"), method_26134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845, type_26098), Reflex::Literal("resize"), method_26135, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_26136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_26137, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_26138, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26107, type_3845), Reflex::Literal("operator[]"), operator_26139, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26109, type_3845), Reflex::Literal("operator[]"), operator_26140, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26107, type_3845), Reflex::Literal("at"), method_26142, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26109, type_3845), Reflex::Literal("at"), method_26143, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26107), Reflex::Literal("front"), method_26144, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26109), Reflex::Literal("front"), method_26145, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26107), Reflex::Literal("back"), method_26146, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26109), Reflex::Literal("back"), method_26147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15412), Reflex::Literal("data"), method_26148, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26105), Reflex::Literal("data"), method_26149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_26109), Reflex::Literal("push_back"), method_26150, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("pop_back"), method_26151, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12077, type_12077, type_26109), Reflex::Literal("insert"), method_26152, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_12077, type_3845, type_26109), Reflex::Literal("insert"), method_26153, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12077, type_12077), Reflex::Literal("erase"), method_26154, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12077, type_12077, type_12077), Reflex::Literal("erase"), method_26155, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_65395), Reflex::Literal("swap"), method_26156, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_26157, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> > > -------------------------------
static void constructor_39986( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::PackedGenParticle> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::PackedGenParticle> >();
}

static void constructor_39987( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::PackedGenParticle> >(*(::std::auto_ptr<std::vector<pat::PackedGenParticle> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::PackedGenParticle> >(*(::std::auto_ptr<std::vector<pat::PackedGenParticle> >*)arg[0]);
}

static void destructor_39988(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->::edm::Wrapper<std::vector<pat::PackedGenParticle> >::~Wrapper)();
}
static  void method_39989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->product)();
}

static  void operator_39990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->operator->)();
}

static  void method_39991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->productTypeInfo)();
}

static  void method_39992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->typeInfo)();
}

static void constructor_39993( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::PackedGenParticle> >((::std::vector<pat::PackedGenParticle>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::PackedGenParticle> >((::std::vector<pat::PackedGenParticle>*)arg[0]);
}

static  void method_39994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->getInterface)();
}

static  void method_39995( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_39996( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_39997( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_39998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->dynamicTypeInfo)();
}

static  void method_39999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->isPresent)();
}

static  void method_40000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::PackedGenParticle> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6809( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::PackedGenParticle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::PackedGenParticle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::PackedGenParticle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::PackedGenParticle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::PackedGenParticle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> > > -------------------------------
void __edm__Wrapper_std__vector_pat__PackedGenParticle_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__PackedGenParticle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__PackedGenParticle_s__datamem_bld(&__edm__Wrapper_std__vector_pat__PackedGenParticle_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__PackedGenParticle_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__PackedGenParticle_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__PackedGenParticle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::PackedGenParticle> >"), typeid(::edm::Wrapper<std::vector<pat::PackedGenParticle> >), sizeof(::edm::Wrapper<std::vector<pat::PackedGenParticle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3507, Reflex::Literal("edm::Wrapper<std::vector<pat::PackedGenParticle> >::value_type"))
  .AddTypedef(type_3507, Reflex::Literal("edm::Wrapper<std::vector<pat::PackedGenParticle> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_39986, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3250), Reflex::Literal("Wrapper"), constructor_39987, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_39988, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71002), Reflex::Literal("Wrapper"), constructor_39993, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6809, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__PackedGenParticle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__PackedGenParticle_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> > > -------------------
void __edm__Wrapper_std__vector_pat__PackedGenParticle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__PackedGenParticle_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3507, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__PackedGenParticle_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> > > -------------------
void __edm__Wrapper_std__vector_pat__PackedGenParticle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70698), Reflex::Literal("product"), method_39989, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70698), Reflex::Literal("operator->"), operator_39990, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_39991, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_39992, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71003), Reflex::Literal("getInterface"), method_39994, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_39995, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_39996, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_39997, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_39998, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_39999, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_40000, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------------------
static void constructor_40007( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::PackedCandidate> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::PackedCandidate> >();
}

static void constructor_40008( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::PackedCandidate> >(*(::std::auto_ptr<std::vector<pat::PackedCandidate> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::PackedCandidate> >(*(::std::auto_ptr<std::vector<pat::PackedCandidate> >*)arg[0]);
}

static void destructor_40009(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->::edm::Wrapper<std::vector<pat::PackedCandidate> >::~Wrapper)();
}
static  void method_40010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->product)();
}

static  void operator_40011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->operator->)();
}

static  void method_40012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->productTypeInfo)();
}

static  void method_40013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->typeInfo)();
}

static void constructor_40014( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::PackedCandidate> >((::std::vector<pat::PackedCandidate>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::PackedCandidate> >((::std::vector<pat::PackedCandidate>*)arg[0]);
}

static  void method_40015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->getInterface)();
}

static  void method_40016( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_40017( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_40018( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_40019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->dynamicTypeInfo)();
}

static  void method_40020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->isPresent)();
}

static  void method_40021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::PackedCandidate> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6810( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::PackedCandidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::PackedCandidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::PackedCandidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::PackedCandidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::PackedCandidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------------------
void __edm__Wrapper_std__vector_pat__PackedCandidate_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__PackedCandidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__PackedCandidate_s__datamem_bld(&__edm__Wrapper_std__vector_pat__PackedCandidate_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__PackedCandidate_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__PackedCandidate_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__PackedCandidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::PackedCandidate> >"), typeid(::edm::Wrapper<std::vector<pat::PackedCandidate> >), sizeof(::edm::Wrapper<std::vector<pat::PackedCandidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3508, Reflex::Literal("edm::Wrapper<std::vector<pat::PackedCandidate> >::value_type"))
  .AddTypedef(type_3508, Reflex::Literal("edm::Wrapper<std::vector<pat::PackedCandidate> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_40007, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3251), Reflex::Literal("Wrapper"), constructor_40008, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_40009, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71006), Reflex::Literal("Wrapper"), constructor_40014, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6810, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__PackedCandidate_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__PackedCandidate_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------
void __edm__Wrapper_std__vector_pat__PackedCandidate_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__PackedCandidate_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3508, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__PackedCandidate_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------
void __edm__Wrapper_std__vector_pat__PackedCandidate_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70704), Reflex::Literal("product"), method_40010, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70704), Reflex::Literal("operator->"), operator_40011, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_40012, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_40013, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71007), Reflex::Literal("getInterface"), method_40015, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_40016, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_40017, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_40018, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_40019, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_40020, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_40021, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::Conversion, std::allocator<pat::Conversion> > > -------------------------------
static void constructor_40028( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Conversion> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Conversion> >();
}

static void constructor_40029( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Conversion> >(*(::std::auto_ptr<std::vector<pat::Conversion> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Conversion> >(*(::std::auto_ptr<std::vector<pat::Conversion> >*)arg[0]);
}

static void destructor_40030(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::Conversion> >*)o)->::edm::Wrapper<std::vector<pat::Conversion> >::~Wrapper)();
}
static  void method_40031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Conversion> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::Conversion> >*)o)->product)();
}

static  void operator_40032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Conversion> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::Conversion> >*)o)->operator->)();
}

static  void method_40033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Conversion> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Conversion> >*)o)->productTypeInfo)();
}

static  void method_40034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Conversion> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Conversion> >*)o)->typeInfo)();
}

static void constructor_40035( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Conversion> >((::std::vector<pat::Conversion>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Conversion> >((::std::vector<pat::Conversion>*)arg[0]);
}

static  void method_40036( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::Conversion> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::Conversion> >*)o)->getInterface)();
}

static  void method_40037( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Conversion> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_40038( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Conversion> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_40039( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Conversion> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_40040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Conversion> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::Conversion> >*)o)->dynamicTypeInfo)();
}

static  void method_40041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::Conversion> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::Conversion> >*)o)->isPresent)();
}

static  void method_40042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Conversion> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::Conversion> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6811( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Conversion> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Conversion> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Conversion> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Conversion> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Conversion> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::Conversion, std::allocator<pat::Conversion> > > -------------------------------
void __edm__Wrapper_std__vector_pat__Conversion_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__Conversion_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Conversion_s__datamem_bld(&__edm__Wrapper_std__vector_pat__Conversion_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Conversion_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__Conversion_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__Conversion_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Conversion> >"), typeid(::edm::Wrapper<std::vector<pat::Conversion> >), sizeof(::edm::Wrapper<std::vector<pat::Conversion> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3509, Reflex::Literal("edm::Wrapper<std::vector<pat::Conversion> >::value_type"))
  .AddTypedef(type_3509, Reflex::Literal("edm::Wrapper<std::vector<pat::Conversion> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_40028, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3252), Reflex::Literal("Wrapper"), constructor_40029, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_40030, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71010), Reflex::Literal("Wrapper"), constructor_40035, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6811, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__Conversion_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__Conversion_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::Conversion, std::allocator<pat::Conversion> > > -------------------
void __edm__Wrapper_std__vector_pat__Conversion_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Conversion_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3509, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Conversion_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::Conversion, std::allocator<pat::Conversion> > > -------------------
void __edm__Wrapper_std__vector_pat__Conversion_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70710), Reflex::Literal("product"), method_40031, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70710), Reflex::Literal("operator->"), operator_40032, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_40033, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_40034, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71011), Reflex::Literal("getInterface"), method_40036, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_40037, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_40038, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_40039, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_40040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_40041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_40042, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> > > -------------------------------
static void constructor_40049( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Hemisphere> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Hemisphere> >();
}

static void constructor_40050( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Hemisphere> >(*(::std::auto_ptr<std::vector<pat::Hemisphere> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Hemisphere> >(*(::std::auto_ptr<std::vector<pat::Hemisphere> >*)arg[0]);
}

static void destructor_40051(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->::edm::Wrapper<std::vector<pat::Hemisphere> >::~Wrapper)();
}
static  void method_40052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->product)();
}

static  void operator_40053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->operator->)();
}

static  void method_40054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->productTypeInfo)();
}

static  void method_40055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->typeInfo)();
}

static void constructor_40056( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Hemisphere> >((::std::vector<pat::Hemisphere>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Hemisphere> >((::std::vector<pat::Hemisphere>*)arg[0]);
}

static  void method_40057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->getInterface)();
}

static  void method_40058( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_40059( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_40060( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_40061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->dynamicTypeInfo)();
}

static  void method_40062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->isPresent)();
}

static  void method_40063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::Hemisphere> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6812( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Hemisphere> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Hemisphere> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Hemisphere> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Hemisphere> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Hemisphere> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> > > -------------------------------
void __edm__Wrapper_std__vector_pat__Hemisphere_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__Hemisphere_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Hemisphere_s__datamem_bld(&__edm__Wrapper_std__vector_pat__Hemisphere_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Hemisphere_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__Hemisphere_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__Hemisphere_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Hemisphere> >"), typeid(::edm::Wrapper<std::vector<pat::Hemisphere> >), sizeof(::edm::Wrapper<std::vector<pat::Hemisphere> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3510, Reflex::Literal("edm::Wrapper<std::vector<pat::Hemisphere> >::value_type"))
  .AddTypedef(type_3510, Reflex::Literal("edm::Wrapper<std::vector<pat::Hemisphere> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_40049, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3253), Reflex::Literal("Wrapper"), constructor_40050, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_40051, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71014), Reflex::Literal("Wrapper"), constructor_40056, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6812, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__Hemisphere_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__Hemisphere_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> > > -------------------
void __edm__Wrapper_std__vector_pat__Hemisphere_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Hemisphere_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3510, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Hemisphere_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> > > -------------------
void __edm__Wrapper_std__vector_pat__Hemisphere_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70716), Reflex::Literal("product"), method_40052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70716), Reflex::Literal("operator->"), operator_40053, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_40054, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_40055, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71015), Reflex::Literal("getInterface"), method_40057, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_40058, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_40059, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_40060, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_40061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_40062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_40063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> > > -------------------------------
static void constructor_40070( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::GenericParticle> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::GenericParticle> >();
}

static void constructor_40071( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::GenericParticle> >(*(::std::auto_ptr<std::vector<pat::GenericParticle> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::GenericParticle> >(*(::std::auto_ptr<std::vector<pat::GenericParticle> >*)arg[0]);
}

static void destructor_40072(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->::edm::Wrapper<std::vector<pat::GenericParticle> >::~Wrapper)();
}
static  void method_40073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->product)();
}

static  void operator_40074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->operator->)();
}

static  void method_40075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->productTypeInfo)();
}

static  void method_40076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->typeInfo)();
}

static void constructor_40077( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::GenericParticle> >((::std::vector<pat::GenericParticle>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::GenericParticle> >((::std::vector<pat::GenericParticle>*)arg[0]);
}

static  void method_40078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->getInterface)();
}

static  void method_40079( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_40080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_40081( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_40082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->dynamicTypeInfo)();
}

static  void method_40083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->isPresent)();
}

static  void method_40084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::GenericParticle> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6813( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::GenericParticle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::GenericParticle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::GenericParticle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::GenericParticle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::GenericParticle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> > > -------------------------------
void __edm__Wrapper_std__vector_pat__GenericParticle_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__GenericParticle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__GenericParticle_s__datamem_bld(&__edm__Wrapper_std__vector_pat__GenericParticle_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__GenericParticle_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__GenericParticle_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__GenericParticle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::GenericParticle> >"), typeid(::edm::Wrapper<std::vector<pat::GenericParticle> >), sizeof(::edm::Wrapper<std::vector<pat::GenericParticle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3511, Reflex::Literal("edm::Wrapper<std::vector<pat::GenericParticle> >::value_type"))
  .AddTypedef(type_3511, Reflex::Literal("edm::Wrapper<std::vector<pat::GenericParticle> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_40070, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254), Reflex::Literal("Wrapper"), constructor_40071, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_40072, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71018), Reflex::Literal("Wrapper"), constructor_40077, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6813, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__GenericParticle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__GenericParticle_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> > > -------------------
void __edm__Wrapper_std__vector_pat__GenericParticle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__GenericParticle_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3511, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__GenericParticle_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> > > -------------------
void __edm__Wrapper_std__vector_pat__GenericParticle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70722), Reflex::Literal("product"), method_40073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70722), Reflex::Literal("operator->"), operator_40074, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_40075, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_40076, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71019), Reflex::Literal("getInterface"), method_40078, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_40079, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_40080, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_40081, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_40082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_40083, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_40084, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> > > -------------------------------
static void constructor_40091( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::PFParticle> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::PFParticle> >();
}

static void constructor_40092( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::PFParticle> >(*(::std::auto_ptr<std::vector<pat::PFParticle> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::PFParticle> >(*(::std::auto_ptr<std::vector<pat::PFParticle> >*)arg[0]);
}

static void destructor_40093(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->::edm::Wrapper<std::vector<pat::PFParticle> >::~Wrapper)();
}
static  void method_40094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->product)();
}

static  void operator_40095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->operator->)();
}

static  void method_40096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->productTypeInfo)();
}

static  void method_40097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->typeInfo)();
}

static void constructor_40098( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::PFParticle> >((::std::vector<pat::PFParticle>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::PFParticle> >((::std::vector<pat::PFParticle>*)arg[0]);
}

static  void method_40099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->getInterface)();
}

static  void method_40100( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_40101( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_40102( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_40103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->dynamicTypeInfo)();
}

static  void method_40104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->isPresent)();
}

static  void method_40105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::PFParticle> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6814( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::PFParticle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::PFParticle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::PFParticle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::PFParticle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::PFParticle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> > > -------------------------------
void __edm__Wrapper_std__vector_pat__PFParticle_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__PFParticle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__PFParticle_s__datamem_bld(&__edm__Wrapper_std__vector_pat__PFParticle_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__PFParticle_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__PFParticle_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__PFParticle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::PFParticle> >"), typeid(::edm::Wrapper<std::vector<pat::PFParticle> >), sizeof(::edm::Wrapper<std::vector<pat::PFParticle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3512, Reflex::Literal("edm::Wrapper<std::vector<pat::PFParticle> >::value_type"))
  .AddTypedef(type_3512, Reflex::Literal("edm::Wrapper<std::vector<pat::PFParticle> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_40091, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3255), Reflex::Literal("Wrapper"), constructor_40092, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_40093, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71022), Reflex::Literal("Wrapper"), constructor_40098, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6814, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__PFParticle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__PFParticle_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> > > -------------------
void __edm__Wrapper_std__vector_pat__PFParticle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__PFParticle_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3512, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__PFParticle_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> > > -------------------
void __edm__Wrapper_std__vector_pat__PFParticle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70728), Reflex::Literal("product"), method_40094, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70728), Reflex::Literal("operator->"), operator_40095, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_40096, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_40097, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71023), Reflex::Literal("getInterface"), method_40099, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_40100, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_40101, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_40102, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_40103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_40104, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_40105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> > > -------------------------------
static void constructor_40112( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::CompositeCandidate> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::CompositeCandidate> >();
}

static void constructor_40113( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::CompositeCandidate> >(*(::std::auto_ptr<std::vector<pat::CompositeCandidate> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::CompositeCandidate> >(*(::std::auto_ptr<std::vector<pat::CompositeCandidate> >*)arg[0]);
}

static void destructor_40114(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->::edm::Wrapper<std::vector<pat::CompositeCandidate> >::~Wrapper)();
}
static  void method_40115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->product)();
}

static  void operator_40116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->operator->)();
}

static  void method_40117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->productTypeInfo)();
}

static  void method_40118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->typeInfo)();
}

static void constructor_40119( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::CompositeCandidate> >((::std::vector<pat::CompositeCandidate>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::CompositeCandidate> >((::std::vector<pat::CompositeCandidate>*)arg[0]);
}

static  void method_40120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->getInterface)();
}

static  void method_40121( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_40122( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_40123( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_40124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->dynamicTypeInfo)();
}

static  void method_40125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->isPresent)();
}

static  void method_40126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::CompositeCandidate> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6815( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::CompositeCandidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::CompositeCandidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::CompositeCandidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::CompositeCandidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::CompositeCandidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> > > -------------------------------
void __edm__Wrapper_std__vector_pat__CompositeCandidate_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__CompositeCandidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__CompositeCandidate_s__datamem_bld(&__edm__Wrapper_std__vector_pat__CompositeCandidate_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__CompositeCandidate_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__CompositeCandidate_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__CompositeCandidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::CompositeCandidate> >"), typeid(::edm::Wrapper<std::vector<pat::CompositeCandidate> >), sizeof(::edm::Wrapper<std::vector<pat::CompositeCandidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3513, Reflex::Literal("edm::Wrapper<std::vector<pat::CompositeCandidate> >::value_type"))
  .AddTypedef(type_3513, Reflex::Literal("edm::Wrapper<std::vector<pat::CompositeCandidate> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_40112, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3256), Reflex::Literal("Wrapper"), constructor_40113, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_40114, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71026), Reflex::Literal("Wrapper"), constructor_40119, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6815, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__CompositeCandidate_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__CompositeCandidate_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> > > -------------------
void __edm__Wrapper_std__vector_pat__CompositeCandidate_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__CompositeCandidate_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3513, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__CompositeCandidate_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> > > -------------------
void __edm__Wrapper_std__vector_pat__CompositeCandidate_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70734), Reflex::Literal("product"), method_40115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70734), Reflex::Literal("operator->"), operator_40116, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_40117, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_40118, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71027), Reflex::Literal("getInterface"), method_40120, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_40121, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_40122, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_40123, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_40124, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_40125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_40126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::Particle, std::allocator<pat::Particle> > > -------------------------------
static void constructor_40133( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Particle> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Particle> >();
}

static void constructor_40134( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Particle> >(*(::std::auto_ptr<std::vector<pat::Particle> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Particle> >(*(::std::auto_ptr<std::vector<pat::Particle> >*)arg[0]);
}

static void destructor_40135(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::Particle> >*)o)->::edm::Wrapper<std::vector<pat::Particle> >::~Wrapper)();
}
static  void method_40136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Particle> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::Particle> >*)o)->product)();
}

static  void operator_40137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Particle> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::Particle> >*)o)->operator->)();
}

static  void method_40138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Particle> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Particle> >*)o)->productTypeInfo)();
}

static  void method_40139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Particle> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Particle> >*)o)->typeInfo)();
}

static void constructor_40140( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Particle> >((::std::vector<pat::Particle>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Particle> >((::std::vector<pat::Particle>*)arg[0]);
}

static  void method_40141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::Particle> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::Particle> >*)o)->getInterface)();
}

static  void method_40142( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Particle> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_40143( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Particle> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_40144( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Particle> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_40145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Particle> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::Particle> >*)o)->dynamicTypeInfo)();
}

static  void method_40146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::Particle> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::Particle> >*)o)->isPresent)();
}

static  void method_40147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Particle> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::Particle> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6816( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Particle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Particle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Particle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Particle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Particle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::Particle, std::allocator<pat::Particle> > > -------------------------------
void __edm__Wrapper_std__vector_pat__Particle_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__Particle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Particle_s__datamem_bld(&__edm__Wrapper_std__vector_pat__Particle_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Particle_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__Particle_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__Particle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Particle> >"), typeid(::edm::Wrapper<std::vector<pat::Particle> >), sizeof(::edm::Wrapper<std::vector<pat::Particle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3514, Reflex::Literal("edm::Wrapper<std::vector<pat::Particle> >::value_type"))
  .AddTypedef(type_3514, Reflex::Literal("edm::Wrapper<std::vector<pat::Particle> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_40133, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3257), Reflex::Literal("Wrapper"), constructor_40134, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_40135, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71030), Reflex::Literal("Wrapper"), constructor_40140, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6816, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__Particle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__Particle_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::Particle, std::allocator<pat::Particle> > > -------------------
void __edm__Wrapper_std__vector_pat__Particle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Particle_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3514, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Particle_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::Particle, std::allocator<pat::Particle> > > -------------------
void __edm__Wrapper_std__vector_pat__Particle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70740), Reflex::Literal("product"), method_40136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70740), Reflex::Literal("operator->"), operator_40137, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_40138, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_40139, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71031), Reflex::Literal("getInterface"), method_40141, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_40142, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_40143, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_40144, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_40145, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_40146, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_40147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::MHT, std::allocator<pat::MHT> > > -------------------------------
static void constructor_40154( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::MHT> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::MHT> >();
}

static void constructor_40155( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::MHT> >(*(::std::auto_ptr<std::vector<pat::MHT> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::MHT> >(*(::std::auto_ptr<std::vector<pat::MHT> >*)arg[0]);
}

static void destructor_40156(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::MHT> >*)o)->::edm::Wrapper<std::vector<pat::MHT> >::~Wrapper)();
}
static  void method_40157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::MHT> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::MHT> >*)o)->product)();
}

static  void operator_40158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::MHT> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::MHT> >*)o)->operator->)();
}

static  void method_40159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::MHT> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::MHT> >*)o)->productTypeInfo)();
}

static  void method_40160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::MHT> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::MHT> >*)o)->typeInfo)();
}

static void constructor_40161( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::MHT> >((::std::vector<pat::MHT>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::MHT> >((::std::vector<pat::MHT>*)arg[0]);
}

static  void method_40162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::MHT> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::MHT> >*)o)->getInterface)();
}

static  void method_40163( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::MHT> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_40164( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::MHT> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_40165( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::MHT> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_40166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::MHT> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::MHT> >*)o)->dynamicTypeInfo)();
}

static  void method_40167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::MHT> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::MHT> >*)o)->isPresent)();
}

static  void method_40168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::MHT> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::MHT> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6817( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::MHT> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::MHT> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::MHT> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::MHT> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::MHT> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::MHT, std::allocator<pat::MHT> > > -------------------------------
void __edm__Wrapper_std__vector_pat__MHT_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__MHT_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__MHT_s__datamem_bld(&__edm__Wrapper_std__vector_pat__MHT_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__MHT_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__MHT_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__MHT_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::MHT> >"), typeid(::edm::Wrapper<std::vector<pat::MHT> >), sizeof(::edm::Wrapper<std::vector<pat::MHT> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3521, Reflex::Literal("edm::Wrapper<std::vector<pat::MHT> >::value_type"))
  .AddTypedef(type_3521, Reflex::Literal("edm::Wrapper<std::vector<pat::MHT> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_40154, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3258), Reflex::Literal("Wrapper"), constructor_40155, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_40156, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71035), Reflex::Literal("Wrapper"), constructor_40161, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6817, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__MHT_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__MHT_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::MHT, std::allocator<pat::MHT> > > -------------------
void __edm__Wrapper_std__vector_pat__MHT_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__MHT_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3521, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__MHT_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::MHT, std::allocator<pat::MHT> > > -------------------
void __edm__Wrapper_std__vector_pat__MHT_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71034), Reflex::Literal("product"), method_40157, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71034), Reflex::Literal("operator->"), operator_40158, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_40159, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_40160, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71036), Reflex::Literal("getInterface"), method_40162, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_40163, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_40164, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_40165, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_40166, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_40167, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_40168, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::MET, std::allocator<pat::MET> > > -------------------------------
static void constructor_40175( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::MET> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::MET> >();
}

static void constructor_40176( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::MET> >(*(::std::auto_ptr<std::vector<pat::MET> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::MET> >(*(::std::auto_ptr<std::vector<pat::MET> >*)arg[0]);
}

static void destructor_40177(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::MET> >*)o)->::edm::Wrapper<std::vector<pat::MET> >::~Wrapper)();
}
static  void method_40178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::MET> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::MET> >*)o)->product)();
}

static  void operator_40179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::MET> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::MET> >*)o)->operator->)();
}

static  void method_40180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::MET> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::MET> >*)o)->productTypeInfo)();
}

static  void method_40181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::MET> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::MET> >*)o)->typeInfo)();
}

static void constructor_40182( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::MET> >((::std::vector<pat::MET>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::MET> >((::std::vector<pat::MET>*)arg[0]);
}

static  void method_40183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::MET> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::MET> >*)o)->getInterface)();
}

static  void method_40184( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::MET> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_40185( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::MET> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_40186( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::MET> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_40187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::MET> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::MET> >*)o)->dynamicTypeInfo)();
}

static  void method_40188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::MET> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::MET> >*)o)->isPresent)();
}

static  void method_40189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::MET> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::MET> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6818( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::MET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::MET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::MET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::MET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::MET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::MET, std::allocator<pat::MET> > > -------------------------------
void __edm__Wrapper_std__vector_pat__MET_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__MET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__MET_s__datamem_bld(&__edm__Wrapper_std__vector_pat__MET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__MET_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__MET_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__MET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::MET> >"), typeid(::edm::Wrapper<std::vector<pat::MET> >), sizeof(::edm::Wrapper<std::vector<pat::MET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3515, Reflex::Literal("edm::Wrapper<std::vector<pat::MET> >::value_type"))
  .AddTypedef(type_3515, Reflex::Literal("edm::Wrapper<std::vector<pat::MET> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_40175, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3259), Reflex::Literal("Wrapper"), constructor_40176, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_40177, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71039), Reflex::Literal("Wrapper"), constructor_40182, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6818, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__MET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__MET_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::MET, std::allocator<pat::MET> > > -------------------
void __edm__Wrapper_std__vector_pat__MET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__MET_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3515, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__MET_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::MET, std::allocator<pat::MET> > > -------------------
void __edm__Wrapper_std__vector_pat__MET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70746), Reflex::Literal("product"), method_40178, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70746), Reflex::Literal("operator->"), operator_40179, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_40180, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_40181, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71040), Reflex::Literal("getInterface"), method_40183, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_40184, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_40185, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_40186, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_40187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_40188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_40189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::Jet, std::allocator<pat::Jet> > > -------------------------------
static void constructor_40196( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Jet> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Jet> >();
}

static void constructor_40197( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Jet> >(*(::std::auto_ptr<std::vector<pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Jet> >(*(::std::auto_ptr<std::vector<pat::Jet> >*)arg[0]);
}

static void destructor_40198(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::Jet> >*)o)->::edm::Wrapper<std::vector<pat::Jet> >::~Wrapper)();
}
static  void method_40199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Jet> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::Jet> >*)o)->product)();
}

static  void operator_40200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Jet> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::Jet> >*)o)->operator->)();
}

static  void method_40201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Jet> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Jet> >*)o)->productTypeInfo)();
}

static  void method_40202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Jet> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Jet> >*)o)->typeInfo)();
}

static void constructor_40203( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Jet> >((::std::vector<pat::Jet>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Jet> >((::std::vector<pat::Jet>*)arg[0]);
}

static  void method_40204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::Jet> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::Jet> >*)o)->getInterface)();
}

static  void method_40205( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Jet> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_40206( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Jet> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_40207( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Jet> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_40208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Jet> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::Jet> >*)o)->dynamicTypeInfo)();
}

static  void method_40209( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::Jet> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::Jet> >*)o)->isPresent)();
}

static  void method_40210( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Jet> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::Jet> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6819( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Jet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Jet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Jet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Jet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Jet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::Jet, std::allocator<pat::Jet> > > -------------------------------
void __edm__Wrapper_std__vector_pat__Jet_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__Jet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Jet_s__datamem_bld(&__edm__Wrapper_std__vector_pat__Jet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Jet_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__Jet_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__Jet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Jet> >"), typeid(::edm::Wrapper<std::vector<pat::Jet> >), sizeof(::edm::Wrapper<std::vector<pat::Jet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3516, Reflex::Literal("edm::Wrapper<std::vector<pat::Jet> >::value_type"))
  .AddTypedef(type_3516, Reflex::Literal("edm::Wrapper<std::vector<pat::Jet> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_40196, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3260), Reflex::Literal("Wrapper"), constructor_40197, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_40198, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71043), Reflex::Literal("Wrapper"), constructor_40203, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6819, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__Jet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__Jet_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::Jet, std::allocator<pat::Jet> > > -------------------
void __edm__Wrapper_std__vector_pat__Jet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Jet_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3516, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Jet_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::Jet, std::allocator<pat::Jet> > > -------------------
void __edm__Wrapper_std__vector_pat__Jet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70752), Reflex::Literal("product"), method_40199, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70752), Reflex::Literal("operator->"), operator_40200, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_40201, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_40202, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71044), Reflex::Literal("getInterface"), method_40204, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_40205, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_40206, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_40207, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_40208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_40209, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_40210, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::Photon, std::allocator<pat::Photon> > > -------------------------------
static void constructor_40217( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Photon> >();
}

static void constructor_40218( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Photon> >(*(::std::auto_ptr<std::vector<pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Photon> >(*(::std::auto_ptr<std::vector<pat::Photon> >*)arg[0]);
}

static void destructor_40219(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::Photon> >*)o)->::edm::Wrapper<std::vector<pat::Photon> >::~Wrapper)();
}
static  void method_40220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::Photon> >*)o)->product)();
}

static  void operator_40221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::Photon> >*)o)->operator->)();
}

static  void method_40222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_40223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Photon> >*)o)->typeInfo)();
}

static void constructor_40224( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Photon> >((::std::vector<pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Photon> >((::std::vector<pat::Photon>*)arg[0]);
}

static  void method_40225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::Photon> >*)o)->getInterface)();
}

static  void method_40226( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_40227( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_40228( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_40229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_40230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::Photon> >*)o)->isPresent)();
}

static  void method_40231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6820( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::Photon, std::allocator<pat::Photon> > > -------------------------------
void __edm__Wrapper_std__vector_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Photon_s__datamem_bld(&__edm__Wrapper_std__vector_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Photon_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__Photon_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Photon> >"), typeid(::edm::Wrapper<std::vector<pat::Photon> >), sizeof(::edm::Wrapper<std::vector<pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3517, Reflex::Literal("edm::Wrapper<std::vector<pat::Photon> >::value_type"))
  .AddTypedef(type_3517, Reflex::Literal("edm::Wrapper<std::vector<pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_40217, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3261), Reflex::Literal("Wrapper"), constructor_40218, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_40219, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71047), Reflex::Literal("Wrapper"), constructor_40224, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6820, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::Photon, std::allocator<pat::Photon> > > -------------------
void __edm__Wrapper_std__vector_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3517, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::Photon, std::allocator<pat::Photon> > > -------------------
void __edm__Wrapper_std__vector_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70758), Reflex::Literal("product"), method_40220, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70758), Reflex::Literal("operator->"), operator_40221, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_40222, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_40223, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71048), Reflex::Literal("getInterface"), method_40225, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_40226, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_40227, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_40228, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_40229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_40230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_40231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::Tau, std::allocator<pat::Tau> > > -------------------------------
static void constructor_40238( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Tau> >();
}

static void constructor_40239( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Tau> >(*(::std::auto_ptr<std::vector<pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Tau> >(*(::std::auto_ptr<std::vector<pat::Tau> >*)arg[0]);
}

static void destructor_40240(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::Tau> >*)o)->::edm::Wrapper<std::vector<pat::Tau> >::~Wrapper)();
}
static  void method_40241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::Tau> >*)o)->product)();
}

static  void operator_40242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::Tau> >*)o)->operator->)();
}

static  void method_40243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_40244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Tau> >*)o)->typeInfo)();
}

static void constructor_40245( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Tau> >((::std::vector<pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Tau> >((::std::vector<pat::Tau>*)arg[0]);
}

static  void method_40246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::Tau> >*)o)->getInterface)();
}

static  void method_40247( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_40248( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_40249( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_40250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_40251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::Tau> >*)o)->isPresent)();
}

static  void method_40252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6821( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::Tau, std::allocator<pat::Tau> > > -------------------------------
void __edm__Wrapper_std__vector_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Tau_s__datamem_bld(&__edm__Wrapper_std__vector_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Tau_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__Tau_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Tau> >"), typeid(::edm::Wrapper<std::vector<pat::Tau> >), sizeof(::edm::Wrapper<std::vector<pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3518, Reflex::Literal("edm::Wrapper<std::vector<pat::Tau> >::value_type"))
  .AddTypedef(type_3518, Reflex::Literal("edm::Wrapper<std::vector<pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_40238, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3262), Reflex::Literal("Wrapper"), constructor_40239, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_40240, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71051), Reflex::Literal("Wrapper"), constructor_40245, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6821, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::Tau, std::allocator<pat::Tau> > > -------------------
void __edm__Wrapper_std__vector_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3518, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::Tau, std::allocator<pat::Tau> > > -------------------
void __edm__Wrapper_std__vector_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70764), Reflex::Literal("product"), method_40241, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70764), Reflex::Literal("operator->"), operator_40242, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_40243, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_40244, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71052), Reflex::Literal("getInterface"), method_40246, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_40247, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_40248, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_40249, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_40250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_40251, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_40252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::Muon, std::allocator<pat::Muon> > > -------------------------------
static void constructor_40259( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Muon> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Muon> >();
}

static void constructor_40260( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Muon> >(*(::std::auto_ptr<std::vector<pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Muon> >(*(::std::auto_ptr<std::vector<pat::Muon> >*)arg[0]);
}

static void destructor_40261(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::Muon> >*)o)->::edm::Wrapper<std::vector<pat::Muon> >::~Wrapper)();
}
static  void method_40262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Muon> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::Muon> >*)o)->product)();
}

static  void operator_40263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Muon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::Muon> >*)o)->operator->)();
}

static  void method_40264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Muon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Muon> >*)o)->productTypeInfo)();
}

static  void method_40265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Muon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Muon> >*)o)->typeInfo)();
}

static void constructor_40266( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Muon> >((::std::vector<pat::Muon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Muon> >((::std::vector<pat::Muon>*)arg[0]);
}

static  void method_40267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::Muon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::Muon> >*)o)->getInterface)();
}

static  void method_40268( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Muon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_40269( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Muon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_40270( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Muon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_40271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Muon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::Muon> >*)o)->dynamicTypeInfo)();
}

static  void method_40272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::Muon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::Muon> >*)o)->isPresent)();
}

static  void method_40273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Muon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::Muon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6822( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::Muon, std::allocator<pat::Muon> > > -------------------------------
void __edm__Wrapper_std__vector_pat__Muon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Muon_s__datamem_bld(&__edm__Wrapper_std__vector_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Muon_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__Muon_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Muon> >"), typeid(::edm::Wrapper<std::vector<pat::Muon> >), sizeof(::edm::Wrapper<std::vector<pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3519, Reflex::Literal("edm::Wrapper<std::vector<pat::Muon> >::value_type"))
  .AddTypedef(type_3519, Reflex::Literal("edm::Wrapper<std::vector<pat::Muon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_40259, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3263), Reflex::Literal("Wrapper"), constructor_40260, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_40261, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71055), Reflex::Literal("Wrapper"), constructor_40266, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6822, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__Muon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::Muon, std::allocator<pat::Muon> > > -------------------
void __edm__Wrapper_std__vector_pat__Muon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Muon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3519, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Muon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::Muon, std::allocator<pat::Muon> > > -------------------
void __edm__Wrapper_std__vector_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70770), Reflex::Literal("product"), method_40262, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70770), Reflex::Literal("operator->"), operator_40263, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_40264, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_40265, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71056), Reflex::Literal("getInterface"), method_40267, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_40268, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_40269, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_40270, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_40271, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_40272, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_40273, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<pat::Electron, std::allocator<pat::Electron> > > -------------------------------
static void constructor_40280( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Electron> >();
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Electron> >();
}

static void constructor_40281( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Electron> >(*(::std::auto_ptr<std::vector<pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Electron> >(*(::std::auto_ptr<std::vector<pat::Electron> >*)arg[0]);
}

static void destructor_40282(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<pat::Electron> >*)o)->::edm::Wrapper<std::vector<pat::Electron> >::~Wrapper)();
}
static  void method_40283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Electron> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<pat::Electron> >*)o)->product)();
}

static  void operator_40284( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<pat::Electron> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<pat::Electron> >*)o)->operator->)();
}

static  void method_40285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Electron> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Electron> >*)o)->productTypeInfo)();
}

static  void method_40286( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<pat::Electron> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<pat::Electron> >*)o)->typeInfo)();
}

static void constructor_40287( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<pat::Electron> >((::std::vector<pat::Electron>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<pat::Electron> >((::std::vector<pat::Electron>*)arg[0]);
}

static  void method_40288( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<pat::Electron> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<pat::Electron> >*)o)->getInterface)();
}

static  void method_40289( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Electron> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_40290( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Electron> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_40291( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<pat::Electron> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_40292( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Electron> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<pat::Electron> >*)o)->dynamicTypeInfo)();
}

static  void method_40293( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<pat::Electron> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<pat::Electron> >*)o)->isPresent)();
}

static  void method_40294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<pat::Electron> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<pat::Electron> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6823( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Electron> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Electron> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Electron> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Electron> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<pat::Electron> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<pat::Electron, std::allocator<pat::Electron> > > -------------------------------
void __edm__Wrapper_std__vector_pat__Electron_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_pat__Electron_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Electron_s__datamem_bld(&__edm__Wrapper_std__vector_pat__Electron_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_pat__Electron_s__funcmem_bld(&__edm__Wrapper_std__vector_pat__Electron_s__db_funcmem);
void __edm__Wrapper_std__vector_pat__Electron_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<pat::Electron> >"), typeid(::edm::Wrapper<std::vector<pat::Electron> >), sizeof(::edm::Wrapper<std::vector<pat::Electron> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3520, Reflex::Literal("edm::Wrapper<std::vector<pat::Electron> >::value_type"))
  .AddTypedef(type_3520, Reflex::Literal("edm::Wrapper<std::vector<pat::Electron> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_40280, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3264), Reflex::Literal("Wrapper"), constructor_40281, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_40282, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71059), Reflex::Literal("Wrapper"), constructor_40287, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6823, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_pat__Electron_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_pat__Electron_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<pat::Electron, std::allocator<pat::Electron> > > -------------------
void __edm__Wrapper_std__vector_pat__Electron_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Electron_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3520, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_pat__Electron_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<pat::Electron, std::allocator<pat::Electron> > > -------------------
void __edm__Wrapper_std__vector_pat__Electron_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70776), Reflex::Literal("product"), method_40283, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70776), Reflex::Literal("operator->"), operator_40284, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_40285, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_40286, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71060), Reflex::Literal("getInterface"), method_40288, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_40289, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_40290, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_40291, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_40292, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_40293, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_40294, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class AtomicPtrCache<std::vector<reco::SuperCluster, std::allocator<reco::SuperCluster> > > -------------------------------
static void constructor_40862( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >();
  else ::new(mem) ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >();
}

static void constructor_40863( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >((::std::vector<reco::SuperCluster>*)arg[0]);
  else ::new(mem) ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >((::std::vector<reco::SuperCluster>*)arg[0]);
}

static void constructor_40864( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >(*(const ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)arg[0]);
  else ::new(mem) ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >(*(const ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)arg[0]);
}

static  void operator_40865( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->operator=)(*(const ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)arg[0]);
  else   (((::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->operator=)(*(const ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)arg[0]);
}

static void destructor_40866(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >::~AtomicPtrCache)();
}
static  void operator_40867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->operator->)());
  else   (((const ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->operator->)();
}

static  void operator_40868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->operator*)();
  else   (((const ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->operator*)();
}

static  void method_40869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->load)());
  else   (((const ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->load)();
}

static  void method_40870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->isSet)());
  else   (((const ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->isSet)();
}

static  void operator_40871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->operator->)());
  else   (((::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->operator->)();
}

static  void operator_40872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->operator*)();
  else   (((::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->operator*)();
}

static  void method_40873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->load)());
  else   (((::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->load)();
}

static  void method_40874( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >*)o)->reset)();
}

static void method_newdel_7117( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::AtomicPtrCache<std::vector<reco::SuperCluster> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class AtomicPtrCache<std::vector<reco::SuperCluster, std::allocator<reco::SuperCluster> > > -------------------------------
void __edm__AtomicPtrCache_std__vector_reco__SuperCluster_s__db_datamem(Reflex::Class*);
void __edm__AtomicPtrCache_std__vector_reco__SuperCluster_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__AtomicPtrCache_std__vector_reco__SuperCluster_s__datamem_bld(&__edm__AtomicPtrCache_std__vector_reco__SuperCluster_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__AtomicPtrCache_std__vector_reco__SuperCluster_s__funcmem_bld(&__edm__AtomicPtrCache_std__vector_reco__SuperCluster_s__db_funcmem);
void __edm__AtomicPtrCache_std__vector_reco__SuperCluster_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::AtomicPtrCache<std::vector<reco::SuperCluster> >"), typeid(::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >), sizeof(::edm::AtomicPtrCache<std::vector<reco::SuperCluster> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("AtomicPtrCache"), constructor_40862, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71770), Reflex::Literal("AtomicPtrCache"), constructor_40863, 0, "", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71771), Reflex::Literal("AtomicPtrCache"), constructor_40864, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~AtomicPtrCache"), destructor_40866, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7117, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__AtomicPtrCache_std__vector_reco__SuperCluster_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__AtomicPtrCache_std__vector_reco__SuperCluster_s__funcmem_bld);
}

//------Delayed data member builder for class AtomicPtrCache<std::vector<reco::SuperCluster, std::allocator<reco::SuperCluster> > > -------------------
void __edm__AtomicPtrCache_std__vector_reco__SuperCluster_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_71770, Reflex::Literal("m_data"), OffsetOf(__shadow__::__edm__AtomicPtrCache_std__vector_reco__SuperCluster_s_, m_data), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class AtomicPtrCache<std::vector<reco::SuperCluster, std::allocator<reco::SuperCluster> > > -------------------
void __edm__AtomicPtrCache_std__vector_reco__SuperCluster_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71772, type_71771), Reflex::Literal("operator="), operator_40865, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70905), Reflex::Literal("operator->"), operator_40867, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36142), Reflex::Literal("operator*"), operator_40868, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70905), Reflex::Literal("load"), method_40869, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isSet"), method_40870, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71770), Reflex::Literal("operator->"), operator_40871, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65104), Reflex::Literal("operator*"), operator_40872, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71770), Reflex::Literal("load"), method_40873, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("reset"), method_40874, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Ptr<pat::Tau> -------------------------------
static  void operator_41576( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<pat::Tau>*)o)->operator=)(*(const ::edm::Ptr<pat::Tau>*)arg[0]);
  else   (((::edm::Ptr<pat::Tau>*)o)->operator=)(*(const ::edm::Ptr<pat::Tau>*)arg[0]);
}

static void constructor_41577( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Tau>(*(const ::edm::Ptr<pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::Tau>(*(const ::edm::Ptr<pat::Tau>*)arg[0]);
}

static void constructor_41578( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Tau>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::Tau>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_41579( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Tau>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Tau*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::Tau>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Tau*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_41580( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Tau>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::Tau>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_41581( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Tau>();
  else ::new(mem) ::edm::Ptr<pat::Tau>();
}

static void destructor_41582(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<pat::Tau>*)o)->::edm::Ptr<pat::Tau>::~Ptr)();
}
static  void operator_41583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::Tau>*)o)->operator*)();
  else   (((const ::edm::Ptr<pat::Tau>*)o)->operator*)();
}

static  void operator_41584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Tau>*)o)->operator->)());
  else   (((const ::edm::Ptr<pat::Tau>*)o)->operator->)();
}

static  void method_41585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Tau>*)o)->get)());
  else   (((const ::edm::Ptr<pat::Tau>*)o)->get)();
}

static  void method_41586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Tau>*)o)->isNull)());
  else   (((const ::edm::Ptr<pat::Tau>*)o)->isNull)();
}

static  void method_41587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Tau>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<pat::Tau>*)o)->isNonnull)();
}

static  void operator_41588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Tau>*)o)->operator!)());
  else   (((const ::edm::Ptr<pat::Tau>*)o)->operator!)();
}

static  void method_41589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Tau>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<pat::Tau>*)o)->isAvailable)();
}

static  void method_41590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Tau>*)o)->isTransient)());
  else   (((const ::edm::Ptr<pat::Tau>*)o)->isTransient)();
}

static  void method_41591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<pat::Tau>*)o)->id)());
  else   (((const ::edm::Ptr<pat::Tau>*)o)->id)();
}

static  void method_41592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Tau>*)o)->productGetter)());
  else   (((const ::edm::Ptr<pat::Tau>*)o)->productGetter)();
}

static  void method_41593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<pat::Tau>*)o)->key)());
  else   (((const ::edm::Ptr<pat::Tau>*)o)->key)();
}

static  void method_41594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Tau>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<pat::Tau>*)o)->hasProductCache)();
}

static  void method_41595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::Tau>*)o)->refCore)();
  else   (((const ::edm::Ptr<pat::Tau>*)o)->refCore)();
}

static  void method_41596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Tau>*)o)->product)());
  else   (((const ::edm::Ptr<pat::Tau>*)o)->product)();
}

static  void method_41597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<pat::Tau>*)o)->Class_Version)());
  else   (((::edm::Ptr<pat::Tau>*)o)->Class_Version)();
}

static void method_newdel_7319( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<pat::Tau> -------------------------------
void __edm__Ptr_pat__Tau__db_datamem(Reflex::Class*);
void __edm__Ptr_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__Tau__datamem_bld(&__edm__Ptr_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__Tau__funcmem_bld(&__edm__Ptr_pat__Tau__db_funcmem);
void __edm__Ptr_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<pat::Tau>"), typeid(::edm::Ptr<pat::Tau>), sizeof(::edm::Ptr<pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<pat::Tau>::Class_Version())
  .AddTypedef(type_58, Reflex::Literal("edm::Ptr<pat::Tau>::key_type"))
  .AddTypedef(type_13568, Reflex::Literal("edm::Ptr<pat::Tau>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71943, type_71944), Reflex::Literal("operator="), operator_41576, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71944), Reflex::Literal("Ptr"), constructor_41577, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_58, type_35207), Reflex::Literal("Ptr"), constructor_41578, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17817, type_58), Reflex::Literal("Ptr"), constructor_41579, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ptr"), constructor_41580, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_41581, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_41582, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7319, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class Ptr<pat::Tau> -------------------
void __edm__Ptr_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7198, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_pat__Tau_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_58, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_pat__Tau_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<pat::Tau> -------------------
void __edm__Ptr_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17819), Reflex::Literal("operator*"), operator_41583, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17817), Reflex::Literal("operator->"), operator_41584, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17817), Reflex::Literal("get"), method_41585, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_41586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_41587, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_41588, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_41589, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_41590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_41591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_41592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_58), Reflex::Literal("key"), method_41593, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_41594, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_41595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_41596, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_41597, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<pat::Muon> -------------------------------
static  void operator_41604( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<pat::Muon>*)o)->operator=)(*(const ::edm::Ptr<pat::Muon>*)arg[0]);
  else   (((::edm::Ptr<pat::Muon>*)o)->operator=)(*(const ::edm::Ptr<pat::Muon>*)arg[0]);
}

static void constructor_41605( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Muon>(*(const ::edm::Ptr<pat::Muon>*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::Muon>(*(const ::edm::Ptr<pat::Muon>*)arg[0]);
}

static void constructor_41606( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Muon>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::Muon>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_41607( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Muon>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Muon*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::Muon>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Muon*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_41608( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Muon>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::Muon>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_41609( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Muon>();
  else ::new(mem) ::edm::Ptr<pat::Muon>();
}

static void destructor_41610(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<pat::Muon>*)o)->::edm::Ptr<pat::Muon>::~Ptr)();
}
static  void operator_41611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::Muon>*)o)->operator*)();
  else   (((const ::edm::Ptr<pat::Muon>*)o)->operator*)();
}

static  void operator_41612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Muon>*)o)->operator->)());
  else   (((const ::edm::Ptr<pat::Muon>*)o)->operator->)();
}

static  void method_41613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Muon>*)o)->get)());
  else   (((const ::edm::Ptr<pat::Muon>*)o)->get)();
}

static  void method_41614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Muon>*)o)->isNull)());
  else   (((const ::edm::Ptr<pat::Muon>*)o)->isNull)();
}

static  void method_41615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Muon>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<pat::Muon>*)o)->isNonnull)();
}

static  void operator_41616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Muon>*)o)->operator!)());
  else   (((const ::edm::Ptr<pat::Muon>*)o)->operator!)();
}

static  void method_41617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Muon>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<pat::Muon>*)o)->isAvailable)();
}

static  void method_41618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Muon>*)o)->isTransient)());
  else   (((const ::edm::Ptr<pat::Muon>*)o)->isTransient)();
}

static  void method_41619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<pat::Muon>*)o)->id)());
  else   (((const ::edm::Ptr<pat::Muon>*)o)->id)();
}

static  void method_41620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Muon>*)o)->productGetter)());
  else   (((const ::edm::Ptr<pat::Muon>*)o)->productGetter)();
}

static  void method_41621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<pat::Muon>*)o)->key)());
  else   (((const ::edm::Ptr<pat::Muon>*)o)->key)();
}

static  void method_41622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Muon>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<pat::Muon>*)o)->hasProductCache)();
}

static  void method_41623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::Muon>*)o)->refCore)();
  else   (((const ::edm::Ptr<pat::Muon>*)o)->refCore)();
}

static  void method_41624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Muon>*)o)->product)());
  else   (((const ::edm::Ptr<pat::Muon>*)o)->product)();
}

static  void method_41625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<pat::Muon>*)o)->Class_Version)());
  else   (((::edm::Ptr<pat::Muon>*)o)->Class_Version)();
}

static void method_newdel_7320( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Muon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Muon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Muon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Muon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Muon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<pat::Muon> -------------------------------
void __edm__Ptr_pat__Muon__db_datamem(Reflex::Class*);
void __edm__Ptr_pat__Muon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__Muon__datamem_bld(&__edm__Ptr_pat__Muon__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__Muon__funcmem_bld(&__edm__Ptr_pat__Muon__db_funcmem);
void __edm__Ptr_pat__Muon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<pat::Muon>"), typeid(::edm::Ptr<pat::Muon>), sizeof(::edm::Ptr<pat::Muon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<pat::Muon>::Class_Version())
  .AddTypedef(type_58, Reflex::Literal("edm::Ptr<pat::Muon>::key_type"))
  .AddTypedef(type_13465, Reflex::Literal("edm::Ptr<pat::Muon>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71945, type_71946), Reflex::Literal("operator="), operator_41604, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71946), Reflex::Literal("Ptr"), constructor_41605, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_58, type_35207), Reflex::Literal("Ptr"), constructor_41606, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17828, type_58), Reflex::Literal("Ptr"), constructor_41607, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ptr"), constructor_41608, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_41609, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_41610, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7320, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_pat__Muon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_pat__Muon__funcmem_bld);
}

//------Delayed data member builder for class Ptr<pat::Muon> -------------------
void __edm__Ptr_pat__Muon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7198, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_pat__Muon_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_58, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_pat__Muon_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<pat::Muon> -------------------
void __edm__Ptr_pat__Muon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17830), Reflex::Literal("operator*"), operator_41611, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17828), Reflex::Literal("operator->"), operator_41612, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17828), Reflex::Literal("get"), method_41613, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_41614, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_41615, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_41616, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_41617, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_41618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_41619, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_41620, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_58), Reflex::Literal("key"), method_41621, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_41622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_41623, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_41624, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_41625, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<pat::Conversion> -------------------------------
static  void operator_41632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<pat::Conversion>*)o)->operator=)(*(const ::edm::Ptr<pat::Conversion>*)arg[0]);
  else   (((::edm::Ptr<pat::Conversion>*)o)->operator=)(*(const ::edm::Ptr<pat::Conversion>*)arg[0]);
}

static void constructor_41633( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Conversion>(*(const ::edm::Ptr<pat::Conversion>*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::Conversion>(*(const ::edm::Ptr<pat::Conversion>*)arg[0]);
}

static void constructor_41634( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Conversion>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::Conversion>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_41635( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Conversion>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Conversion*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::Conversion>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Conversion*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_41636( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Conversion>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::Conversion>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_41637( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Conversion>();
  else ::new(mem) ::edm::Ptr<pat::Conversion>();
}

static void destructor_41638(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<pat::Conversion>*)o)->::edm::Ptr<pat::Conversion>::~Ptr)();
}
static  void operator_41639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::Conversion>*)o)->operator*)();
  else   (((const ::edm::Ptr<pat::Conversion>*)o)->operator*)();
}

static  void operator_41640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Conversion>*)o)->operator->)());
  else   (((const ::edm::Ptr<pat::Conversion>*)o)->operator->)();
}

static  void method_41641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Conversion>*)o)->get)());
  else   (((const ::edm::Ptr<pat::Conversion>*)o)->get)();
}

static  void method_41642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Conversion>*)o)->isNull)());
  else   (((const ::edm::Ptr<pat::Conversion>*)o)->isNull)();
}

static  void method_41643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Conversion>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<pat::Conversion>*)o)->isNonnull)();
}

static  void operator_41644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Conversion>*)o)->operator!)());
  else   (((const ::edm::Ptr<pat::Conversion>*)o)->operator!)();
}

static  void method_41645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Conversion>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<pat::Conversion>*)o)->isAvailable)();
}

static  void method_41646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Conversion>*)o)->isTransient)());
  else   (((const ::edm::Ptr<pat::Conversion>*)o)->isTransient)();
}

static  void method_41647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<pat::Conversion>*)o)->id)());
  else   (((const ::edm::Ptr<pat::Conversion>*)o)->id)();
}

static  void method_41648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Conversion>*)o)->productGetter)());
  else   (((const ::edm::Ptr<pat::Conversion>*)o)->productGetter)();
}

static  void method_41649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<pat::Conversion>*)o)->key)());
  else   (((const ::edm::Ptr<pat::Conversion>*)o)->key)();
}

static  void method_41650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Conversion>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<pat::Conversion>*)o)->hasProductCache)();
}

static  void method_41651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::Conversion>*)o)->refCore)();
  else   (((const ::edm::Ptr<pat::Conversion>*)o)->refCore)();
}

static  void method_41652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Conversion>*)o)->product)());
  else   (((const ::edm::Ptr<pat::Conversion>*)o)->product)();
}

static  void method_41653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<pat::Conversion>*)o)->Class_Version)());
  else   (((::edm::Ptr<pat::Conversion>*)o)->Class_Version)();
}

static void method_newdel_7321( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Conversion> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Conversion> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Conversion> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Conversion> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Conversion> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<pat::Conversion> -------------------------------
void __edm__Ptr_pat__Conversion__db_datamem(Reflex::Class*);
void __edm__Ptr_pat__Conversion__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__Conversion__datamem_bld(&__edm__Ptr_pat__Conversion__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__Conversion__funcmem_bld(&__edm__Ptr_pat__Conversion__db_funcmem);
void __edm__Ptr_pat__Conversion__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<pat::Conversion>"), typeid(::edm::Ptr<pat::Conversion>), sizeof(::edm::Ptr<pat::Conversion>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<pat::Conversion>::Class_Version())
  .AddTypedef(type_58, Reflex::Literal("edm::Ptr<pat::Conversion>::key_type"))
  .AddTypedef(type_13535, Reflex::Literal("edm::Ptr<pat::Conversion>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71947, type_71948), Reflex::Literal("operator="), operator_41632, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71948), Reflex::Literal("Ptr"), constructor_41633, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_58, type_35207), Reflex::Literal("Ptr"), constructor_41634, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17707, type_58), Reflex::Literal("Ptr"), constructor_41635, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ptr"), constructor_41636, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_41637, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_41638, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7321, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_pat__Conversion__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_pat__Conversion__funcmem_bld);
}

//------Delayed data member builder for class Ptr<pat::Conversion> -------------------
void __edm__Ptr_pat__Conversion__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7198, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_pat__Conversion_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_58, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_pat__Conversion_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<pat::Conversion> -------------------
void __edm__Ptr_pat__Conversion__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17709), Reflex::Literal("operator*"), operator_41639, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17707), Reflex::Literal("operator->"), operator_41640, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17707), Reflex::Literal("get"), method_41641, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_41642, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_41643, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_41644, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_41645, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_41646, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_41647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_41648, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_58), Reflex::Literal("key"), method_41649, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_41650, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_41651, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_41652, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_41653, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<pat::Electron> -------------------------------
static  void operator_41660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<pat::Electron>*)o)->operator=)(*(const ::edm::Ptr<pat::Electron>*)arg[0]);
  else   (((::edm::Ptr<pat::Electron>*)o)->operator=)(*(const ::edm::Ptr<pat::Electron>*)arg[0]);
}

static void constructor_41661( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Electron>(*(const ::edm::Ptr<pat::Electron>*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::Electron>(*(const ::edm::Ptr<pat::Electron>*)arg[0]);
}

static void constructor_41662( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Electron>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::Electron>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_41663( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Electron>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Electron*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::Electron>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Electron*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_41664( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Electron>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::Electron>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_41665( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Electron>();
  else ::new(mem) ::edm::Ptr<pat::Electron>();
}

static void destructor_41666(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<pat::Electron>*)o)->::edm::Ptr<pat::Electron>::~Ptr)();
}
static  void operator_41667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::Electron>*)o)->operator*)();
  else   (((const ::edm::Ptr<pat::Electron>*)o)->operator*)();
}

static  void operator_41668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Electron>*)o)->operator->)());
  else   (((const ::edm::Ptr<pat::Electron>*)o)->operator->)();
}

static  void method_41669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Electron>*)o)->get)());
  else   (((const ::edm::Ptr<pat::Electron>*)o)->get)();
}

static  void method_41670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Electron>*)o)->isNull)());
  else   (((const ::edm::Ptr<pat::Electron>*)o)->isNull)();
}

static  void method_41671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Electron>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<pat::Electron>*)o)->isNonnull)();
}

static  void operator_41672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Electron>*)o)->operator!)());
  else   (((const ::edm::Ptr<pat::Electron>*)o)->operator!)();
}

static  void method_41673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Electron>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<pat::Electron>*)o)->isAvailable)();
}

static  void method_41674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Electron>*)o)->isTransient)());
  else   (((const ::edm::Ptr<pat::Electron>*)o)->isTransient)();
}

static  void method_41675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<pat::Electron>*)o)->id)());
  else   (((const ::edm::Ptr<pat::Electron>*)o)->id)();
}

static  void method_41676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Electron>*)o)->productGetter)());
  else   (((const ::edm::Ptr<pat::Electron>*)o)->productGetter)();
}

static  void method_41677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<pat::Electron>*)o)->key)());
  else   (((const ::edm::Ptr<pat::Electron>*)o)->key)();
}

static  void method_41678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Electron>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<pat::Electron>*)o)->hasProductCache)();
}

static  void method_41679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::Electron>*)o)->refCore)();
  else   (((const ::edm::Ptr<pat::Electron>*)o)->refCore)();
}

static  void method_41680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Electron>*)o)->product)());
  else   (((const ::edm::Ptr<pat::Electron>*)o)->product)();
}

static  void method_41681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<pat::Electron>*)o)->Class_Version)());
  else   (((::edm::Ptr<pat::Electron>*)o)->Class_Version)();
}

static void method_newdel_7322( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Electron> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Electron> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Electron> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Electron> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Electron> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<pat::Electron> -------------------------------
void __edm__Ptr_pat__Electron__db_datamem(Reflex::Class*);
void __edm__Ptr_pat__Electron__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__Electron__datamem_bld(&__edm__Ptr_pat__Electron__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__Electron__funcmem_bld(&__edm__Ptr_pat__Electron__db_funcmem);
void __edm__Ptr_pat__Electron__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<pat::Electron>"), typeid(::edm::Ptr<pat::Electron>), sizeof(::edm::Ptr<pat::Electron>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<pat::Electron>::Class_Version())
  .AddTypedef(type_58, Reflex::Literal("edm::Ptr<pat::Electron>::key_type"))
  .AddTypedef(type_13576, Reflex::Literal("edm::Ptr<pat::Electron>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71949, type_71950), Reflex::Literal("operator="), operator_41660, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71950), Reflex::Literal("Ptr"), constructor_41661, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_58, type_35207), Reflex::Literal("Ptr"), constructor_41662, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17839, type_58), Reflex::Literal("Ptr"), constructor_41663, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ptr"), constructor_41664, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_41665, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_41666, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7322, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_pat__Electron__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_pat__Electron__funcmem_bld);
}

//------Delayed data member builder for class Ptr<pat::Electron> -------------------
void __edm__Ptr_pat__Electron__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7198, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_pat__Electron_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_58, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_pat__Electron_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<pat::Electron> -------------------
void __edm__Ptr_pat__Electron__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17841), Reflex::Literal("operator*"), operator_41667, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17839), Reflex::Literal("operator->"), operator_41668, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17839), Reflex::Literal("get"), method_41669, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_41670, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_41671, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_41672, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_41673, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_41674, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_41675, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_41676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_58), Reflex::Literal("key"), method_41677, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_41678, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_41679, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_41680, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_41681, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<pat::MET> -------------------------------
static  void operator_41688( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<pat::MET>*)o)->operator=)(*(const ::edm::Ptr<pat::MET>*)arg[0]);
  else   (((::edm::Ptr<pat::MET>*)o)->operator=)(*(const ::edm::Ptr<pat::MET>*)arg[0]);
}

static void constructor_41689( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::MET>(*(const ::edm::Ptr<pat::MET>*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::MET>(*(const ::edm::Ptr<pat::MET>*)arg[0]);
}

static void constructor_41690( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::MET>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::MET>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_41691( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::MET>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::MET*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::MET>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::MET*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_41692( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::MET>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::MET>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_41693( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::MET>();
  else ::new(mem) ::edm::Ptr<pat::MET>();
}

static void destructor_41694(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<pat::MET>*)o)->::edm::Ptr<pat::MET>::~Ptr)();
}
static  void operator_41695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::MET>*)o)->operator*)();
  else   (((const ::edm::Ptr<pat::MET>*)o)->operator*)();
}

static  void operator_41696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::MET>*)o)->operator->)());
  else   (((const ::edm::Ptr<pat::MET>*)o)->operator->)();
}

static  void method_41697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::MET>*)o)->get)());
  else   (((const ::edm::Ptr<pat::MET>*)o)->get)();
}

static  void method_41698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::MET>*)o)->isNull)());
  else   (((const ::edm::Ptr<pat::MET>*)o)->isNull)();
}

static  void method_41699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::MET>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<pat::MET>*)o)->isNonnull)();
}

static  void operator_41700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::MET>*)o)->operator!)());
  else   (((const ::edm::Ptr<pat::MET>*)o)->operator!)();
}

static  void method_41701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::MET>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<pat::MET>*)o)->isAvailable)();
}

static  void method_41702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::MET>*)o)->isTransient)());
  else   (((const ::edm::Ptr<pat::MET>*)o)->isTransient)();
}

static  void method_41703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<pat::MET>*)o)->id)());
  else   (((const ::edm::Ptr<pat::MET>*)o)->id)();
}

static  void method_41704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::MET>*)o)->productGetter)());
  else   (((const ::edm::Ptr<pat::MET>*)o)->productGetter)();
}

static  void method_41705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<pat::MET>*)o)->key)());
  else   (((const ::edm::Ptr<pat::MET>*)o)->key)();
}

static  void method_41706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::MET>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<pat::MET>*)o)->hasProductCache)();
}

static  void method_41707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::MET>*)o)->refCore)();
  else   (((const ::edm::Ptr<pat::MET>*)o)->refCore)();
}

static  void method_41708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::MET>*)o)->product)());
  else   (((const ::edm::Ptr<pat::MET>*)o)->product)();
}

static  void method_41709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<pat::MET>*)o)->Class_Version)());
  else   (((::edm::Ptr<pat::MET>*)o)->Class_Version)();
}

static void method_newdel_7323( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::MET> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::MET> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::MET> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::MET> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::MET> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<pat::MET> -------------------------------
void __edm__Ptr_pat__MET__db_datamem(Reflex::Class*);
void __edm__Ptr_pat__MET__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__MET__datamem_bld(&__edm__Ptr_pat__MET__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__MET__funcmem_bld(&__edm__Ptr_pat__MET__db_funcmem);
void __edm__Ptr_pat__MET__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<pat::MET>"), typeid(::edm::Ptr<pat::MET>), sizeof(::edm::Ptr<pat::MET>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<pat::MET>::Class_Version())
  .AddTypedef(type_58, Reflex::Literal("edm::Ptr<pat::MET>::key_type"))
  .AddTypedef(type_13544, Reflex::Literal("edm::Ptr<pat::MET>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71951, type_71952), Reflex::Literal("operator="), operator_41688, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71952), Reflex::Literal("Ptr"), constructor_41689, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_58, type_35207), Reflex::Literal("Ptr"), constructor_41690, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17784, type_58), Reflex::Literal("Ptr"), constructor_41691, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ptr"), constructor_41692, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_41693, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_41694, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7323, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_pat__MET__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_pat__MET__funcmem_bld);
}

//------Delayed data member builder for class Ptr<pat::MET> -------------------
void __edm__Ptr_pat__MET__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7198, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_pat__MET_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_58, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_pat__MET_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<pat::MET> -------------------
void __edm__Ptr_pat__MET__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17786), Reflex::Literal("operator*"), operator_41695, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17784), Reflex::Literal("operator->"), operator_41696, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17784), Reflex::Literal("get"), method_41697, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_41698, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_41699, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_41700, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_41701, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_41702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_41703, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_41704, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_58), Reflex::Literal("key"), method_41705, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_41706, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_41707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_41708, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_41709, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<pat::Jet> -------------------------------
static  void operator_41716( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<pat::Jet>*)o)->operator=)(*(const ::edm::Ptr<pat::Jet>*)arg[0]);
  else   (((::edm::Ptr<pat::Jet>*)o)->operator=)(*(const ::edm::Ptr<pat::Jet>*)arg[0]);
}

static void constructor_41717( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Jet>(*(const ::edm::Ptr<pat::Jet>*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::Jet>(*(const ::edm::Ptr<pat::Jet>*)arg[0]);
}

static void constructor_41718( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Jet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::Jet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_41719( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Jet>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Jet*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::Jet>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Jet*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_41720( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Jet>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::Jet>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_41721( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Jet>();
  else ::new(mem) ::edm::Ptr<pat::Jet>();
}

static void destructor_41722(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<pat::Jet>*)o)->::edm::Ptr<pat::Jet>::~Ptr)();
}
static  void operator_41723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::Jet>*)o)->operator*)();
  else   (((const ::edm::Ptr<pat::Jet>*)o)->operator*)();
}

static  void operator_41724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Jet>*)o)->operator->)());
  else   (((const ::edm::Ptr<pat::Jet>*)o)->operator->)();
}

static  void method_41725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Jet>*)o)->get)());
  else   (((const ::edm::Ptr<pat::Jet>*)o)->get)();
}

static  void method_41726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Jet>*)o)->isNull)());
  else   (((const ::edm::Ptr<pat::Jet>*)o)->isNull)();
}

static  void method_41727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Jet>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<pat::Jet>*)o)->isNonnull)();
}

static  void operator_41728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Jet>*)o)->operator!)());
  else   (((const ::edm::Ptr<pat::Jet>*)o)->operator!)();
}

static  void method_41729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Jet>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<pat::Jet>*)o)->isAvailable)();
}

static  void method_41730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Jet>*)o)->isTransient)());
  else   (((const ::edm::Ptr<pat::Jet>*)o)->isTransient)();
}

static  void method_41731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<pat::Jet>*)o)->id)());
  else   (((const ::edm::Ptr<pat::Jet>*)o)->id)();
}

static  void method_41732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Jet>*)o)->productGetter)());
  else   (((const ::edm::Ptr<pat::Jet>*)o)->productGetter)();
}

static  void method_41733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<pat::Jet>*)o)->key)());
  else   (((const ::edm::Ptr<pat::Jet>*)o)->key)();
}

static  void method_41734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Jet>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<pat::Jet>*)o)->hasProductCache)();
}

static  void method_41735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::Jet>*)o)->refCore)();
  else   (((const ::edm::Ptr<pat::Jet>*)o)->refCore)();
}

static  void method_41736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Jet>*)o)->product)());
  else   (((const ::edm::Ptr<pat::Jet>*)o)->product)();
}

static  void method_41737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<pat::Jet>*)o)->Class_Version)());
  else   (((::edm::Ptr<pat::Jet>*)o)->Class_Version)();
}

static void method_newdel_7324( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Jet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Jet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Jet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Jet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Jet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<pat::Jet> -------------------------------
void __edm__Ptr_pat__Jet__db_datamem(Reflex::Class*);
void __edm__Ptr_pat__Jet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__Jet__datamem_bld(&__edm__Ptr_pat__Jet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__Jet__funcmem_bld(&__edm__Ptr_pat__Jet__db_funcmem);
void __edm__Ptr_pat__Jet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<pat::Jet>"), typeid(::edm::Ptr<pat::Jet>), sizeof(::edm::Ptr<pat::Jet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<pat::Jet>::Class_Version())
  .AddTypedef(type_58, Reflex::Literal("edm::Ptr<pat::Jet>::key_type"))
  .AddTypedef(type_13487, Reflex::Literal("edm::Ptr<pat::Jet>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71953, type_71954), Reflex::Literal("operator="), operator_41716, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71954), Reflex::Literal("Ptr"), constructor_41717, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_58, type_35207), Reflex::Literal("Ptr"), constructor_41718, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17795, type_58), Reflex::Literal("Ptr"), constructor_41719, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ptr"), constructor_41720, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_41721, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_41722, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7324, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_pat__Jet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_pat__Jet__funcmem_bld);
}

//------Delayed data member builder for class Ptr<pat::Jet> -------------------
void __edm__Ptr_pat__Jet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7198, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_pat__Jet_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_58, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_pat__Jet_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<pat::Jet> -------------------
void __edm__Ptr_pat__Jet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17797), Reflex::Literal("operator*"), operator_41723, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17795), Reflex::Literal("operator->"), operator_41724, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17795), Reflex::Literal("get"), method_41725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_41726, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_41727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_41728, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_41729, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_41730, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_41731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_41732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_58), Reflex::Literal("key"), method_41733, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_41734, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_41735, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_41736, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_41737, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Lepton<reco::BaseTau> -------------------------------
static  void operator_60158( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::Lepton<reco::BaseTau>*)o)->operator=)(*(const ::pat::Lepton<reco::BaseTau>*)arg[0]);
  else   (((::pat::Lepton<reco::BaseTau>*)o)->operator=)(*(const ::pat::Lepton<reco::BaseTau>*)arg[0]);
}

static void constructor_60159( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Lepton<reco::BaseTau>(*(const ::pat::Lepton<reco::BaseTau>*)arg[0]);
  else ::new(mem) ::pat::Lepton<reco::BaseTau>(*(const ::pat::Lepton<reco::BaseTau>*)arg[0]);
}

static void constructor_60160( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Lepton<reco::BaseTau>();
  else ::new(mem) ::pat::Lepton<reco::BaseTau>();
}

static void constructor_60161( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Lepton<reco::BaseTau>(*(const ::reco::BaseTau*)arg[0]);
  else ::new(mem) ::pat::Lepton<reco::BaseTau>(*(const ::reco::BaseTau*)arg[0]);
}

static void constructor_60162( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Lepton<reco::BaseTau>(*(const ::edm::RefToBase<reco::BaseTau>*)arg[0]);
  else ::new(mem) ::pat::Lepton<reco::BaseTau>(*(const ::edm::RefToBase<reco::BaseTau>*)arg[0]);
}

static void constructor_60163( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Lepton<reco::BaseTau>(*(const ::edm::Ptr<reco::BaseTau>*)arg[0]);
  else ::new(mem) ::pat::Lepton<reco::BaseTau>(*(const ::edm::Ptr<reco::BaseTau>*)arg[0]);
}

static void destructor_60164(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::Lepton<reco::BaseTau>*)o)->::pat::Lepton<reco::BaseTau>::~Lepton)();
}
static  void method_60165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::BaseTau>*)o)->clone)());
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->clone)();
}

static  void method_60166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::BaseTau>*)o)->genLepton)());
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->genLepton)();
}

static  void method_60167( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::Lepton<reco::BaseTau>*)o)->setGenLepton)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::Lepton<reco::BaseTau>*)o)->setGenLepton)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_60168( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::BaseTau>*)o)->userIsolation)(*(::pat::IsolationKeys*)arg[0]));
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->userIsolation)(*(::pat::IsolationKeys*)arg[0]);
}

static  void method_60169( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::BaseTau>*)o)->userIsolation)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->userIsolation)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60170( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::BaseTau>*)o)->setIsolation)(*(::pat::IsolationKeys*)arg[0],
    *(float*)arg[1]);
}

static  void method_60171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::BaseTau>*)o)->trackIso)());
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->trackIso)();
}

static  void method_60172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::BaseTau>*)o)->caloIso)());
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->caloIso)();
}

static  void method_60173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::BaseTau>*)o)->ecalIso)());
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->ecalIso)();
}

static  void method_60174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::BaseTau>*)o)->hcalIso)());
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->hcalIso)();
}

static  void method_60175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::BaseTau>*)o)->particleIso)());
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->particleIso)();
}

static  void method_60176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::BaseTau>*)o)->chargedHadronIso)());
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->chargedHadronIso)();
}

static  void method_60177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::BaseTau>*)o)->neutralHadronIso)());
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->neutralHadronIso)();
}

static  void method_60178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::BaseTau>*)o)->photonIso)());
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->photonIso)();
}

static  void method_60179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::BaseTau>*)o)->puChargedHadronIso)());
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->puChargedHadronIso)();
}

static  void method_60180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::BaseTau>*)o)->userIso)());
    else     (((const ::pat::Lepton<reco::BaseTau>*)o)->userIso)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::BaseTau>*)o)->userIso)(*(::uint8_t*)arg[0]));
    else     (((const ::pat::Lepton<reco::BaseTau>*)o)->userIso)(*(::uint8_t*)arg[0]);
  }
}

static  void method_60181( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::BaseTau>*)o)->setTrackIso)(*(float*)arg[0]);
}

static  void method_60182( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::BaseTau>*)o)->setEcalIso)(*(float*)arg[0]);
}

static  void method_60183( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::BaseTau>*)o)->setHcalIso)(*(float*)arg[0]);
}

static  void method_60184( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::Lepton<reco::BaseTau>*)o)->setUserIso)(*(float*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::Lepton<reco::BaseTau>*)o)->setUserIso)(*(float*)arg[0],
      *(::uint8_t*)arg[1]);
  }
}

static  void method_60185( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::BaseTau>*)o)->isoDeposit)(*(::pat::IsolationKeys*)arg[0]));
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->isoDeposit)(*(::pat::IsolationKeys*)arg[0]);
}

static  void method_60186( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::BaseTau>*)o)->setIsoDeposit)(*(::pat::IsolationKeys*)arg[0],
    *(const ::pat::IsoDeposit*)arg[1]);
}

static  void method_60187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::BaseTau>*)o)->trackIsoDeposit)());
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->trackIsoDeposit)();
}

static  void method_60188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::BaseTau>*)o)->ecalIsoDeposit)());
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->ecalIsoDeposit)();
}

static  void method_60189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::BaseTau>*)o)->hcalIsoDeposit)());
  else   (((const ::pat::Lepton<reco::BaseTau>*)o)->hcalIsoDeposit)();
}

static  void method_60190( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::BaseTau>*)o)->userIsoDeposit)());
    else     (((const ::pat::Lepton<reco::BaseTau>*)o)->userIsoDeposit)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::BaseTau>*)o)->userIsoDeposit)(*(::uint8_t*)arg[0]));
    else     (((const ::pat::Lepton<reco::BaseTau>*)o)->userIsoDeposit)(*(::uint8_t*)arg[0]);
  }
}

static  void method_60191( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::BaseTau>*)o)->trackIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
}

static  void method_60192( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::BaseTau>*)o)->ecalIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
}

static  void method_60193( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::BaseTau>*)o)->hcalIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
}

static  void method_60194( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::Lepton<reco::BaseTau>*)o)->userIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::Lepton<reco::BaseTau>*)o)->userIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0],
      *(::uint8_t*)arg[1]);
  }
}

static void method_newdel_13528( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::Lepton<reco::BaseTau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::Lepton<reco::BaseTau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::Lepton<reco::BaseTau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::Lepton<reco::BaseTau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::Lepton<reco::BaseTau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x113( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::BaseTau>")), ::Reflex::BaseOffset< ::pat::Lepton<reco::BaseTau>,::pat::PATObject<reco::BaseTau> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::BaseTau")), ::Reflex::BaseOffset< ::pat::Lepton<reco::BaseTau>,::reco::BaseTau >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::pat::Lepton<reco::BaseTau>,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::Lepton<reco::BaseTau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::Lepton<reco::BaseTau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Lepton<reco::BaseTau> -------------------------------
void __pat__Lepton_reco__BaseTau__db_datamem(Reflex::Class*);
void __pat__Lepton_reco__BaseTau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__Lepton_reco__BaseTau__datamem_bld(&__pat__Lepton_reco__BaseTau__db_datamem);
Reflex::GenreflexMemberBuilder __pat__Lepton_reco__BaseTau__funcmem_bld(&__pat__Lepton_reco__BaseTau__db_funcmem);
void __pat__Lepton_reco__BaseTau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::Lepton<reco::BaseTau>"), typeid(::pat::Lepton<reco::BaseTau>), sizeof(::pat::Lepton<reco::BaseTau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_13553, ::Reflex::BaseOffset< ::pat::Lepton<reco::BaseTau>, ::pat::PATObject<reco::BaseTau> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3523, Reflex::Literal("pat::Lepton<reco::BaseTau>::IsoDepositPairs"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75133, type_75134), Reflex::Literal("operator="), operator_60158, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75134), Reflex::Literal("Lepton"), constructor_60159, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Lepton"), constructor_60160, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26889), Reflex::Literal("Lepton"), constructor_60161, 0, "aLepton", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71915), Reflex::Literal("Lepton"), constructor_60162, 0, "aLeptonRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71972), Reflex::Literal("Lepton"), constructor_60163, 0, "aLeptonRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Lepton"), destructor_60164, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13528, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x113, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__Lepton_reco__BaseTau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__Lepton_reco__BaseTau__funcmem_bld);
}

//------Delayed data member builder for class Lepton<reco::BaseTau> -------------------
void __pat__Lepton_reco__BaseTau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3523, Reflex::Literal("isoDeposits_"), OffsetOf(__shadow__::__pat__Lepton_reco__BaseTau_, isoDeposits_), ::Reflex::PROTECTED)
  .AddDataMember(type_3527, Reflex::Literal("isolations_"), OffsetOf(__shadow__::__pat__Lepton_reco__BaseTau_, isolations_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Lepton<reco::BaseTau> -------------------
void __pat__Lepton_reco__BaseTau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75135), Reflex::Literal("clone"), method_60165, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22220), Reflex::Literal("genLepton"), method_60166, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938, type_1810), Reflex::Literal("setGenLepton"), method_60167, 0, "gl;embed=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_13493), Reflex::Literal("userIsolation"), method_60168, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_18052), Reflex::Literal("userIsolation"), method_60169, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_13493, type_990), Reflex::Literal("setIsolation"), method_60170, 0, "key;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("trackIso"), method_60171, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("caloIso"), method_60172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("ecalIso"), method_60173, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("hcalIso"), method_60174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("particleIso"), method_60175, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("chargedHadronIso"), method_60176, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("neutralHadronIso"), method_60177, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("photonIso"), method_60178, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("puChargedHadronIso"), method_60179, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_2051), Reflex::Literal("userIso"), method_60180, 0, "index=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setTrackIso"), method_60181, 0, "trackIso", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setEcalIso"), method_60182, 0, "caloIso", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setHcalIso"), method_60183, 0, "caloIso", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990, type_2051), Reflex::Literal("setUserIso"), method_60184, 0, "value;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131, type_13493), Reflex::Literal("isoDeposit"), method_60185, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_13493, type_75132), Reflex::Literal("setIsoDeposit"), method_60186, 0, "key;dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131), Reflex::Literal("trackIsoDeposit"), method_60187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131), Reflex::Literal("ecalIsoDeposit"), method_60188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131), Reflex::Literal("hcalIsoDeposit"), method_60189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131, type_2051), Reflex::Literal("userIsoDeposit"), method_60190, 0, "index=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132), Reflex::Literal("trackIsoDeposit"), method_60191, 0, "dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132), Reflex::Literal("ecalIsoDeposit"), method_60192, 0, "dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132), Reflex::Literal("hcalIsoDeposit"), method_60193, 0, "dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132, type_2051), Reflex::Literal("userIsoDeposit"), method_60194, 0, "dep;index=0", ::Reflex::PUBLIC);
}
//------Stub functions for class Lepton<reco::Muon> -------------------------------
static  void operator_60198( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::Lepton<reco::Muon>*)o)->operator=)(*(const ::pat::Lepton<reco::Muon>*)arg[0]);
  else   (((::pat::Lepton<reco::Muon>*)o)->operator=)(*(const ::pat::Lepton<reco::Muon>*)arg[0]);
}

static void constructor_60199( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Lepton<reco::Muon>(*(const ::pat::Lepton<reco::Muon>*)arg[0]);
  else ::new(mem) ::pat::Lepton<reco::Muon>(*(const ::pat::Lepton<reco::Muon>*)arg[0]);
}

static void constructor_60200( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Lepton<reco::Muon>();
  else ::new(mem) ::pat::Lepton<reco::Muon>();
}

static void constructor_60201( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Lepton<reco::Muon>(*(const ::reco::Muon*)arg[0]);
  else ::new(mem) ::pat::Lepton<reco::Muon>(*(const ::reco::Muon*)arg[0]);
}

static void constructor_60202( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Lepton<reco::Muon>(*(const ::edm::RefToBase<reco::Muon>*)arg[0]);
  else ::new(mem) ::pat::Lepton<reco::Muon>(*(const ::edm::RefToBase<reco::Muon>*)arg[0]);
}

static void constructor_60203( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Lepton<reco::Muon>(*(const ::edm::Ptr<reco::Muon>*)arg[0]);
  else ::new(mem) ::pat::Lepton<reco::Muon>(*(const ::edm::Ptr<reco::Muon>*)arg[0]);
}

static void destructor_60204(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::Lepton<reco::Muon>*)o)->::pat::Lepton<reco::Muon>::~Lepton)();
}
static  void method_60205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::Muon>*)o)->clone)());
  else   (((const ::pat::Lepton<reco::Muon>*)o)->clone)();
}

static  void method_60206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::Muon>*)o)->genLepton)());
  else   (((const ::pat::Lepton<reco::Muon>*)o)->genLepton)();
}

static  void method_60207( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::Lepton<reco::Muon>*)o)->setGenLepton)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::Lepton<reco::Muon>*)o)->setGenLepton)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_60208( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::Muon>*)o)->userIsolation)(*(::pat::IsolationKeys*)arg[0]));
  else   (((const ::pat::Lepton<reco::Muon>*)o)->userIsolation)(*(::pat::IsolationKeys*)arg[0]);
}

static  void method_60209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::Muon>*)o)->userIsolation)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::Lepton<reco::Muon>*)o)->userIsolation)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60210( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::Muon>*)o)->setIsolation)(*(::pat::IsolationKeys*)arg[0],
    *(float*)arg[1]);
}

static  void method_60211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::Muon>*)o)->trackIso)());
  else   (((const ::pat::Lepton<reco::Muon>*)o)->trackIso)();
}

static  void method_60212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::Muon>*)o)->caloIso)());
  else   (((const ::pat::Lepton<reco::Muon>*)o)->caloIso)();
}

static  void method_60213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::Muon>*)o)->ecalIso)());
  else   (((const ::pat::Lepton<reco::Muon>*)o)->ecalIso)();
}

static  void method_60214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::Muon>*)o)->hcalIso)());
  else   (((const ::pat::Lepton<reco::Muon>*)o)->hcalIso)();
}

static  void method_60215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::Muon>*)o)->particleIso)());
  else   (((const ::pat::Lepton<reco::Muon>*)o)->particleIso)();
}

static  void method_60216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::Muon>*)o)->chargedHadronIso)());
  else   (((const ::pat::Lepton<reco::Muon>*)o)->chargedHadronIso)();
}

static  void method_60217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::Muon>*)o)->neutralHadronIso)());
  else   (((const ::pat::Lepton<reco::Muon>*)o)->neutralHadronIso)();
}

static  void method_60218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::Muon>*)o)->photonIso)());
  else   (((const ::pat::Lepton<reco::Muon>*)o)->photonIso)();
}

static  void method_60219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::Muon>*)o)->puChargedHadronIso)());
  else   (((const ::pat::Lepton<reco::Muon>*)o)->puChargedHadronIso)();
}

static  void method_60220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::Muon>*)o)->userIso)());
    else     (((const ::pat::Lepton<reco::Muon>*)o)->userIso)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::Muon>*)o)->userIso)(*(::uint8_t*)arg[0]));
    else     (((const ::pat::Lepton<reco::Muon>*)o)->userIso)(*(::uint8_t*)arg[0]);
  }
}

static  void method_60221( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::Muon>*)o)->setTrackIso)(*(float*)arg[0]);
}

static  void method_60222( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::Muon>*)o)->setEcalIso)(*(float*)arg[0]);
}

static  void method_60223( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::Muon>*)o)->setHcalIso)(*(float*)arg[0]);
}

static  void method_60224( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::Lepton<reco::Muon>*)o)->setUserIso)(*(float*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::Lepton<reco::Muon>*)o)->setUserIso)(*(float*)arg[0],
      *(::uint8_t*)arg[1]);
  }
}

static  void method_60225( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::Muon>*)o)->isoDeposit)(*(::pat::IsolationKeys*)arg[0]));
  else   (((const ::pat::Lepton<reco::Muon>*)o)->isoDeposit)(*(::pat::IsolationKeys*)arg[0]);
}

static  void method_60226( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::Muon>*)o)->setIsoDeposit)(*(::pat::IsolationKeys*)arg[0],
    *(const ::pat::IsoDeposit*)arg[1]);
}

static  void method_60227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::Muon>*)o)->trackIsoDeposit)());
  else   (((const ::pat::Lepton<reco::Muon>*)o)->trackIsoDeposit)();
}

static  void method_60228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::Muon>*)o)->ecalIsoDeposit)());
  else   (((const ::pat::Lepton<reco::Muon>*)o)->ecalIsoDeposit)();
}

static  void method_60229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::Muon>*)o)->hcalIsoDeposit)());
  else   (((const ::pat::Lepton<reco::Muon>*)o)->hcalIsoDeposit)();
}

static  void method_60230( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::Muon>*)o)->userIsoDeposit)());
    else     (((const ::pat::Lepton<reco::Muon>*)o)->userIsoDeposit)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::Muon>*)o)->userIsoDeposit)(*(::uint8_t*)arg[0]));
    else     (((const ::pat::Lepton<reco::Muon>*)o)->userIsoDeposit)(*(::uint8_t*)arg[0]);
  }
}

static  void method_60231( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::Muon>*)o)->trackIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
}

static  void method_60232( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::Muon>*)o)->ecalIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
}

static  void method_60233( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::Muon>*)o)->hcalIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
}

static  void method_60234( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::Lepton<reco::Muon>*)o)->userIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::Lepton<reco::Muon>*)o)->userIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0],
      *(::uint8_t*)arg[1]);
  }
}

static void method_newdel_13529( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::Lepton<reco::Muon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::Lepton<reco::Muon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::Lepton<reco::Muon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::Lepton<reco::Muon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::Lepton<reco::Muon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x115( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::Muon>")), ::Reflex::BaseOffset< ::pat::Lepton<reco::Muon>,::pat::PATObject<reco::Muon> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Muon")), ::Reflex::BaseOffset< ::pat::Lepton<reco::Muon>,::reco::Muon >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::pat::Lepton<reco::Muon>,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::Lepton<reco::Muon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::Lepton<reco::Muon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Lepton<reco::Muon> -------------------------------
void __pat__Lepton_reco__Muon__db_datamem(Reflex::Class*);
void __pat__Lepton_reco__Muon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__Lepton_reco__Muon__datamem_bld(&__pat__Lepton_reco__Muon__db_datamem);
Reflex::GenreflexMemberBuilder __pat__Lepton_reco__Muon__funcmem_bld(&__pat__Lepton_reco__Muon__db_funcmem);
void __pat__Lepton_reco__Muon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::Lepton<reco::Muon>"), typeid(::pat::Lepton<reco::Muon>), sizeof(::pat::Lepton<reco::Muon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_13554, ::Reflex::BaseOffset< ::pat::Lepton<reco::Muon>, ::pat::PATObject<reco::Muon> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3523, Reflex::Literal("pat::Lepton<reco::Muon>::IsoDepositPairs"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75136, type_75137), Reflex::Literal("operator="), operator_60198, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75137), Reflex::Literal("Lepton"), constructor_60199, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Lepton"), constructor_60200, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27924), Reflex::Literal("Lepton"), constructor_60201, 0, "aLepton", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71920), Reflex::Literal("Lepton"), constructor_60202, 0, "aLeptonRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71976), Reflex::Literal("Lepton"), constructor_60203, 0, "aLeptonRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Lepton"), destructor_60204, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13529, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x115, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__Lepton_reco__Muon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__Lepton_reco__Muon__funcmem_bld);
}

//------Delayed data member builder for class Lepton<reco::Muon> -------------------
void __pat__Lepton_reco__Muon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3523, Reflex::Literal("isoDeposits_"), OffsetOf(__shadow__::__pat__Lepton_reco__Muon_, isoDeposits_), ::Reflex::PROTECTED)
  .AddDataMember(type_3527, Reflex::Literal("isolations_"), OffsetOf(__shadow__::__pat__Lepton_reco__Muon_, isolations_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Lepton<reco::Muon> -------------------
void __pat__Lepton_reco__Muon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75138), Reflex::Literal("clone"), method_60205, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22220), Reflex::Literal("genLepton"), method_60206, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938, type_1810), Reflex::Literal("setGenLepton"), method_60207, 0, "gl;embed=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_13493), Reflex::Literal("userIsolation"), method_60208, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_18052), Reflex::Literal("userIsolation"), method_60209, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_13493, type_990), Reflex::Literal("setIsolation"), method_60210, 0, "key;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("trackIso"), method_60211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("caloIso"), method_60212, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("ecalIso"), method_60213, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("hcalIso"), method_60214, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("particleIso"), method_60215, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("chargedHadronIso"), method_60216, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("neutralHadronIso"), method_60217, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("photonIso"), method_60218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("puChargedHadronIso"), method_60219, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_2051), Reflex::Literal("userIso"), method_60220, 0, "index=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setTrackIso"), method_60221, 0, "trackIso", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setEcalIso"), method_60222, 0, "caloIso", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setHcalIso"), method_60223, 0, "caloIso", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990, type_2051), Reflex::Literal("setUserIso"), method_60224, 0, "value;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131, type_13493), Reflex::Literal("isoDeposit"), method_60225, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_13493, type_75132), Reflex::Literal("setIsoDeposit"), method_60226, 0, "key;dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131), Reflex::Literal("trackIsoDeposit"), method_60227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131), Reflex::Literal("ecalIsoDeposit"), method_60228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131), Reflex::Literal("hcalIsoDeposit"), method_60229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131, type_2051), Reflex::Literal("userIsoDeposit"), method_60230, 0, "index=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132), Reflex::Literal("trackIsoDeposit"), method_60231, 0, "dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132), Reflex::Literal("ecalIsoDeposit"), method_60232, 0, "dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132), Reflex::Literal("hcalIsoDeposit"), method_60233, 0, "dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132, type_2051), Reflex::Literal("userIsoDeposit"), method_60234, 0, "dep;index=0", ::Reflex::PUBLIC);
}
//------Stub functions for class Lepton<reco::GsfElectron> -------------------------------
static  void operator_60238( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::Lepton<reco::GsfElectron>*)o)->operator=)(*(const ::pat::Lepton<reco::GsfElectron>*)arg[0]);
  else   (((::pat::Lepton<reco::GsfElectron>*)o)->operator=)(*(const ::pat::Lepton<reco::GsfElectron>*)arg[0]);
}

static void constructor_60239( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Lepton<reco::GsfElectron>(*(const ::pat::Lepton<reco::GsfElectron>*)arg[0]);
  else ::new(mem) ::pat::Lepton<reco::GsfElectron>(*(const ::pat::Lepton<reco::GsfElectron>*)arg[0]);
}

static void constructor_60240( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Lepton<reco::GsfElectron>();
  else ::new(mem) ::pat::Lepton<reco::GsfElectron>();
}

static void constructor_60241( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Lepton<reco::GsfElectron>(*(const ::reco::GsfElectron*)arg[0]);
  else ::new(mem) ::pat::Lepton<reco::GsfElectron>(*(const ::reco::GsfElectron*)arg[0]);
}

static void constructor_60242( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Lepton<reco::GsfElectron>(*(const ::edm::RefToBase<reco::GsfElectron>*)arg[0]);
  else ::new(mem) ::pat::Lepton<reco::GsfElectron>(*(const ::edm::RefToBase<reco::GsfElectron>*)arg[0]);
}

static void constructor_60243( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::Lepton<reco::GsfElectron>(*(const ::edm::Ptr<reco::GsfElectron>*)arg[0]);
  else ::new(mem) ::pat::Lepton<reco::GsfElectron>(*(const ::edm::Ptr<reco::GsfElectron>*)arg[0]);
}

static void destructor_60244(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::Lepton<reco::GsfElectron>*)o)->::pat::Lepton<reco::GsfElectron>::~Lepton)();
}
static  void method_60245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::GsfElectron>*)o)->clone)());
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->clone)();
}

static  void method_60246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::GsfElectron>*)o)->genLepton)());
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->genLepton)();
}

static  void method_60247( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::Lepton<reco::GsfElectron>*)o)->setGenLepton)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::Lepton<reco::GsfElectron>*)o)->setGenLepton)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_60248( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::GsfElectron>*)o)->userIsolation)(*(::pat::IsolationKeys*)arg[0]));
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->userIsolation)(*(::pat::IsolationKeys*)arg[0]);
}

static  void method_60249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::GsfElectron>*)o)->userIsolation)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->userIsolation)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60250( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::GsfElectron>*)o)->setIsolation)(*(::pat::IsolationKeys*)arg[0],
    *(float*)arg[1]);
}

static  void method_60251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::GsfElectron>*)o)->trackIso)());
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->trackIso)();
}

static  void method_60252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::GsfElectron>*)o)->caloIso)());
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->caloIso)();
}

static  void method_60253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::GsfElectron>*)o)->ecalIso)());
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->ecalIso)();
}

static  void method_60254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::GsfElectron>*)o)->hcalIso)());
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->hcalIso)();
}

static  void method_60255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::GsfElectron>*)o)->particleIso)());
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->particleIso)();
}

static  void method_60256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::GsfElectron>*)o)->chargedHadronIso)());
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->chargedHadronIso)();
}

static  void method_60257( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::GsfElectron>*)o)->neutralHadronIso)());
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->neutralHadronIso)();
}

static  void method_60258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::GsfElectron>*)o)->photonIso)());
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->photonIso)();
}

static  void method_60259( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::GsfElectron>*)o)->puChargedHadronIso)());
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->puChargedHadronIso)();
}

static  void method_60260( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::GsfElectron>*)o)->userIso)());
    else     (((const ::pat::Lepton<reco::GsfElectron>*)o)->userIso)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::pat::Lepton<reco::GsfElectron>*)o)->userIso)(*(::uint8_t*)arg[0]));
    else     (((const ::pat::Lepton<reco::GsfElectron>*)o)->userIso)(*(::uint8_t*)arg[0]);
  }
}

static  void method_60261( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::GsfElectron>*)o)->setTrackIso)(*(float*)arg[0]);
}

static  void method_60262( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::GsfElectron>*)o)->setEcalIso)(*(float*)arg[0]);
}

static  void method_60263( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::GsfElectron>*)o)->setHcalIso)(*(float*)arg[0]);
}

static  void method_60264( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::Lepton<reco::GsfElectron>*)o)->setUserIso)(*(float*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::Lepton<reco::GsfElectron>*)o)->setUserIso)(*(float*)arg[0],
      *(::uint8_t*)arg[1]);
  }
}

static  void method_60265( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::GsfElectron>*)o)->isoDeposit)(*(::pat::IsolationKeys*)arg[0]));
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->isoDeposit)(*(::pat::IsolationKeys*)arg[0]);
}

static  void method_60266( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::GsfElectron>*)o)->setIsoDeposit)(*(::pat::IsolationKeys*)arg[0],
    *(const ::pat::IsoDeposit*)arg[1]);
}

static  void method_60267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::GsfElectron>*)o)->trackIsoDeposit)());
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->trackIsoDeposit)();
}

static  void method_60268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::GsfElectron>*)o)->ecalIsoDeposit)());
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->ecalIsoDeposit)();
}

static  void method_60269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::GsfElectron>*)o)->hcalIsoDeposit)());
  else   (((const ::pat::Lepton<reco::GsfElectron>*)o)->hcalIsoDeposit)();
}

static  void method_60270( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::GsfElectron>*)o)->userIsoDeposit)());
    else     (((const ::pat::Lepton<reco::GsfElectron>*)o)->userIsoDeposit)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::Lepton<reco::GsfElectron>*)o)->userIsoDeposit)(*(::uint8_t*)arg[0]));
    else     (((const ::pat::Lepton<reco::GsfElectron>*)o)->userIsoDeposit)(*(::uint8_t*)arg[0]);
  }
}

static  void method_60271( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::GsfElectron>*)o)->trackIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
}

static  void method_60272( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::GsfElectron>*)o)->ecalIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
}

static  void method_60273( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::Lepton<reco::GsfElectron>*)o)->hcalIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
}

static  void method_60274( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::Lepton<reco::GsfElectron>*)o)->userIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::Lepton<reco::GsfElectron>*)o)->userIsoDeposit)(*(const ::pat::IsoDeposit*)arg[0],
      *(::uint8_t*)arg[1]);
  }
}

static void method_newdel_13530( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::Lepton<reco::GsfElectron> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::Lepton<reco::GsfElectron> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::Lepton<reco::GsfElectron> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::Lepton<reco::GsfElectron> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::Lepton<reco::GsfElectron> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x117( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::GsfElectron>")), ::Reflex::BaseOffset< ::pat::Lepton<reco::GsfElectron>,::pat::PATObject<reco::GsfElectron> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::GsfElectron")), ::Reflex::BaseOffset< ::pat::Lepton<reco::GsfElectron>,::reco::GsfElectron >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::pat::Lepton<reco::GsfElectron>,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::Lepton<reco::GsfElectron>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::Lepton<reco::GsfElectron>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Lepton<reco::GsfElectron> -------------------------------
void __pat__Lepton_reco__GsfElectron__db_datamem(Reflex::Class*);
void __pat__Lepton_reco__GsfElectron__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__Lepton_reco__GsfElectron__datamem_bld(&__pat__Lepton_reco__GsfElectron__db_datamem);
Reflex::GenreflexMemberBuilder __pat__Lepton_reco__GsfElectron__funcmem_bld(&__pat__Lepton_reco__GsfElectron__db_funcmem);
void __pat__Lepton_reco__GsfElectron__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::Lepton<reco::GsfElectron>"), typeid(::pat::Lepton<reco::GsfElectron>), sizeof(::pat::Lepton<reco::GsfElectron>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_13555, ::Reflex::BaseOffset< ::pat::Lepton<reco::GsfElectron>, ::pat::PATObject<reco::GsfElectron> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3523, Reflex::Literal("pat::Lepton<reco::GsfElectron>::IsoDepositPairs"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75139, type_75140), Reflex::Literal("operator="), operator_60238, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75140), Reflex::Literal("Lepton"), constructor_60239, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Lepton"), constructor_60240, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29540), Reflex::Literal("Lepton"), constructor_60241, 0, "aLepton", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71925), Reflex::Literal("Lepton"), constructor_60242, 0, "aLeptonRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71978), Reflex::Literal("Lepton"), constructor_60243, 0, "aLeptonRef", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Lepton"), destructor_60244, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13530, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x117, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__Lepton_reco__GsfElectron__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__Lepton_reco__GsfElectron__funcmem_bld);
}

//------Delayed data member builder for class Lepton<reco::GsfElectron> -------------------
void __pat__Lepton_reco__GsfElectron__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3523, Reflex::Literal("isoDeposits_"), OffsetOf(__shadow__::__pat__Lepton_reco__GsfElectron_, isoDeposits_), ::Reflex::PROTECTED)
  .AddDataMember(type_3527, Reflex::Literal("isolations_"), OffsetOf(__shadow__::__pat__Lepton_reco__GsfElectron_, isolations_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Lepton<reco::GsfElectron> -------------------
void __pat__Lepton_reco__GsfElectron__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75141), Reflex::Literal("clone"), method_60245, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22220), Reflex::Literal("genLepton"), method_60246, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938, type_1810), Reflex::Literal("setGenLepton"), method_60247, 0, "gl;embed=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_13493), Reflex::Literal("userIsolation"), method_60248, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_18052), Reflex::Literal("userIsolation"), method_60249, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_13493, type_990), Reflex::Literal("setIsolation"), method_60250, 0, "key;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("trackIso"), method_60251, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("caloIso"), method_60252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("ecalIso"), method_60253, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("hcalIso"), method_60254, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("particleIso"), method_60255, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("chargedHadronIso"), method_60256, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("neutralHadronIso"), method_60257, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("photonIso"), method_60258, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990), Reflex::Literal("puChargedHadronIso"), method_60259, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_2051), Reflex::Literal("userIso"), method_60260, 0, "index=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setTrackIso"), method_60261, 0, "trackIso", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setEcalIso"), method_60262, 0, "caloIso", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990), Reflex::Literal("setHcalIso"), method_60263, 0, "caloIso", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_990, type_2051), Reflex::Literal("setUserIso"), method_60264, 0, "value;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131, type_13493), Reflex::Literal("isoDeposit"), method_60265, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_13493, type_75132), Reflex::Literal("setIsoDeposit"), method_60266, 0, "key;dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131), Reflex::Literal("trackIsoDeposit"), method_60267, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131), Reflex::Literal("ecalIsoDeposit"), method_60268, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131), Reflex::Literal("hcalIsoDeposit"), method_60269, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75131, type_2051), Reflex::Literal("userIsoDeposit"), method_60270, 0, "index=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132), Reflex::Literal("trackIsoDeposit"), method_60271, 0, "dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132), Reflex::Literal("ecalIsoDeposit"), method_60272, 0, "dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132), Reflex::Literal("hcalIsoDeposit"), method_60273, 0, "dep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75132, type_2051), Reflex::Literal("userIsoDeposit"), method_60274, 0, "dep;index=0", ::Reflex::PUBLIC);
}
//------Stub functions for class PATObject<reco::RecoCandidate> -------------------------------
static  void operator_60615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::PATObject<reco::RecoCandidate>*)o)->operator=)(*(const ::pat::PATObject<reco::RecoCandidate>*)arg[0]);
  else   (((::pat::PATObject<reco::RecoCandidate>*)o)->operator=)(*(const ::pat::PATObject<reco::RecoCandidate>*)arg[0]);
}

static void destructor_60621(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::PATObject<reco::RecoCandidate>*)o)->::pat::PATObject<reco::RecoCandidate>::~PATObject)();
}
static  void method_60622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->originalObject)());
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->originalObject)();
}

static  void method_60623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::RecoCandidate>*)o)->originalObjectRef)();
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->originalObjectRef)();
}

static  void method_60624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatches)();
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatches)();
}

static  void method_60625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatch)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatch)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]);
  }
}

static  void method_60626( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
}

static  void method_60627( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]);
}

static  void method_60628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]);
}

static  void method_60629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60630( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60633( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]);
}

static  void method_60634( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60635( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60636( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]);
}

static  void method_60638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60639( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60640( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_60641( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_60642( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_60643( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_60644( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_60645( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_60646( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_60647( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_60648( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60649( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]);
}

static  void method_60650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60651( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60652( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_60653( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_60654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_60655( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_60656( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_60657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_60658( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_60659( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_60660( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::RecoCandidate>*)o)->addTriggerObjectMatch)(*(const ::pat::TriggerObjectStandAlone*)arg[0]);
}

static  void method_60661( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::RecoCandidate>*)o)->unpackTriggerObjectPathNames)(*(const ::edm::TriggerNames*)arg[0]);
}

static  void method_60662( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::RecoCandidate>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,pat::LookupTableRecord> >)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->efficiencies)());
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->efficiencies)();
}

static  void method_60664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::RecoCandidate>*)o)->efficiencyNames)();
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->efficiencyNames)();
}

static  void method_60665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::RecoCandidate>*)o)->efficiencyValues)();
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->efficiencyValues)();
}

static  void method_60666( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::RecoCandidate>*)o)->setEfficiency)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::pat::LookupTableRecord*)arg[1]);
}

static  void method_60667( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticleRef)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticleRef)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticleRef)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticleRef)(*(::size_t*)arg[0]);
  }
}

static  void method_60668( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]);
  }
}

static  void method_60669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticle)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticle)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticle)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticle)(*(::size_t*)arg[0]);
  }
}

static  void method_60670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticlesSize)());
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticlesSize)();
}

static  void method_60671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > >)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticleRefs)());
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->genParticleRefs)();
}

static  void method_60672( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::RecoCandidate>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::RecoCandidate>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_60673( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::RecoCandidate>*)o)->addGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
}

static  void method_60674( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::RecoCandidate>*)o)->setGenParticle)(*(const ::reco::GenParticle*)arg[0]);
}

static  void method_60675( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::PATObject<reco::RecoCandidate>*)o)->embedGenParticle)();
}

static  void method_60676( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60677( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::RecoCandidate>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::RecoCandidate>*)o)->overlapLabels)();
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->overlapLabels)();
}

static  void method_60679( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::RecoCandidate>*)o)->setOverlaps)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::PtrVector<reco::Candidate>*)arg[1]);
}

static  void method_60680( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::RecoCandidate>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::RecoCandidate>*)o)->userDataNames)();
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->userDataNames)();
}

static  void method_60683( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::RecoCandidate>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60684( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::RecoCandidate>*)o)->addUserDataFromPtr)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<pat::UserData>*)arg[1]);
}

static  void method_60685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60686( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->userFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->userFloat)((const char*)arg[0]);
}

static  void method_60687( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::RecoCandidate>*)o)->addUserFloat)(*(const ::std::basic_string<char>*)arg[0],
    *(float*)arg[1]);
}

static  void method_60688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::RecoCandidate>*)o)->userFloatNames)();
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->userFloatNames)();
}

static  void method_60689( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60690( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasUserFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasUserFloat)((const char*)arg[0]);
}

static  void method_60691( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60692( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::RecoCandidate>*)o)->addUserInt)(*(const ::std::basic_string<char>*)arg[0],
    *(int*)arg[1]);
}

static  void method_60693( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::RecoCandidate>*)o)->userIntNames)();
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->userIntNames)();
}

static  void method_60694( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60695( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60696( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::RecoCandidate>*)o)->addUserCand)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<reco::Candidate>*)arg[1]);
}

static  void method_60697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::RecoCandidate>*)o)->userCandNames)();
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->userCandNames)();
}

static  void method_60698( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60699( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::RecoCandidate>*)o)->getKinResolution)();
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->getKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::RecoCandidate>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60700( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasKinResolution)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60701( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::RecoCandidate>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::RecoCandidate>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
}

static  void method_60702( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolEta)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolEta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60703( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolTheta)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolTheta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60704( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPhi)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPhi)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolE)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolE)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60706( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolEt)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolEt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60707( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolP)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolP)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60708( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPt)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60709( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPInv)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPInv)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60710( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPx)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPx)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60711( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPy)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPy)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60712( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPz)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPz)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60713( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolM)());
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolM)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::RecoCandidate>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static void method_x118( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::RecoCandidate>,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::RecoCandidate>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::RecoCandidate>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATObject<reco::RecoCandidate> -------------------------------
void __pat__PATObject_reco__RecoCandidate__db_datamem(Reflex::Class*);
void __pat__PATObject_reco__RecoCandidate__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__RecoCandidate__datamem_bld(&__pat__PATObject_reco__RecoCandidate__db_datamem);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__RecoCandidate__funcmem_bld(&__pat__PATObject_reco__RecoCandidate__db_funcmem);
void __pat__PATObject_reco__RecoCandidate__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::PATObject<reco::RecoCandidate>"), typeid(::pat::PATObject<reco::RecoCandidate>), sizeof(::pat::PATObject<reco::RecoCandidate>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_11424, ::Reflex::BaseOffset< ::pat::PATObject<reco::RecoCandidate>, ::reco::RecoCandidate >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_11424, Reflex::Literal("pat::PATObject<reco::RecoCandidate>::base_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75166, type_75167), Reflex::Literal("operator="), operator_60615, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATObject"), destructor_60621, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x118, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__PATObject_reco__RecoCandidate__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__PATObject_reco__RecoCandidate__funcmem_bld);
}

//------Delayed data member builder for class PATObject<reco::RecoCandidate> -------------------
void __pat__PATObject_reco__RecoCandidate__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7325, Reflex::Literal("refToOrig_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, refToOrig_), ::Reflex::PROTECTED)
  .AddDataMember(type_3536, Reflex::Literal("triggerObjectMatchesEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, triggerObjectMatchesEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3535, Reflex::Literal("efficiencyValues_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, efficiencyValues_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("efficiencyNames_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, efficiencyNames_), ::Reflex::PROTECTED)
  .AddDataMember(type_3534, Reflex::Literal("genParticleRef_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, genParticleRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_3533, Reflex::Literal("genParticleEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, genParticleEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("overlapLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, overlapLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3532, Reflex::Literal("overlapItems_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, overlapItems_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userDataLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, userDataLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_7463, Reflex::Literal("userDataObjects_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, userDataObjects_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userFloatLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, userFloatLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3527, Reflex::Literal("userFloats_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, userFloats_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userIntLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, userIntLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3531, Reflex::Literal("userInts_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, userInts_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userCandLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, userCandLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3530, Reflex::Literal("userCands_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, userCands_), ::Reflex::PROTECTED)
  .AddDataMember(type_3529, Reflex::Literal("kinResolutions_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, kinResolutions_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("kinResolutionLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__RecoCandidate_, kinResolutionLabels_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class PATObject<reco::RecoCandidate> -------------------
void __pat__PATObject_reco__RecoCandidate__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("originalObject"), method_60622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22032), Reflex::Literal("originalObjectRef"), method_60623, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35967), Reflex::Literal("triggerObjectMatches"), method_60624, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_2393c), Reflex::Literal("triggerObjectMatch"), method_60625, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_13634c), Reflex::Literal("triggerObjectMatchesByType"), method_60626, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByType"), method_60627, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByFilterID"), method_60628, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_13634c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_60629, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_60630, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByFilterID"), method_60631, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCollection"), method_60632, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCollection"), method_60633, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_60634, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_60635, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCondition"), method_60636, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCondition"), method_60637, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_60638, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_60639, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_60640, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_60641, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_60642, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_60643, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_60644, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_60645, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_60646, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_60647, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByFilter"), method_60648, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByFilter"), method_60649, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_60650, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_60651, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_60652, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_60653, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_60654, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_60655, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_60656, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_60657, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_60658, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_60659, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22412), Reflex::Literal("addTriggerObjectMatch"), method_60660, 0, "trigObj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75115), Reflex::Literal("unpackTriggerObjectPathNames"), method_60661, 0, "names", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17959, type_18052), Reflex::Literal("efficiency"), method_60662, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3537), Reflex::Literal("efficiencies"), method_60663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("efficiencyNames"), method_60664, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65126), Reflex::Literal("efficiencyValues"), method_60665, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_17959), Reflex::Literal("setEfficiency"), method_60666, 0, "name;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_2393), Reflex::Literal("genParticleRef"), method_60667, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_72, type_72, type_2051), Reflex::Literal("genParticleById"), method_60668, 0, "pdgId;status;autoCharge=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22220, type_2393), Reflex::Literal("genParticle"), method_60669, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("genParticlesSize"), method_60670, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3534), Reflex::Literal("genParticleRefs"), method_60671, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938, type_1810), Reflex::Literal("setGenParticleRef"), method_60672, 0, "ref;embed=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938), Reflex::Literal("addGenParticleRef"), method_60673, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22224), Reflex::Literal("setGenParticle"), method_60674, 0, "particle", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedGenParticle"), method_60675, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasOverlaps"), method_60676, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22159, type_18052), Reflex::Literal("overlaps"), method_60677, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("overlapLabels"), method_60678, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22159), Reflex::Literal("setOverlaps"), method_60679, 0, "label;overlaps", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserData"), method_60680, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18052, type_18052), Reflex::Literal("userDataObjectType"), method_60681, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userDataNames"), method_60682, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416, type_18052), Reflex::Literal("userDataBare"), method_60683, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_71958), Reflex::Literal("addUserDataFromPtr"), method_60684, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_18052), Reflex::Literal("userFloat"), method_60685, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_4688), Reflex::Literal("userFloat"), method_60686, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_990), Reflex::Literal("addUserFloat"), method_60687, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userFloatNames"), method_60688, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserFloat"), method_60689, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_4688), Reflex::Literal("hasUserFloat"), method_60690, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_18052), Reflex::Literal("userInt"), method_60691, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_72), Reflex::Literal("addUserInt"), method_60692, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userIntNames"), method_60693, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserInt"), method_60694, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7325, type_18052), Reflex::Literal("userCand"), method_60695, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22032), Reflex::Literal("addUserCand"), method_60696, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userCandNames"), method_60697, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserCand"), method_60698, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21967, type_18052), Reflex::Literal("getKinResolution"), method_60699, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasKinResolution"), method_60700, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_21967, type_18052), Reflex::Literal("setKinResolution"), method_60701, 0, "resol;label=\"\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEta"), method_60702, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolTheta"), method_60703, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPhi"), method_60704, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolE"), method_60705, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEt"), method_60706, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolP"), method_60707, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPt"), method_60708, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPInv"), method_60709, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPx"), method_60710, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPy"), method_60711, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPz"), method_60712, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolM"), method_60713, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PATObject<reco::PFCandidate> -------------------------------
static  void operator_60734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::PATObject<reco::PFCandidate>*)o)->operator=)(*(const ::pat::PATObject<reco::PFCandidate>*)arg[0]);
  else   (((::pat::PATObject<reco::PFCandidate>*)o)->operator=)(*(const ::pat::PATObject<reco::PFCandidate>*)arg[0]);
}

static void constructor_60735( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::PFCandidate>(*(const ::pat::PATObject<reco::PFCandidate>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::PFCandidate>(*(const ::pat::PATObject<reco::PFCandidate>*)arg[0]);
}

static void constructor_60736( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::PFCandidate>();
  else ::new(mem) ::pat::PATObject<reco::PFCandidate>();
}

static void constructor_60737( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::PFCandidate>(*(const ::reco::PFCandidate*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::PFCandidate>(*(const ::reco::PFCandidate*)arg[0]);
}

static void constructor_60738( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::PFCandidate>(*(const ::edm::RefToBase<reco::PFCandidate>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::PFCandidate>(*(const ::edm::RefToBase<reco::PFCandidate>*)arg[0]);
}

static void constructor_60739( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::PFCandidate>(*(const ::edm::Ptr<reco::PFCandidate>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::PFCandidate>(*(const ::edm::Ptr<reco::PFCandidate>*)arg[0]);
}

static void destructor_60740(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::PATObject<reco::PFCandidate>*)o)->::pat::PATObject<reco::PFCandidate>::~PATObject)();
}
static  void method_60741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->originalObject)());
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->originalObject)();
}

static  void method_60742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::PFCandidate>*)o)->originalObjectRef)();
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->originalObjectRef)();
}

static  void method_60743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatches)();
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatches)();
}

static  void method_60744( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatch)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatch)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]);
  }
}

static  void method_60745( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
}

static  void method_60746( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]);
}

static  void method_60747( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]);
}

static  void method_60748( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60749( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60750( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60751( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60752( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]);
}

static  void method_60753( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60754( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60755( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60756( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]);
}

static  void method_60757( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60758( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60759( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_60760( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_60761( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_60762( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_60763( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_60764( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_60765( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_60766( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_60767( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60768( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]);
}

static  void method_60769( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60770( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_60772( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_60773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_60774( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_60775( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_60776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_60777( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_60778( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_60779( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::PFCandidate>*)o)->addTriggerObjectMatch)(*(const ::pat::TriggerObjectStandAlone*)arg[0]);
}

static  void method_60780( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::PFCandidate>*)o)->unpackTriggerObjectPathNames)(*(const ::edm::TriggerNames*)arg[0]);
}

static  void method_60781( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::PFCandidate>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,pat::LookupTableRecord> >)((((const ::pat::PATObject<reco::PFCandidate>*)o)->efficiencies)());
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->efficiencies)();
}

static  void method_60783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::PFCandidate>*)o)->efficiencyNames)();
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->efficiencyNames)();
}

static  void method_60784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::PFCandidate>*)o)->efficiencyValues)();
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->efficiencyValues)();
}

static  void method_60785( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::PFCandidate>*)o)->setEfficiency)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::pat::LookupTableRecord*)arg[1]);
}

static  void method_60786( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticleRef)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticleRef)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticleRef)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticleRef)(*(::size_t*)arg[0]);
  }
}

static  void method_60787( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]);
  }
}

static  void method_60788( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticle)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticle)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticle)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticle)(*(::size_t*)arg[0]);
  }
}

static  void method_60789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticlesSize)());
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticlesSize)();
}

static  void method_60790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > >)((((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticleRefs)());
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->genParticleRefs)();
}

static  void method_60791( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::PFCandidate>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::PFCandidate>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_60792( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::PFCandidate>*)o)->addGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
}

static  void method_60793( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::PFCandidate>*)o)->setGenParticle)(*(const ::reco::GenParticle*)arg[0]);
}

static  void method_60794( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::PATObject<reco::PFCandidate>*)o)->embedGenParticle)();
}

static  void method_60795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::PFCandidate>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::PFCandidate>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::PFCandidate>*)o)->overlapLabels)();
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->overlapLabels)();
}

static  void method_60798( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::PFCandidate>*)o)->setOverlaps)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::PtrVector<reco::Candidate>*)arg[1]);
}

static  void method_60799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::PFCandidate>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60800( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::PFCandidate>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::PFCandidate>*)o)->userDataNames)();
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->userDataNames)();
}

static  void method_60802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::PFCandidate>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60803( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::PFCandidate>*)o)->addUserDataFromPtr)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<pat::UserData>*)arg[1]);
}

static  void method_60804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::PFCandidate>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::PFCandidate>*)o)->userFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->userFloat)((const char*)arg[0]);
}

static  void method_60806( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::PFCandidate>*)o)->addUserFloat)(*(const ::std::basic_string<char>*)arg[0],
    *(float*)arg[1]);
}

static  void method_60807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::PFCandidate>*)o)->userFloatNames)();
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->userFloatNames)();
}

static  void method_60808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::PFCandidate>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60809( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::PFCandidate>*)o)->hasUserFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->hasUserFloat)((const char*)arg[0]);
}

static  void method_60810( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PATObject<reco::PFCandidate>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60811( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::PFCandidate>*)o)->addUserInt)(*(const ::std::basic_string<char>*)arg[0],
    *(int*)arg[1]);
}

static  void method_60812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::PFCandidate>*)o)->userIntNames)();
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->userIntNames)();
}

static  void method_60813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::PFCandidate>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::pat::PATObject<reco::PFCandidate>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60815( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::PFCandidate>*)o)->addUserCand)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<reco::Candidate>*)arg[1]);
}

static  void method_60816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::PFCandidate>*)o)->userCandNames)();
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->userCandNames)();
}

static  void method_60817( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::PFCandidate>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::PFCandidate>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60818( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::PFCandidate>*)o)->getKinResolution)();
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->getKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::PFCandidate>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60819( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::PFCandidate>*)o)->hasKinResolution)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->hasKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::PFCandidate>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60820( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::PFCandidate>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::PFCandidate>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
}

static  void method_60821( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolEta)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolEta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60822( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolTheta)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolTheta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60823( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPhi)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPhi)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60824( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolE)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolE)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60825( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolEt)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolEt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60826( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolP)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolP)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60827( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPt)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60828( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPInv)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPInv)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60829( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPx)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPx)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60830( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPy)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPy)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60831( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPz)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPz)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60832( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolM)());
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolM)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::PFCandidate>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::PFCandidate>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static void method_newdel_13547( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::PFCandidate> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::PFCandidate> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::PFCandidate> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::PFCandidate> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::PFCandidate> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x120( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::PFCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::PFCandidate>,::reco::PFCandidate >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::CompositeCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::PFCandidate>,::reco::CompositeCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::PFCandidate>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::PFCandidate>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATObject<reco::PFCandidate> -------------------------------
void __pat__PATObject_reco__PFCandidate__db_datamem(Reflex::Class*);
void __pat__PATObject_reco__PFCandidate__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__PFCandidate__datamem_bld(&__pat__PATObject_reco__PFCandidate__db_datamem);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__PFCandidate__funcmem_bld(&__pat__PATObject_reco__PFCandidate__db_funcmem);
void __pat__PATObject_reco__PFCandidate__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::PATObject<reco::PFCandidate>"), typeid(::pat::PATObject<reco::PFCandidate>), sizeof(::pat::PATObject<reco::PFCandidate>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_11602, ::Reflex::BaseOffset< ::pat::PATObject<reco::PFCandidate>, ::reco::PFCandidate >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_11602, Reflex::Literal("pat::PATObject<reco::PFCandidate>::base_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75168, type_75169), Reflex::Literal("operator="), operator_60734, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75169), Reflex::Literal("PATObject"), constructor_60735, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATObject"), constructor_60736, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23124), Reflex::Literal("PATObject"), constructor_60737, 0, "obj", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71877), Reflex::Literal("PATObject"), constructor_60738, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23707), Reflex::Literal("PATObject"), constructor_60739, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATObject"), destructor_60740, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13547, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x120, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__PATObject_reco__PFCandidate__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__PATObject_reco__PFCandidate__funcmem_bld);
}

//------Delayed data member builder for class PATObject<reco::PFCandidate> -------------------
void __pat__PATObject_reco__PFCandidate__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7325, Reflex::Literal("refToOrig_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, refToOrig_), ::Reflex::PROTECTED)
  .AddDataMember(type_3536, Reflex::Literal("triggerObjectMatchesEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, triggerObjectMatchesEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3535, Reflex::Literal("efficiencyValues_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, efficiencyValues_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("efficiencyNames_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, efficiencyNames_), ::Reflex::PROTECTED)
  .AddDataMember(type_3534, Reflex::Literal("genParticleRef_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, genParticleRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_3533, Reflex::Literal("genParticleEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, genParticleEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("overlapLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, overlapLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3532, Reflex::Literal("overlapItems_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, overlapItems_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userDataLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, userDataLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_7463, Reflex::Literal("userDataObjects_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, userDataObjects_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userFloatLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, userFloatLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3527, Reflex::Literal("userFloats_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, userFloats_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userIntLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, userIntLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3531, Reflex::Literal("userInts_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, userInts_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userCandLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, userCandLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3530, Reflex::Literal("userCands_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, userCands_), ::Reflex::PROTECTED)
  .AddDataMember(type_3529, Reflex::Literal("kinResolutions_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, kinResolutions_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("kinResolutionLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__PFCandidate_, kinResolutionLabels_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class PATObject<reco::PFCandidate> -------------------
void __pat__PATObject_reco__PFCandidate__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("originalObject"), method_60741, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22032), Reflex::Literal("originalObjectRef"), method_60742, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35967), Reflex::Literal("triggerObjectMatches"), method_60743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_2393c), Reflex::Literal("triggerObjectMatch"), method_60744, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_13634c), Reflex::Literal("triggerObjectMatchesByType"), method_60745, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByType"), method_60746, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByFilterID"), method_60747, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_13634c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_60748, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_60749, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByFilterID"), method_60750, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCollection"), method_60751, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCollection"), method_60752, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_60753, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_60754, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCondition"), method_60755, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCondition"), method_60756, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_60757, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_60758, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_60759, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_60760, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_60761, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_60762, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_60763, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_60764, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_60765, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_60766, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByFilter"), method_60767, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByFilter"), method_60768, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_60769, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_60770, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_60771, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_60772, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_60773, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_60774, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_60775, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_60776, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_60777, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_60778, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22412), Reflex::Literal("addTriggerObjectMatch"), method_60779, 0, "trigObj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75115), Reflex::Literal("unpackTriggerObjectPathNames"), method_60780, 0, "names", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17959, type_18052), Reflex::Literal("efficiency"), method_60781, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3537), Reflex::Literal("efficiencies"), method_60782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("efficiencyNames"), method_60783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65126), Reflex::Literal("efficiencyValues"), method_60784, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_17959), Reflex::Literal("setEfficiency"), method_60785, 0, "name;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_2393), Reflex::Literal("genParticleRef"), method_60786, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_72, type_72, type_2051), Reflex::Literal("genParticleById"), method_60787, 0, "pdgId;status;autoCharge=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22220, type_2393), Reflex::Literal("genParticle"), method_60788, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("genParticlesSize"), method_60789, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3534), Reflex::Literal("genParticleRefs"), method_60790, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938, type_1810), Reflex::Literal("setGenParticleRef"), method_60791, 0, "ref;embed=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938), Reflex::Literal("addGenParticleRef"), method_60792, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22224), Reflex::Literal("setGenParticle"), method_60793, 0, "particle", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedGenParticle"), method_60794, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasOverlaps"), method_60795, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22159, type_18052), Reflex::Literal("overlaps"), method_60796, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("overlapLabels"), method_60797, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22159), Reflex::Literal("setOverlaps"), method_60798, 0, "label;overlaps", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserData"), method_60799, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18052, type_18052), Reflex::Literal("userDataObjectType"), method_60800, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userDataNames"), method_60801, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416, type_18052), Reflex::Literal("userDataBare"), method_60802, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_71958), Reflex::Literal("addUserDataFromPtr"), method_60803, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_18052), Reflex::Literal("userFloat"), method_60804, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_4688), Reflex::Literal("userFloat"), method_60805, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_990), Reflex::Literal("addUserFloat"), method_60806, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userFloatNames"), method_60807, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserFloat"), method_60808, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_4688), Reflex::Literal("hasUserFloat"), method_60809, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_18052), Reflex::Literal("userInt"), method_60810, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_72), Reflex::Literal("addUserInt"), method_60811, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userIntNames"), method_60812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserInt"), method_60813, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7325, type_18052), Reflex::Literal("userCand"), method_60814, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22032), Reflex::Literal("addUserCand"), method_60815, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userCandNames"), method_60816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserCand"), method_60817, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21967, type_18052), Reflex::Literal("getKinResolution"), method_60818, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasKinResolution"), method_60819, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_21967, type_18052), Reflex::Literal("setKinResolution"), method_60820, 0, "resol;label=\"\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEta"), method_60821, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolTheta"), method_60822, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPhi"), method_60823, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolE"), method_60824, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEt"), method_60825, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolP"), method_60826, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPt"), method_60827, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPInv"), method_60828, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPx"), method_60829, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPy"), method_60830, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPz"), method_60831, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolM"), method_60832, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PATObject<reco::CompositeCandidate> -------------------------------
static  void operator_60853( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::PATObject<reco::CompositeCandidate>*)o)->operator=)(*(const ::pat::PATObject<reco::CompositeCandidate>*)arg[0]);
  else   (((::pat::PATObject<reco::CompositeCandidate>*)o)->operator=)(*(const ::pat::PATObject<reco::CompositeCandidate>*)arg[0]);
}

static void constructor_60854( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::CompositeCandidate>(*(const ::pat::PATObject<reco::CompositeCandidate>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::CompositeCandidate>(*(const ::pat::PATObject<reco::CompositeCandidate>*)arg[0]);
}

static void constructor_60855( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::CompositeCandidate>();
  else ::new(mem) ::pat::PATObject<reco::CompositeCandidate>();
}

static void constructor_60856( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::CompositeCandidate>(*(const ::reco::CompositeCandidate*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::CompositeCandidate>(*(const ::reco::CompositeCandidate*)arg[0]);
}

static void constructor_60857( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::CompositeCandidate>(*(const ::edm::RefToBase<reco::CompositeCandidate>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::CompositeCandidate>(*(const ::edm::RefToBase<reco::CompositeCandidate>*)arg[0]);
}

static void constructor_60858( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::CompositeCandidate>(*(const ::edm::Ptr<reco::CompositeCandidate>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::CompositeCandidate>(*(const ::edm::Ptr<reco::CompositeCandidate>*)arg[0]);
}

static void destructor_60859(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::PATObject<reco::CompositeCandidate>*)o)->::pat::PATObject<reco::CompositeCandidate>::~PATObject)();
}
static  void method_60860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->originalObject)());
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->originalObject)();
}

static  void method_60861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::CompositeCandidate>*)o)->originalObjectRef)();
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->originalObjectRef)();
}

static  void method_60862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatches)();
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatches)();
}

static  void method_60863( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatch)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatch)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]);
  }
}

static  void method_60864( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
}

static  void method_60865( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]);
}

static  void method_60866( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]);
}

static  void method_60867( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60868( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60869( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60870( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]);
}

static  void method_60872( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60873( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60874( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60875( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]);
}

static  void method_60876( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_60879( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_60880( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_60881( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_60882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_60883( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_60884( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_60885( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_60886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60887( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]);
}

static  void method_60888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60890( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_60891( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_60892( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_60893( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_60894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_60895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_60896( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_60897( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_60898( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::CompositeCandidate>*)o)->addTriggerObjectMatch)(*(const ::pat::TriggerObjectStandAlone*)arg[0]);
}

static  void method_60899( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::CompositeCandidate>*)o)->unpackTriggerObjectPathNames)(*(const ::edm::TriggerNames*)arg[0]);
}

static  void method_60900( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::CompositeCandidate>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,pat::LookupTableRecord> >)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->efficiencies)());
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->efficiencies)();
}

static  void method_60902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::CompositeCandidate>*)o)->efficiencyNames)();
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->efficiencyNames)();
}

static  void method_60903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::CompositeCandidate>*)o)->efficiencyValues)();
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->efficiencyValues)();
}

static  void method_60904( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::CompositeCandidate>*)o)->setEfficiency)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::pat::LookupTableRecord*)arg[1]);
}

static  void method_60905( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticleRef)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticleRef)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticleRef)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticleRef)(*(::size_t*)arg[0]);
  }
}

static  void method_60906( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]);
  }
}

static  void method_60907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticle)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticle)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticle)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticle)(*(::size_t*)arg[0]);
  }
}

static  void method_60908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticlesSize)());
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticlesSize)();
}

static  void method_60909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > >)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticleRefs)());
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->genParticleRefs)();
}

static  void method_60910( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::CompositeCandidate>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::CompositeCandidate>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_60911( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::CompositeCandidate>*)o)->addGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
}

static  void method_60912( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::CompositeCandidate>*)o)->setGenParticle)(*(const ::reco::GenParticle*)arg[0]);
}

static  void method_60913( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::PATObject<reco::CompositeCandidate>*)o)->embedGenParticle)();
}

static  void method_60914( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60915( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::CompositeCandidate>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::CompositeCandidate>*)o)->overlapLabels)();
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->overlapLabels)();
}

static  void method_60917( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::CompositeCandidate>*)o)->setOverlaps)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::PtrVector<reco::Candidate>*)arg[1]);
}

static  void method_60918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userDataNames)();
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userDataNames)();
}

static  void method_60921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60922( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::CompositeCandidate>*)o)->addUserDataFromPtr)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<pat::UserData>*)arg[1]);
}

static  void method_60923( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userFloat)((const char*)arg[0]);
}

static  void method_60925( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::CompositeCandidate>*)o)->addUserFloat)(*(const ::std::basic_string<char>*)arg[0],
    *(float*)arg[1]);
}

static  void method_60926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userFloatNames)();
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userFloatNames)();
}

static  void method_60927( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60928( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasUserFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasUserFloat)((const char*)arg[0]);
}

static  void method_60929( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60930( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::CompositeCandidate>*)o)->addUserInt)(*(const ::std::basic_string<char>*)arg[0],
    *(int*)arg[1]);
}

static  void method_60931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userIntNames)();
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userIntNames)();
}

static  void method_60932( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60933( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60934( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::CompositeCandidate>*)o)->addUserCand)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<reco::Candidate>*)arg[1]);
}

static  void method_60935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userCandNames)();
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->userCandNames)();
}

static  void method_60936( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60937( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::CompositeCandidate>*)o)->getKinResolution)();
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->getKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::CompositeCandidate>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60938( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasKinResolution)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60939( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::CompositeCandidate>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::CompositeCandidate>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
}

static  void method_60940( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolEta)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolEta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60941( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolTheta)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolTheta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPhi)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPhi)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60943( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolE)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolE)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60944( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolEt)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolEt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60945( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolP)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolP)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60946( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPt)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60947( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPInv)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPInv)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60948( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPx)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPx)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPy)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPy)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60950( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPz)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPz)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_60951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolM)());
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolM)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::CompositeCandidate>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static void method_newdel_13548( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::CompositeCandidate> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::CompositeCandidate> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::CompositeCandidate> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::CompositeCandidate> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::CompositeCandidate> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x122( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::CompositeCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::CompositeCandidate>,::reco::CompositeCandidate >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::CompositeCandidate>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::CompositeCandidate>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATObject<reco::CompositeCandidate> -------------------------------
void __pat__PATObject_reco__CompositeCandidate__db_datamem(Reflex::Class*);
void __pat__PATObject_reco__CompositeCandidate__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__CompositeCandidate__datamem_bld(&__pat__PATObject_reco__CompositeCandidate__db_datamem);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__CompositeCandidate__funcmem_bld(&__pat__PATObject_reco__CompositeCandidate__db_funcmem);
void __pat__PATObject_reco__CompositeCandidate__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::PATObject<reco::CompositeCandidate>"), typeid(::pat::PATObject<reco::CompositeCandidate>), sizeof(::pat::PATObject<reco::CompositeCandidate>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_11585, ::Reflex::BaseOffset< ::pat::PATObject<reco::CompositeCandidate>, ::reco::CompositeCandidate >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_11585, Reflex::Literal("pat::PATObject<reco::CompositeCandidate>::base_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75170, type_75171), Reflex::Literal("operator="), operator_60853, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75171), Reflex::Literal("PATObject"), constructor_60854, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATObject"), constructor_60855, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28501), Reflex::Literal("PATObject"), constructor_60856, 0, "obj", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71882), Reflex::Literal("PATObject"), constructor_60857, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71961), Reflex::Literal("PATObject"), constructor_60858, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATObject"), destructor_60859, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13548, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x122, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__PATObject_reco__CompositeCandidate__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__PATObject_reco__CompositeCandidate__funcmem_bld);
}

//------Delayed data member builder for class PATObject<reco::CompositeCandidate> -------------------
void __pat__PATObject_reco__CompositeCandidate__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7325, Reflex::Literal("refToOrig_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, refToOrig_), ::Reflex::PROTECTED)
  .AddDataMember(type_3536, Reflex::Literal("triggerObjectMatchesEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, triggerObjectMatchesEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3535, Reflex::Literal("efficiencyValues_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, efficiencyValues_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("efficiencyNames_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, efficiencyNames_), ::Reflex::PROTECTED)
  .AddDataMember(type_3534, Reflex::Literal("genParticleRef_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, genParticleRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_3533, Reflex::Literal("genParticleEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, genParticleEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("overlapLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, overlapLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3532, Reflex::Literal("overlapItems_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, overlapItems_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userDataLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, userDataLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_7463, Reflex::Literal("userDataObjects_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, userDataObjects_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userFloatLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, userFloatLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3527, Reflex::Literal("userFloats_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, userFloats_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userIntLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, userIntLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3531, Reflex::Literal("userInts_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, userInts_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userCandLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, userCandLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3530, Reflex::Literal("userCands_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, userCands_), ::Reflex::PROTECTED)
  .AddDataMember(type_3529, Reflex::Literal("kinResolutions_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, kinResolutions_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("kinResolutionLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__CompositeCandidate_, kinResolutionLabels_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class PATObject<reco::CompositeCandidate> -------------------
void __pat__PATObject_reco__CompositeCandidate__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("originalObject"), method_60860, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22032), Reflex::Literal("originalObjectRef"), method_60861, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35967), Reflex::Literal("triggerObjectMatches"), method_60862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_2393c), Reflex::Literal("triggerObjectMatch"), method_60863, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_13634c), Reflex::Literal("triggerObjectMatchesByType"), method_60864, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByType"), method_60865, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByFilterID"), method_60866, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_13634c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_60867, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_60868, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByFilterID"), method_60869, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCollection"), method_60870, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCollection"), method_60871, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_60872, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_60873, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCondition"), method_60874, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCondition"), method_60875, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_60876, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_60877, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_60878, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_60879, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_60880, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_60881, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_60882, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_60883, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_60884, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_60885, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByFilter"), method_60886, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByFilter"), method_60887, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_60888, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_60889, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_60890, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_60891, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_60892, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_60893, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_60894, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_60895, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_60896, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_60897, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22412), Reflex::Literal("addTriggerObjectMatch"), method_60898, 0, "trigObj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75115), Reflex::Literal("unpackTriggerObjectPathNames"), method_60899, 0, "names", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17959, type_18052), Reflex::Literal("efficiency"), method_60900, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3537), Reflex::Literal("efficiencies"), method_60901, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("efficiencyNames"), method_60902, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65126), Reflex::Literal("efficiencyValues"), method_60903, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_17959), Reflex::Literal("setEfficiency"), method_60904, 0, "name;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_2393), Reflex::Literal("genParticleRef"), method_60905, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_72, type_72, type_2051), Reflex::Literal("genParticleById"), method_60906, 0, "pdgId;status;autoCharge=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22220, type_2393), Reflex::Literal("genParticle"), method_60907, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("genParticlesSize"), method_60908, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3534), Reflex::Literal("genParticleRefs"), method_60909, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938, type_1810), Reflex::Literal("setGenParticleRef"), method_60910, 0, "ref;embed=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938), Reflex::Literal("addGenParticleRef"), method_60911, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22224), Reflex::Literal("setGenParticle"), method_60912, 0, "particle", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedGenParticle"), method_60913, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasOverlaps"), method_60914, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22159, type_18052), Reflex::Literal("overlaps"), method_60915, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("overlapLabels"), method_60916, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22159), Reflex::Literal("setOverlaps"), method_60917, 0, "label;overlaps", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserData"), method_60918, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18052, type_18052), Reflex::Literal("userDataObjectType"), method_60919, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userDataNames"), method_60920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416, type_18052), Reflex::Literal("userDataBare"), method_60921, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_71958), Reflex::Literal("addUserDataFromPtr"), method_60922, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_18052), Reflex::Literal("userFloat"), method_60923, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_4688), Reflex::Literal("userFloat"), method_60924, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_990), Reflex::Literal("addUserFloat"), method_60925, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userFloatNames"), method_60926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserFloat"), method_60927, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_4688), Reflex::Literal("hasUserFloat"), method_60928, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_18052), Reflex::Literal("userInt"), method_60929, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_72), Reflex::Literal("addUserInt"), method_60930, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userIntNames"), method_60931, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserInt"), method_60932, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7325, type_18052), Reflex::Literal("userCand"), method_60933, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22032), Reflex::Literal("addUserCand"), method_60934, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userCandNames"), method_60935, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserCand"), method_60936, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21967, type_18052), Reflex::Literal("getKinResolution"), method_60937, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasKinResolution"), method_60938, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_21967, type_18052), Reflex::Literal("setKinResolution"), method_60939, 0, "resol;label=\"\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEta"), method_60940, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolTheta"), method_60941, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPhi"), method_60942, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolE"), method_60943, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEt"), method_60944, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolP"), method_60945, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPt"), method_60946, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPInv"), method_60947, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPx"), method_60948, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPy"), method_60949, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPz"), method_60950, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolM"), method_60951, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PATObject<reco::LeafCandidate> -------------------------------
static  void operator_60972( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::PATObject<reco::LeafCandidate>*)o)->operator=)(*(const ::pat::PATObject<reco::LeafCandidate>*)arg[0]);
  else   (((::pat::PATObject<reco::LeafCandidate>*)o)->operator=)(*(const ::pat::PATObject<reco::LeafCandidate>*)arg[0]);
}

static void constructor_60973( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::LeafCandidate>(*(const ::pat::PATObject<reco::LeafCandidate>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::LeafCandidate>(*(const ::pat::PATObject<reco::LeafCandidate>*)arg[0]);
}

static void constructor_60974( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::LeafCandidate>();
  else ::new(mem) ::pat::PATObject<reco::LeafCandidate>();
}

static void constructor_60975( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::LeafCandidate>(*(const ::reco::LeafCandidate*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::LeafCandidate>(*(const ::reco::LeafCandidate*)arg[0]);
}

static void constructor_60976( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::LeafCandidate>(*(const ::edm::RefToBase<reco::LeafCandidate>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::LeafCandidate>(*(const ::edm::RefToBase<reco::LeafCandidate>*)arg[0]);
}

static void constructor_60977( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::LeafCandidate>(*(const ::edm::Ptr<reco::LeafCandidate>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::LeafCandidate>(*(const ::edm::Ptr<reco::LeafCandidate>*)arg[0]);
}

static void destructor_60978(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::PATObject<reco::LeafCandidate>*)o)->::pat::PATObject<reco::LeafCandidate>::~PATObject)();
}
static  void method_60979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->originalObject)());
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->originalObject)();
}

static  void method_60980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::LeafCandidate>*)o)->originalObjectRef)();
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->originalObjectRef)();
}

static  void method_60981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatches)();
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatches)();
}

static  void method_60982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatch)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatch)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]);
  }
}

static  void method_60983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
}

static  void method_60984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]);
}

static  void method_60985( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]);
}

static  void method_60986( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60988( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60990( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]);
}

static  void method_60991( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60992( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60993( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_60994( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]);
}

static  void method_60995( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_60997( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_60998( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_60999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_61000( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_61001( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61002( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61003( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61004( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61005( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61006( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]);
}

static  void method_61007( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61008( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61009( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_61010( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_61011( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_61012( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_61013( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61014( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61015( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61016( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61017( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::LeafCandidate>*)o)->addTriggerObjectMatch)(*(const ::pat::TriggerObjectStandAlone*)arg[0]);
}

static  void method_61018( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::LeafCandidate>*)o)->unpackTriggerObjectPathNames)(*(const ::edm::TriggerNames*)arg[0]);
}

static  void method_61019( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::LeafCandidate>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,pat::LookupTableRecord> >)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->efficiencies)());
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->efficiencies)();
}

static  void method_61021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::LeafCandidate>*)o)->efficiencyNames)();
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->efficiencyNames)();
}

static  void method_61022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::LeafCandidate>*)o)->efficiencyValues)();
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->efficiencyValues)();
}

static  void method_61023( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::LeafCandidate>*)o)->setEfficiency)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::pat::LookupTableRecord*)arg[1]);
}

static  void method_61024( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticleRef)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticleRef)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticleRef)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticleRef)(*(::size_t*)arg[0]);
  }
}

static  void method_61025( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]);
  }
}

static  void method_61026( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticle)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticle)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticle)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticle)(*(::size_t*)arg[0]);
  }
}

static  void method_61027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticlesSize)());
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticlesSize)();
}

static  void method_61028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > >)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticleRefs)());
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->genParticleRefs)();
}

static  void method_61029( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::LeafCandidate>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::LeafCandidate>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_61030( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::LeafCandidate>*)o)->addGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
}

static  void method_61031( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::LeafCandidate>*)o)->setGenParticle)(*(const ::reco::GenParticle*)arg[0]);
}

static  void method_61032( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::PATObject<reco::LeafCandidate>*)o)->embedGenParticle)();
}

static  void method_61033( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61034( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::LeafCandidate>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::LeafCandidate>*)o)->overlapLabels)();
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->overlapLabels)();
}

static  void method_61036( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::LeafCandidate>*)o)->setOverlaps)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::PtrVector<reco::Candidate>*)arg[1]);
}

static  void method_61037( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61038( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::LeafCandidate>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::LeafCandidate>*)o)->userDataNames)();
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->userDataNames)();
}

static  void method_61040( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::LeafCandidate>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61041( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::LeafCandidate>*)o)->addUserDataFromPtr)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<pat::UserData>*)arg[1]);
}

static  void method_61042( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61043( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->userFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->userFloat)((const char*)arg[0]);
}

static  void method_61044( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::LeafCandidate>*)o)->addUserFloat)(*(const ::std::basic_string<char>*)arg[0],
    *(float*)arg[1]);
}

static  void method_61045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::LeafCandidate>*)o)->userFloatNames)();
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->userFloatNames)();
}

static  void method_61046( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61047( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasUserFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasUserFloat)((const char*)arg[0]);
}

static  void method_61048( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61049( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::LeafCandidate>*)o)->addUserInt)(*(const ::std::basic_string<char>*)arg[0],
    *(int*)arg[1]);
}

static  void method_61050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::LeafCandidate>*)o)->userIntNames)();
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->userIntNames)();
}

static  void method_61051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61053( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::LeafCandidate>*)o)->addUserCand)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<reco::Candidate>*)arg[1]);
}

static  void method_61054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::LeafCandidate>*)o)->userCandNames)();
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->userCandNames)();
}

static  void method_61055( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61056( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::LeafCandidate>*)o)->getKinResolution)();
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->getKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::LeafCandidate>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61057( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasKinResolution)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61058( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::LeafCandidate>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::LeafCandidate>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
}

static  void method_61059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolEta)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolEta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolTheta)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolTheta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPhi)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPhi)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61062( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolE)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolE)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61063( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolEt)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolEt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolP)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolP)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61065( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPt)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61066( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPInv)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPInv)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPx)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPx)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPy)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPy)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPz)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPz)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61070( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolM)());
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolM)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::LeafCandidate>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static void method_newdel_13549( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::LeafCandidate> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::LeafCandidate> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::LeafCandidate> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::LeafCandidate> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::LeafCandidate> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x124( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::LeafCandidate>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::LeafCandidate>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATObject<reco::LeafCandidate> -------------------------------
void __pat__PATObject_reco__LeafCandidate__db_datamem(Reflex::Class*);
void __pat__PATObject_reco__LeafCandidate__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__LeafCandidate__datamem_bld(&__pat__PATObject_reco__LeafCandidate__db_datamem);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__LeafCandidate__funcmem_bld(&__pat__PATObject_reco__LeafCandidate__db_funcmem);
void __pat__PATObject_reco__LeafCandidate__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>"), typeid(::pat::PATObject<reco::LeafCandidate>), sizeof(::pat::PATObject<reco::LeafCandidate>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_9074, ::Reflex::BaseOffset< ::pat::PATObject<reco::LeafCandidate>, ::reco::LeafCandidate >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_9074, Reflex::Literal("pat::PATObject<reco::LeafCandidate>::base_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75172, type_75173), Reflex::Literal("operator="), operator_60972, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75173), Reflex::Literal("PATObject"), constructor_60973, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATObject"), constructor_60974, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71891), Reflex::Literal("PATObject"), constructor_60975, 0, "obj", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71887), Reflex::Literal("PATObject"), constructor_60976, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71963), Reflex::Literal("PATObject"), constructor_60977, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATObject"), destructor_60978, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13549, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x124, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__PATObject_reco__LeafCandidate__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__PATObject_reco__LeafCandidate__funcmem_bld);
}

//------Delayed data member builder for class PATObject<reco::LeafCandidate> -------------------
void __pat__PATObject_reco__LeafCandidate__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7325, Reflex::Literal("refToOrig_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, refToOrig_), ::Reflex::PROTECTED)
  .AddDataMember(type_3536, Reflex::Literal("triggerObjectMatchesEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, triggerObjectMatchesEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3535, Reflex::Literal("efficiencyValues_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, efficiencyValues_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("efficiencyNames_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, efficiencyNames_), ::Reflex::PROTECTED)
  .AddDataMember(type_3534, Reflex::Literal("genParticleRef_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, genParticleRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_3533, Reflex::Literal("genParticleEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, genParticleEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("overlapLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, overlapLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3532, Reflex::Literal("overlapItems_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, overlapItems_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userDataLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, userDataLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_7463, Reflex::Literal("userDataObjects_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, userDataObjects_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userFloatLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, userFloatLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3527, Reflex::Literal("userFloats_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, userFloats_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userIntLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, userIntLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3531, Reflex::Literal("userInts_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, userInts_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userCandLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, userCandLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3530, Reflex::Literal("userCands_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, userCands_), ::Reflex::PROTECTED)
  .AddDataMember(type_3529, Reflex::Literal("kinResolutions_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, kinResolutions_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("kinResolutionLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__LeafCandidate_, kinResolutionLabels_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class PATObject<reco::LeafCandidate> -------------------
void __pat__PATObject_reco__LeafCandidate__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("originalObject"), method_60979, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22032), Reflex::Literal("originalObjectRef"), method_60980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35967), Reflex::Literal("triggerObjectMatches"), method_60981, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_2393c), Reflex::Literal("triggerObjectMatch"), method_60982, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_13634c), Reflex::Literal("triggerObjectMatchesByType"), method_60983, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByType"), method_60984, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByFilterID"), method_60985, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_13634c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_60986, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_60987, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByFilterID"), method_60988, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCollection"), method_60989, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCollection"), method_60990, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_60991, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_60992, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCondition"), method_60993, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCondition"), method_60994, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_60995, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_60996, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_60997, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_60998, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_60999, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61000, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61001, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61002, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61003, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61004, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByFilter"), method_61005, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByFilter"), method_61006, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_61007, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_61008, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_61009, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_61010, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_61011, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_61012, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61013, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61014, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61015, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61016, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22412), Reflex::Literal("addTriggerObjectMatch"), method_61017, 0, "trigObj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75115), Reflex::Literal("unpackTriggerObjectPathNames"), method_61018, 0, "names", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17959, type_18052), Reflex::Literal("efficiency"), method_61019, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3537), Reflex::Literal("efficiencies"), method_61020, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("efficiencyNames"), method_61021, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65126), Reflex::Literal("efficiencyValues"), method_61022, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_17959), Reflex::Literal("setEfficiency"), method_61023, 0, "name;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_2393), Reflex::Literal("genParticleRef"), method_61024, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_72, type_72, type_2051), Reflex::Literal("genParticleById"), method_61025, 0, "pdgId;status;autoCharge=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22220, type_2393), Reflex::Literal("genParticle"), method_61026, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("genParticlesSize"), method_61027, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3534), Reflex::Literal("genParticleRefs"), method_61028, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938, type_1810), Reflex::Literal("setGenParticleRef"), method_61029, 0, "ref;embed=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938), Reflex::Literal("addGenParticleRef"), method_61030, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22224), Reflex::Literal("setGenParticle"), method_61031, 0, "particle", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedGenParticle"), method_61032, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasOverlaps"), method_61033, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22159, type_18052), Reflex::Literal("overlaps"), method_61034, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("overlapLabels"), method_61035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22159), Reflex::Literal("setOverlaps"), method_61036, 0, "label;overlaps", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserData"), method_61037, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18052, type_18052), Reflex::Literal("userDataObjectType"), method_61038, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userDataNames"), method_61039, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416, type_18052), Reflex::Literal("userDataBare"), method_61040, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_71958), Reflex::Literal("addUserDataFromPtr"), method_61041, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_18052), Reflex::Literal("userFloat"), method_61042, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_4688), Reflex::Literal("userFloat"), method_61043, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_990), Reflex::Literal("addUserFloat"), method_61044, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userFloatNames"), method_61045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserFloat"), method_61046, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_4688), Reflex::Literal("hasUserFloat"), method_61047, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_18052), Reflex::Literal("userInt"), method_61048, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_72), Reflex::Literal("addUserInt"), method_61049, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userIntNames"), method_61050, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserInt"), method_61051, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7325, type_18052), Reflex::Literal("userCand"), method_61052, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22032), Reflex::Literal("addUserCand"), method_61053, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userCandNames"), method_61054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserCand"), method_61055, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21967, type_18052), Reflex::Literal("getKinResolution"), method_61056, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasKinResolution"), method_61057, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_21967, type_18052), Reflex::Literal("setKinResolution"), method_61058, 0, "resol;label=\"\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEta"), method_61059, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolTheta"), method_61060, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPhi"), method_61061, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolE"), method_61062, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEt"), method_61063, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolP"), method_61064, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPt"), method_61065, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPInv"), method_61066, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPx"), method_61067, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPy"), method_61068, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPz"), method_61069, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolM"), method_61070, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PATObject<reco::MET> -------------------------------
static  void operator_61091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::PATObject<reco::MET>*)o)->operator=)(*(const ::pat::PATObject<reco::MET>*)arg[0]);
  else   (((::pat::PATObject<reco::MET>*)o)->operator=)(*(const ::pat::PATObject<reco::MET>*)arg[0]);
}

static void constructor_61092( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::MET>(*(const ::pat::PATObject<reco::MET>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::MET>(*(const ::pat::PATObject<reco::MET>*)arg[0]);
}

static void constructor_61093( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::MET>();
  else ::new(mem) ::pat::PATObject<reco::MET>();
}

static void constructor_61094( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::MET>(*(const ::reco::MET*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::MET>(*(const ::reco::MET*)arg[0]);
}

static void constructor_61095( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::MET>(*(const ::edm::RefToBase<reco::MET>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::MET>(*(const ::edm::RefToBase<reco::MET>*)arg[0]);
}

static void constructor_61096( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::MET>(*(const ::edm::Ptr<reco::MET>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::MET>(*(const ::edm::Ptr<reco::MET>*)arg[0]);
}

static void destructor_61097(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::PATObject<reco::MET>*)o)->::pat::PATObject<reco::MET>::~PATObject)();
}
static  void method_61098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->originalObject)());
  else   (((const ::pat::PATObject<reco::MET>*)o)->originalObject)();
}

static  void method_61099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::MET>*)o)->originalObjectRef)();
  else   (((const ::pat::PATObject<reco::MET>*)o)->originalObjectRef)();
}

static  void method_61100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatches)();
  else   (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatches)();
}

static  void method_61101( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatch)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatch)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]);
  }
}

static  void method_61102( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
}

static  void method_61103( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]);
}

static  void method_61104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]);
}

static  void method_61105( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61107( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61108( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61109( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]);
}

static  void method_61110( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61111( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61112( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61113( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]);
}

static  void method_61114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61115( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61116( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_61117( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_61118( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_61119( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_61120( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61121( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61125( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]);
}

static  void method_61126( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61127( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61128( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_61129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_61130( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_61131( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_61132( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61135( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61136( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::MET>*)o)->addTriggerObjectMatch)(*(const ::pat::TriggerObjectStandAlone*)arg[0]);
}

static  void method_61137( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::MET>*)o)->unpackTriggerObjectPathNames)(*(const ::edm::TriggerNames*)arg[0]);
}

static  void method_61138( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::MET>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::MET>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,pat::LookupTableRecord> >)((((const ::pat::PATObject<reco::MET>*)o)->efficiencies)());
  else   (((const ::pat::PATObject<reco::MET>*)o)->efficiencies)();
}

static  void method_61140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::MET>*)o)->efficiencyNames)();
  else   (((const ::pat::PATObject<reco::MET>*)o)->efficiencyNames)();
}

static  void method_61141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::MET>*)o)->efficiencyValues)();
  else   (((const ::pat::PATObject<reco::MET>*)o)->efficiencyValues)();
}

static  void method_61142( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::MET>*)o)->setEfficiency)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::pat::LookupTableRecord*)arg[1]);
}

static  void method_61143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::MET>*)o)->genParticleRef)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->genParticleRef)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::MET>*)o)->genParticleRef)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->genParticleRef)(*(::size_t*)arg[0]);
  }
}

static  void method_61144( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::MET>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::MET>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]);
  }
}

static  void method_61145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->genParticle)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->genParticle)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->genParticle)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->genParticle)(*(::size_t*)arg[0]);
  }
}

static  void method_61146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PATObject<reco::MET>*)o)->genParticlesSize)());
  else   (((const ::pat::PATObject<reco::MET>*)o)->genParticlesSize)();
}

static  void method_61147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > >)((((const ::pat::PATObject<reco::MET>*)o)->genParticleRefs)());
  else   (((const ::pat::PATObject<reco::MET>*)o)->genParticleRefs)();
}

static  void method_61148( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::MET>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::MET>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_61149( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::MET>*)o)->addGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
}

static  void method_61150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::MET>*)o)->setGenParticle)(*(const ::reco::GenParticle*)arg[0]);
}

static  void method_61151( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::PATObject<reco::MET>*)o)->embedGenParticle)();
}

static  void method_61152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::MET>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61153( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::MET>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::MET>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::MET>*)o)->overlapLabels)();
  else   (((const ::pat::PATObject<reco::MET>*)o)->overlapLabels)();
}

static  void method_61155( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::MET>*)o)->setOverlaps)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::PtrVector<reco::Candidate>*)arg[1]);
}

static  void method_61156( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::MET>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::MET>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::MET>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::MET>*)o)->userDataNames)();
  else   (((const ::pat::PATObject<reco::MET>*)o)->userDataNames)();
}

static  void method_61159( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::MET>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61160( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::MET>*)o)->addUserDataFromPtr)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<pat::UserData>*)arg[1]);
}

static  void method_61161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::MET>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61162( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::MET>*)o)->userFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->userFloat)((const char*)arg[0]);
}

static  void method_61163( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::MET>*)o)->addUserFloat)(*(const ::std::basic_string<char>*)arg[0],
    *(float*)arg[1]);
}

static  void method_61164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::MET>*)o)->userFloatNames)();
  else   (((const ::pat::PATObject<reco::MET>*)o)->userFloatNames)();
}

static  void method_61165( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::MET>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61166( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::MET>*)o)->hasUserFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->hasUserFloat)((const char*)arg[0]);
}

static  void method_61167( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PATObject<reco::MET>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61168( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::MET>*)o)->addUserInt)(*(const ::std::basic_string<char>*)arg[0],
    *(int*)arg[1]);
}

static  void method_61169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::MET>*)o)->userIntNames)();
  else   (((const ::pat::PATObject<reco::MET>*)o)->userIntNames)();
}

static  void method_61170( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::MET>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61171( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::pat::PATObject<reco::MET>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61172( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::MET>*)o)->addUserCand)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<reco::Candidate>*)arg[1]);
}

static  void method_61173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::MET>*)o)->userCandNames)();
  else   (((const ::pat::PATObject<reco::MET>*)o)->userCandNames)();
}

static  void method_61174( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::MET>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::MET>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61175( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::MET>*)o)->getKinResolution)();
    else     (((const ::pat::PATObject<reco::MET>*)o)->getKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::MET>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
    else     (((const ::pat::PATObject<reco::MET>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61176( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::MET>*)o)->hasKinResolution)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->hasKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::MET>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61177( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::MET>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::MET>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
}

static  void method_61178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolEta)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolEta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolTheta)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolTheta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolPhi)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolPhi)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolE)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolE)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolEt)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolEt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolP)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolP)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolPt)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolPt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61185( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolPInv)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolPInv)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61186( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolPx)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolPx)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61187( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolPy)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolPy)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61188( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolPz)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolPz)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61189( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolM)());
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolM)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::MET>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::MET>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static void method_newdel_13550( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::MET> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::MET> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::MET> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::MET> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::MET> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x126( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::MET")), ::Reflex::BaseOffset< ::pat::PATObject<reco::MET>,::reco::MET >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::MET>,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::MET>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::MET>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATObject<reco::MET> -------------------------------
void __pat__PATObject_reco__MET__db_datamem(Reflex::Class*);
void __pat__PATObject_reco__MET__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__MET__datamem_bld(&__pat__PATObject_reco__MET__db_datamem);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__MET__funcmem_bld(&__pat__PATObject_reco__MET__db_funcmem);
void __pat__PATObject_reco__MET__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::PATObject<reco::MET>"), typeid(::pat::PATObject<reco::MET>), sizeof(::pat::PATObject<reco::MET>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_11551, ::Reflex::BaseOffset< ::pat::PATObject<reco::MET>, ::reco::MET >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_11551, Reflex::Literal("pat::PATObject<reco::MET>::base_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75174, type_75175), Reflex::Literal("operator="), operator_61091, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75175), Reflex::Literal("PATObject"), constructor_61092, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATObject"), constructor_61093, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71898), Reflex::Literal("PATObject"), constructor_61094, 0, "obj", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71894), Reflex::Literal("PATObject"), constructor_61095, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71965), Reflex::Literal("PATObject"), constructor_61096, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATObject"), destructor_61097, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13550, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x126, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__PATObject_reco__MET__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__PATObject_reco__MET__funcmem_bld);
}

//------Delayed data member builder for class PATObject<reco::MET> -------------------
void __pat__PATObject_reco__MET__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7325, Reflex::Literal("refToOrig_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, refToOrig_), ::Reflex::PROTECTED)
  .AddDataMember(type_3536, Reflex::Literal("triggerObjectMatchesEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, triggerObjectMatchesEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3535, Reflex::Literal("efficiencyValues_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, efficiencyValues_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("efficiencyNames_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, efficiencyNames_), ::Reflex::PROTECTED)
  .AddDataMember(type_3534, Reflex::Literal("genParticleRef_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, genParticleRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_3533, Reflex::Literal("genParticleEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, genParticleEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("overlapLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, overlapLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3532, Reflex::Literal("overlapItems_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, overlapItems_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userDataLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, userDataLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_7463, Reflex::Literal("userDataObjects_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, userDataObjects_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userFloatLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, userFloatLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3527, Reflex::Literal("userFloats_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, userFloats_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userIntLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, userIntLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3531, Reflex::Literal("userInts_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, userInts_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userCandLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, userCandLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3530, Reflex::Literal("userCands_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, userCands_), ::Reflex::PROTECTED)
  .AddDataMember(type_3529, Reflex::Literal("kinResolutions_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, kinResolutions_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("kinResolutionLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__MET_, kinResolutionLabels_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class PATObject<reco::MET> -------------------
void __pat__PATObject_reco__MET__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("originalObject"), method_61098, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22032), Reflex::Literal("originalObjectRef"), method_61099, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35967), Reflex::Literal("triggerObjectMatches"), method_61100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_2393c), Reflex::Literal("triggerObjectMatch"), method_61101, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_13634c), Reflex::Literal("triggerObjectMatchesByType"), method_61102, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByType"), method_61103, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByFilterID"), method_61104, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_13634c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_61105, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_61106, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByFilterID"), method_61107, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCollection"), method_61108, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCollection"), method_61109, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_61110, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_61111, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCondition"), method_61112, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCondition"), method_61113, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_61114, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_61115, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61116, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61117, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61118, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61119, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61120, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61121, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61122, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61123, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByFilter"), method_61124, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByFilter"), method_61125, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_61126, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_61127, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_61128, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_61129, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_61130, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_61131, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61132, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61133, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61134, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61135, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22412), Reflex::Literal("addTriggerObjectMatch"), method_61136, 0, "trigObj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75115), Reflex::Literal("unpackTriggerObjectPathNames"), method_61137, 0, "names", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17959, type_18052), Reflex::Literal("efficiency"), method_61138, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3537), Reflex::Literal("efficiencies"), method_61139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("efficiencyNames"), method_61140, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65126), Reflex::Literal("efficiencyValues"), method_61141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_17959), Reflex::Literal("setEfficiency"), method_61142, 0, "name;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_2393), Reflex::Literal("genParticleRef"), method_61143, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_72, type_72, type_2051), Reflex::Literal("genParticleById"), method_61144, 0, "pdgId;status;autoCharge=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22220, type_2393), Reflex::Literal("genParticle"), method_61145, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("genParticlesSize"), method_61146, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3534), Reflex::Literal("genParticleRefs"), method_61147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938, type_1810), Reflex::Literal("setGenParticleRef"), method_61148, 0, "ref;embed=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938), Reflex::Literal("addGenParticleRef"), method_61149, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22224), Reflex::Literal("setGenParticle"), method_61150, 0, "particle", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedGenParticle"), method_61151, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasOverlaps"), method_61152, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22159, type_18052), Reflex::Literal("overlaps"), method_61153, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("overlapLabels"), method_61154, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22159), Reflex::Literal("setOverlaps"), method_61155, 0, "label;overlaps", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserData"), method_61156, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18052, type_18052), Reflex::Literal("userDataObjectType"), method_61157, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userDataNames"), method_61158, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416, type_18052), Reflex::Literal("userDataBare"), method_61159, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_71958), Reflex::Literal("addUserDataFromPtr"), method_61160, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_18052), Reflex::Literal("userFloat"), method_61161, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_4688), Reflex::Literal("userFloat"), method_61162, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_990), Reflex::Literal("addUserFloat"), method_61163, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userFloatNames"), method_61164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserFloat"), method_61165, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_4688), Reflex::Literal("hasUserFloat"), method_61166, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_18052), Reflex::Literal("userInt"), method_61167, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_72), Reflex::Literal("addUserInt"), method_61168, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userIntNames"), method_61169, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserInt"), method_61170, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7325, type_18052), Reflex::Literal("userCand"), method_61171, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22032), Reflex::Literal("addUserCand"), method_61172, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userCandNames"), method_61173, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserCand"), method_61174, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21967, type_18052), Reflex::Literal("getKinResolution"), method_61175, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasKinResolution"), method_61176, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_21967, type_18052), Reflex::Literal("setKinResolution"), method_61177, 0, "resol;label=\"\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEta"), method_61178, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolTheta"), method_61179, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPhi"), method_61180, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolE"), method_61181, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEt"), method_61182, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolP"), method_61183, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPt"), method_61184, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPInv"), method_61185, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPx"), method_61186, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPy"), method_61187, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPz"), method_61188, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolM"), method_61189, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PATObject<reco::Jet> -------------------------------
static  void operator_61210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::PATObject<reco::Jet>*)o)->operator=)(*(const ::pat::PATObject<reco::Jet>*)arg[0]);
  else   (((::pat::PATObject<reco::Jet>*)o)->operator=)(*(const ::pat::PATObject<reco::Jet>*)arg[0]);
}

static void constructor_61211( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::Jet>(*(const ::pat::PATObject<reco::Jet>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::Jet>(*(const ::pat::PATObject<reco::Jet>*)arg[0]);
}

static void constructor_61212( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::Jet>();
  else ::new(mem) ::pat::PATObject<reco::Jet>();
}

static void constructor_61213( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::Jet>(*(const ::reco::Jet*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::Jet>(*(const ::reco::Jet*)arg[0]);
}

static void constructor_61214( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::Jet>(*(const ::edm::RefToBase<reco::Jet>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::Jet>(*(const ::edm::RefToBase<reco::Jet>*)arg[0]);
}

static void constructor_61215( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::Jet>(*(const ::edm::Ptr<reco::Jet>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::Jet>(*(const ::edm::Ptr<reco::Jet>*)arg[0]);
}

static void destructor_61216(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::PATObject<reco::Jet>*)o)->::pat::PATObject<reco::Jet>::~PATObject)();
}
static  void method_61217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->originalObject)());
  else   (((const ::pat::PATObject<reco::Jet>*)o)->originalObject)();
}

static  void method_61218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Jet>*)o)->originalObjectRef)();
  else   (((const ::pat::PATObject<reco::Jet>*)o)->originalObjectRef)();
}

static  void method_61219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatches)();
  else   (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatches)();
}

static  void method_61220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatch)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatch)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]);
  }
}

static  void method_61221( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
}

static  void method_61222( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]);
}

static  void method_61223( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]);
}

static  void method_61224( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61225( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61226( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61227( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61228( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]);
}

static  void method_61229( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61230( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61231( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61232( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]);
}

static  void method_61233( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61234( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61235( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_61236( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_61237( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_61238( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_61239( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61240( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61241( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61242( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61243( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61244( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]);
}

static  void method_61245( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61246( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61247( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_61248( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_61249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_61250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_61251( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61252( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61254( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61255( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Jet>*)o)->addTriggerObjectMatch)(*(const ::pat::TriggerObjectStandAlone*)arg[0]);
}

static  void method_61256( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Jet>*)o)->unpackTriggerObjectPathNames)(*(const ::edm::TriggerNames*)arg[0]);
}

static  void method_61257( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Jet>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::Jet>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,pat::LookupTableRecord> >)((((const ::pat::PATObject<reco::Jet>*)o)->efficiencies)());
  else   (((const ::pat::PATObject<reco::Jet>*)o)->efficiencies)();
}

static  void method_61259( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Jet>*)o)->efficiencyNames)();
  else   (((const ::pat::PATObject<reco::Jet>*)o)->efficiencyNames)();
}

static  void method_61260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Jet>*)o)->efficiencyValues)();
  else   (((const ::pat::PATObject<reco::Jet>*)o)->efficiencyValues)();
}

static  void method_61261( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Jet>*)o)->setEfficiency)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::pat::LookupTableRecord*)arg[1]);
}

static  void method_61262( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::Jet>*)o)->genParticleRef)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->genParticleRef)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::Jet>*)o)->genParticleRef)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->genParticleRef)(*(::size_t*)arg[0]);
  }
}

static  void method_61263( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::Jet>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::Jet>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]);
  }
}

static  void method_61264( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->genParticle)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->genParticle)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->genParticle)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->genParticle)(*(::size_t*)arg[0]);
  }
}

static  void method_61265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PATObject<reco::Jet>*)o)->genParticlesSize)());
  else   (((const ::pat::PATObject<reco::Jet>*)o)->genParticlesSize)();
}

static  void method_61266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > >)((((const ::pat::PATObject<reco::Jet>*)o)->genParticleRefs)());
  else   (((const ::pat::PATObject<reco::Jet>*)o)->genParticleRefs)();
}

static  void method_61267( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::Jet>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::Jet>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_61268( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Jet>*)o)->addGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
}

static  void method_61269( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Jet>*)o)->setGenParticle)(*(const ::reco::GenParticle*)arg[0]);
}

static  void method_61270( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::PATObject<reco::Jet>*)o)->embedGenParticle)();
}

static  void method_61271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Jet>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61272( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Jet>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::Jet>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Jet>*)o)->overlapLabels)();
  else   (((const ::pat::PATObject<reco::Jet>*)o)->overlapLabels)();
}

static  void method_61274( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Jet>*)o)->setOverlaps)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::PtrVector<reco::Candidate>*)arg[1]);
}

static  void method_61275( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Jet>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61276( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Jet>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::Jet>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Jet>*)o)->userDataNames)();
  else   (((const ::pat::PATObject<reco::Jet>*)o)->userDataNames)();
}

static  void method_61278( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Jet>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61279( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Jet>*)o)->addUserDataFromPtr)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<pat::UserData>*)arg[1]);
}

static  void method_61280( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::Jet>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61281( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::Jet>*)o)->userFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->userFloat)((const char*)arg[0]);
}

static  void method_61282( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Jet>*)o)->addUserFloat)(*(const ::std::basic_string<char>*)arg[0],
    *(float*)arg[1]);
}

static  void method_61283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Jet>*)o)->userFloatNames)();
  else   (((const ::pat::PATObject<reco::Jet>*)o)->userFloatNames)();
}

static  void method_61284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Jet>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61285( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Jet>*)o)->hasUserFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->hasUserFloat)((const char*)arg[0]);
}

static  void method_61286( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PATObject<reco::Jet>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61287( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Jet>*)o)->addUserInt)(*(const ::std::basic_string<char>*)arg[0],
    *(int*)arg[1]);
}

static  void method_61288( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Jet>*)o)->userIntNames)();
  else   (((const ::pat::PATObject<reco::Jet>*)o)->userIntNames)();
}

static  void method_61289( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Jet>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61290( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::pat::PATObject<reco::Jet>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61291( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Jet>*)o)->addUserCand)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<reco::Candidate>*)arg[1]);
}

static  void method_61292( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Jet>*)o)->userCandNames)();
  else   (((const ::pat::PATObject<reco::Jet>*)o)->userCandNames)();
}

static  void method_61293( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Jet>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Jet>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61294( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Jet>*)o)->getKinResolution)();
    else     (((const ::pat::PATObject<reco::Jet>*)o)->getKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Jet>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
    else     (((const ::pat::PATObject<reco::Jet>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61295( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Jet>*)o)->hasKinResolution)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->hasKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Jet>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61296( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::Jet>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::Jet>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
}

static  void method_61297( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolEta)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolEta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61298( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolTheta)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolTheta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61299( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolPhi)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolPhi)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61300( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolE)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolE)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61301( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolEt)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolEt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61302( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolP)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolP)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61303( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolPt)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolPt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61304( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolPInv)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolPInv)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61305( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolPx)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolPx)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61306( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolPy)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolPy)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61307( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolPz)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolPz)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61308( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolM)());
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolM)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Jet>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Jet>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static void method_newdel_13551( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::Jet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::Jet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::Jet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::Jet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::Jet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x128( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Jet")), ::Reflex::BaseOffset< ::pat::PATObject<reco::Jet>,::reco::Jet >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::CompositePtrCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::Jet>,::reco::CompositePtrCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::Jet>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::Jet>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATObject<reco::Jet> -------------------------------
void __pat__PATObject_reco__Jet__db_datamem(Reflex::Class*);
void __pat__PATObject_reco__Jet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__Jet__datamem_bld(&__pat__PATObject_reco__Jet__db_datamem);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__Jet__funcmem_bld(&__pat__PATObject_reco__Jet__db_funcmem);
void __pat__PATObject_reco__Jet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::PATObject<reco::Jet>"), typeid(::pat::PATObject<reco::Jet>), sizeof(::pat::PATObject<reco::Jet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_11344, ::Reflex::BaseOffset< ::pat::PATObject<reco::Jet>, ::reco::Jet >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_11344, Reflex::Literal("pat::PATObject<reco::Jet>::base_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75176, type_75177), Reflex::Literal("operator="), operator_61210, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75177), Reflex::Literal("PATObject"), constructor_61211, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATObject"), constructor_61212, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71902), Reflex::Literal("PATObject"), constructor_61213, 0, "obj", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_65058), Reflex::Literal("PATObject"), constructor_61214, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71968), Reflex::Literal("PATObject"), constructor_61215, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATObject"), destructor_61216, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13551, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x128, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__PATObject_reco__Jet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__PATObject_reco__Jet__funcmem_bld);
}

//------Delayed data member builder for class PATObject<reco::Jet> -------------------
void __pat__PATObject_reco__Jet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7325, Reflex::Literal("refToOrig_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, refToOrig_), ::Reflex::PROTECTED)
  .AddDataMember(type_3536, Reflex::Literal("triggerObjectMatchesEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, triggerObjectMatchesEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3535, Reflex::Literal("efficiencyValues_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, efficiencyValues_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("efficiencyNames_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, efficiencyNames_), ::Reflex::PROTECTED)
  .AddDataMember(type_3534, Reflex::Literal("genParticleRef_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, genParticleRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_3533, Reflex::Literal("genParticleEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, genParticleEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("overlapLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, overlapLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3532, Reflex::Literal("overlapItems_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, overlapItems_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userDataLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, userDataLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_7463, Reflex::Literal("userDataObjects_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, userDataObjects_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userFloatLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, userFloatLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3527, Reflex::Literal("userFloats_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, userFloats_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userIntLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, userIntLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3531, Reflex::Literal("userInts_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, userInts_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userCandLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, userCandLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3530, Reflex::Literal("userCands_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, userCands_), ::Reflex::PROTECTED)
  .AddDataMember(type_3529, Reflex::Literal("kinResolutions_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, kinResolutions_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("kinResolutionLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Jet_, kinResolutionLabels_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class PATObject<reco::Jet> -------------------
void __pat__PATObject_reco__Jet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("originalObject"), method_61217, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22032), Reflex::Literal("originalObjectRef"), method_61218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35967), Reflex::Literal("triggerObjectMatches"), method_61219, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_2393c), Reflex::Literal("triggerObjectMatch"), method_61220, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_13634c), Reflex::Literal("triggerObjectMatchesByType"), method_61221, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByType"), method_61222, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByFilterID"), method_61223, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_13634c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_61224, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_61225, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByFilterID"), method_61226, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCollection"), method_61227, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCollection"), method_61228, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_61229, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_61230, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCondition"), method_61231, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCondition"), method_61232, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_61233, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_61234, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61235, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61236, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61237, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61238, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61239, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61240, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61241, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61242, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByFilter"), method_61243, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByFilter"), method_61244, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_61245, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_61246, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_61247, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_61248, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_61249, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_61250, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61251, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61252, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61253, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61254, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22412), Reflex::Literal("addTriggerObjectMatch"), method_61255, 0, "trigObj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75115), Reflex::Literal("unpackTriggerObjectPathNames"), method_61256, 0, "names", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17959, type_18052), Reflex::Literal("efficiency"), method_61257, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3537), Reflex::Literal("efficiencies"), method_61258, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("efficiencyNames"), method_61259, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65126), Reflex::Literal("efficiencyValues"), method_61260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_17959), Reflex::Literal("setEfficiency"), method_61261, 0, "name;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_2393), Reflex::Literal("genParticleRef"), method_61262, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_72, type_72, type_2051), Reflex::Literal("genParticleById"), method_61263, 0, "pdgId;status;autoCharge=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22220, type_2393), Reflex::Literal("genParticle"), method_61264, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("genParticlesSize"), method_61265, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3534), Reflex::Literal("genParticleRefs"), method_61266, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938, type_1810), Reflex::Literal("setGenParticleRef"), method_61267, 0, "ref;embed=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938), Reflex::Literal("addGenParticleRef"), method_61268, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22224), Reflex::Literal("setGenParticle"), method_61269, 0, "particle", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedGenParticle"), method_61270, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasOverlaps"), method_61271, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22159, type_18052), Reflex::Literal("overlaps"), method_61272, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("overlapLabels"), method_61273, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22159), Reflex::Literal("setOverlaps"), method_61274, 0, "label;overlaps", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserData"), method_61275, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18052, type_18052), Reflex::Literal("userDataObjectType"), method_61276, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userDataNames"), method_61277, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416, type_18052), Reflex::Literal("userDataBare"), method_61278, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_71958), Reflex::Literal("addUserDataFromPtr"), method_61279, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_18052), Reflex::Literal("userFloat"), method_61280, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_4688), Reflex::Literal("userFloat"), method_61281, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_990), Reflex::Literal("addUserFloat"), method_61282, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userFloatNames"), method_61283, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserFloat"), method_61284, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_4688), Reflex::Literal("hasUserFloat"), method_61285, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_18052), Reflex::Literal("userInt"), method_61286, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_72), Reflex::Literal("addUserInt"), method_61287, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userIntNames"), method_61288, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserInt"), method_61289, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7325, type_18052), Reflex::Literal("userCand"), method_61290, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22032), Reflex::Literal("addUserCand"), method_61291, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userCandNames"), method_61292, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserCand"), method_61293, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21967, type_18052), Reflex::Literal("getKinResolution"), method_61294, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasKinResolution"), method_61295, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_21967, type_18052), Reflex::Literal("setKinResolution"), method_61296, 0, "resol;label=\"\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEta"), method_61297, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolTheta"), method_61298, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPhi"), method_61299, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolE"), method_61300, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEt"), method_61301, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolP"), method_61302, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPt"), method_61303, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPInv"), method_61304, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPx"), method_61305, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPy"), method_61306, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPz"), method_61307, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolM"), method_61308, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PATObject<reco::Photon> -------------------------------
static  void operator_61329( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::PATObject<reco::Photon>*)o)->operator=)(*(const ::pat::PATObject<reco::Photon>*)arg[0]);
  else   (((::pat::PATObject<reco::Photon>*)o)->operator=)(*(const ::pat::PATObject<reco::Photon>*)arg[0]);
}

static void constructor_61330( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::Photon>(*(const ::pat::PATObject<reco::Photon>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::Photon>(*(const ::pat::PATObject<reco::Photon>*)arg[0]);
}

static void constructor_61331( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::Photon>();
  else ::new(mem) ::pat::PATObject<reco::Photon>();
}

static void constructor_61332( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::Photon>(*(const ::reco::Photon*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::Photon>(*(const ::reco::Photon*)arg[0]);
}

static void constructor_61333( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::Photon>(*(const ::edm::RefToBase<reco::Photon>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::Photon>(*(const ::edm::RefToBase<reco::Photon>*)arg[0]);
}

static void constructor_61334( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::Photon>(*(const ::edm::Ptr<reco::Photon>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::Photon>(*(const ::edm::Ptr<reco::Photon>*)arg[0]);
}

static void destructor_61335(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::PATObject<reco::Photon>*)o)->::pat::PATObject<reco::Photon>::~PATObject)();
}
static  void method_61336( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->originalObject)());
  else   (((const ::pat::PATObject<reco::Photon>*)o)->originalObject)();
}

static  void method_61337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Photon>*)o)->originalObjectRef)();
  else   (((const ::pat::PATObject<reco::Photon>*)o)->originalObjectRef)();
}

static  void method_61338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatches)();
  else   (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatches)();
}

static  void method_61339( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatch)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatch)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]);
  }
}

static  void method_61340( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
}

static  void method_61341( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]);
}

static  void method_61342( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]);
}

static  void method_61343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61344( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61345( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61346( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61347( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]);
}

static  void method_61348( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61349( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61350( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61351( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]);
}

static  void method_61352( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61353( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61354( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_61355( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_61356( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_61357( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_61358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61361( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61362( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61363( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]);
}

static  void method_61364( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61366( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_61367( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_61368( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_61369( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_61370( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61371( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61374( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Photon>*)o)->addTriggerObjectMatch)(*(const ::pat::TriggerObjectStandAlone*)arg[0]);
}

static  void method_61375( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Photon>*)o)->unpackTriggerObjectPathNames)(*(const ::edm::TriggerNames*)arg[0]);
}

static  void method_61376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Photon>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::Photon>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,pat::LookupTableRecord> >)((((const ::pat::PATObject<reco::Photon>*)o)->efficiencies)());
  else   (((const ::pat::PATObject<reco::Photon>*)o)->efficiencies)();
}

static  void method_61378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Photon>*)o)->efficiencyNames)();
  else   (((const ::pat::PATObject<reco::Photon>*)o)->efficiencyNames)();
}

static  void method_61379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Photon>*)o)->efficiencyValues)();
  else   (((const ::pat::PATObject<reco::Photon>*)o)->efficiencyValues)();
}

static  void method_61380( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Photon>*)o)->setEfficiency)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::pat::LookupTableRecord*)arg[1]);
}

static  void method_61381( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::Photon>*)o)->genParticleRef)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->genParticleRef)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::Photon>*)o)->genParticleRef)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->genParticleRef)(*(::size_t*)arg[0]);
  }
}

static  void method_61382( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::Photon>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::Photon>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]);
  }
}

static  void method_61383( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->genParticle)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->genParticle)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->genParticle)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->genParticle)(*(::size_t*)arg[0]);
  }
}

static  void method_61384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PATObject<reco::Photon>*)o)->genParticlesSize)());
  else   (((const ::pat::PATObject<reco::Photon>*)o)->genParticlesSize)();
}

static  void method_61385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > >)((((const ::pat::PATObject<reco::Photon>*)o)->genParticleRefs)());
  else   (((const ::pat::PATObject<reco::Photon>*)o)->genParticleRefs)();
}

static  void method_61386( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::Photon>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::Photon>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_61387( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Photon>*)o)->addGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
}

static  void method_61388( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Photon>*)o)->setGenParticle)(*(const ::reco::GenParticle*)arg[0]);
}

static  void method_61389( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::PATObject<reco::Photon>*)o)->embedGenParticle)();
}

static  void method_61390( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Photon>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Photon>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::Photon>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61392( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Photon>*)o)->overlapLabels)();
  else   (((const ::pat::PATObject<reco::Photon>*)o)->overlapLabels)();
}

static  void method_61393( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Photon>*)o)->setOverlaps)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::PtrVector<reco::Candidate>*)arg[1]);
}

static  void method_61394( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Photon>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61395( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Photon>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::Photon>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Photon>*)o)->userDataNames)();
  else   (((const ::pat::PATObject<reco::Photon>*)o)->userDataNames)();
}

static  void method_61397( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Photon>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61398( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Photon>*)o)->addUserDataFromPtr)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<pat::UserData>*)arg[1]);
}

static  void method_61399( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::Photon>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61400( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::Photon>*)o)->userFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->userFloat)((const char*)arg[0]);
}

static  void method_61401( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Photon>*)o)->addUserFloat)(*(const ::std::basic_string<char>*)arg[0],
    *(float*)arg[1]);
}

static  void method_61402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Photon>*)o)->userFloatNames)();
  else   (((const ::pat::PATObject<reco::Photon>*)o)->userFloatNames)();
}

static  void method_61403( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Photon>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61404( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Photon>*)o)->hasUserFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->hasUserFloat)((const char*)arg[0]);
}

static  void method_61405( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PATObject<reco::Photon>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61406( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Photon>*)o)->addUserInt)(*(const ::std::basic_string<char>*)arg[0],
    *(int*)arg[1]);
}

static  void method_61407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Photon>*)o)->userIntNames)();
  else   (((const ::pat::PATObject<reco::Photon>*)o)->userIntNames)();
}

static  void method_61408( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Photon>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61409( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::pat::PATObject<reco::Photon>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61410( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Photon>*)o)->addUserCand)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<reco::Candidate>*)arg[1]);
}

static  void method_61411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Photon>*)o)->userCandNames)();
  else   (((const ::pat::PATObject<reco::Photon>*)o)->userCandNames)();
}

static  void method_61412( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Photon>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Photon>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61413( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Photon>*)o)->getKinResolution)();
    else     (((const ::pat::PATObject<reco::Photon>*)o)->getKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Photon>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
    else     (((const ::pat::PATObject<reco::Photon>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61414( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Photon>*)o)->hasKinResolution)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->hasKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Photon>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61415( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::Photon>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::Photon>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
}

static  void method_61416( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolEta)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolEta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61417( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolTheta)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolTheta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61418( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolPhi)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolPhi)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61419( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolE)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolE)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61420( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolEt)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolEt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61421( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolP)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolP)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61422( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolPt)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolPt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61423( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolPInv)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolPInv)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61424( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolPx)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolPx)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61425( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolPy)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolPy)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolPz)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolPz)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61427( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolM)());
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolM)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Photon>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Photon>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static void method_newdel_13552( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x130( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Photon")), ::Reflex::BaseOffset< ::pat::PATObject<reco::Photon>,::reco::Photon >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::Photon>,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATObject<reco::Photon> -------------------------------
void __pat__PATObject_reco__Photon__db_datamem(Reflex::Class*);
void __pat__PATObject_reco__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__Photon__datamem_bld(&__pat__PATObject_reco__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__Photon__funcmem_bld(&__pat__PATObject_reco__Photon__db_funcmem);
void __pat__PATObject_reco__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::PATObject<reco::Photon>"), typeid(::pat::PATObject<reco::Photon>), sizeof(::pat::PATObject<reco::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_11479, ::Reflex::BaseOffset< ::pat::PATObject<reco::Photon>, ::reco::Photon >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_11479, Reflex::Literal("pat::PATObject<reco::Photon>::base_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75178, type_75179), Reflex::Literal("operator="), operator_61329, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75179), Reflex::Literal("PATObject"), constructor_61330, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATObject"), constructor_61331, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27469), Reflex::Literal("PATObject"), constructor_61332, 0, "obj", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71905), Reflex::Literal("PATObject"), constructor_61333, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71970), Reflex::Literal("PATObject"), constructor_61334, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATObject"), destructor_61335, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13552, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x130, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__PATObject_reco__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__PATObject_reco__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATObject<reco::Photon> -------------------
void __pat__PATObject_reco__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7325, Reflex::Literal("refToOrig_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, refToOrig_), ::Reflex::PROTECTED)
  .AddDataMember(type_3536, Reflex::Literal("triggerObjectMatchesEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, triggerObjectMatchesEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3535, Reflex::Literal("efficiencyValues_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, efficiencyValues_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("efficiencyNames_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, efficiencyNames_), ::Reflex::PROTECTED)
  .AddDataMember(type_3534, Reflex::Literal("genParticleRef_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, genParticleRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_3533, Reflex::Literal("genParticleEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, genParticleEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("overlapLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, overlapLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3532, Reflex::Literal("overlapItems_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, overlapItems_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userDataLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, userDataLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_7463, Reflex::Literal("userDataObjects_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, userDataObjects_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userFloatLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, userFloatLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3527, Reflex::Literal("userFloats_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, userFloats_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userIntLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, userIntLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3531, Reflex::Literal("userInts_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, userInts_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userCandLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, userCandLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3530, Reflex::Literal("userCands_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, userCands_), ::Reflex::PROTECTED)
  .AddDataMember(type_3529, Reflex::Literal("kinResolutions_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, kinResolutions_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("kinResolutionLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Photon_, kinResolutionLabels_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class PATObject<reco::Photon> -------------------
void __pat__PATObject_reco__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("originalObject"), method_61336, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22032), Reflex::Literal("originalObjectRef"), method_61337, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35967), Reflex::Literal("triggerObjectMatches"), method_61338, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_2393c), Reflex::Literal("triggerObjectMatch"), method_61339, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_13634c), Reflex::Literal("triggerObjectMatchesByType"), method_61340, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByType"), method_61341, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByFilterID"), method_61342, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_13634c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_61343, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_61344, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByFilterID"), method_61345, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCollection"), method_61346, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCollection"), method_61347, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_61348, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_61349, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCondition"), method_61350, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCondition"), method_61351, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_61352, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_61353, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61354, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61355, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61356, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61357, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61358, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61359, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61360, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61361, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByFilter"), method_61362, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByFilter"), method_61363, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_61364, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_61365, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_61366, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_61367, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_61368, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_61369, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61370, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61371, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61372, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61373, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22412), Reflex::Literal("addTriggerObjectMatch"), method_61374, 0, "trigObj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75115), Reflex::Literal("unpackTriggerObjectPathNames"), method_61375, 0, "names", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17959, type_18052), Reflex::Literal("efficiency"), method_61376, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3537), Reflex::Literal("efficiencies"), method_61377, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("efficiencyNames"), method_61378, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65126), Reflex::Literal("efficiencyValues"), method_61379, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_17959), Reflex::Literal("setEfficiency"), method_61380, 0, "name;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_2393), Reflex::Literal("genParticleRef"), method_61381, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_72, type_72, type_2051), Reflex::Literal("genParticleById"), method_61382, 0, "pdgId;status;autoCharge=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22220, type_2393), Reflex::Literal("genParticle"), method_61383, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("genParticlesSize"), method_61384, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3534), Reflex::Literal("genParticleRefs"), method_61385, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938, type_1810), Reflex::Literal("setGenParticleRef"), method_61386, 0, "ref;embed=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938), Reflex::Literal("addGenParticleRef"), method_61387, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22224), Reflex::Literal("setGenParticle"), method_61388, 0, "particle", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedGenParticle"), method_61389, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasOverlaps"), method_61390, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22159, type_18052), Reflex::Literal("overlaps"), method_61391, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("overlapLabels"), method_61392, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22159), Reflex::Literal("setOverlaps"), method_61393, 0, "label;overlaps", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserData"), method_61394, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18052, type_18052), Reflex::Literal("userDataObjectType"), method_61395, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userDataNames"), method_61396, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416, type_18052), Reflex::Literal("userDataBare"), method_61397, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_71958), Reflex::Literal("addUserDataFromPtr"), method_61398, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_18052), Reflex::Literal("userFloat"), method_61399, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_4688), Reflex::Literal("userFloat"), method_61400, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_990), Reflex::Literal("addUserFloat"), method_61401, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userFloatNames"), method_61402, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserFloat"), method_61403, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_4688), Reflex::Literal("hasUserFloat"), method_61404, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_18052), Reflex::Literal("userInt"), method_61405, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_72), Reflex::Literal("addUserInt"), method_61406, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userIntNames"), method_61407, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserInt"), method_61408, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7325, type_18052), Reflex::Literal("userCand"), method_61409, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22032), Reflex::Literal("addUserCand"), method_61410, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userCandNames"), method_61411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserCand"), method_61412, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21967, type_18052), Reflex::Literal("getKinResolution"), method_61413, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasKinResolution"), method_61414, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_21967, type_18052), Reflex::Literal("setKinResolution"), method_61415, 0, "resol;label=\"\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEta"), method_61416, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolTheta"), method_61417, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPhi"), method_61418, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolE"), method_61419, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEt"), method_61420, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolP"), method_61421, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPt"), method_61422, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPInv"), method_61423, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPx"), method_61424, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPy"), method_61425, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPz"), method_61426, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolM"), method_61427, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PATObject<reco::BaseTau> -------------------------------
static  void operator_61448( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::PATObject<reco::BaseTau>*)o)->operator=)(*(const ::pat::PATObject<reco::BaseTau>*)arg[0]);
  else   (((::pat::PATObject<reco::BaseTau>*)o)->operator=)(*(const ::pat::PATObject<reco::BaseTau>*)arg[0]);
}

static void constructor_61449( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::BaseTau>(*(const ::pat::PATObject<reco::BaseTau>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::BaseTau>(*(const ::pat::PATObject<reco::BaseTau>*)arg[0]);
}

static void constructor_61450( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::BaseTau>();
  else ::new(mem) ::pat::PATObject<reco::BaseTau>();
}

static void constructor_61451( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::BaseTau>(*(const ::reco::BaseTau*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::BaseTau>(*(const ::reco::BaseTau*)arg[0]);
}

static void constructor_61452( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::BaseTau>(*(const ::edm::RefToBase<reco::BaseTau>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::BaseTau>(*(const ::edm::RefToBase<reco::BaseTau>*)arg[0]);
}

static void constructor_61453( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::BaseTau>(*(const ::edm::Ptr<reco::BaseTau>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::BaseTau>(*(const ::edm::Ptr<reco::BaseTau>*)arg[0]);
}

static void destructor_61454(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::PATObject<reco::BaseTau>*)o)->::pat::PATObject<reco::BaseTau>::~PATObject)();
}
static  void method_61455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->originalObject)());
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->originalObject)();
}

static  void method_61456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::BaseTau>*)o)->originalObjectRef)();
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->originalObjectRef)();
}

static  void method_61457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatches)();
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatches)();
}

static  void method_61458( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatch)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatch)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]);
  }
}

static  void method_61459( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
}

static  void method_61460( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]);
}

static  void method_61461( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]);
}

static  void method_61462( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61463( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61464( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61465( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61466( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]);
}

static  void method_61467( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61468( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61469( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61470( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]);
}

static  void method_61471( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61472( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61473( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_61474( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_61475( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_61476( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_61477( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61478( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61479( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61480( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61481( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61482( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]);
}

static  void method_61483( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61484( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61485( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_61486( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_61487( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_61488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_61489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61490( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61491( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61492( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61493( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::BaseTau>*)o)->addTriggerObjectMatch)(*(const ::pat::TriggerObjectStandAlone*)arg[0]);
}

static  void method_61494( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::BaseTau>*)o)->unpackTriggerObjectPathNames)(*(const ::edm::TriggerNames*)arg[0]);
}

static  void method_61495( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::BaseTau>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,pat::LookupTableRecord> >)((((const ::pat::PATObject<reco::BaseTau>*)o)->efficiencies)());
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->efficiencies)();
}

static  void method_61497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::BaseTau>*)o)->efficiencyNames)();
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->efficiencyNames)();
}

static  void method_61498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::BaseTau>*)o)->efficiencyValues)();
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->efficiencyValues)();
}

static  void method_61499( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::BaseTau>*)o)->setEfficiency)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::pat::LookupTableRecord*)arg[1]);
}

static  void method_61500( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::BaseTau>*)o)->genParticleRef)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->genParticleRef)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::BaseTau>*)o)->genParticleRef)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->genParticleRef)(*(::size_t*)arg[0]);
  }
}

static  void method_61501( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::BaseTau>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::BaseTau>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]);
  }
}

static  void method_61502( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->genParticle)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->genParticle)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->genParticle)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->genParticle)(*(::size_t*)arg[0]);
  }
}

static  void method_61503( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PATObject<reco::BaseTau>*)o)->genParticlesSize)());
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->genParticlesSize)();
}

static  void method_61504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > >)((((const ::pat::PATObject<reco::BaseTau>*)o)->genParticleRefs)());
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->genParticleRefs)();
}

static  void method_61505( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::BaseTau>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::BaseTau>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_61506( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::BaseTau>*)o)->addGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
}

static  void method_61507( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::BaseTau>*)o)->setGenParticle)(*(const ::reco::GenParticle*)arg[0]);
}

static  void method_61508( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::PATObject<reco::BaseTau>*)o)->embedGenParticle)();
}

static  void method_61509( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::BaseTau>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61510( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::BaseTau>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::BaseTau>*)o)->overlapLabels)();
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->overlapLabels)();
}

static  void method_61512( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::BaseTau>*)o)->setOverlaps)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::PtrVector<reco::Candidate>*)arg[1]);
}

static  void method_61513( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::BaseTau>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61514( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::BaseTau>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::BaseTau>*)o)->userDataNames)();
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->userDataNames)();
}

static  void method_61516( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::BaseTau>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61517( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::BaseTau>*)o)->addUserDataFromPtr)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<pat::UserData>*)arg[1]);
}

static  void method_61518( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::BaseTau>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61519( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::BaseTau>*)o)->userFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->userFloat)((const char*)arg[0]);
}

static  void method_61520( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::BaseTau>*)o)->addUserFloat)(*(const ::std::basic_string<char>*)arg[0],
    *(float*)arg[1]);
}

static  void method_61521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::BaseTau>*)o)->userFloatNames)();
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->userFloatNames)();
}

static  void method_61522( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::BaseTau>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61523( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::BaseTau>*)o)->hasUserFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->hasUserFloat)((const char*)arg[0]);
}

static  void method_61524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PATObject<reco::BaseTau>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61525( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::BaseTau>*)o)->addUserInt)(*(const ::std::basic_string<char>*)arg[0],
    *(int*)arg[1]);
}

static  void method_61526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::BaseTau>*)o)->userIntNames)();
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->userIntNames)();
}

static  void method_61527( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::BaseTau>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61528( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::pat::PATObject<reco::BaseTau>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61529( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::BaseTau>*)o)->addUserCand)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<reco::Candidate>*)arg[1]);
}

static  void method_61530( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::BaseTau>*)o)->userCandNames)();
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->userCandNames)();
}

static  void method_61531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::BaseTau>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::BaseTau>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61532( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::BaseTau>*)o)->getKinResolution)();
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->getKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::BaseTau>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61533( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::BaseTau>*)o)->hasKinResolution)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->hasKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::BaseTau>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61534( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::BaseTau>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::BaseTau>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
}

static  void method_61535( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolEta)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolEta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61536( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolTheta)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolTheta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61537( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolPhi)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolPhi)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61538( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolE)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolE)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolEt)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolEt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61540( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolP)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolP)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61541( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolPt)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolPt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61542( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolPInv)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolPInv)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolPx)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolPx)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61544( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolPy)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolPy)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolPz)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolPz)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolM)());
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolM)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::BaseTau>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::BaseTau>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static void method_newdel_13553( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::BaseTau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::BaseTau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::BaseTau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::BaseTau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::BaseTau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x132( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::BaseTau")), ::Reflex::BaseOffset< ::pat::PATObject<reco::BaseTau>,::reco::BaseTau >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::BaseTau>,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::BaseTau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::BaseTau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATObject<reco::BaseTau> -------------------------------
void __pat__PATObject_reco__BaseTau__db_datamem(Reflex::Class*);
void __pat__PATObject_reco__BaseTau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__BaseTau__datamem_bld(&__pat__PATObject_reco__BaseTau__db_datamem);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__BaseTau__funcmem_bld(&__pat__PATObject_reco__BaseTau__db_funcmem);
void __pat__PATObject_reco__BaseTau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::PATObject<reco::BaseTau>"), typeid(::pat::PATObject<reco::BaseTau>), sizeof(::pat::PATObject<reco::BaseTau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_11630, ::Reflex::BaseOffset< ::pat::PATObject<reco::BaseTau>, ::reco::BaseTau >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_11630, Reflex::Literal("pat::PATObject<reco::BaseTau>::base_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75180, type_75181), Reflex::Literal("operator="), operator_61448, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75181), Reflex::Literal("PATObject"), constructor_61449, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATObject"), constructor_61450, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26889), Reflex::Literal("PATObject"), constructor_61451, 0, "obj", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71915), Reflex::Literal("PATObject"), constructor_61452, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71972), Reflex::Literal("PATObject"), constructor_61453, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATObject"), destructor_61454, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13553, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x132, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__PATObject_reco__BaseTau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__PATObject_reco__BaseTau__funcmem_bld);
}

//------Delayed data member builder for class PATObject<reco::BaseTau> -------------------
void __pat__PATObject_reco__BaseTau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7325, Reflex::Literal("refToOrig_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, refToOrig_), ::Reflex::PROTECTED)
  .AddDataMember(type_3536, Reflex::Literal("triggerObjectMatchesEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, triggerObjectMatchesEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3535, Reflex::Literal("efficiencyValues_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, efficiencyValues_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("efficiencyNames_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, efficiencyNames_), ::Reflex::PROTECTED)
  .AddDataMember(type_3534, Reflex::Literal("genParticleRef_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, genParticleRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_3533, Reflex::Literal("genParticleEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, genParticleEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("overlapLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, overlapLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3532, Reflex::Literal("overlapItems_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, overlapItems_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userDataLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, userDataLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_7463, Reflex::Literal("userDataObjects_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, userDataObjects_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userFloatLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, userFloatLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3527, Reflex::Literal("userFloats_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, userFloats_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userIntLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, userIntLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3531, Reflex::Literal("userInts_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, userInts_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userCandLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, userCandLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3530, Reflex::Literal("userCands_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, userCands_), ::Reflex::PROTECTED)
  .AddDataMember(type_3529, Reflex::Literal("kinResolutions_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, kinResolutions_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("kinResolutionLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__BaseTau_, kinResolutionLabels_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class PATObject<reco::BaseTau> -------------------
void __pat__PATObject_reco__BaseTau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("originalObject"), method_61455, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22032), Reflex::Literal("originalObjectRef"), method_61456, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35967), Reflex::Literal("triggerObjectMatches"), method_61457, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_2393c), Reflex::Literal("triggerObjectMatch"), method_61458, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_13634c), Reflex::Literal("triggerObjectMatchesByType"), method_61459, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByType"), method_61460, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByFilterID"), method_61461, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_13634c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_61462, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_61463, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByFilterID"), method_61464, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCollection"), method_61465, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCollection"), method_61466, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_61467, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_61468, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCondition"), method_61469, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCondition"), method_61470, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_61471, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_61472, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61473, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61474, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61475, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61476, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61477, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61478, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61479, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61480, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByFilter"), method_61481, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByFilter"), method_61482, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_61483, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_61484, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_61485, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_61486, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_61487, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_61488, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61489, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61490, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61491, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61492, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22412), Reflex::Literal("addTriggerObjectMatch"), method_61493, 0, "trigObj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75115), Reflex::Literal("unpackTriggerObjectPathNames"), method_61494, 0, "names", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17959, type_18052), Reflex::Literal("efficiency"), method_61495, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3537), Reflex::Literal("efficiencies"), method_61496, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("efficiencyNames"), method_61497, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65126), Reflex::Literal("efficiencyValues"), method_61498, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_17959), Reflex::Literal("setEfficiency"), method_61499, 0, "name;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_2393), Reflex::Literal("genParticleRef"), method_61500, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_72, type_72, type_2051), Reflex::Literal("genParticleById"), method_61501, 0, "pdgId;status;autoCharge=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22220, type_2393), Reflex::Literal("genParticle"), method_61502, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("genParticlesSize"), method_61503, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3534), Reflex::Literal("genParticleRefs"), method_61504, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938, type_1810), Reflex::Literal("setGenParticleRef"), method_61505, 0, "ref;embed=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938), Reflex::Literal("addGenParticleRef"), method_61506, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22224), Reflex::Literal("setGenParticle"), method_61507, 0, "particle", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedGenParticle"), method_61508, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasOverlaps"), method_61509, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22159, type_18052), Reflex::Literal("overlaps"), method_61510, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("overlapLabels"), method_61511, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22159), Reflex::Literal("setOverlaps"), method_61512, 0, "label;overlaps", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserData"), method_61513, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18052, type_18052), Reflex::Literal("userDataObjectType"), method_61514, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userDataNames"), method_61515, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416, type_18052), Reflex::Literal("userDataBare"), method_61516, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_71958), Reflex::Literal("addUserDataFromPtr"), method_61517, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_18052), Reflex::Literal("userFloat"), method_61518, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_4688), Reflex::Literal("userFloat"), method_61519, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_990), Reflex::Literal("addUserFloat"), method_61520, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userFloatNames"), method_61521, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserFloat"), method_61522, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_4688), Reflex::Literal("hasUserFloat"), method_61523, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_18052), Reflex::Literal("userInt"), method_61524, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_72), Reflex::Literal("addUserInt"), method_61525, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userIntNames"), method_61526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserInt"), method_61527, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7325, type_18052), Reflex::Literal("userCand"), method_61528, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22032), Reflex::Literal("addUserCand"), method_61529, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userCandNames"), method_61530, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserCand"), method_61531, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21967, type_18052), Reflex::Literal("getKinResolution"), method_61532, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasKinResolution"), method_61533, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_21967, type_18052), Reflex::Literal("setKinResolution"), method_61534, 0, "resol;label=\"\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEta"), method_61535, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolTheta"), method_61536, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPhi"), method_61537, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolE"), method_61538, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEt"), method_61539, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolP"), method_61540, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPt"), method_61541, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPInv"), method_61542, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPx"), method_61543, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPy"), method_61544, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPz"), method_61545, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolM"), method_61546, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PATObject<reco::Muon> -------------------------------
static  void operator_61567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::PATObject<reco::Muon>*)o)->operator=)(*(const ::pat::PATObject<reco::Muon>*)arg[0]);
  else   (((::pat::PATObject<reco::Muon>*)o)->operator=)(*(const ::pat::PATObject<reco::Muon>*)arg[0]);
}

static void constructor_61568( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::Muon>(*(const ::pat::PATObject<reco::Muon>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::Muon>(*(const ::pat::PATObject<reco::Muon>*)arg[0]);
}

static void constructor_61569( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::Muon>();
  else ::new(mem) ::pat::PATObject<reco::Muon>();
}

static void constructor_61570( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::Muon>(*(const ::reco::Muon*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::Muon>(*(const ::reco::Muon*)arg[0]);
}

static void constructor_61571( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::Muon>(*(const ::edm::RefToBase<reco::Muon>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::Muon>(*(const ::edm::RefToBase<reco::Muon>*)arg[0]);
}

static void constructor_61572( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::Muon>(*(const ::edm::Ptr<reco::Muon>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::Muon>(*(const ::edm::Ptr<reco::Muon>*)arg[0]);
}

static void destructor_61573(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::PATObject<reco::Muon>*)o)->::pat::PATObject<reco::Muon>::~PATObject)();
}
static  void method_61574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->originalObject)());
  else   (((const ::pat::PATObject<reco::Muon>*)o)->originalObject)();
}

static  void method_61575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Muon>*)o)->originalObjectRef)();
  else   (((const ::pat::PATObject<reco::Muon>*)o)->originalObjectRef)();
}

static  void method_61576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatches)();
  else   (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatches)();
}

static  void method_61577( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatch)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatch)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]);
  }
}

static  void method_61578( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
}

static  void method_61579( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]);
}

static  void method_61580( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]);
}

static  void method_61581( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61582( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61583( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61585( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]);
}

static  void method_61586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61589( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]);
}

static  void method_61590( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61591( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61592( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_61593( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_61594( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_61595( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_61596( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61597( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61598( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61599( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61601( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]);
}

static  void method_61602( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61604( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_61605( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_61606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_61607( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_61608( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61610( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61612( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Muon>*)o)->addTriggerObjectMatch)(*(const ::pat::TriggerObjectStandAlone*)arg[0]);
}

static  void method_61613( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Muon>*)o)->unpackTriggerObjectPathNames)(*(const ::edm::TriggerNames*)arg[0]);
}

static  void method_61614( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Muon>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::Muon>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,pat::LookupTableRecord> >)((((const ::pat::PATObject<reco::Muon>*)o)->efficiencies)());
  else   (((const ::pat::PATObject<reco::Muon>*)o)->efficiencies)();
}

static  void method_61616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Muon>*)o)->efficiencyNames)();
  else   (((const ::pat::PATObject<reco::Muon>*)o)->efficiencyNames)();
}

static  void method_61617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Muon>*)o)->efficiencyValues)();
  else   (((const ::pat::PATObject<reco::Muon>*)o)->efficiencyValues)();
}

static  void method_61618( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Muon>*)o)->setEfficiency)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::pat::LookupTableRecord*)arg[1]);
}

static  void method_61619( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::Muon>*)o)->genParticleRef)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->genParticleRef)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::Muon>*)o)->genParticleRef)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->genParticleRef)(*(::size_t*)arg[0]);
  }
}

static  void method_61620( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::Muon>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::Muon>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]);
  }
}

static  void method_61621( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->genParticle)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->genParticle)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->genParticle)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->genParticle)(*(::size_t*)arg[0]);
  }
}

static  void method_61622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PATObject<reco::Muon>*)o)->genParticlesSize)());
  else   (((const ::pat::PATObject<reco::Muon>*)o)->genParticlesSize)();
}

static  void method_61623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > >)((((const ::pat::PATObject<reco::Muon>*)o)->genParticleRefs)());
  else   (((const ::pat::PATObject<reco::Muon>*)o)->genParticleRefs)();
}

static  void method_61624( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::Muon>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::Muon>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_61625( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Muon>*)o)->addGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
}

static  void method_61626( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Muon>*)o)->setGenParticle)(*(const ::reco::GenParticle*)arg[0]);
}

static  void method_61627( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::PATObject<reco::Muon>*)o)->embedGenParticle)();
}

static  void method_61628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Muon>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Muon>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::Muon>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Muon>*)o)->overlapLabels)();
  else   (((const ::pat::PATObject<reco::Muon>*)o)->overlapLabels)();
}

static  void method_61631( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Muon>*)o)->setOverlaps)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::PtrVector<reco::Candidate>*)arg[1]);
}

static  void method_61632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Muon>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61633( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Muon>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::Muon>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Muon>*)o)->userDataNames)();
  else   (((const ::pat::PATObject<reco::Muon>*)o)->userDataNames)();
}

static  void method_61635( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::Muon>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61636( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Muon>*)o)->addUserDataFromPtr)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<pat::UserData>*)arg[1]);
}

static  void method_61637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::Muon>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::Muon>*)o)->userFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->userFloat)((const char*)arg[0]);
}

static  void method_61639( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Muon>*)o)->addUserFloat)(*(const ::std::basic_string<char>*)arg[0],
    *(float*)arg[1]);
}

static  void method_61640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Muon>*)o)->userFloatNames)();
  else   (((const ::pat::PATObject<reco::Muon>*)o)->userFloatNames)();
}

static  void method_61641( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Muon>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61642( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Muon>*)o)->hasUserFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->hasUserFloat)((const char*)arg[0]);
}

static  void method_61643( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PATObject<reco::Muon>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61644( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Muon>*)o)->addUserInt)(*(const ::std::basic_string<char>*)arg[0],
    *(int*)arg[1]);
}

static  void method_61645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Muon>*)o)->userIntNames)();
  else   (((const ::pat::PATObject<reco::Muon>*)o)->userIntNames)();
}

static  void method_61646( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Muon>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61647( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::pat::PATObject<reco::Muon>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61648( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::Muon>*)o)->addUserCand)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<reco::Candidate>*)arg[1]);
}

static  void method_61649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Muon>*)o)->userCandNames)();
  else   (((const ::pat::PATObject<reco::Muon>*)o)->userCandNames)();
}

static  void method_61650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Muon>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::Muon>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61651( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Muon>*)o)->getKinResolution)();
    else     (((const ::pat::PATObject<reco::Muon>*)o)->getKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::Muon>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
    else     (((const ::pat::PATObject<reco::Muon>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61652( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Muon>*)o)->hasKinResolution)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->hasKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::Muon>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61653( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::Muon>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::Muon>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
}

static  void method_61654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolEta)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolEta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61655( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolTheta)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolTheta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61656( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolPhi)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolPhi)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolE)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolE)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61658( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolEt)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolEt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61659( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolP)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolP)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolPt)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolPt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolPInv)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolPInv)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61662( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolPx)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolPx)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolPy)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolPy)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolPz)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolPz)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolM)());
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolM)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::Muon>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::Muon>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static void method_newdel_13554( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::Muon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::Muon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::Muon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::Muon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::Muon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x134( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Muon")), ::Reflex::BaseOffset< ::pat::PATObject<reco::Muon>,::reco::Muon >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::Muon>,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::Muon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::Muon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATObject<reco::Muon> -------------------------------
void __pat__PATObject_reco__Muon__db_datamem(Reflex::Class*);
void __pat__PATObject_reco__Muon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__Muon__datamem_bld(&__pat__PATObject_reco__Muon__db_datamem);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__Muon__funcmem_bld(&__pat__PATObject_reco__Muon__db_funcmem);
void __pat__PATObject_reco__Muon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::PATObject<reco::Muon>"), typeid(::pat::PATObject<reco::Muon>), sizeof(::pat::PATObject<reco::Muon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_11232, ::Reflex::BaseOffset< ::pat::PATObject<reco::Muon>, ::reco::Muon >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_11232, Reflex::Literal("pat::PATObject<reco::Muon>::base_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75182, type_75183), Reflex::Literal("operator="), operator_61567, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75183), Reflex::Literal("PATObject"), constructor_61568, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATObject"), constructor_61569, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27924), Reflex::Literal("PATObject"), constructor_61570, 0, "obj", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71920), Reflex::Literal("PATObject"), constructor_61571, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71976), Reflex::Literal("PATObject"), constructor_61572, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATObject"), destructor_61573, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13554, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x134, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__PATObject_reco__Muon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__PATObject_reco__Muon__funcmem_bld);
}

//------Delayed data member builder for class PATObject<reco::Muon> -------------------
void __pat__PATObject_reco__Muon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7325, Reflex::Literal("refToOrig_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, refToOrig_), ::Reflex::PROTECTED)
  .AddDataMember(type_3536, Reflex::Literal("triggerObjectMatchesEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, triggerObjectMatchesEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3535, Reflex::Literal("efficiencyValues_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, efficiencyValues_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("efficiencyNames_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, efficiencyNames_), ::Reflex::PROTECTED)
  .AddDataMember(type_3534, Reflex::Literal("genParticleRef_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, genParticleRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_3533, Reflex::Literal("genParticleEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, genParticleEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("overlapLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, overlapLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3532, Reflex::Literal("overlapItems_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, overlapItems_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userDataLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, userDataLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_7463, Reflex::Literal("userDataObjects_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, userDataObjects_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userFloatLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, userFloatLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3527, Reflex::Literal("userFloats_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, userFloats_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userIntLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, userIntLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3531, Reflex::Literal("userInts_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, userInts_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userCandLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, userCandLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3530, Reflex::Literal("userCands_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, userCands_), ::Reflex::PROTECTED)
  .AddDataMember(type_3529, Reflex::Literal("kinResolutions_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, kinResolutions_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("kinResolutionLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__Muon_, kinResolutionLabels_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class PATObject<reco::Muon> -------------------
void __pat__PATObject_reco__Muon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("originalObject"), method_61574, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22032), Reflex::Literal("originalObjectRef"), method_61575, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35967), Reflex::Literal("triggerObjectMatches"), method_61576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_2393c), Reflex::Literal("triggerObjectMatch"), method_61577, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_13634c), Reflex::Literal("triggerObjectMatchesByType"), method_61578, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByType"), method_61579, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByFilterID"), method_61580, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_13634c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_61581, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_61582, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByFilterID"), method_61583, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCollection"), method_61584, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCollection"), method_61585, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_61586, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_61587, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCondition"), method_61588, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCondition"), method_61589, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_61590, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_61591, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61592, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61593, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61594, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61595, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61596, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61597, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61598, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61599, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByFilter"), method_61600, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByFilter"), method_61601, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_61602, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_61603, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_61604, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_61605, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_61606, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_61607, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61608, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61609, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61610, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61611, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22412), Reflex::Literal("addTriggerObjectMatch"), method_61612, 0, "trigObj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75115), Reflex::Literal("unpackTriggerObjectPathNames"), method_61613, 0, "names", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17959, type_18052), Reflex::Literal("efficiency"), method_61614, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3537), Reflex::Literal("efficiencies"), method_61615, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("efficiencyNames"), method_61616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65126), Reflex::Literal("efficiencyValues"), method_61617, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_17959), Reflex::Literal("setEfficiency"), method_61618, 0, "name;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_2393), Reflex::Literal("genParticleRef"), method_61619, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_72, type_72, type_2051), Reflex::Literal("genParticleById"), method_61620, 0, "pdgId;status;autoCharge=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22220, type_2393), Reflex::Literal("genParticle"), method_61621, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("genParticlesSize"), method_61622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3534), Reflex::Literal("genParticleRefs"), method_61623, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938, type_1810), Reflex::Literal("setGenParticleRef"), method_61624, 0, "ref;embed=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938), Reflex::Literal("addGenParticleRef"), method_61625, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22224), Reflex::Literal("setGenParticle"), method_61626, 0, "particle", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedGenParticle"), method_61627, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasOverlaps"), method_61628, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22159, type_18052), Reflex::Literal("overlaps"), method_61629, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("overlapLabels"), method_61630, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22159), Reflex::Literal("setOverlaps"), method_61631, 0, "label;overlaps", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserData"), method_61632, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18052, type_18052), Reflex::Literal("userDataObjectType"), method_61633, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userDataNames"), method_61634, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416, type_18052), Reflex::Literal("userDataBare"), method_61635, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_71958), Reflex::Literal("addUserDataFromPtr"), method_61636, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_18052), Reflex::Literal("userFloat"), method_61637, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_4688), Reflex::Literal("userFloat"), method_61638, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_990), Reflex::Literal("addUserFloat"), method_61639, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userFloatNames"), method_61640, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserFloat"), method_61641, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_4688), Reflex::Literal("hasUserFloat"), method_61642, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_18052), Reflex::Literal("userInt"), method_61643, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_72), Reflex::Literal("addUserInt"), method_61644, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userIntNames"), method_61645, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserInt"), method_61646, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7325, type_18052), Reflex::Literal("userCand"), method_61647, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22032), Reflex::Literal("addUserCand"), method_61648, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userCandNames"), method_61649, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserCand"), method_61650, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21967, type_18052), Reflex::Literal("getKinResolution"), method_61651, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasKinResolution"), method_61652, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_21967, type_18052), Reflex::Literal("setKinResolution"), method_61653, 0, "resol;label=\"\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEta"), method_61654, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolTheta"), method_61655, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPhi"), method_61656, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolE"), method_61657, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEt"), method_61658, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolP"), method_61659, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPt"), method_61660, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPInv"), method_61661, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPx"), method_61662, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPy"), method_61663, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPz"), method_61664, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolM"), method_61665, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PATObject<reco::GsfElectron> -------------------------------
static  void operator_61686( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::PATObject<reco::GsfElectron>*)o)->operator=)(*(const ::pat::PATObject<reco::GsfElectron>*)arg[0]);
  else   (((::pat::PATObject<reco::GsfElectron>*)o)->operator=)(*(const ::pat::PATObject<reco::GsfElectron>*)arg[0]);
}

static void constructor_61687( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::GsfElectron>(*(const ::pat::PATObject<reco::GsfElectron>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::GsfElectron>(*(const ::pat::PATObject<reco::GsfElectron>*)arg[0]);
}

static void constructor_61688( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::GsfElectron>();
  else ::new(mem) ::pat::PATObject<reco::GsfElectron>();
}

static void constructor_61689( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::GsfElectron>(*(const ::reco::GsfElectron*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::GsfElectron>(*(const ::reco::GsfElectron*)arg[0]);
}

static void constructor_61690( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::GsfElectron>(*(const ::edm::RefToBase<reco::GsfElectron>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::GsfElectron>(*(const ::edm::RefToBase<reco::GsfElectron>*)arg[0]);
}

static void constructor_61691( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::PATObject<reco::GsfElectron>(*(const ::edm::Ptr<reco::GsfElectron>*)arg[0]);
  else ::new(mem) ::pat::PATObject<reco::GsfElectron>(*(const ::edm::Ptr<reco::GsfElectron>*)arg[0]);
}

static void destructor_61692(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::PATObject<reco::GsfElectron>*)o)->::pat::PATObject<reco::GsfElectron>::~PATObject)();
}
static  void method_61693( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->originalObject)());
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->originalObject)();
}

static  void method_61694( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::GsfElectron>*)o)->originalObjectRef)();
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->originalObjectRef)();
}

static  void method_61695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatches)();
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatches)();
}

static  void method_61696( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatch)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatch)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatch)(*(const ::size_t*)arg[0]);
  }
}

static  void method_61697( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
}

static  void method_61698( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByType)(*(const unsigned int*)arg[0]);
}

static  void method_61699( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByFilterID)(*(const unsigned int*)arg[0]);
}

static  void method_61700( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByType)(*(const ::trigger::TriggerObjectType*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61701( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByType)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61702( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByFilterID)(*(const unsigned int*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61703( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByCollection)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61704( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByCollection)((const char*)arg[0]);
}

static  void method_61705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCollection)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61706( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCollection)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCollection)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61707( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByCondition)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61708( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByCondition)((const char*)arg[0]);
}

static  void method_61709( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCondition)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61710( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCondition)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByCondition)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61711( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_61712( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_61713( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_61714( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByAlgorithm)((const char*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_61715( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61716( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61717( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61718( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByAlgorithm)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::size_t*)arg[2]);
  }
}

static  void method_61719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByFilter)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61720( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByFilter)((const char*)arg[0]);
}

static  void method_61721( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByFilter)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61722( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByFilter)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByFilter)((const char*)arg[0],
      *(const ::size_t*)arg[1]);
  }
}

static  void method_61723( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_61724( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_61725( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_61726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<pat::TriggerObjectStandAlone>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchesByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
}

static  void method_61727( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61728( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)((const char*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61729( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->triggerObjectMatchByPath)((const char*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const ::size_t*)arg[3]);
  }
}

static  void method_61731( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::GsfElectron>*)o)->addTriggerObjectMatch)(*(const ::pat::TriggerObjectStandAlone*)arg[0]);
}

static  void method_61732( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::GsfElectron>*)o)->unpackTriggerObjectPathNames)(*(const ::edm::TriggerNames*)arg[0]);
}

static  void method_61733( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::GsfElectron>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->efficiency)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::pair<std::basic_string<char>,pat::LookupTableRecord> >)((((const ::pat::PATObject<reco::GsfElectron>*)o)->efficiencies)());
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->efficiencies)();
}

static  void method_61735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::GsfElectron>*)o)->efficiencyNames)();
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->efficiencyNames)();
}

static  void method_61736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::GsfElectron>*)o)->efficiencyValues)();
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->efficiencyValues)();
}

static  void method_61737( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::GsfElectron>*)o)->setEfficiency)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::pat::LookupTableRecord*)arg[1]);
}

static  void method_61738( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticleRef)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticleRef)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticleRef)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticleRef)(*(::size_t*)arg[0]);
  }
}

static  void method_61739( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >)((((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticleById)(*(int*)arg[0],
      *(int*)arg[1],
      *(::uint8_t*)arg[2]);
  }
}

static  void method_61740( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticle)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticle)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticle)(*(::size_t*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticle)(*(::size_t*)arg[0]);
  }
}

static  void method_61741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticlesSize)());
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticlesSize)();
}

static  void method_61742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> > >)((((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticleRefs)());
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->genParticleRefs)();
}

static  void method_61743( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::GsfElectron>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::GsfElectron>*)o)->setGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_61744( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::GsfElectron>*)o)->addGenParticleRef)(*(const ::edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >*)arg[0]);
}

static  void method_61745( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::GsfElectron>*)o)->setGenParticle)(*(const ::reco::GenParticle*)arg[0]);
}

static  void method_61746( void*, void* o, const std::vector<void*>&, void*)
{
  (((::pat::PATObject<reco::GsfElectron>*)o)->embedGenParticle)();
}

static  void method_61747( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::GsfElectron>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->hasOverlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61748( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::GsfElectron>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->overlaps)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::GsfElectron>*)o)->overlapLabels)();
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->overlapLabels)();
}

static  void method_61750( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::GsfElectron>*)o)->setOverlaps)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::PtrVector<reco::Candidate>*)arg[1]);
}

static  void method_61751( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::GsfElectron>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->hasUserData)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61752( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::GsfElectron>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->userDataObjectType)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::GsfElectron>*)o)->userDataNames)();
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->userDataNames)();
}

static  void method_61754( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::pat::PATObject<reco::GsfElectron>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->userDataBare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61755( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::GsfElectron>*)o)->addUserDataFromPtr)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<pat::UserData>*)arg[1]);
}

static  void method_61756( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::GsfElectron>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->userFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61757( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::pat::PATObject<reco::GsfElectron>*)o)->userFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->userFloat)((const char*)arg[0]);
}

static  void method_61758( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::GsfElectron>*)o)->addUserFloat)(*(const ::std::basic_string<char>*)arg[0],
    *(float*)arg[1]);
}

static  void method_61759( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::GsfElectron>*)o)->userFloatNames)();
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->userFloatNames)();
}

static  void method_61760( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::GsfElectron>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->hasUserFloat)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61761( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::GsfElectron>*)o)->hasUserFloat)((const char*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->hasUserFloat)((const char*)arg[0]);
}

static  void method_61762( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::PATObject<reco::GsfElectron>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->userInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61763( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::GsfElectron>*)o)->addUserInt)(*(const ::std::basic_string<char>*)arg[0],
    *(int*)arg[1]);
}

static  void method_61764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::GsfElectron>*)o)->userIntNames)();
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->userIntNames)();
}

static  void method_61765( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::GsfElectron>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->hasUserInt)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61766( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::pat::PATObject<reco::GsfElectron>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->userCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61767( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::pat::PATObject<reco::GsfElectron>*)o)->addUserCand)(*(const ::std::basic_string<char>*)arg[0],
    *(const ::edm::Ptr<reco::Candidate>*)arg[1]);
}

static  void method_61768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::GsfElectron>*)o)->userCandNames)();
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->userCandNames)();
}

static  void method_61769( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::GsfElectron>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::pat::PATObject<reco::GsfElectron>*)o)->hasUserCand)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_61770( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::GsfElectron>*)o)->getKinResolution)();
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->getKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::PATObject<reco::GsfElectron>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->getKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::GsfElectron>*)o)->hasKinResolution)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->hasKinResolution)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::pat::PATObject<reco::GsfElectron>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->hasKinResolution)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61772( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::pat::PATObject<reco::GsfElectron>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::pat::PATObject<reco::GsfElectron>*)o)->setKinResolution)(*(const ::pat::CandKinResolution*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
}

static  void method_61773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolEta)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolEta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolEta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61774( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolTheta)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolTheta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolTheta)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61775( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPhi)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPhi)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPhi)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolE)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolE)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolE)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61777( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolEt)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolEt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolEt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61778( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolP)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolP)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolP)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61779( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPt)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPt)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61780( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPInv)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPInv)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPInv)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61781( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPx)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPx)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPx)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61782( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPy)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPy)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPy)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61783( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPz)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPz)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolPz)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static  void method_61784( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolM)());
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolM)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::pat::PATObject<reco::GsfElectron>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::pat::PATObject<reco::GsfElectron>*)o)->resolM)(*(const ::std::basic_string<char>*)arg[0]);
  }
}

static void method_newdel_13555( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::GsfElectron> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::GsfElectron> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::GsfElectron> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::GsfElectron> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::PATObject<reco::GsfElectron> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x136( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::GsfElectron")), ::Reflex::BaseOffset< ::pat::PATObject<reco::GsfElectron>,::reco::GsfElectron >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::GsfElectron>,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::GsfElectron>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::pat::PATObject<reco::GsfElectron>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATObject<reco::GsfElectron> -------------------------------
void __pat__PATObject_reco__GsfElectron__db_datamem(Reflex::Class*);
void __pat__PATObject_reco__GsfElectron__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__GsfElectron__datamem_bld(&__pat__PATObject_reco__GsfElectron__db_datamem);
Reflex::GenreflexMemberBuilder __pat__PATObject_reco__GsfElectron__funcmem_bld(&__pat__PATObject_reco__GsfElectron__db_funcmem);
void __pat__PATObject_reco__GsfElectron__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::PATObject<reco::GsfElectron>"), typeid(::pat::PATObject<reco::GsfElectron>), sizeof(::pat::PATObject<reco::GsfElectron>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_11217, ::Reflex::BaseOffset< ::pat::PATObject<reco::GsfElectron>, ::reco::GsfElectron >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_11217, Reflex::Literal("pat::PATObject<reco::GsfElectron>::base_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75184, type_75185), Reflex::Literal("operator="), operator_61686, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75185), Reflex::Literal("PATObject"), constructor_61687, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATObject"), constructor_61688, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29540), Reflex::Literal("PATObject"), constructor_61689, 0, "obj", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71925), Reflex::Literal("PATObject"), constructor_61690, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71978), Reflex::Literal("PATObject"), constructor_61691, 0, "ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATObject"), destructor_61692, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13555, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x136, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__PATObject_reco__GsfElectron__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__PATObject_reco__GsfElectron__funcmem_bld);
}

//------Delayed data member builder for class PATObject<reco::GsfElectron> -------------------
void __pat__PATObject_reco__GsfElectron__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7325, Reflex::Literal("refToOrig_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, refToOrig_), ::Reflex::PROTECTED)
  .AddDataMember(type_3536, Reflex::Literal("triggerObjectMatchesEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, triggerObjectMatchesEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3535, Reflex::Literal("efficiencyValues_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, efficiencyValues_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("efficiencyNames_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, efficiencyNames_), ::Reflex::PROTECTED)
  .AddDataMember(type_3534, Reflex::Literal("genParticleRef_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, genParticleRef_), ::Reflex::PROTECTED)
  .AddDataMember(type_3533, Reflex::Literal("genParticleEmbedded_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, genParticleEmbedded_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("overlapLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, overlapLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3532, Reflex::Literal("overlapItems_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, overlapItems_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userDataLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, userDataLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_7463, Reflex::Literal("userDataObjects_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, userDataObjects_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userFloatLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, userFloatLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3527, Reflex::Literal("userFloats_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, userFloats_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userIntLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, userIntLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3531, Reflex::Literal("userInts_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, userInts_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("userCandLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, userCandLabels_), ::Reflex::PROTECTED)
  .AddDataMember(type_3530, Reflex::Literal("userCands_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, userCands_), ::Reflex::PROTECTED)
  .AddDataMember(type_3529, Reflex::Literal("kinResolutions_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, kinResolutions_), ::Reflex::PROTECTED)
  .AddDataMember(type_3528, Reflex::Literal("kinResolutionLabels_"), OffsetOf(__shadow__::__pat__PATObject_reco__GsfElectron_, kinResolutionLabels_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class PATObject<reco::GsfElectron> -------------------
void __pat__PATObject_reco__GsfElectron__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("originalObject"), method_61693, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22032), Reflex::Literal("originalObjectRef"), method_61694, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35967), Reflex::Literal("triggerObjectMatches"), method_61695, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_2393c), Reflex::Literal("triggerObjectMatch"), method_61696, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_13634c), Reflex::Literal("triggerObjectMatchesByType"), method_61697, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByType"), method_61698, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_227c), Reflex::Literal("triggerObjectMatchesByFilterID"), method_61699, 0, "triggerObjectType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_13634c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_61700, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByType"), method_61701, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByFilterID"), method_61702, 0, "triggerObjectType;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCollection"), method_61703, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCollection"), method_61704, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_61705, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCollection"), method_61706, 0, "coll;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByCondition"), method_61707, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByCondition"), method_61708, 0, "nameCondition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_61709, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByCondition"), method_61710, 0, "nameCondition;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61711, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61712, 0, "nameAlgorithm;algoCondAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61713, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c), Reflex::Literal("triggerObjectMatchesByAlgorithm"), method_61714, 0, "nameAlgorithm;algoCondAccepted", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61715, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61716, 0, "nameAlgorithm;algoCondAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61717, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByAlgorithm"), method_61718, 0, "nameAlgorithm;algoCondAccepted;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052), Reflex::Literal("triggerObjectMatchesByFilter"), method_61719, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688), Reflex::Literal("triggerObjectMatchesByFilter"), method_61720, 0, "labelFilter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_61721, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_2393c), Reflex::Literal("triggerObjectMatchByFilter"), method_61722, 0, "labelFilter;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_61723, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_1810c, type_1810c), Reflex::Literal("triggerObjectMatchesByPath"), method_61724, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_18052, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_61725, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536c, type_4688, type_227c, type_227c), Reflex::Literal("triggerObjectMatchesByPath"), method_61726, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61727, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_1810c, type_1810c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61728, 0, "namePath;pathLastFilterAccepted=false;pathL3FilterAccepted=true;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_18052, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61729, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409, type_4688, type_227c, type_227c, type_2393c), Reflex::Literal("triggerObjectMatchByPath"), method_61730, 0, "namePath;pathLastFilterAccepted;pathL3FilterAccepted=1;idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22412), Reflex::Literal("addTriggerObjectMatch"), method_61731, 0, "trigObj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_75115), Reflex::Literal("unpackTriggerObjectPathNames"), method_61732, 0, "names", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17959, type_18052), Reflex::Literal("efficiency"), method_61733, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3537), Reflex::Literal("efficiencies"), method_61734, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("efficiencyNames"), method_61735, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65126), Reflex::Literal("efficiencyValues"), method_61736, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_17959), Reflex::Literal("setEfficiency"), method_61737, 0, "name;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_2393), Reflex::Literal("genParticleRef"), method_61738, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7381, type_72, type_72, type_2051), Reflex::Literal("genParticleById"), method_61739, 0, "pdgId;status;autoCharge=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22220, type_2393), Reflex::Literal("genParticle"), method_61740, 0, "idx=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("genParticlesSize"), method_61741, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3534), Reflex::Literal("genParticleRefs"), method_61742, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938, type_1810), Reflex::Literal("setGenParticleRef"), method_61743, 0, "ref;embed=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_17938), Reflex::Literal("addGenParticleRef"), method_61744, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_22224), Reflex::Literal("setGenParticle"), method_61745, 0, "particle", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("embedGenParticle"), method_61746, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasOverlaps"), method_61747, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22159, type_18052), Reflex::Literal("overlaps"), method_61748, 0, "label", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("overlapLabels"), method_61749, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22159), Reflex::Literal("setOverlaps"), method_61750, 0, "label;overlaps", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserData"), method_61751, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18052, type_18052), Reflex::Literal("userDataObjectType"), method_61752, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userDataNames"), method_61753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416, type_18052), Reflex::Literal("userDataBare"), method_61754, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_71958), Reflex::Literal("addUserDataFromPtr"), method_61755, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_18052), Reflex::Literal("userFloat"), method_61756, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_4688), Reflex::Literal("userFloat"), method_61757, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_990), Reflex::Literal("addUserFloat"), method_61758, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userFloatNames"), method_61759, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserFloat"), method_61760, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_4688), Reflex::Literal("hasUserFloat"), method_61761, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_18052), Reflex::Literal("userInt"), method_61762, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_72), Reflex::Literal("addUserInt"), method_61763, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userIntNames"), method_61764, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserInt"), method_61765, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7325, type_18052), Reflex::Literal("userCand"), method_61766, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_18052, type_22032), Reflex::Literal("addUserCand"), method_61767, 0, "label;data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65110), Reflex::Literal("userCandNames"), method_61768, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasUserCand"), method_61769, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21967, type_18052), Reflex::Literal("getKinResolution"), method_61770, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_18052), Reflex::Literal("hasKinResolution"), method_61771, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_21967, type_18052), Reflex::Literal("setKinResolution"), method_61772, 0, "resol;label=\"\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEta"), method_61773, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolTheta"), method_61774, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPhi"), method_61775, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolE"), method_61776, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolEt"), method_61777, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolP"), method_61778, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPt"), method_61779, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPInv"), method_61780, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPx"), method_61781, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPy"), method_61782, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolPz"), method_61783, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112, type_18052), Reflex::Literal("resolM"), method_61784, 0, "label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefVector<std::vector<pat::Particle, std::allocator<pat::Particle> >,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > -------------------------------
static void destructor_38308(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::~RefVector)();
}
static void constructor_38309( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >();
}

static void constructor_38310( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
}

static void constructor_38311( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_38312( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
}

static  void operator_38313( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >)((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_38314( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >)((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_38315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->refVector)();
}

static  void method_38316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->empty)();
}

static  void method_38317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->size)();
}

static  void method_38318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->capacity)();
}

static  void method_38319( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_38320( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >)((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->begin)();
}

static  void method_38321( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >)((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->end)();
}

static  void method_38322( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->id)();
}

static  void method_38323( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->productGetter)();
}

static  void method_38324( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isNull)();
}

static  void method_38325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isNonnull)();
}

static  void operator_38326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->operator!)();
}

static  void method_38327( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->product)();
}

static  void method_38328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isAvailable)();
}

static  void method_38329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isTransient)();
}

static  void method_38330( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >)((((::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
}

static  void method_38331( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->clear)();
}

static  void method_38332( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
}

static  void operator_38333( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
}

static  void method_38334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->hasProductCache)();
}

static  void method_38335( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_38336( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->Class_Version)();
}

static void method_newdel_6483( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::Particle, std::allocator<pat::Particle> >,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > -------------------------------
void __edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__datamem_bld(&__edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__funcmem_bld(&__edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__db_funcmem);
void __edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >"), typeid(::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >), sizeof(::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::Class_Version())
  .AddTypedef(type_3514, Reflex::Literal("edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::collection_type"))
  .AddTypedef(type_13527, Reflex::Literal("edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::member_type"))
  .AddTypedef(type_35568, Reflex::Literal("edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::finder_type"))
  .AddTypedef(type_6384, Reflex::Literal("edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::iterator"))
  .AddTypedef(type_6384, Reflex::Literal("edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::const_iterator"))
  .AddTypedef(type_7374, Reflex::Literal("edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::value_type"))
  .AddTypedef(type_7374c, Reflex::Literal("edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::const_reference"))
  .AddTypedef(type_7374c, Reflex::Literal("edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::reference"))
  .AddTypedef(type_227, Reflex::Literal("edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::key_type"))
  .AddTypedef(type_3506, Reflex::Literal("edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::KeyVec"))
  .AddTypedef(type_3845, Reflex::Literal("edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::size_type"))
  .AddTypedef(type_5370, Reflex::Literal("edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_38308, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_38309, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70738), Reflex::Literal("RefVector"), constructor_38310, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("RefVector"), constructor_38311, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6483, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::Particle, std::allocator<pat::Particle> >,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > -------------------
void __edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5370, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::Particle, std::allocator<pat::Particle> >,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > -------------------
void __edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70739), Reflex::Literal("push_back"), method_38312, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7374c, type_3845), Reflex::Literal("operator[]"), operator_38313, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7374c, type_3845), Reflex::Literal("at"), method_38314, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35206), Reflex::Literal("refVector"), method_38315, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_38316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_38317, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_38318, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_38319, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6384), Reflex::Literal("begin"), method_38320, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6384), Reflex::Literal("end"), method_38321, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_38322, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_38323, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_38324, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_38325, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_38326, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70740), Reflex::Literal("product"), method_38327, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_38328, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_38329, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6384, type_70741), Reflex::Literal("erase"), method_38330, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_38331, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70742), Reflex::Literal("swap"), method_38332, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70742, type_70738), Reflex::Literal("operator="), operator_38333, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_38334, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_35212), Reflex::Literal("fillView"), method_38335, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_38336, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::Photon, std::allocator<pat::Photon> >,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > -------------------------------
static void destructor_38434(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::~RefVector)();
}
static void constructor_38435( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >();
}

static void constructor_38436( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
}

static void constructor_38437( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_38438( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
}

static  void operator_38439( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >)((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_38440( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >)((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_38441( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->refVector)();
}

static  void method_38442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->empty)();
}

static  void method_38443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->size)();
}

static  void method_38444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->capacity)();
}

static  void method_38445( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_38446( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >)((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->begin)();
}

static  void method_38447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >)((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->end)();
}

static  void method_38448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->id)();
}

static  void method_38449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->productGetter)();
}

static  void method_38450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isNull)();
}

static  void method_38451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isNonnull)();
}

static  void operator_38452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->operator!)();
}

static  void method_38453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->product)();
}

static  void method_38454( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isAvailable)();
}

static  void method_38455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isTransient)();
}

static  void method_38456( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >)((((::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
}

static  void method_38457( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->clear)();
}

static  void method_38458( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
}

static  void operator_38459( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
}

static  void method_38460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->hasProductCache)();
}

static  void method_38461( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_38462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->Class_Version)();
}

static void method_newdel_6486( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::Photon, std::allocator<pat::Photon> >,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > -------------------------------
void __edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__datamem_bld(&__edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__funcmem_bld(&__edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__db_funcmem);
void __edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >"), typeid(::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >), sizeof(::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::Class_Version())
  .AddTypedef(type_3517, Reflex::Literal("edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::collection_type"))
  .AddTypedef(type_13525, Reflex::Literal("edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::member_type"))
  .AddTypedef(type_35604, Reflex::Literal("edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::finder_type"))
  .AddTypedef(type_6387, Reflex::Literal("edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::iterator"))
  .AddTypedef(type_6387, Reflex::Literal("edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::const_iterator"))
  .AddTypedef(type_7377, Reflex::Literal("edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::value_type"))
  .AddTypedef(type_7377c, Reflex::Literal("edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::const_reference"))
  .AddTypedef(type_7377c, Reflex::Literal("edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::reference"))
  .AddTypedef(type_227, Reflex::Literal("edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::key_type"))
  .AddTypedef(type_3506, Reflex::Literal("edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::KeyVec"))
  .AddTypedef(type_3845, Reflex::Literal("edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::size_type"))
  .AddTypedef(type_5370, Reflex::Literal("edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_38434, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_38435, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70756), Reflex::Literal("RefVector"), constructor_38436, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("RefVector"), constructor_38437, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6486, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::Photon, std::allocator<pat::Photon> >,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > -------------------
void __edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5370, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::Photon, std::allocator<pat::Photon> >,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > -------------------
void __edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70757), Reflex::Literal("push_back"), method_38438, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7377c, type_3845), Reflex::Literal("operator[]"), operator_38439, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7377c, type_3845), Reflex::Literal("at"), method_38440, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35206), Reflex::Literal("refVector"), method_38441, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_38442, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_38443, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_38444, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_38445, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6387), Reflex::Literal("begin"), method_38446, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6387), Reflex::Literal("end"), method_38447, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_38448, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_38449, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_38450, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_38451, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_38452, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70758), Reflex::Literal("product"), method_38453, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_38454, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_38455, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6387, type_70759), Reflex::Literal("erase"), method_38456, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_38457, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70760), Reflex::Literal("swap"), method_38458, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70760, type_70756), Reflex::Literal("operator="), operator_38459, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_38460, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_35212), Reflex::Literal("fillView"), method_38461, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_38462, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::Muon, std::allocator<pat::Muon> >,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > -------------------------------
static void destructor_38518(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::~RefVector)();
}
static void constructor_38519( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >();
}

static void constructor_38520( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
}

static void constructor_38521( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_38522( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
}

static  void operator_38523( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >)((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_38524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >)((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_38525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->refVector)();
}

static  void method_38526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->empty)();
}

static  void method_38527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->size)();
}

static  void method_38528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->capacity)();
}

static  void method_38529( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_38530( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >)((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->begin)();
}

static  void method_38531( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >)((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->end)();
}

static  void method_38532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->id)();
}

static  void method_38533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->productGetter)();
}

static  void method_38534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isNull)();
}

static  void method_38535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isNonnull)();
}

static  void operator_38536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->operator!)();
}

static  void method_38537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->product)();
}

static  void method_38538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isAvailable)();
}

static  void method_38539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isTransient)();
}

static  void method_38540( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >)((((::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
}

static  void method_38541( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->clear)();
}

static  void method_38542( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
}

static  void operator_38543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
}

static  void method_38544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->hasProductCache)();
}

static  void method_38545( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_38546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->Class_Version)();
}

static void method_newdel_6488( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::Muon, std::allocator<pat::Muon> >,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > -------------------------------
void __edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__datamem_bld(&__edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__funcmem_bld(&__edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__db_funcmem);
void __edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >"), typeid(::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >), sizeof(::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::Class_Version())
  .AddTypedef(type_3519, Reflex::Literal("edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::collection_type"))
  .AddTypedef(type_13465, Reflex::Literal("edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::member_type"))
  .AddTypedef(type_35628, Reflex::Literal("edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::finder_type"))
  .AddTypedef(type_6389, Reflex::Literal("edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::iterator"))
  .AddTypedef(type_6389, Reflex::Literal("edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::const_iterator"))
  .AddTypedef(type_7379, Reflex::Literal("edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::value_type"))
  .AddTypedef(type_7379c, Reflex::Literal("edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::const_reference"))
  .AddTypedef(type_7379c, Reflex::Literal("edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::reference"))
  .AddTypedef(type_227, Reflex::Literal("edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::key_type"))
  .AddTypedef(type_3506, Reflex::Literal("edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::KeyVec"))
  .AddTypedef(type_3845, Reflex::Literal("edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::size_type"))
  .AddTypedef(type_5370, Reflex::Literal("edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_38518, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_38519, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70768), Reflex::Literal("RefVector"), constructor_38520, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("RefVector"), constructor_38521, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6488, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::Muon, std::allocator<pat::Muon> >,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > -------------------
void __edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5370, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::Muon, std::allocator<pat::Muon> >,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > -------------------
void __edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70769), Reflex::Literal("push_back"), method_38522, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7379c, type_3845), Reflex::Literal("operator[]"), operator_38523, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7379c, type_3845), Reflex::Literal("at"), method_38524, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35206), Reflex::Literal("refVector"), method_38525, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_38526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_38527, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_38528, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_38529, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6389), Reflex::Literal("begin"), method_38530, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6389), Reflex::Literal("end"), method_38531, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_38532, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_38533, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_38534, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_38535, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_38536, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70770), Reflex::Literal("product"), method_38537, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_38538, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_38539, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6389, type_70771), Reflex::Literal("erase"), method_38540, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_38541, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70772), Reflex::Literal("swap"), method_38542, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70772, type_70768), Reflex::Literal("operator="), operator_38543, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_38544, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_35212), Reflex::Literal("fillView"), method_38545, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_38546, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >, pat::PackedGenParticle> > -------------------------------
static  void operator_42371( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0]);
}

static void constructor_42372( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0]);
}

static void constructor_42373( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >();
}

static void constructor_42374( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::Handle<std::vector<pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::Handle<std::vector<pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::Handle<std::vector<pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::Handle<std::vector<pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42375( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::OrphanHandle<std::vector<pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::OrphanHandle<std::vector<pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::OrphanHandle<std::vector<pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::OrphanHandle<std::vector<pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42376( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42377( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >((const ::std::vector<pat::PackedGenParticle>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >((const ::std::vector<pat::PackedGenParticle>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >((const ::std::vector<pat::PackedGenParticle>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >((const ::std::vector<pat::PackedGenParticle>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42378( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::TestHandle<std::vector<pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::TestHandle<std::vector<pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::TestHandle<std::vector<pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::TestHandle<std::vector<pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42379( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_42380( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::PackedGenParticle*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::PackedGenParticle>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::PackedGenParticle*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::PackedGenParticle>*)arg[3]);
}

static void constructor_42381( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_42382( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::RefProd<std::vector<pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::RefProd<std::vector<pat::PackedGenParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_42383(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::~Ref)();
}
static  void operator_42384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->operator*)();
}

static  void operator_42385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->operator->)();
}

static  void method_42386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->get)();
}

static  void method_42387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isNull)();
}

static  void method_42388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isNonnull)();
}

static  void operator_42389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->operator!)();
}

static  void method_42390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->id)();
}

static  void method_42391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->productGetter)();
}

static  void method_42392( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->product)();
}

static  void method_42393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->key)();
}

static  void method_42394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->index)();
}

static  void method_42395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->hasProductCache)();
}

static  void method_42396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isAvailable)();
}

static  void method_42397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isTransient)();
}

static  void method_42398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->refCore)();
}

static  void method_42399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->Class_Version)();
}

static void constructor_42400( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_7368( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >, pat::PackedGenParticle> > -------------------------------
void __edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__datamem_bld(&__edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__funcmem_bld(&__edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__db_funcmem);
void __edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >"), typeid(::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >), sizeof(::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::Class_Version())
  .AddTypedef(type_9072, Reflex::Literal("edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::T"))
  .AddTypedef(type_35484, Reflex::Literal("edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::F"))
  .AddTypedef(type_37527, Reflex::Literal("edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::VF"))
  .AddTypedef(type_37526, Reflex::Literal("edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::VBF"))
  .AddTypedef(type_3507, Reflex::Literal("edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::product_type"))
  .AddTypedef(type_9072, Reflex::Literal("edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::value_type"))
  .AddTypedef(type_9072c, Reflex::Literal("edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::element_type"))
  .AddTypedef(type_35484, Reflex::Literal("edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::finder_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::argument_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72000, type_70697), Reflex::Literal("operator="), operator_42371, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70697), Reflex::Literal("Ref"), constructor_42372, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_42373, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72001, type_227, type_1810), Reflex::Literal("Ref"), constructor_42374, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72002, type_227, type_1810), Reflex::Literal("Ref"), constructor_42375, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70696, type_227, type_1810), Reflex::Literal("Ref"), constructor_42376, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70698, type_227, type_1810), Reflex::Literal("Ref"), constructor_42377, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72003, type_227, type_1810), Reflex::Literal("Ref"), constructor_42378, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_227, type_35207), Reflex::Literal("Ref"), constructor_42379, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17685, type_227, type_70698), Reflex::Literal("Ref"), constructor_42380, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ref"), constructor_42381, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72004, type_227), Reflex::Literal("Ref"), constructor_42382, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_42383, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35224, type_18009), Reflex::Literal("Ref"), constructor_42400, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7368, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >, pat::PackedGenParticle> > -------------------
void __edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7471, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >, pat::PackedGenParticle> > -------------------
void __edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17687), Reflex::Literal("operator*"), operator_42384, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17685), Reflex::Literal("operator->"), operator_42385, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17685), Reflex::Literal("get"), method_42386, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_42387, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_42388, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_42389, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_42390, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_42391, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70698), Reflex::Literal("product"), method_42392, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("key"), method_42393, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("index"), method_42394, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_42395, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_42396, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_42397, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_42398, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_42399, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::Jet, std::allocator<pat::Jet> >,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > -------------------------------
static void destructor_38392(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::~RefVector)();
}
static void constructor_38393( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >();
}

static void constructor_38394( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
}

static void constructor_38395( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_38396( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
}

static  void operator_38397( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >)((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_38398( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >)((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_38399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->refVector)();
}

static  void method_38400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->empty)();
}

static  void method_38401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->size)();
}

static  void method_38402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->capacity)();
}

static  void method_38403( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_38404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >)((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->begin)();
}

static  void method_38405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >)((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->end)();
}

static  void method_38406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->id)();
}

static  void method_38407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->productGetter)();
}

static  void method_38408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isNull)();
}

static  void method_38409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isNonnull)();
}

static  void operator_38410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->operator!)();
}

static  void method_38411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->product)();
}

static  void method_38412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isAvailable)();
}

static  void method_38413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isTransient)();
}

static  void method_38414( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >)((((::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
}

static  void method_38415( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->clear)();
}

static  void method_38416( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
}

static  void operator_38417( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
}

static  void method_38418( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->hasProductCache)();
}

static  void method_38419( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_38420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->Class_Version)();
}

static void method_newdel_6485( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::Jet, std::allocator<pat::Jet> >,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > -------------------------------
void __edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__datamem_bld(&__edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__funcmem_bld(&__edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__db_funcmem);
void __edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >"), typeid(::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >), sizeof(::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::Class_Version())
  .AddTypedef(type_3516, Reflex::Literal("edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::collection_type"))
  .AddTypedef(type_13487, Reflex::Literal("edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::member_type"))
  .AddTypedef(type_35592, Reflex::Literal("edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::finder_type"))
  .AddTypedef(type_6386, Reflex::Literal("edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::iterator"))
  .AddTypedef(type_6386, Reflex::Literal("edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::const_iterator"))
  .AddTypedef(type_7376, Reflex::Literal("edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::value_type"))
  .AddTypedef(type_7376c, Reflex::Literal("edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::const_reference"))
  .AddTypedef(type_7376c, Reflex::Literal("edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::reference"))
  .AddTypedef(type_227, Reflex::Literal("edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::key_type"))
  .AddTypedef(type_3506, Reflex::Literal("edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::KeyVec"))
  .AddTypedef(type_3845, Reflex::Literal("edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::size_type"))
  .AddTypedef(type_5370, Reflex::Literal("edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_38392, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_38393, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70750), Reflex::Literal("RefVector"), constructor_38394, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("RefVector"), constructor_38395, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6485, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::Jet, std::allocator<pat::Jet> >,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > -------------------
void __edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5370, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::Jet, std::allocator<pat::Jet> >,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > -------------------
void __edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70751), Reflex::Literal("push_back"), method_38396, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7376c, type_3845), Reflex::Literal("operator[]"), operator_38397, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7376c, type_3845), Reflex::Literal("at"), method_38398, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35206), Reflex::Literal("refVector"), method_38399, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_38400, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_38401, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_38402, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_38403, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6386), Reflex::Literal("begin"), method_38404, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6386), Reflex::Literal("end"), method_38405, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_38406, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_38407, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_38408, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_38409, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_38410, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70752), Reflex::Literal("product"), method_38411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_38412, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_38413, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6386, type_70753), Reflex::Literal("erase"), method_38414, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_38415, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70754), Reflex::Literal("swap"), method_38416, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70754, type_70750), Reflex::Literal("operator="), operator_38417, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_38418, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_35212), Reflex::Literal("fillView"), method_38419, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_38420, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > -------------------------------
static void destructor_38182(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::~RefVector)();
}
static void constructor_38183( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >();
}

static void constructor_38184( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
}

static void constructor_38185( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_38186( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
}

static  void operator_38187( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >)((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_38188( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >)((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_38189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->refVector)();
}

static  void method_38190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->empty)();
}

static  void method_38191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->size)();
}

static  void method_38192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->capacity)();
}

static  void method_38193( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_38194( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >)((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->begin)();
}

static  void method_38195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >)((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->end)();
}

static  void method_38196( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->id)();
}

static  void method_38197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->productGetter)();
}

static  void method_38198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isNull)();
}

static  void method_38199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isNonnull)();
}

static  void operator_38200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->operator!)();
}

static  void method_38201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->product)();
}

static  void method_38202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isAvailable)();
}

static  void method_38203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isTransient)();
}

static  void method_38204( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >)((((::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
}

static  void method_38205( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->clear)();
}

static  void method_38206( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
}

static  void operator_38207( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
}

static  void method_38208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->hasProductCache)();
}

static  void method_38209( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_38210( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->Class_Version)();
}

static void method_newdel_6480( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > -------------------------------
void __edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__datamem_bld(&__edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__funcmem_bld(&__edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__db_funcmem);
void __edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >"), typeid(::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >), sizeof(::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::Class_Version())
  .AddTypedef(type_3511, Reflex::Literal("edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::collection_type"))
  .AddTypedef(type_13540, Reflex::Literal("edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::member_type"))
  .AddTypedef(type_35532, Reflex::Literal("edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::finder_type"))
  .AddTypedef(type_6381, Reflex::Literal("edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::iterator"))
  .AddTypedef(type_6381, Reflex::Literal("edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::const_iterator"))
  .AddTypedef(type_7371, Reflex::Literal("edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::value_type"))
  .AddTypedef(type_7371c, Reflex::Literal("edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::const_reference"))
  .AddTypedef(type_7371c, Reflex::Literal("edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::reference"))
  .AddTypedef(type_227, Reflex::Literal("edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::key_type"))
  .AddTypedef(type_3506, Reflex::Literal("edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::KeyVec"))
  .AddTypedef(type_3845, Reflex::Literal("edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::size_type"))
  .AddTypedef(type_5370, Reflex::Literal("edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_38182, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_38183, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70720), Reflex::Literal("RefVector"), constructor_38184, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("RefVector"), constructor_38185, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6480, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > -------------------
void __edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5370, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > -------------------
void __edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70721), Reflex::Literal("push_back"), method_38186, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7371c, type_3845), Reflex::Literal("operator[]"), operator_38187, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7371c, type_3845), Reflex::Literal("at"), method_38188, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35206), Reflex::Literal("refVector"), method_38189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_38190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_38191, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_38192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_38193, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6381), Reflex::Literal("begin"), method_38194, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6381), Reflex::Literal("end"), method_38195, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_38196, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_38197, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_38198, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_38199, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_38200, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70722), Reflex::Literal("product"), method_38201, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_38202, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_38203, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6381, type_70723), Reflex::Literal("erase"), method_38204, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_38205, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70724), Reflex::Literal("swap"), method_38206, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70724, type_70720), Reflex::Literal("operator="), operator_38207, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_38208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_35212), Reflex::Literal("fillView"), method_38209, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_38210, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::Particle, std::allocator<pat::Particle> >,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > -------------------------------
static  void operator_42623( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
}

static void constructor_42624( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
}

static void constructor_42625( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >();
}

static void constructor_42626( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::Handle<std::vector<pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::Handle<std::vector<pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::Handle<std::vector<pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::Handle<std::vector<pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42627( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::OrphanHandle<std::vector<pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::OrphanHandle<std::vector<pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::OrphanHandle<std::vector<pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::OrphanHandle<std::vector<pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42628( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42629( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >((const ::std::vector<pat::Particle>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >((const ::std::vector<pat::Particle>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >((const ::std::vector<pat::Particle>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >((const ::std::vector<pat::Particle>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42630( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::TestHandle<std::vector<pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::TestHandle<std::vector<pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::TestHandle<std::vector<pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::TestHandle<std::vector<pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42631( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_42632( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Particle*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Particle>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Particle*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Particle>*)arg[3]);
}

static void constructor_42633( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_42634( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::RefProd<std::vector<pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::RefProd<std::vector<pat::Particle> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_42635(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::~Ref)();
}
static  void operator_42636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->operator*)();
}

static  void operator_42637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->operator->)();
}

static  void method_42638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->get)();
}

static  void method_42639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isNull)();
}

static  void method_42640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isNonnull)();
}

static  void operator_42641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->operator!)();
}

static  void method_42642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->id)();
}

static  void method_42643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->productGetter)();
}

static  void method_42644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->product)();
}

static  void method_42645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->key)();
}

static  void method_42646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->index)();
}

static  void method_42647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->hasProductCache)();
}

static  void method_42648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isAvailable)();
}

static  void method_42649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->isTransient)();
}

static  void method_42650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->refCore)();
}

static  void method_42651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)o)->Class_Version)();
}

static void constructor_42652( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_7374( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::Particle, std::allocator<pat::Particle> >,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > -------------------------------
void __edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__datamem_bld(&__edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__funcmem_bld(&__edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__db_funcmem);
void __edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >"), typeid(::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >), sizeof(::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::Class_Version())
  .AddTypedef(type_13527, Reflex::Literal("edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::T"))
  .AddTypedef(type_35568, Reflex::Literal("edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::F"))
  .AddTypedef(type_37541, Reflex::Literal("edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::VF"))
  .AddTypedef(type_37540, Reflex::Literal("edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::VBF"))
  .AddTypedef(type_3514, Reflex::Literal("edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::product_type"))
  .AddTypedef(type_13527, Reflex::Literal("edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::value_type"))
  .AddTypedef(type_13527c, Reflex::Literal("edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::element_type"))
  .AddTypedef(type_35568, Reflex::Literal("edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::finder_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::argument_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72030, type_70739), Reflex::Literal("operator="), operator_42623, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70739), Reflex::Literal("Ref"), constructor_42624, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_42625, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72031, type_227, type_1810), Reflex::Literal("Ref"), constructor_42626, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72032, type_227, type_1810), Reflex::Literal("Ref"), constructor_42627, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70738, type_227, type_1810), Reflex::Literal("Ref"), constructor_42628, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70740, type_227, type_1810), Reflex::Literal("Ref"), constructor_42629, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72033, type_227, type_1810), Reflex::Literal("Ref"), constructor_42630, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_227, type_35207), Reflex::Literal("Ref"), constructor_42631, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17762, type_227, type_70740), Reflex::Literal("Ref"), constructor_42632, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ref"), constructor_42633, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72034, type_227), Reflex::Literal("Ref"), constructor_42634, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_42635, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35224, type_18009), Reflex::Literal("Ref"), constructor_42652, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7374, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::Particle, std::allocator<pat::Particle> >,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > -------------------
void __edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7471, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::Particle, std::allocator<pat::Particle> >,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > -------------------
void __edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17764), Reflex::Literal("operator*"), operator_42636, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17762), Reflex::Literal("operator->"), operator_42637, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17762), Reflex::Literal("get"), method_42638, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_42639, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_42640, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_42641, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_42642, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_42643, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70740), Reflex::Literal("product"), method_42644, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("key"), method_42645, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("index"), method_42646, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_42647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_42648, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_42649, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_42650, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_42651, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > -------------------------------
static  void operator_42497( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
}

static void constructor_42498( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
}

static void constructor_42499( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >();
}

static void constructor_42500( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::Handle<std::vector<pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::Handle<std::vector<pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::Handle<std::vector<pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::Handle<std::vector<pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42501( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::OrphanHandle<std::vector<pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::OrphanHandle<std::vector<pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::OrphanHandle<std::vector<pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::OrphanHandle<std::vector<pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42502( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42503( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >((const ::std::vector<pat::GenericParticle>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >((const ::std::vector<pat::GenericParticle>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >((const ::std::vector<pat::GenericParticle>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >((const ::std::vector<pat::GenericParticle>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42504( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::TestHandle<std::vector<pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::TestHandle<std::vector<pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::TestHandle<std::vector<pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::TestHandle<std::vector<pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42505( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_42506( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::GenericParticle*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::GenericParticle>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::GenericParticle*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::GenericParticle>*)arg[3]);
}

static void constructor_42507( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_42508( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::RefProd<std::vector<pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::RefProd<std::vector<pat::GenericParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_42509(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::~Ref)();
}
static  void operator_42510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->operator*)();
}

static  void operator_42511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->operator->)();
}

static  void method_42512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->get)();
}

static  void method_42513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isNull)();
}

static  void method_42514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isNonnull)();
}

static  void operator_42515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->operator!)();
}

static  void method_42516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->id)();
}

static  void method_42517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->productGetter)();
}

static  void method_42518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->product)();
}

static  void method_42519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->key)();
}

static  void method_42520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->index)();
}

static  void method_42521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->hasProductCache)();
}

static  void method_42522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isAvailable)();
}

static  void method_42523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->isTransient)();
}

static  void method_42524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->refCore)();
}

static  void method_42525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)o)->Class_Version)();
}

static void constructor_42526( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_7371( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > -------------------------------
void __edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__datamem_bld(&__edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__funcmem_bld(&__edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__db_funcmem);
void __edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >"), typeid(::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >), sizeof(::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::Class_Version())
  .AddTypedef(type_13540, Reflex::Literal("edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::T"))
  .AddTypedef(type_35532, Reflex::Literal("edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::F"))
  .AddTypedef(type_37535, Reflex::Literal("edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::VF"))
  .AddTypedef(type_37534, Reflex::Literal("edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::VBF"))
  .AddTypedef(type_3511, Reflex::Literal("edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::product_type"))
  .AddTypedef(type_13540, Reflex::Literal("edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::value_type"))
  .AddTypedef(type_13540c, Reflex::Literal("edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::element_type"))
  .AddTypedef(type_35532, Reflex::Literal("edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::finder_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::argument_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72015, type_70721), Reflex::Literal("operator="), operator_42497, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70721), Reflex::Literal("Ref"), constructor_42498, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_42499, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72016, type_227, type_1810), Reflex::Literal("Ref"), constructor_42500, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72017, type_227, type_1810), Reflex::Literal("Ref"), constructor_42501, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70720, type_227, type_1810), Reflex::Literal("Ref"), constructor_42502, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70722, type_227, type_1810), Reflex::Literal("Ref"), constructor_42503, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72018, type_227, type_1810), Reflex::Literal("Ref"), constructor_42504, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_227, type_35207), Reflex::Literal("Ref"), constructor_42505, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17729, type_227, type_70722), Reflex::Literal("Ref"), constructor_42506, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ref"), constructor_42507, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72019, type_227), Reflex::Literal("Ref"), constructor_42508, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_42509, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35224, type_18009), Reflex::Literal("Ref"), constructor_42526, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7371, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > -------------------
void __edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7471, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > -------------------
void __edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17731), Reflex::Literal("operator*"), operator_42510, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17729), Reflex::Literal("operator->"), operator_42511, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17729), Reflex::Literal("get"), method_42512, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_42513, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_42514, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_42515, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_42516, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_42517, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70722), Reflex::Literal("product"), method_42518, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("key"), method_42519, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("index"), method_42520, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_42521, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_42522, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_42523, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_42524, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_42525, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >, pat::PackedCandidate> > -------------------------------
static void destructor_38056(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::~RefVector)();
}
static void constructor_38057( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >();
}

static void constructor_38058( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0]);
}

static void constructor_38059( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_38060( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0]);
}

static  void operator_38061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >)((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_38062( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >)((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_38063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->refVector)();
}

static  void method_38064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->empty)();
}

static  void method_38065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->size)();
}

static  void method_38066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->capacity)();
}

static  void method_38067( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_38068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >)((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->begin)();
}

static  void method_38069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >)((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->end)();
}

static  void method_38070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->id)();
}

static  void method_38071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->productGetter)();
}

static  void method_38072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isNull)();
}

static  void method_38073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isNonnull)();
}

static  void operator_38074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->operator!)();
}

static  void method_38075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->product)();
}

static  void method_38076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isAvailable)();
}

static  void method_38077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isTransient)();
}

static  void method_38078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >)((((::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0]);
}

static  void method_38079( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->clear)();
}

static  void method_38080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0]);
}

static  void operator_38081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0]);
}

static  void method_38082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->hasProductCache)();
}

static  void method_38083( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_38084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->Class_Version)();
}

static void method_newdel_6477( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >, pat::PackedCandidate> > -------------------------------
void __edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__datamem_bld(&__edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__funcmem_bld(&__edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__db_funcmem);
void __edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >"), typeid(::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >), sizeof(::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::Class_Version())
  .AddTypedef(type_3508, Reflex::Literal("edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::collection_type"))
  .AddTypedef(type_9073, Reflex::Literal("edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::member_type"))
  .AddTypedef(type_35496, Reflex::Literal("edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::finder_type"))
  .AddTypedef(type_6378, Reflex::Literal("edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::iterator"))
  .AddTypedef(type_6378, Reflex::Literal("edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::const_iterator"))
  .AddTypedef(type_7367, Reflex::Literal("edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::value_type"))
  .AddTypedef(type_7367c, Reflex::Literal("edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::const_reference"))
  .AddTypedef(type_7367c, Reflex::Literal("edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::reference"))
  .AddTypedef(type_227, Reflex::Literal("edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::key_type"))
  .AddTypedef(type_3506, Reflex::Literal("edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::KeyVec"))
  .AddTypedef(type_3845, Reflex::Literal("edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::size_type"))
  .AddTypedef(type_5370, Reflex::Literal("edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_38056, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_38057, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70702), Reflex::Literal("RefVector"), constructor_38058, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("RefVector"), constructor_38059, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6477, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >, pat::PackedCandidate> > -------------------
void __edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5370, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >, pat::PackedCandidate> > -------------------
void __edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70703), Reflex::Literal("push_back"), method_38060, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7367c, type_3845), Reflex::Literal("operator[]"), operator_38061, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7367c, type_3845), Reflex::Literal("at"), method_38062, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35206), Reflex::Literal("refVector"), method_38063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_38064, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_38065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_38066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_38067, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6378), Reflex::Literal("begin"), method_38068, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6378), Reflex::Literal("end"), method_38069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_38070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_38071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_38072, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_38073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_38074, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70704), Reflex::Literal("product"), method_38075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_38076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_38077, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6378, type_70705), Reflex::Literal("erase"), method_38078, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_38079, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70706), Reflex::Literal("swap"), method_38080, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70706, type_70702), Reflex::Literal("operator="), operator_38081, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_38082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_35212), Reflex::Literal("fillView"), method_38083, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_38084, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere> > -------------------------------
static void destructor_38140(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::~RefVector)();
}
static void constructor_38141( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >();
}

static void constructor_38142( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0]);
}

static void constructor_38143( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_38144( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0]);
}

static  void operator_38145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >)((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_38146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >)((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_38147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->refVector)();
}

static  void method_38148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->empty)();
}

static  void method_38149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->size)();
}

static  void method_38150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->capacity)();
}

static  void method_38151( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_38152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >)((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->begin)();
}

static  void method_38153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >)((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->end)();
}

static  void method_38154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->id)();
}

static  void method_38155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->productGetter)();
}

static  void method_38156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isNull)();
}

static  void method_38157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isNonnull)();
}

static  void operator_38158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->operator!)();
}

static  void method_38159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->product)();
}

static  void method_38160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isAvailable)();
}

static  void method_38161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isTransient)();
}

static  void method_38162( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >)((((::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0]);
}

static  void method_38163( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->clear)();
}

static  void method_38164( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0]);
}

static  void operator_38165( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0]);
}

static  void method_38166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->hasProductCache)();
}

static  void method_38167( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_38168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->Class_Version)();
}

static void method_newdel_6479( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere> > -------------------------------
void __edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__datamem_bld(&__edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__funcmem_bld(&__edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__db_funcmem);
void __edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >"), typeid(::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >), sizeof(::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::Class_Version())
  .AddTypedef(type_3510, Reflex::Literal("edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::collection_type"))
  .AddTypedef(type_13517, Reflex::Literal("edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::member_type"))
  .AddTypedef(type_35520, Reflex::Literal("edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::finder_type"))
  .AddTypedef(type_6380, Reflex::Literal("edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::iterator"))
  .AddTypedef(type_6380, Reflex::Literal("edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::const_iterator"))
  .AddTypedef(type_7370, Reflex::Literal("edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::value_type"))
  .AddTypedef(type_7370c, Reflex::Literal("edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::const_reference"))
  .AddTypedef(type_7370c, Reflex::Literal("edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::reference"))
  .AddTypedef(type_227, Reflex::Literal("edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::key_type"))
  .AddTypedef(type_3506, Reflex::Literal("edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::KeyVec"))
  .AddTypedef(type_3845, Reflex::Literal("edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::size_type"))
  .AddTypedef(type_5370, Reflex::Literal("edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_38140, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_38141, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70714), Reflex::Literal("RefVector"), constructor_38142, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("RefVector"), constructor_38143, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6479, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere> > -------------------
void __edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5370, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere> > -------------------
void __edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70715), Reflex::Literal("push_back"), method_38144, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7370c, type_3845), Reflex::Literal("operator[]"), operator_38145, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7370c, type_3845), Reflex::Literal("at"), method_38146, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35206), Reflex::Literal("refVector"), method_38147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_38148, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_38149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_38150, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_38151, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6380), Reflex::Literal("begin"), method_38152, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6380), Reflex::Literal("end"), method_38153, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_38154, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_38155, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_38156, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_38157, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_38158, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70716), Reflex::Literal("product"), method_38159, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_38160, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_38161, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6380, type_70717), Reflex::Literal("erase"), method_38162, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_38163, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70718), Reflex::Literal("swap"), method_38164, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70718, type_70714), Reflex::Literal("operator="), operator_38165, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_38166, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_35212), Reflex::Literal("fillView"), method_38167, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_38168, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > -------------------------------
static void destructor_38266(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::~RefVector)();
}
static void constructor_38267( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >();
}

static void constructor_38268( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
}

static void constructor_38269( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_38270( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
}

static  void operator_38271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >)((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_38272( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >)((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_38273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->refVector)();
}

static  void method_38274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->empty)();
}

static  void method_38275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->size)();
}

static  void method_38276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->capacity)();
}

static  void method_38277( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_38278( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >)((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->begin)();
}

static  void method_38279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >)((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->end)();
}

static  void method_38280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->id)();
}

static  void method_38281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->productGetter)();
}

static  void method_38282( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isNull)();
}

static  void method_38283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isNonnull)();
}

static  void operator_38284( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->operator!)();
}

static  void method_38285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->product)();
}

static  void method_38286( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isAvailable)();
}

static  void method_38287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isTransient)();
}

static  void method_38288( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >)((((::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
}

static  void method_38289( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->clear)();
}

static  void method_38290( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
}

static  void operator_38291( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
}

static  void method_38292( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->hasProductCache)();
}

static  void method_38293( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_38294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->Class_Version)();
}

static void method_newdel_6482( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > -------------------------------
void __edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__datamem_bld(&__edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__funcmem_bld(&__edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__db_funcmem);
void __edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >"), typeid(::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >), sizeof(::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::Class_Version())
  .AddTypedef(type_3513, Reflex::Literal("edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::collection_type"))
  .AddTypedef(type_13564, Reflex::Literal("edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::member_type"))
  .AddTypedef(type_35556, Reflex::Literal("edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::finder_type"))
  .AddTypedef(type_6383, Reflex::Literal("edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::iterator"))
  .AddTypedef(type_6383, Reflex::Literal("edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::const_iterator"))
  .AddTypedef(type_7373, Reflex::Literal("edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::value_type"))
  .AddTypedef(type_7373c, Reflex::Literal("edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::const_reference"))
  .AddTypedef(type_7373c, Reflex::Literal("edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::reference"))
  .AddTypedef(type_227, Reflex::Literal("edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::key_type"))
  .AddTypedef(type_3506, Reflex::Literal("edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::KeyVec"))
  .AddTypedef(type_3845, Reflex::Literal("edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::size_type"))
  .AddTypedef(type_5370, Reflex::Literal("edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_38266, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_38267, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70732), Reflex::Literal("RefVector"), constructor_38268, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("RefVector"), constructor_38269, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6482, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > -------------------
void __edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5370, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > -------------------
void __edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70733), Reflex::Literal("push_back"), method_38270, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7373c, type_3845), Reflex::Literal("operator[]"), operator_38271, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7373c, type_3845), Reflex::Literal("at"), method_38272, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35206), Reflex::Literal("refVector"), method_38273, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_38274, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_38275, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_38276, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_38277, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6383), Reflex::Literal("begin"), method_38278, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6383), Reflex::Literal("end"), method_38279, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_38280, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_38281, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_38282, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_38283, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_38284, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70734), Reflex::Literal("product"), method_38285, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_38286, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_38287, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6383, type_70735), Reflex::Literal("erase"), method_38288, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_38289, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70736), Reflex::Literal("swap"), method_38290, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70736, type_70732), Reflex::Literal("operator="), operator_38291, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_38292, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_35212), Reflex::Literal("fillView"), method_38293, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_38294, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > -------------------------------
static  void operator_42539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
}

static void constructor_42540( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
}

static void constructor_42541( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >();
}

static void constructor_42542( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::Handle<std::vector<pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::Handle<std::vector<pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::Handle<std::vector<pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::Handle<std::vector<pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42543( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::OrphanHandle<std::vector<pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::OrphanHandle<std::vector<pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::OrphanHandle<std::vector<pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::OrphanHandle<std::vector<pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42544( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42545( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >((const ::std::vector<pat::PFParticle>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >((const ::std::vector<pat::PFParticle>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >((const ::std::vector<pat::PFParticle>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >((const ::std::vector<pat::PFParticle>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42546( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::TestHandle<std::vector<pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::TestHandle<std::vector<pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::TestHandle<std::vector<pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::TestHandle<std::vector<pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42547( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_42548( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::PFParticle*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::PFParticle>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::PFParticle*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::PFParticle>*)arg[3]);
}

static void constructor_42549( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_42550( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::RefProd<std::vector<pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::RefProd<std::vector<pat::PFParticle> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_42551(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::~Ref)();
}
static  void operator_42552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->operator*)();
}

static  void operator_42553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->operator->)();
}

static  void method_42554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->get)();
}

static  void method_42555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isNull)();
}

static  void method_42556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isNonnull)();
}

static  void operator_42557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->operator!)();
}

static  void method_42558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->id)();
}

static  void method_42559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->productGetter)();
}

static  void method_42560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->product)();
}

static  void method_42561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->key)();
}

static  void method_42562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->index)();
}

static  void method_42563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->hasProductCache)();
}

static  void method_42564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isAvailable)();
}

static  void method_42565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isTransient)();
}

static  void method_42566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->refCore)();
}

static  void method_42567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->Class_Version)();
}

static void constructor_42568( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_7372( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > -------------------------------
void __edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__datamem_bld(&__edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__funcmem_bld(&__edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__db_funcmem);
void __edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >"), typeid(::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >), sizeof(::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::Class_Version())
  .AddTypedef(type_13478, Reflex::Literal("edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::T"))
  .AddTypedef(type_35544, Reflex::Literal("edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::F"))
  .AddTypedef(type_37537, Reflex::Literal("edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::VF"))
  .AddTypedef(type_37536, Reflex::Literal("edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::VBF"))
  .AddTypedef(type_3512, Reflex::Literal("edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::product_type"))
  .AddTypedef(type_13478, Reflex::Literal("edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::value_type"))
  .AddTypedef(type_13478c, Reflex::Literal("edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::element_type"))
  .AddTypedef(type_35544, Reflex::Literal("edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::finder_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::argument_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72020, type_70727), Reflex::Literal("operator="), operator_42539, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70727), Reflex::Literal("Ref"), constructor_42540, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_42541, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72021, type_227, type_1810), Reflex::Literal("Ref"), constructor_42542, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72022, type_227, type_1810), Reflex::Literal("Ref"), constructor_42543, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70726, type_227, type_1810), Reflex::Literal("Ref"), constructor_42544, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70728, type_227, type_1810), Reflex::Literal("Ref"), constructor_42545, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72023, type_227, type_1810), Reflex::Literal("Ref"), constructor_42546, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_227, type_35207), Reflex::Literal("Ref"), constructor_42547, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17740, type_227, type_70728), Reflex::Literal("Ref"), constructor_42548, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ref"), constructor_42549, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72024, type_227), Reflex::Literal("Ref"), constructor_42550, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_42551, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35224, type_18009), Reflex::Literal("Ref"), constructor_42568, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7372, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > -------------------
void __edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7471, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > -------------------
void __edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17742), Reflex::Literal("operator*"), operator_42552, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17740), Reflex::Literal("operator->"), operator_42553, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17740), Reflex::Literal("get"), method_42554, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_42555, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_42556, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_42557, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_42558, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_42559, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70728), Reflex::Literal("product"), method_42560, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("key"), method_42561, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("index"), method_42562, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_42563, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_42564, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_42565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_42566, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_42567, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::Conversion, std::allocator<pat::Conversion> >,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion> > -------------------------------
static void destructor_38098(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::~RefVector)();
}
static void constructor_38099( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >();
}

static void constructor_38100( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0]);
}

static void constructor_38101( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_38102( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0]);
}

static  void operator_38103( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >)((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_38104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >)((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_38105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->refVector)();
}

static  void method_38106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->empty)();
}

static  void method_38107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->size)();
}

static  void method_38108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->capacity)();
}

static  void method_38109( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_38110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >)((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->begin)();
}

static  void method_38111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >)((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->end)();
}

static  void method_38112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->id)();
}

static  void method_38113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->productGetter)();
}

static  void method_38114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isNull)();
}

static  void method_38115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isNonnull)();
}

static  void operator_38116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->operator!)();
}

static  void method_38117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->product)();
}

static  void method_38118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isAvailable)();
}

static  void method_38119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isTransient)();
}

static  void method_38120( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >)((((::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0]);
}

static  void method_38121( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->clear)();
}

static  void method_38122( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0]);
}

static  void operator_38123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0]);
}

static  void method_38124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->hasProductCache)();
}

static  void method_38125( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_38126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->Class_Version)();
}

static void method_newdel_6478( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::Conversion, std::allocator<pat::Conversion> >,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion> > -------------------------------
void __edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__datamem_bld(&__edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__funcmem_bld(&__edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__db_funcmem);
void __edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >"), typeid(::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >), sizeof(::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::Class_Version())
  .AddTypedef(type_3509, Reflex::Literal("edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::collection_type"))
  .AddTypedef(type_13535, Reflex::Literal("edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::member_type"))
  .AddTypedef(type_35508, Reflex::Literal("edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::finder_type"))
  .AddTypedef(type_6379, Reflex::Literal("edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::iterator"))
  .AddTypedef(type_6379, Reflex::Literal("edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::const_iterator"))
  .AddTypedef(type_7369, Reflex::Literal("edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::value_type"))
  .AddTypedef(type_7369c, Reflex::Literal("edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::const_reference"))
  .AddTypedef(type_7369c, Reflex::Literal("edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::reference"))
  .AddTypedef(type_227, Reflex::Literal("edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::key_type"))
  .AddTypedef(type_3506, Reflex::Literal("edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::KeyVec"))
  .AddTypedef(type_3845, Reflex::Literal("edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::size_type"))
  .AddTypedef(type_5370, Reflex::Literal("edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_38098, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_38099, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70708), Reflex::Literal("RefVector"), constructor_38100, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("RefVector"), constructor_38101, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6478, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::Conversion, std::allocator<pat::Conversion> >,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion> > -------------------
void __edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5370, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::Conversion, std::allocator<pat::Conversion> >,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion> > -------------------
void __edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70709), Reflex::Literal("push_back"), method_38102, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7369c, type_3845), Reflex::Literal("operator[]"), operator_38103, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7369c, type_3845), Reflex::Literal("at"), method_38104, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35206), Reflex::Literal("refVector"), method_38105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_38106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_38107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_38108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_38109, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6379), Reflex::Literal("begin"), method_38110, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6379), Reflex::Literal("end"), method_38111, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_38112, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_38113, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_38114, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_38115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_38116, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70710), Reflex::Literal("product"), method_38117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_38118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_38119, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6379, type_70711), Reflex::Literal("erase"), method_38120, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_38121, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70712), Reflex::Literal("swap"), method_38122, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70712, type_70708), Reflex::Literal("operator="), operator_38123, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_38124, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_35212), Reflex::Literal("fillView"), method_38125, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_38126, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::Tau, std::allocator<pat::Tau> >,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > -------------------------------
static  void operator_42791( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
}

static void constructor_42792( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
}

static void constructor_42793( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >();
}

static void constructor_42794( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::Handle<std::vector<pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::Handle<std::vector<pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::Handle<std::vector<pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::Handle<std::vector<pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42795( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::OrphanHandle<std::vector<pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::OrphanHandle<std::vector<pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::OrphanHandle<std::vector<pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::OrphanHandle<std::vector<pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42796( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42797( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >((const ::std::vector<pat::Tau>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >((const ::std::vector<pat::Tau>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >((const ::std::vector<pat::Tau>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >((const ::std::vector<pat::Tau>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42798( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::TestHandle<std::vector<pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::TestHandle<std::vector<pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::TestHandle<std::vector<pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::TestHandle<std::vector<pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42799( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_42800( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Tau*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Tau>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Tau*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Tau>*)arg[3]);
}

static void constructor_42801( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_42802( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::RefProd<std::vector<pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::RefProd<std::vector<pat::Tau> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_42803(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::~Ref)();
}
static  void operator_42804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->operator*)();
}

static  void operator_42805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->operator->)();
}

static  void method_42806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->get)();
}

static  void method_42807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isNull)();
}

static  void method_42808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isNonnull)();
}

static  void operator_42809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->operator!)();
}

static  void method_42810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->id)();
}

static  void method_42811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->productGetter)();
}

static  void method_42812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->product)();
}

static  void method_42813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->key)();
}

static  void method_42814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->index)();
}

static  void method_42815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->hasProductCache)();
}

static  void method_42816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isAvailable)();
}

static  void method_42817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isTransient)();
}

static  void method_42818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->refCore)();
}

static  void method_42819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->Class_Version)();
}

static void constructor_42820( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_7378( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::Tau, std::allocator<pat::Tau> >,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > -------------------------------
void __edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__datamem_bld(&__edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__funcmem_bld(&__edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__db_funcmem);
void __edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >"), typeid(::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >), sizeof(::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::Class_Version())
  .AddTypedef(type_13568, Reflex::Literal("edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::T"))
  .AddTypedef(type_35616, Reflex::Literal("edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::F"))
  .AddTypedef(type_37549, Reflex::Literal("edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::VF"))
  .AddTypedef(type_37548, Reflex::Literal("edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::VBF"))
  .AddTypedef(type_3518, Reflex::Literal("edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::product_type"))
  .AddTypedef(type_13568, Reflex::Literal("edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::value_type"))
  .AddTypedef(type_13568c, Reflex::Literal("edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::element_type"))
  .AddTypedef(type_35616, Reflex::Literal("edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::finder_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::argument_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72050, type_70763), Reflex::Literal("operator="), operator_42791, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70763), Reflex::Literal("Ref"), constructor_42792, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_42793, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72051, type_227, type_1810), Reflex::Literal("Ref"), constructor_42794, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72052, type_227, type_1810), Reflex::Literal("Ref"), constructor_42795, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70762, type_227, type_1810), Reflex::Literal("Ref"), constructor_42796, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70764, type_227, type_1810), Reflex::Literal("Ref"), constructor_42797, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72053, type_227, type_1810), Reflex::Literal("Ref"), constructor_42798, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_227, type_35207), Reflex::Literal("Ref"), constructor_42799, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17817, type_227, type_70764), Reflex::Literal("Ref"), constructor_42800, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ref"), constructor_42801, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72054, type_227), Reflex::Literal("Ref"), constructor_42802, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_42803, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35224, type_18009), Reflex::Literal("Ref"), constructor_42820, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7378, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::Tau, std::allocator<pat::Tau> >,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > -------------------
void __edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7471, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::Tau, std::allocator<pat::Tau> >,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > -------------------
void __edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17819), Reflex::Literal("operator*"), operator_42804, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17817), Reflex::Literal("operator->"), operator_42805, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17817), Reflex::Literal("get"), method_42806, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_42807, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_42808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_42809, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_42810, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_42811, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70764), Reflex::Literal("product"), method_42812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("key"), method_42813, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("index"), method_42814, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_42815, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_42816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_42817, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_42818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_42819, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > -------------------------------
static  void operator_42581( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
}

static void constructor_42582( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
}

static void constructor_42583( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >();
}

static void constructor_42584( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::Handle<std::vector<pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::Handle<std::vector<pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::Handle<std::vector<pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::Handle<std::vector<pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42585( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::OrphanHandle<std::vector<pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::OrphanHandle<std::vector<pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::OrphanHandle<std::vector<pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::OrphanHandle<std::vector<pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42586( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42587( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >((const ::std::vector<pat::CompositeCandidate>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >((const ::std::vector<pat::CompositeCandidate>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >((const ::std::vector<pat::CompositeCandidate>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >((const ::std::vector<pat::CompositeCandidate>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42588( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::TestHandle<std::vector<pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::TestHandle<std::vector<pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::TestHandle<std::vector<pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::TestHandle<std::vector<pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42589( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_42590( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::CompositeCandidate*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::CompositeCandidate>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::CompositeCandidate*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::CompositeCandidate>*)arg[3]);
}

static void constructor_42591( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_42592( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::RefProd<std::vector<pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::RefProd<std::vector<pat::CompositeCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_42593(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::~Ref)();
}
static  void operator_42594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->operator*)();
}

static  void operator_42595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->operator->)();
}

static  void method_42596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->get)();
}

static  void method_42597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isNull)();
}

static  void method_42598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isNonnull)();
}

static  void operator_42599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->operator!)();
}

static  void method_42600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->id)();
}

static  void method_42601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->productGetter)();
}

static  void method_42602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->product)();
}

static  void method_42603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->key)();
}

static  void method_42604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->index)();
}

static  void method_42605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->hasProductCache)();
}

static  void method_42606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isAvailable)();
}

static  void method_42607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->isTransient)();
}

static  void method_42608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->refCore)();
}

static  void method_42609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)o)->Class_Version)();
}

static void constructor_42610( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_7373( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > -------------------------------
void __edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__datamem_bld(&__edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__funcmem_bld(&__edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__db_funcmem);
void __edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >"), typeid(::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >), sizeof(::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::Class_Version())
  .AddTypedef(type_13564, Reflex::Literal("edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::T"))
  .AddTypedef(type_35556, Reflex::Literal("edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::F"))
  .AddTypedef(type_37539, Reflex::Literal("edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::VF"))
  .AddTypedef(type_37538, Reflex::Literal("edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::VBF"))
  .AddTypedef(type_3513, Reflex::Literal("edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::product_type"))
  .AddTypedef(type_13564, Reflex::Literal("edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::value_type"))
  .AddTypedef(type_13564c, Reflex::Literal("edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::element_type"))
  .AddTypedef(type_35556, Reflex::Literal("edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::finder_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::argument_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72025, type_70733), Reflex::Literal("operator="), operator_42581, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70733), Reflex::Literal("Ref"), constructor_42582, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_42583, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72026, type_227, type_1810), Reflex::Literal("Ref"), constructor_42584, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72027, type_227, type_1810), Reflex::Literal("Ref"), constructor_42585, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70732, type_227, type_1810), Reflex::Literal("Ref"), constructor_42586, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70734, type_227, type_1810), Reflex::Literal("Ref"), constructor_42587, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72028, type_227, type_1810), Reflex::Literal("Ref"), constructor_42588, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_227, type_35207), Reflex::Literal("Ref"), constructor_42589, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17751, type_227, type_70734), Reflex::Literal("Ref"), constructor_42590, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ref"), constructor_42591, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72029, type_227), Reflex::Literal("Ref"), constructor_42592, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_42593, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35224, type_18009), Reflex::Literal("Ref"), constructor_42610, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7373, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > -------------------
void __edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7471, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > -------------------
void __edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17753), Reflex::Literal("operator*"), operator_42594, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17751), Reflex::Literal("operator->"), operator_42595, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17751), Reflex::Literal("get"), method_42596, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_42597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_42598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_42599, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_42600, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_42601, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70734), Reflex::Literal("product"), method_42602, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("key"), method_42603, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("index"), method_42604, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_42605, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_42606, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_42607, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_42608, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_42609, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::Tau, std::allocator<pat::Tau> >,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > -------------------------------
static void destructor_38476(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::~RefVector)();
}
static void constructor_38477( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >();
}

static void constructor_38478( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
}

static void constructor_38479( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_38480( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
}

static  void operator_38481( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >)((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_38482( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >)((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_38483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->refVector)();
}

static  void method_38484( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->empty)();
}

static  void method_38485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->size)();
}

static  void method_38486( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->capacity)();
}

static  void method_38487( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_38488( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >)((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->begin)();
}

static  void method_38489( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >)((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->end)();
}

static  void method_38490( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->id)();
}

static  void method_38491( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->productGetter)();
}

static  void method_38492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isNull)();
}

static  void method_38493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isNonnull)();
}

static  void operator_38494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->operator!)();
}

static  void method_38495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->product)();
}

static  void method_38496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isAvailable)();
}

static  void method_38497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->isTransient)();
}

static  void method_38498( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >)((((::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
}

static  void method_38499( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->clear)();
}

static  void method_38500( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
}

static  void operator_38501( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
}

static  void method_38502( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->hasProductCache)();
}

static  void method_38503( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_38504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)o)->Class_Version)();
}

static void method_newdel_6487( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::Tau, std::allocator<pat::Tau> >,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > -------------------------------
void __edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__datamem_bld(&__edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__funcmem_bld(&__edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__db_funcmem);
void __edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >"), typeid(::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >), sizeof(::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::Class_Version())
  .AddTypedef(type_3518, Reflex::Literal("edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::collection_type"))
  .AddTypedef(type_13568, Reflex::Literal("edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::member_type"))
  .AddTypedef(type_35616, Reflex::Literal("edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::finder_type"))
  .AddTypedef(type_6388, Reflex::Literal("edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::iterator"))
  .AddTypedef(type_6388, Reflex::Literal("edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::const_iterator"))
  .AddTypedef(type_7378, Reflex::Literal("edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::value_type"))
  .AddTypedef(type_7378c, Reflex::Literal("edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::const_reference"))
  .AddTypedef(type_7378c, Reflex::Literal("edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::reference"))
  .AddTypedef(type_227, Reflex::Literal("edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::key_type"))
  .AddTypedef(type_3506, Reflex::Literal("edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::KeyVec"))
  .AddTypedef(type_3845, Reflex::Literal("edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::size_type"))
  .AddTypedef(type_5370, Reflex::Literal("edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_38476, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_38477, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70762), Reflex::Literal("RefVector"), constructor_38478, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("RefVector"), constructor_38479, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6487, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::Tau, std::allocator<pat::Tau> >,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > -------------------
void __edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5370, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::Tau, std::allocator<pat::Tau> >,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > -------------------
void __edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70763), Reflex::Literal("push_back"), method_38480, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7378c, type_3845), Reflex::Literal("operator[]"), operator_38481, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7378c, type_3845), Reflex::Literal("at"), method_38482, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35206), Reflex::Literal("refVector"), method_38483, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_38484, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_38485, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_38486, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_38487, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6388), Reflex::Literal("begin"), method_38488, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6388), Reflex::Literal("end"), method_38489, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_38490, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_38491, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_38492, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_38493, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_38494, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70764), Reflex::Literal("product"), method_38495, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_38496, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_38497, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6388, type_70765), Reflex::Literal("erase"), method_38498, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_38499, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70766), Reflex::Literal("swap"), method_38500, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70766, type_70762), Reflex::Literal("operator="), operator_38501, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_38502, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_35212), Reflex::Literal("fillView"), method_38503, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_38504, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::MET, std::allocator<pat::MET> >,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > -------------------------------
static void destructor_38350(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::~RefVector)();
}
static void constructor_38351( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >();
}

static void constructor_38352( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
}

static void constructor_38353( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_38354( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
}

static  void operator_38355( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >)((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_38356( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >)((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_38357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->refVector)();
}

static  void method_38358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->empty)();
}

static  void method_38359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->size)();
}

static  void method_38360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->capacity)();
}

static  void method_38361( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_38362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >)((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->begin)();
}

static  void method_38363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >)((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->end)();
}

static  void method_38364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->id)();
}

static  void method_38365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->productGetter)();
}

static  void method_38366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isNull)();
}

static  void method_38367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isNonnull)();
}

static  void operator_38368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->operator!)();
}

static  void method_38369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->product)();
}

static  void method_38370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isAvailable)();
}

static  void method_38371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isTransient)();
}

static  void method_38372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >)((((::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
}

static  void method_38373( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->clear)();
}

static  void method_38374( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
}

static  void operator_38375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
}

static  void method_38376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->hasProductCache)();
}

static  void method_38377( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_38378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->Class_Version)();
}

static void method_newdel_6484( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::MET, std::allocator<pat::MET> >,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > -------------------------------
void __edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__datamem_bld(&__edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__funcmem_bld(&__edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__db_funcmem);
void __edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >"), typeid(::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >), sizeof(::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::Class_Version())
  .AddTypedef(type_3515, Reflex::Literal("edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::collection_type"))
  .AddTypedef(type_13544, Reflex::Literal("edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::member_type"))
  .AddTypedef(type_35580, Reflex::Literal("edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::finder_type"))
  .AddTypedef(type_6385, Reflex::Literal("edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::iterator"))
  .AddTypedef(type_6385, Reflex::Literal("edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::const_iterator"))
  .AddTypedef(type_7375, Reflex::Literal("edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::value_type"))
  .AddTypedef(type_7375c, Reflex::Literal("edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::const_reference"))
  .AddTypedef(type_7375c, Reflex::Literal("edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::reference"))
  .AddTypedef(type_227, Reflex::Literal("edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::key_type"))
  .AddTypedef(type_3506, Reflex::Literal("edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::KeyVec"))
  .AddTypedef(type_3845, Reflex::Literal("edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::size_type"))
  .AddTypedef(type_5370, Reflex::Literal("edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_38350, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_38351, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70744), Reflex::Literal("RefVector"), constructor_38352, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("RefVector"), constructor_38353, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6484, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::MET, std::allocator<pat::MET> >,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > -------------------
void __edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5370, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::MET, std::allocator<pat::MET> >,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > -------------------
void __edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70745), Reflex::Literal("push_back"), method_38354, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7375c, type_3845), Reflex::Literal("operator[]"), operator_38355, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7375c, type_3845), Reflex::Literal("at"), method_38356, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35206), Reflex::Literal("refVector"), method_38357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_38358, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_38359, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_38360, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_38361, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6385), Reflex::Literal("begin"), method_38362, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6385), Reflex::Literal("end"), method_38363, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_38364, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_38365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_38366, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_38367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_38368, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70746), Reflex::Literal("product"), method_38369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_38370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_38371, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6385, type_70747), Reflex::Literal("erase"), method_38372, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_38373, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70748), Reflex::Literal("swap"), method_38374, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70748, type_70744), Reflex::Literal("operator="), operator_38375, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_38376, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_35212), Reflex::Literal("fillView"), method_38377, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_38378, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >, pat::PackedCandidate> > -------------------------------
static  void operator_42329( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0]);
}

static void constructor_42330( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0]);
}

static void constructor_42331( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >();
}

static void constructor_42332( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::Handle<std::vector<pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::Handle<std::vector<pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::Handle<std::vector<pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::Handle<std::vector<pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42333( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::OrphanHandle<std::vector<pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::OrphanHandle<std::vector<pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::OrphanHandle<std::vector<pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::OrphanHandle<std::vector<pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42334( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42335( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >((const ::std::vector<pat::PackedCandidate>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >((const ::std::vector<pat::PackedCandidate>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >((const ::std::vector<pat::PackedCandidate>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >((const ::std::vector<pat::PackedCandidate>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42336( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::TestHandle<std::vector<pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::TestHandle<std::vector<pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::TestHandle<std::vector<pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::TestHandle<std::vector<pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42337( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_42338( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::PackedCandidate*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::PackedCandidate>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::PackedCandidate*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::PackedCandidate>*)arg[3]);
}

static void constructor_42339( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_42340( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_42341(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::~Ref)();
}
static  void operator_42342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->operator*)();
}

static  void operator_42343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->operator->)();
}

static  void method_42344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->get)();
}

static  void method_42345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isNull)();
}

static  void method_42346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isNonnull)();
}

static  void operator_42347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->operator!)();
}

static  void method_42348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->id)();
}

static  void method_42349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->productGetter)();
}

static  void method_42350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->product)();
}

static  void method_42351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->key)();
}

static  void method_42352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->index)();
}

static  void method_42353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->hasProductCache)();
}

static  void method_42354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isAvailable)();
}

static  void method_42355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->isTransient)();
}

static  void method_42356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->refCore)();
}

static  void method_42357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >*)o)->Class_Version)();
}

static void constructor_42358( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_7367( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >, pat::PackedCandidate> > -------------------------------
void __edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__datamem_bld(&__edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__funcmem_bld(&__edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__db_funcmem);
void __edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >"), typeid(::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >), sizeof(::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::Class_Version())
  .AddTypedef(type_9073, Reflex::Literal("edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::T"))
  .AddTypedef(type_35496, Reflex::Literal("edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::F"))
  .AddTypedef(type_37529, Reflex::Literal("edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::VF"))
  .AddTypedef(type_37528, Reflex::Literal("edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::VBF"))
  .AddTypedef(type_3508, Reflex::Literal("edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::product_type"))
  .AddTypedef(type_9073, Reflex::Literal("edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::value_type"))
  .AddTypedef(type_9073c, Reflex::Literal("edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::element_type"))
  .AddTypedef(type_35496, Reflex::Literal("edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::finder_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::argument_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71999, type_70703), Reflex::Literal("operator="), operator_42329, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70703), Reflex::Literal("Ref"), constructor_42330, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_42331, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71852, type_227, type_1810), Reflex::Literal("Ref"), constructor_42332, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71776, type_227, type_1810), Reflex::Literal("Ref"), constructor_42333, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70702, type_227, type_1810), Reflex::Literal("Ref"), constructor_42334, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70704, type_227, type_1810), Reflex::Literal("Ref"), constructor_42335, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71712, type_227, type_1810), Reflex::Literal("Ref"), constructor_42336, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_227, type_35207), Reflex::Literal("Ref"), constructor_42337, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17696, type_227, type_70704), Reflex::Literal("Ref"), constructor_42338, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ref"), constructor_42339, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71851, type_227), Reflex::Literal("Ref"), constructor_42340, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_42341, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35224, type_18009), Reflex::Literal("Ref"), constructor_42358, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7367, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >, pat::PackedCandidate> > -------------------
void __edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7471, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> >, pat::PackedCandidate> > -------------------
void __edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17698), Reflex::Literal("operator*"), operator_42342, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17696), Reflex::Literal("operator->"), operator_42343, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17696), Reflex::Literal("get"), method_42344, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_42345, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_42346, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_42347, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_42348, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_42349, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70704), Reflex::Literal("product"), method_42350, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("key"), method_42351, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("index"), method_42352, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_42353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_42354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_42355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_42356, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_42357, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::MET, std::allocator<pat::MET> >,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > -------------------------------
static  void operator_42665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
}

static void constructor_42666( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
}

static void constructor_42667( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >();
}

static void constructor_42668( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::Handle<std::vector<pat::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::Handle<std::vector<pat::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::Handle<std::vector<pat::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::Handle<std::vector<pat::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42669( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::OrphanHandle<std::vector<pat::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::OrphanHandle<std::vector<pat::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::OrphanHandle<std::vector<pat::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::OrphanHandle<std::vector<pat::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42670( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42671( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >((const ::std::vector<pat::MET>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >((const ::std::vector<pat::MET>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >((const ::std::vector<pat::MET>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >((const ::std::vector<pat::MET>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42672( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::TestHandle<std::vector<pat::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::TestHandle<std::vector<pat::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::TestHandle<std::vector<pat::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::TestHandle<std::vector<pat::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42673( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_42674( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::MET*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::MET>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::MET*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::MET>*)arg[3]);
}

static void constructor_42675( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_42676( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::RefProd<std::vector<pat::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::RefProd<std::vector<pat::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_42677(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::~Ref)();
}
static  void operator_42678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->operator*)();
}

static  void operator_42679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->operator->)();
}

static  void method_42680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->get)();
}

static  void method_42681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isNull)();
}

static  void method_42682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isNonnull)();
}

static  void operator_42683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->operator!)();
}

static  void method_42684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->id)();
}

static  void method_42685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->productGetter)();
}

static  void method_42686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->product)();
}

static  void method_42687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->key)();
}

static  void method_42688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->index)();
}

static  void method_42689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->hasProductCache)();
}

static  void method_42690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isAvailable)();
}

static  void method_42691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->isTransient)();
}

static  void method_42692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->refCore)();
}

static  void method_42693( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)o)->Class_Version)();
}

static void constructor_42694( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_7375( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::MET, std::allocator<pat::MET> >,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > -------------------------------
void __edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__datamem_bld(&__edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__funcmem_bld(&__edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__db_funcmem);
void __edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >"), typeid(::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >), sizeof(::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::Class_Version())
  .AddTypedef(type_13544, Reflex::Literal("edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::T"))
  .AddTypedef(type_35580, Reflex::Literal("edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::F"))
  .AddTypedef(type_37543, Reflex::Literal("edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::VF"))
  .AddTypedef(type_37542, Reflex::Literal("edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::VBF"))
  .AddTypedef(type_3515, Reflex::Literal("edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::product_type"))
  .AddTypedef(type_13544, Reflex::Literal("edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::value_type"))
  .AddTypedef(type_13544c, Reflex::Literal("edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::element_type"))
  .AddTypedef(type_35580, Reflex::Literal("edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::finder_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::argument_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72035, type_70745), Reflex::Literal("operator="), operator_42665, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70745), Reflex::Literal("Ref"), constructor_42666, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_42667, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72036, type_227, type_1810), Reflex::Literal("Ref"), constructor_42668, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72037, type_227, type_1810), Reflex::Literal("Ref"), constructor_42669, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70744, type_227, type_1810), Reflex::Literal("Ref"), constructor_42670, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70746, type_227, type_1810), Reflex::Literal("Ref"), constructor_42671, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72038, type_227, type_1810), Reflex::Literal("Ref"), constructor_42672, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_227, type_35207), Reflex::Literal("Ref"), constructor_42673, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17784, type_227, type_70746), Reflex::Literal("Ref"), constructor_42674, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ref"), constructor_42675, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72039, type_227), Reflex::Literal("Ref"), constructor_42676, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_42677, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35224, type_18009), Reflex::Literal("Ref"), constructor_42694, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7375, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::MET, std::allocator<pat::MET> >,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > -------------------
void __edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7471, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::MET, std::allocator<pat::MET> >,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > -------------------
void __edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17786), Reflex::Literal("operator*"), operator_42678, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17784), Reflex::Literal("operator->"), operator_42679, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17784), Reflex::Literal("get"), method_42680, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_42681, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_42682, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_42683, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_42684, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_42685, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70746), Reflex::Literal("product"), method_42686, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("key"), method_42687, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("index"), method_42688, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_42689, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_42690, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_42691, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_42692, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_42693, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::Photon, std::allocator<pat::Photon> >,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > -------------------------------
static  void operator_42749( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
}

static void constructor_42750( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
}

static void constructor_42751( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >();
}

static void constructor_42752( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::Handle<std::vector<pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::Handle<std::vector<pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::Handle<std::vector<pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::Handle<std::vector<pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42753( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::OrphanHandle<std::vector<pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::OrphanHandle<std::vector<pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::OrphanHandle<std::vector<pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::OrphanHandle<std::vector<pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42754( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42755( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >((const ::std::vector<pat::Photon>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >((const ::std::vector<pat::Photon>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >((const ::std::vector<pat::Photon>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >((const ::std::vector<pat::Photon>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42756( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::TestHandle<std::vector<pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::TestHandle<std::vector<pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::TestHandle<std::vector<pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::TestHandle<std::vector<pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42757( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_42758( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Photon*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Photon>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Photon*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Photon>*)arg[3]);
}

static void constructor_42759( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_42760( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::RefProd<std::vector<pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::RefProd<std::vector<pat::Photon> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_42761(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::~Ref)();
}
static  void operator_42762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->operator*)();
}

static  void operator_42763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->operator->)();
}

static  void method_42764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->get)();
}

static  void method_42765( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isNull)();
}

static  void method_42766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isNonnull)();
}

static  void operator_42767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->operator!)();
}

static  void method_42768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->id)();
}

static  void method_42769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->productGetter)();
}

static  void method_42770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->product)();
}

static  void method_42771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->key)();
}

static  void method_42772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->index)();
}

static  void method_42773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->hasProductCache)();
}

static  void method_42774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isAvailable)();
}

static  void method_42775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->isTransient)();
}

static  void method_42776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->refCore)();
}

static  void method_42777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)o)->Class_Version)();
}

static void constructor_42778( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_7377( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::Photon, std::allocator<pat::Photon> >,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > -------------------------------
void __edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__datamem_bld(&__edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__funcmem_bld(&__edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__db_funcmem);
void __edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >"), typeid(::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >), sizeof(::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::Class_Version())
  .AddTypedef(type_13525, Reflex::Literal("edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::T"))
  .AddTypedef(type_35604, Reflex::Literal("edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::F"))
  .AddTypedef(type_37547, Reflex::Literal("edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::VF"))
  .AddTypedef(type_37546, Reflex::Literal("edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::VBF"))
  .AddTypedef(type_3517, Reflex::Literal("edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::product_type"))
  .AddTypedef(type_13525, Reflex::Literal("edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::value_type"))
  .AddTypedef(type_13525c, Reflex::Literal("edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::element_type"))
  .AddTypedef(type_35604, Reflex::Literal("edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::finder_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::argument_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72045, type_70757), Reflex::Literal("operator="), operator_42749, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70757), Reflex::Literal("Ref"), constructor_42750, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_42751, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72046, type_227, type_1810), Reflex::Literal("Ref"), constructor_42752, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72047, type_227, type_1810), Reflex::Literal("Ref"), constructor_42753, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70756, type_227, type_1810), Reflex::Literal("Ref"), constructor_42754, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70758, type_227, type_1810), Reflex::Literal("Ref"), constructor_42755, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72048, type_227, type_1810), Reflex::Literal("Ref"), constructor_42756, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_227, type_35207), Reflex::Literal("Ref"), constructor_42757, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17806, type_227, type_70758), Reflex::Literal("Ref"), constructor_42758, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ref"), constructor_42759, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72049, type_227), Reflex::Literal("Ref"), constructor_42760, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_42761, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35224, type_18009), Reflex::Literal("Ref"), constructor_42778, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7377, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::Photon, std::allocator<pat::Photon> >,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > -------------------
void __edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7471, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::Photon, std::allocator<pat::Photon> >,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > -------------------
void __edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17808), Reflex::Literal("operator*"), operator_42762, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17806), Reflex::Literal("operator->"), operator_42763, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17806), Reflex::Literal("get"), method_42764, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_42765, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_42766, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_42767, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_42768, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_42769, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70758), Reflex::Literal("product"), method_42770, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("key"), method_42771, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("index"), method_42772, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_42773, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_42774, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_42775, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_42776, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_42777, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > -------------------------------
static void destructor_38224(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::~RefVector)();
}
static void constructor_38225( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >();
}

static void constructor_38226( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
}

static void constructor_38227( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_38228( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
}

static  void operator_38229( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >)((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_38230( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >)((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_38231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->refVector)();
}

static  void method_38232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->empty)();
}

static  void method_38233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->size)();
}

static  void method_38234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->capacity)();
}

static  void method_38235( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_38236( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >)((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->begin)();
}

static  void method_38237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >)((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->end)();
}

static  void method_38238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->id)();
}

static  void method_38239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->productGetter)();
}

static  void method_38240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isNull)();
}

static  void method_38241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isNonnull)();
}

static  void operator_38242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->operator!)();
}

static  void method_38243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->product)();
}

static  void method_38244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isAvailable)();
}

static  void method_38245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->isTransient)();
}

static  void method_38246( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >)((((::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
}

static  void method_38247( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->clear)();
}

static  void method_38248( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
}

static  void operator_38249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
}

static  void method_38250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->hasProductCache)();
}

static  void method_38251( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_38252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)o)->Class_Version)();
}

static void method_newdel_6481( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > -------------------------------
void __edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__datamem_bld(&__edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__funcmem_bld(&__edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__db_funcmem);
void __edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >"), typeid(::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >), sizeof(::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::Class_Version())
  .AddTypedef(type_3512, Reflex::Literal("edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::collection_type"))
  .AddTypedef(type_13478, Reflex::Literal("edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::member_type"))
  .AddTypedef(type_35544, Reflex::Literal("edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::finder_type"))
  .AddTypedef(type_6382, Reflex::Literal("edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::iterator"))
  .AddTypedef(type_6382, Reflex::Literal("edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::const_iterator"))
  .AddTypedef(type_7372, Reflex::Literal("edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::value_type"))
  .AddTypedef(type_7372c, Reflex::Literal("edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::const_reference"))
  .AddTypedef(type_7372c, Reflex::Literal("edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::reference"))
  .AddTypedef(type_227, Reflex::Literal("edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::key_type"))
  .AddTypedef(type_3506, Reflex::Literal("edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::KeyVec"))
  .AddTypedef(type_3845, Reflex::Literal("edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::size_type"))
  .AddTypedef(type_5370, Reflex::Literal("edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_38224, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_38225, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70726), Reflex::Literal("RefVector"), constructor_38226, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("RefVector"), constructor_38227, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6481, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > -------------------
void __edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5370, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > -------------------
void __edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70727), Reflex::Literal("push_back"), method_38228, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7372c, type_3845), Reflex::Literal("operator[]"), operator_38229, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7372c, type_3845), Reflex::Literal("at"), method_38230, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35206), Reflex::Literal("refVector"), method_38231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_38232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_38233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_38234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_38235, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6382), Reflex::Literal("begin"), method_38236, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6382), Reflex::Literal("end"), method_38237, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_38238, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_38239, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_38240, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_38241, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_38242, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70728), Reflex::Literal("product"), method_38243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_38244, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_38245, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6382, type_70729), Reflex::Literal("erase"), method_38246, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_38247, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70730), Reflex::Literal("swap"), method_38248, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70730, type_70726), Reflex::Literal("operator="), operator_38249, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_38250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_35212), Reflex::Literal("fillView"), method_38251, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_38252, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::Muon, std::allocator<pat::Muon> >,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > -------------------------------
static  void operator_42833( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
}

static void constructor_42834( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
}

static void constructor_42835( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >();
}

static void constructor_42836( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::Handle<std::vector<pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::Handle<std::vector<pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::Handle<std::vector<pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::Handle<std::vector<pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42837( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::OrphanHandle<std::vector<pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::OrphanHandle<std::vector<pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::OrphanHandle<std::vector<pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::OrphanHandle<std::vector<pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42838( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42839( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >((const ::std::vector<pat::Muon>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >((const ::std::vector<pat::Muon>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >((const ::std::vector<pat::Muon>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >((const ::std::vector<pat::Muon>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42840( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::TestHandle<std::vector<pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::TestHandle<std::vector<pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::TestHandle<std::vector<pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::TestHandle<std::vector<pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42841( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_42842( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Muon*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Muon>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Muon*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Muon>*)arg[3]);
}

static void constructor_42843( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_42844( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::RefProd<std::vector<pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::RefProd<std::vector<pat::Muon> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_42845(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::~Ref)();
}
static  void operator_42846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->operator*)();
}

static  void operator_42847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->operator->)();
}

static  void method_42848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->get)();
}

static  void method_42849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isNull)();
}

static  void method_42850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isNonnull)();
}

static  void operator_42851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->operator!)();
}

static  void method_42852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->id)();
}

static  void method_42853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->productGetter)();
}

static  void method_42854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->product)();
}

static  void method_42855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->key)();
}

static  void method_42856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->index)();
}

static  void method_42857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->hasProductCache)();
}

static  void method_42858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isAvailable)();
}

static  void method_42859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->isTransient)();
}

static  void method_42860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->refCore)();
}

static  void method_42861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)o)->Class_Version)();
}

static void constructor_42862( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_7379( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::Muon, std::allocator<pat::Muon> >,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > -------------------------------
void __edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__datamem_bld(&__edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__funcmem_bld(&__edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__db_funcmem);
void __edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >"), typeid(::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >), sizeof(::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::Class_Version())
  .AddTypedef(type_13465, Reflex::Literal("edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::T"))
  .AddTypedef(type_35628, Reflex::Literal("edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::F"))
  .AddTypedef(type_37551, Reflex::Literal("edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::VF"))
  .AddTypedef(type_37550, Reflex::Literal("edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::VBF"))
  .AddTypedef(type_3519, Reflex::Literal("edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::product_type"))
  .AddTypedef(type_13465, Reflex::Literal("edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::value_type"))
  .AddTypedef(type_13465c, Reflex::Literal("edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::element_type"))
  .AddTypedef(type_35628, Reflex::Literal("edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::finder_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::argument_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72055, type_70769), Reflex::Literal("operator="), operator_42833, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70769), Reflex::Literal("Ref"), constructor_42834, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_42835, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72056, type_227, type_1810), Reflex::Literal("Ref"), constructor_42836, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72057, type_227, type_1810), Reflex::Literal("Ref"), constructor_42837, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70768, type_227, type_1810), Reflex::Literal("Ref"), constructor_42838, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70770, type_227, type_1810), Reflex::Literal("Ref"), constructor_42839, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72058, type_227, type_1810), Reflex::Literal("Ref"), constructor_42840, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_227, type_35207), Reflex::Literal("Ref"), constructor_42841, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17828, type_227, type_70770), Reflex::Literal("Ref"), constructor_42842, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ref"), constructor_42843, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72059, type_227), Reflex::Literal("Ref"), constructor_42844, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_42845, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35224, type_18009), Reflex::Literal("Ref"), constructor_42862, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7379, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::Muon, std::allocator<pat::Muon> >,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > -------------------
void __edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7471, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::Muon, std::allocator<pat::Muon> >,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > -------------------
void __edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17830), Reflex::Literal("operator*"), operator_42846, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17828), Reflex::Literal("operator->"), operator_42847, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17828), Reflex::Literal("get"), method_42848, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_42849, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_42850, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_42851, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_42852, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_42853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70770), Reflex::Literal("product"), method_42854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("key"), method_42855, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("index"), method_42856, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_42857, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_42858, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_42859, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_42860, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_42861, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::Jet, std::allocator<pat::Jet> >,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > -------------------------------
static  void operator_42707( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
}

static void constructor_42708( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
}

static void constructor_42709( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >();
}

static void constructor_42710( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::Handle<std::vector<pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::Handle<std::vector<pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::Handle<std::vector<pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::Handle<std::vector<pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42711( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::OrphanHandle<std::vector<pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::OrphanHandle<std::vector<pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::OrphanHandle<std::vector<pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::OrphanHandle<std::vector<pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42712( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42713( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >((const ::std::vector<pat::Jet>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >((const ::std::vector<pat::Jet>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >((const ::std::vector<pat::Jet>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >((const ::std::vector<pat::Jet>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42714( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::TestHandle<std::vector<pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::TestHandle<std::vector<pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::TestHandle<std::vector<pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::TestHandle<std::vector<pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42715( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_42716( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Jet*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Jet>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Jet*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Jet>*)arg[3]);
}

static void constructor_42717( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_42718( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::RefProd<std::vector<pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::RefProd<std::vector<pat::Jet> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_42719(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::~Ref)();
}
static  void operator_42720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->operator*)();
}

static  void operator_42721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->operator->)();
}

static  void method_42722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->get)();
}

static  void method_42723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isNull)();
}

static  void method_42724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isNonnull)();
}

static  void operator_42725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->operator!)();
}

static  void method_42726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->id)();
}

static  void method_42727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->productGetter)();
}

static  void method_42728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->product)();
}

static  void method_42729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->key)();
}

static  void method_42730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->index)();
}

static  void method_42731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->hasProductCache)();
}

static  void method_42732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isAvailable)();
}

static  void method_42733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->isTransient)();
}

static  void method_42734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->refCore)();
}

static  void method_42735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)o)->Class_Version)();
}

static void constructor_42736( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_7376( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::Jet, std::allocator<pat::Jet> >,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > -------------------------------
void __edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__datamem_bld(&__edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__funcmem_bld(&__edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__db_funcmem);
void __edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >"), typeid(::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >), sizeof(::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::Class_Version())
  .AddTypedef(type_13487, Reflex::Literal("edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::T"))
  .AddTypedef(type_35592, Reflex::Literal("edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::F"))
  .AddTypedef(type_37545, Reflex::Literal("edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::VF"))
  .AddTypedef(type_37544, Reflex::Literal("edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::VBF"))
  .AddTypedef(type_3516, Reflex::Literal("edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::product_type"))
  .AddTypedef(type_13487, Reflex::Literal("edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::value_type"))
  .AddTypedef(type_13487c, Reflex::Literal("edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::element_type"))
  .AddTypedef(type_35592, Reflex::Literal("edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::finder_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::argument_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72040, type_70751), Reflex::Literal("operator="), operator_42707, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70751), Reflex::Literal("Ref"), constructor_42708, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_42709, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72041, type_227, type_1810), Reflex::Literal("Ref"), constructor_42710, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72042, type_227, type_1810), Reflex::Literal("Ref"), constructor_42711, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70750, type_227, type_1810), Reflex::Literal("Ref"), constructor_42712, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70752, type_227, type_1810), Reflex::Literal("Ref"), constructor_42713, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72043, type_227, type_1810), Reflex::Literal("Ref"), constructor_42714, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_227, type_35207), Reflex::Literal("Ref"), constructor_42715, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17795, type_227, type_70752), Reflex::Literal("Ref"), constructor_42716, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ref"), constructor_42717, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72044, type_227), Reflex::Literal("Ref"), constructor_42718, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_42719, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35224, type_18009), Reflex::Literal("Ref"), constructor_42736, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7376, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::Jet, std::allocator<pat::Jet> >,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > -------------------
void __edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7471, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::Jet, std::allocator<pat::Jet> >,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > -------------------
void __edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17797), Reflex::Literal("operator*"), operator_42720, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17795), Reflex::Literal("operator->"), operator_42721, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17795), Reflex::Literal("get"), method_42722, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_42723, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_42724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_42725, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_42726, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_42727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70752), Reflex::Literal("product"), method_42728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("key"), method_42729, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("index"), method_42730, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_42731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_42732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_42733, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_42734, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_42735, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere> > -------------------------------
static  void operator_42455( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0]);
}

static void constructor_42456( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0]);
}

static void constructor_42457( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >();
}

static void constructor_42458( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::Handle<std::vector<pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::Handle<std::vector<pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::Handle<std::vector<pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::Handle<std::vector<pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42459( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::OrphanHandle<std::vector<pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::OrphanHandle<std::vector<pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::OrphanHandle<std::vector<pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::OrphanHandle<std::vector<pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42460( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42461( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >((const ::std::vector<pat::Hemisphere>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >((const ::std::vector<pat::Hemisphere>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >((const ::std::vector<pat::Hemisphere>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >((const ::std::vector<pat::Hemisphere>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42462( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::TestHandle<std::vector<pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::TestHandle<std::vector<pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::TestHandle<std::vector<pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::TestHandle<std::vector<pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42463( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_42464( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Hemisphere*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Hemisphere>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Hemisphere*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Hemisphere>*)arg[3]);
}

static void constructor_42465( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_42466( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::RefProd<std::vector<pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::RefProd<std::vector<pat::Hemisphere> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_42467(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::~Ref)();
}
static  void operator_42468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->operator*)();
}

static  void operator_42469( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->operator->)();
}

static  void method_42470( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->get)();
}

static  void method_42471( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isNull)();
}

static  void method_42472( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isNonnull)();
}

static  void operator_42473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->operator!)();
}

static  void method_42474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->id)();
}

static  void method_42475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->productGetter)();
}

static  void method_42476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->product)();
}

static  void method_42477( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->key)();
}

static  void method_42478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->index)();
}

static  void method_42479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->hasProductCache)();
}

static  void method_42480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isAvailable)();
}

static  void method_42481( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->isTransient)();
}

static  void method_42482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->refCore)();
}

static  void method_42483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)o)->Class_Version)();
}

static void constructor_42484( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_7370( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere> > -------------------------------
void __edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__datamem_bld(&__edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__funcmem_bld(&__edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__db_funcmem);
void __edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >"), typeid(::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >), sizeof(::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::Class_Version())
  .AddTypedef(type_13517, Reflex::Literal("edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::T"))
  .AddTypedef(type_35520, Reflex::Literal("edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::F"))
  .AddTypedef(type_37533, Reflex::Literal("edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::VF"))
  .AddTypedef(type_37532, Reflex::Literal("edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::VBF"))
  .AddTypedef(type_3510, Reflex::Literal("edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::product_type"))
  .AddTypedef(type_13517, Reflex::Literal("edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::value_type"))
  .AddTypedef(type_13517c, Reflex::Literal("edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::element_type"))
  .AddTypedef(type_35520, Reflex::Literal("edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::finder_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::argument_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72010, type_70715), Reflex::Literal("operator="), operator_42455, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70715), Reflex::Literal("Ref"), constructor_42456, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_42457, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72011, type_227, type_1810), Reflex::Literal("Ref"), constructor_42458, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72012, type_227, type_1810), Reflex::Literal("Ref"), constructor_42459, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70714, type_227, type_1810), Reflex::Literal("Ref"), constructor_42460, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70716, type_227, type_1810), Reflex::Literal("Ref"), constructor_42461, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72013, type_227, type_1810), Reflex::Literal("Ref"), constructor_42462, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_227, type_35207), Reflex::Literal("Ref"), constructor_42463, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17718, type_227, type_70716), Reflex::Literal("Ref"), constructor_42464, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ref"), constructor_42465, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72014, type_227), Reflex::Literal("Ref"), constructor_42466, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_42467, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35224, type_18009), Reflex::Literal("Ref"), constructor_42484, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7370, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere> > -------------------
void __edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7471, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere> > -------------------
void __edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17720), Reflex::Literal("operator*"), operator_42468, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17718), Reflex::Literal("operator->"), operator_42469, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17718), Reflex::Literal("get"), method_42470, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_42471, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_42472, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_42473, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_42474, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_42475, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70716), Reflex::Literal("product"), method_42476, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("key"), method_42477, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("index"), method_42478, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_42479, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_42480, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_42481, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_42482, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_42483, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::Electron, std::allocator<pat::Electron> >,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > -------------------------------
static void destructor_38560(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::~RefVector)();
}
static void constructor_38561( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >();
}

static void constructor_38562( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
}

static void constructor_38563( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_38564( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
}

static  void operator_38565( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >)((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_38566( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >)((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_38567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->refVector)();
}

static  void method_38568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->empty)();
}

static  void method_38569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->size)();
}

static  void method_38570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->capacity)();
}

static  void method_38571( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_38572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >)((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->begin)();
}

static  void method_38573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >)((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->end)();
}

static  void method_38574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->id)();
}

static  void method_38575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->productGetter)();
}

static  void method_38576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isNull)();
}

static  void method_38577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isNonnull)();
}

static  void operator_38578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->operator!)();
}

static  void method_38579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->product)();
}

static  void method_38580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isAvailable)();
}

static  void method_38581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isTransient)();
}

static  void method_38582( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >)((((::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
}

static  void method_38583( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->clear)();
}

static  void method_38584( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
}

static  void operator_38585( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
}

static  void method_38586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->hasProductCache)();
}

static  void method_38587( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_38588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->Class_Version)();
}

static void method_newdel_6489( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::Electron, std::allocator<pat::Electron> >,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > -------------------------------
void __edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__datamem_bld(&__edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__funcmem_bld(&__edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__db_funcmem);
void __edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >"), typeid(::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >), sizeof(::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::Class_Version())
  .AddTypedef(type_3520, Reflex::Literal("edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::collection_type"))
  .AddTypedef(type_13576, Reflex::Literal("edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::member_type"))
  .AddTypedef(type_35640, Reflex::Literal("edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::finder_type"))
  .AddTypedef(type_6390, Reflex::Literal("edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::iterator"))
  .AddTypedef(type_6390, Reflex::Literal("edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::const_iterator"))
  .AddTypedef(type_7380, Reflex::Literal("edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::value_type"))
  .AddTypedef(type_7380c, Reflex::Literal("edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::const_reference"))
  .AddTypedef(type_7380c, Reflex::Literal("edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::reference"))
  .AddTypedef(type_227, Reflex::Literal("edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::key_type"))
  .AddTypedef(type_3506, Reflex::Literal("edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::KeyVec"))
  .AddTypedef(type_3845, Reflex::Literal("edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::size_type"))
  .AddTypedef(type_5370, Reflex::Literal("edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_38560, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_38561, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70774), Reflex::Literal("RefVector"), constructor_38562, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("RefVector"), constructor_38563, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6489, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::Electron, std::allocator<pat::Electron> >,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > -------------------
void __edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5370, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::Electron, std::allocator<pat::Electron> >,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > -------------------
void __edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70775), Reflex::Literal("push_back"), method_38564, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7380c, type_3845), Reflex::Literal("operator[]"), operator_38565, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7380c, type_3845), Reflex::Literal("at"), method_38566, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35206), Reflex::Literal("refVector"), method_38567, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_38568, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_38569, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_38570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_38571, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6390), Reflex::Literal("begin"), method_38572, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6390), Reflex::Literal("end"), method_38573, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_38574, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_38575, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_38576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_38577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_38578, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70776), Reflex::Literal("product"), method_38579, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_38580, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_38581, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6390, type_70777), Reflex::Literal("erase"), method_38582, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_38583, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70778), Reflex::Literal("swap"), method_38584, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70778, type_70774), Reflex::Literal("operator="), operator_38585, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_38586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_35212), Reflex::Literal("fillView"), method_38587, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_38588, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::Conversion, std::allocator<pat::Conversion> >,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion> > -------------------------------
static  void operator_42413( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0]);
}

static void constructor_42414( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0]);
}

static void constructor_42415( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >();
}

static void constructor_42416( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::Handle<std::vector<pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::Handle<std::vector<pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::Handle<std::vector<pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::Handle<std::vector<pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42417( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::OrphanHandle<std::vector<pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::OrphanHandle<std::vector<pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::OrphanHandle<std::vector<pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::OrphanHandle<std::vector<pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42418( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42419( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >((const ::std::vector<pat::Conversion>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >((const ::std::vector<pat::Conversion>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >((const ::std::vector<pat::Conversion>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >((const ::std::vector<pat::Conversion>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42420( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::TestHandle<std::vector<pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::TestHandle<std::vector<pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::TestHandle<std::vector<pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::TestHandle<std::vector<pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42421( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_42422( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Conversion*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Conversion>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Conversion*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Conversion>*)arg[3]);
}

static void constructor_42423( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_42424( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::RefProd<std::vector<pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::RefProd<std::vector<pat::Conversion> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_42425(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::~Ref)();
}
static  void operator_42426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->operator*)();
}

static  void operator_42427( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->operator->)();
}

static  void method_42428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->get)();
}

static  void method_42429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isNull)();
}

static  void method_42430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isNonnull)();
}

static  void operator_42431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->operator!)();
}

static  void method_42432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->id)();
}

static  void method_42433( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->productGetter)();
}

static  void method_42434( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->product)();
}

static  void method_42435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->key)();
}

static  void method_42436( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->index)();
}

static  void method_42437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->hasProductCache)();
}

static  void method_42438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isAvailable)();
}

static  void method_42439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->isTransient)();
}

static  void method_42440( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->refCore)();
}

static  void method_42441( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)o)->Class_Version)();
}

static void constructor_42442( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_7369( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::Conversion, std::allocator<pat::Conversion> >,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion> > -------------------------------
void __edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__datamem_bld(&__edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__funcmem_bld(&__edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__db_funcmem);
void __edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >"), typeid(::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >), sizeof(::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::Class_Version())
  .AddTypedef(type_13535, Reflex::Literal("edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::T"))
  .AddTypedef(type_35508, Reflex::Literal("edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::F"))
  .AddTypedef(type_37531, Reflex::Literal("edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::VF"))
  .AddTypedef(type_37530, Reflex::Literal("edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::VBF"))
  .AddTypedef(type_3509, Reflex::Literal("edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::product_type"))
  .AddTypedef(type_13535, Reflex::Literal("edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::value_type"))
  .AddTypedef(type_13535c, Reflex::Literal("edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::element_type"))
  .AddTypedef(type_35508, Reflex::Literal("edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::finder_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::argument_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72005, type_70709), Reflex::Literal("operator="), operator_42413, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70709), Reflex::Literal("Ref"), constructor_42414, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_42415, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72006, type_227, type_1810), Reflex::Literal("Ref"), constructor_42416, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72007, type_227, type_1810), Reflex::Literal("Ref"), constructor_42417, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70708, type_227, type_1810), Reflex::Literal("Ref"), constructor_42418, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70710, type_227, type_1810), Reflex::Literal("Ref"), constructor_42419, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72008, type_227, type_1810), Reflex::Literal("Ref"), constructor_42420, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_227, type_35207), Reflex::Literal("Ref"), constructor_42421, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17707, type_227, type_70710), Reflex::Literal("Ref"), constructor_42422, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ref"), constructor_42423, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72009, type_227), Reflex::Literal("Ref"), constructor_42424, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_42425, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35224, type_18009), Reflex::Literal("Ref"), constructor_42442, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7369, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::Conversion, std::allocator<pat::Conversion> >,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion> > -------------------
void __edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7471, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::Conversion, std::allocator<pat::Conversion> >,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion> > -------------------
void __edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17709), Reflex::Literal("operator*"), operator_42426, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17707), Reflex::Literal("operator->"), operator_42427, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17707), Reflex::Literal("get"), method_42428, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_42429, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_42430, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_42431, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_42432, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_42433, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70710), Reflex::Literal("product"), method_42434, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("key"), method_42435, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("index"), method_42436, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_42437, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_42438, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_42439, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_42440, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_42441, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<pat::Electron, std::allocator<pat::Electron> >,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > -------------------------------
static  void operator_42875( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
  else   (((::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->operator=)(*(const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
}

static void constructor_42876( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
}

static void constructor_42877( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >();
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >();
}

static void constructor_42878( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::Handle<std::vector<pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::Handle<std::vector<pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::Handle<std::vector<pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::Handle<std::vector<pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42879( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::OrphanHandle<std::vector<pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::OrphanHandle<std::vector<pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::OrphanHandle<std::vector<pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::OrphanHandle<std::vector<pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42880( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42881( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >((const ::std::vector<pat::Electron>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >((const ::std::vector<pat::Electron>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >((const ::std::vector<pat::Electron>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >((const ::std::vector<pat::Electron>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42882( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::TestHandle<std::vector<pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::TestHandle<std::vector<pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::TestHandle<std::vector<pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::TestHandle<std::vector<pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_42883( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_42884( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Electron*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Electron>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Electron*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<pat::Electron>*)arg[3]);
}

static void constructor_42885( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_42886( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::RefProd<std::vector<pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::RefProd<std::vector<pat::Electron> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_42887(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::~Ref)();
}
static  void operator_42888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->operator*)();
}

static  void operator_42889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->operator->)();
}

static  void method_42890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->get)();
}

static  void method_42891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isNull)();
}

static  void method_42892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isNonnull)();
}

static  void operator_42893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->operator!)();
}

static  void method_42894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->id)();
}

static  void method_42895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->productGetter)();
}

static  void method_42896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->product)();
}

static  void method_42897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->key)();
}

static  void method_42898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->index)();
}

static  void method_42899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->hasProductCache)();
}

static  void method_42900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isAvailable)();
}

static  void method_42901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->isTransient)();
}

static  void method_42902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->refCore)();
}

static  void method_42903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)o)->Class_Version)();
}

static void constructor_42904( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_7380( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<pat::Electron, std::allocator<pat::Electron> >,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > -------------------------------
void __edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__datamem_bld(&__edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__funcmem_bld(&__edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__db_funcmem);
void __edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >"), typeid(::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >), sizeof(::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::Class_Version())
  .AddTypedef(type_13576, Reflex::Literal("edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::T"))
  .AddTypedef(type_35640, Reflex::Literal("edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::F"))
  .AddTypedef(type_37553, Reflex::Literal("edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::VF"))
  .AddTypedef(type_37552, Reflex::Literal("edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::VBF"))
  .AddTypedef(type_3520, Reflex::Literal("edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::product_type"))
  .AddTypedef(type_13576, Reflex::Literal("edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::value_type"))
  .AddTypedef(type_13576c, Reflex::Literal("edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::element_type"))
  .AddTypedef(type_35640, Reflex::Literal("edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::finder_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::argument_type"))
  .AddTypedef(type_227, Reflex::Literal("edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72060, type_70775), Reflex::Literal("operator="), operator_42875, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70775), Reflex::Literal("Ref"), constructor_42876, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_42877, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72061, type_227, type_1810), Reflex::Literal("Ref"), constructor_42878, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72062, type_227, type_1810), Reflex::Literal("Ref"), constructor_42879, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70774, type_227, type_1810), Reflex::Literal("Ref"), constructor_42880, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70776, type_227, type_1810), Reflex::Literal("Ref"), constructor_42881, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72063, type_227, type_1810), Reflex::Literal("Ref"), constructor_42882, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_227, type_35207), Reflex::Literal("Ref"), constructor_42883, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_17839, type_227, type_70776), Reflex::Literal("Ref"), constructor_42884, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("Ref"), constructor_42885, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72064, type_227), Reflex::Literal("Ref"), constructor_42886, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_42887, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35224, type_18009), Reflex::Literal("Ref"), constructor_42904, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7380, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<pat::Electron, std::allocator<pat::Electron> >,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > -------------------
void __edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7471, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<pat::Electron, std::allocator<pat::Electron> >,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > -------------------
void __edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17841), Reflex::Literal("operator*"), operator_42888, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17839), Reflex::Literal("operator->"), operator_42889, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17839), Reflex::Literal("get"), method_42890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_42891, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_42892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_42893, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_42894, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_42895, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70776), Reflex::Literal("product"), method_42896, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("key"), method_42897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("index"), method_42898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_42899, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_42900, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_42901, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_42902, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_42903, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >, pat::PackedGenParticle> > -------------------------------
static void destructor_38014(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::~RefVector)();
}
static void constructor_38015( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >();
  else ::new(mem) ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >();
}

static void constructor_38016( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0]);
}

static void constructor_38017( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_38018( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->push_back)(*(const ::edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0]);
}

static  void operator_38019( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >)((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_38020( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >)((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_38021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->refVector)();
}

static  void method_38022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->empty)();
}

static  void method_38023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->size)();
}

static  void method_38024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->capacity)();
}

static  void method_38025( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_38026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >)((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->begin)();
}

static  void method_38027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >)((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->end)();
}

static  void method_38028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->id)();
}

static  void method_38029( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->productGetter)();
}

static  void method_38030( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isNull)();
}

static  void method_38031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isNonnull)();
}

static  void operator_38032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->operator!)();
}

static  void method_38033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->product)();
}

static  void method_38034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isAvailable)();
}

static  void method_38035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->isTransient)();
}

static  void method_38036( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >)((((::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0]);
}

static  void method_38037( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->clear)();
}

static  void method_38038( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->swap)(*(::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0]);
}

static  void operator_38039( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)arg[0]);
}

static  void method_38040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->hasProductCache)();
}

static  void method_38041( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_38042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)o)->Class_Version)();
}

static void method_newdel_6476( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >, pat::PackedGenParticle> > -------------------------------
void __edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__datamem_bld(&__edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__funcmem_bld(&__edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__db_funcmem);
void __edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >"), typeid(::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >), sizeof(::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::Class_Version())
  .AddTypedef(type_3507, Reflex::Literal("edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::collection_type"))
  .AddTypedef(type_9072, Reflex::Literal("edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::member_type"))
  .AddTypedef(type_35484, Reflex::Literal("edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::finder_type"))
  .AddTypedef(type_6377, Reflex::Literal("edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::iterator"))
  .AddTypedef(type_6377, Reflex::Literal("edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::const_iterator"))
  .AddTypedef(type_7368, Reflex::Literal("edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::value_type"))
  .AddTypedef(type_7368c, Reflex::Literal("edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::const_reference"))
  .AddTypedef(type_7368c, Reflex::Literal("edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::reference"))
  .AddTypedef(type_227, Reflex::Literal("edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::key_type"))
  .AddTypedef(type_3506, Reflex::Literal("edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::KeyVec"))
  .AddTypedef(type_3845, Reflex::Literal("edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::size_type"))
  .AddTypedef(type_5370, Reflex::Literal("edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_38014, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_38015, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70696), Reflex::Literal("RefVector"), constructor_38016, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("RefVector"), constructor_38017, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6476, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >, pat::PackedGenParticle> > -------------------
void __edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5370, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> >, pat::PackedGenParticle> > -------------------
void __edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70697), Reflex::Literal("push_back"), method_38018, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7368c, type_3845), Reflex::Literal("operator[]"), operator_38019, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7368c, type_3845), Reflex::Literal("at"), method_38020, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35206), Reflex::Literal("refVector"), method_38021, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_38022, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("size"), method_38023, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3845), Reflex::Literal("capacity"), method_38024, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_3845), Reflex::Literal("reserve"), method_38025, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6377), Reflex::Literal("begin"), method_38026, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6377), Reflex::Literal("end"), method_38027, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_38028, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_38029, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_38030, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_38031, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_38032, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70698), Reflex::Literal("product"), method_38033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_38034, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_38035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6377, type_70699), Reflex::Literal("erase"), method_38036, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_38037, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70700), Reflex::Literal("swap"), method_38038, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70700, type_70696), Reflex::Literal("operator="), operator_38039, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_38040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_35212), Reflex::Literal("fillView"), method_38041, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_38042, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> > > -------------------------------
static void destructor_52713(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >::~__normal_iterator)();
}
static  void operator_52714( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)arg[0]);
}

static void constructor_52715( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >(*(const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >(*(const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)arg[0]);
}

static void constructor_52716( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >();
}

static void constructor_52717( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >(*(const ::pat::PackedGenParticle* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >(*(const ::pat::PackedGenParticle* const*)arg[0]);
}

static  void operator_52718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator*)();
}

static  void operator_52719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator->)();
}

static  void operator_52720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator++)();
}

static  void operator_52721( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >)((((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_52722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator--)();
}

static  void operator_52723( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >)((((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_52724( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52725( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >)((((const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52727( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52728( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >)((((const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_52729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >*)o)->base)();
}

static void method_newdel_11964( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3008, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >::__traits_type"))
  .AddTypedef(type_17685, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >::iterator_type"))
  .AddTypedef(type_3090, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >::iterator_category"))
  .AddTypedef(type_9072, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >::difference_type"))
  .AddTypedef(type_17687, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >::reference"))
  .AddTypedef(type_17685, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_52713, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73862, type_73863), Reflex::Literal("operator="), operator_52714, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73863), Reflex::Literal("__normal_iterator"), constructor_52715, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_52716, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73864), Reflex::Literal("__normal_iterator"), constructor_52717, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11964, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17685, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle, std::allocator<pat::PackedGenParticle> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17687), Reflex::Literal("operator*"), operator_52718, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17685), Reflex::Literal("operator->"), operator_52719, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73862), Reflex::Literal("operator++"), operator_52720, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11964, type_72), Reflex::Literal("operator++"), operator_52721, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73862), Reflex::Literal("operator--"), operator_52722, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11964, type_72), Reflex::Literal("operator--"), operator_52723, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17687, type_72493), Reflex::Literal("operator[]"), operator_52724, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73862, type_72493), Reflex::Literal("operator+="), operator_52725, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11964, type_72493), Reflex::Literal("operator+"), operator_52726, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73862, type_72493), Reflex::Literal("operator-="), operator_52727, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11964, type_72493), Reflex::Literal("operator-"), operator_52728, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73864), Reflex::Literal("base"), method_52729, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------------------
static void destructor_52738(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >::~__normal_iterator)();
}
static  void operator_52739( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)arg[0]);
}

static void constructor_52740( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >(*(const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >(*(const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)arg[0]);
}

static void constructor_52741( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >();
}

static void constructor_52742( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >(*(const ::pat::PackedCandidate* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >(*(const ::pat::PackedCandidate* const*)arg[0]);
}

static  void operator_52743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator*)();
}

static  void operator_52744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator->)();
}

static  void operator_52745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator++)();
}

static  void operator_52746( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >)((((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_52747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator--)();
}

static  void operator_52748( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >)((((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_52749( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52750( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52751( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >)((((const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52752( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52753( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >)((((const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_52754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >*)o)->base)();
}

static void method_newdel_11965( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3009, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >::__traits_type"))
  .AddTypedef(type_17696, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >::iterator_type"))
  .AddTypedef(type_3090, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >::iterator_category"))
  .AddTypedef(type_9073, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >::difference_type"))
  .AddTypedef(type_17698, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >::reference"))
  .AddTypedef(type_17696, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_52738, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73865, type_73866), Reflex::Literal("operator="), operator_52739, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73866), Reflex::Literal("__normal_iterator"), constructor_52740, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_52741, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73867), Reflex::Literal("__normal_iterator"), constructor_52742, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11965, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17696, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17698), Reflex::Literal("operator*"), operator_52743, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17696), Reflex::Literal("operator->"), operator_52744, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73865), Reflex::Literal("operator++"), operator_52745, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11965, type_72), Reflex::Literal("operator++"), operator_52746, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73865), Reflex::Literal("operator--"), operator_52747, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11965, type_72), Reflex::Literal("operator--"), operator_52748, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17698, type_72493), Reflex::Literal("operator[]"), operator_52749, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73865, type_72493), Reflex::Literal("operator+="), operator_52750, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11965, type_72493), Reflex::Literal("operator+"), operator_52751, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73865, type_72493), Reflex::Literal("operator-="), operator_52752, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11965, type_72493), Reflex::Literal("operator-"), operator_52753, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73867), Reflex::Literal("base"), method_52754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::Conversion*,std::vector<pat::Conversion, std::allocator<pat::Conversion> > > -------------------------------
static void destructor_52763(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >::~__normal_iterator)();
}
static  void operator_52764( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)arg[0]);
}

static void constructor_52765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)arg[0]);
}

static void constructor_52766( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >();
}

static void constructor_52767( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >(*(const ::pat::Conversion* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >(*(const ::pat::Conversion* const*)arg[0]);
}

static  void operator_52768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator*)();
}

static  void operator_52769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator->)();
}

static  void operator_52770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator++)();
}

static  void operator_52771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >)((((::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_52772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator--)();
}

static  void operator_52773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >)((((::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_52774( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52775( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52777( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52778( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_52779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >*)o)->base)();
}

static void method_newdel_11966( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::Conversion*,std::vector<pat::Conversion, std::allocator<pat::Conversion> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3010, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >::__traits_type"))
  .AddTypedef(type_17707, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >::iterator_type"))
  .AddTypedef(type_3090, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >::iterator_category"))
  .AddTypedef(type_13535, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >::difference_type"))
  .AddTypedef(type_17709, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >::reference"))
  .AddTypedef(type_17707, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_52763, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73868, type_73869), Reflex::Literal("operator="), operator_52764, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73869), Reflex::Literal("__normal_iterator"), constructor_52765, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_52766, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73870), Reflex::Literal("__normal_iterator"), constructor_52767, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11966, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::Conversion*,std::vector<pat::Conversion, std::allocator<pat::Conversion> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17707, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::Conversion*,std::vector<pat::Conversion, std::allocator<pat::Conversion> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17709), Reflex::Literal("operator*"), operator_52768, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17707), Reflex::Literal("operator->"), operator_52769, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73868), Reflex::Literal("operator++"), operator_52770, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11966, type_72), Reflex::Literal("operator++"), operator_52771, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73868), Reflex::Literal("operator--"), operator_52772, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11966, type_72), Reflex::Literal("operator--"), operator_52773, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17709, type_72493), Reflex::Literal("operator[]"), operator_52774, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73868, type_72493), Reflex::Literal("operator+="), operator_52775, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11966, type_72493), Reflex::Literal("operator+"), operator_52776, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73868, type_72493), Reflex::Literal("operator-="), operator_52777, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11966, type_72493), Reflex::Literal("operator-"), operator_52778, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73870), Reflex::Literal("base"), method_52779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> > > -------------------------------
static void destructor_52788(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >::~__normal_iterator)();
}
static  void operator_52789( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)arg[0]);
}

static void constructor_52790( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)arg[0]);
}

static void constructor_52791( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >();
}

static void constructor_52792( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >(*(const ::pat::Hemisphere* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >(*(const ::pat::Hemisphere* const*)arg[0]);
}

static  void operator_52793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator*)();
}

static  void operator_52794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator->)();
}

static  void operator_52795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator++)();
}

static  void operator_52796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >)((((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_52797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator--)();
}

static  void operator_52798( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >)((((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_52799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52800( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52801( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52803( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_52804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >*)o)->base)();
}

static void method_newdel_11967( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3011, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >::__traits_type"))
  .AddTypedef(type_17718, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >::iterator_type"))
  .AddTypedef(type_3090, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >::iterator_category"))
  .AddTypedef(type_13517, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >::difference_type"))
  .AddTypedef(type_17720, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >::reference"))
  .AddTypedef(type_17718, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_52788, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73871, type_73872), Reflex::Literal("operator="), operator_52789, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73872), Reflex::Literal("__normal_iterator"), constructor_52790, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_52791, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73873), Reflex::Literal("__normal_iterator"), constructor_52792, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11967, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17718, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17720), Reflex::Literal("operator*"), operator_52793, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17718), Reflex::Literal("operator->"), operator_52794, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73871), Reflex::Literal("operator++"), operator_52795, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11967, type_72), Reflex::Literal("operator++"), operator_52796, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73871), Reflex::Literal("operator--"), operator_52797, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11967, type_72), Reflex::Literal("operator--"), operator_52798, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17720, type_72493), Reflex::Literal("operator[]"), operator_52799, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73871, type_72493), Reflex::Literal("operator+="), operator_52800, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11967, type_72493), Reflex::Literal("operator+"), operator_52801, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73871, type_72493), Reflex::Literal("operator-="), operator_52802, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11967, type_72493), Reflex::Literal("operator-"), operator_52803, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73873), Reflex::Literal("base"), method_52804, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> > > -------------------------------
static void destructor_52813(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >::~__normal_iterator)();
}
static  void operator_52814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)arg[0]);
}

static void constructor_52815( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >(*(const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >(*(const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)arg[0]);
}

static void constructor_52816( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >();
}

static void constructor_52817( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >(*(const ::pat::GenericParticle* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >(*(const ::pat::GenericParticle* const*)arg[0]);
}

static  void operator_52818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator*)();
}

static  void operator_52819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator->)();
}

static  void operator_52820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator++)();
}

static  void operator_52821( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >)((((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_52822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator--)();
}

static  void operator_52823( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >)((((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_52824( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52825( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52826( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >)((((const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52827( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52828( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >)((((const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_52829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >*)o)->base)();
}

static void method_newdel_11968( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3012, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >::__traits_type"))
  .AddTypedef(type_17729, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >::iterator_type"))
  .AddTypedef(type_3090, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >::iterator_category"))
  .AddTypedef(type_13540, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >::difference_type"))
  .AddTypedef(type_17731, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >::reference"))
  .AddTypedef(type_17729, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_52813, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73874, type_73875), Reflex::Literal("operator="), operator_52814, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73875), Reflex::Literal("__normal_iterator"), constructor_52815, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_52816, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73876), Reflex::Literal("__normal_iterator"), constructor_52817, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11968, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17729, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17731), Reflex::Literal("operator*"), operator_52818, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17729), Reflex::Literal("operator->"), operator_52819, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73874), Reflex::Literal("operator++"), operator_52820, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11968, type_72), Reflex::Literal("operator++"), operator_52821, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73874), Reflex::Literal("operator--"), operator_52822, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11968, type_72), Reflex::Literal("operator--"), operator_52823, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17731, type_72493), Reflex::Literal("operator[]"), operator_52824, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73874, type_72493), Reflex::Literal("operator+="), operator_52825, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11968, type_72493), Reflex::Literal("operator+"), operator_52826, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73874, type_72493), Reflex::Literal("operator-="), operator_52827, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11968, type_72493), Reflex::Literal("operator-"), operator_52828, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73876), Reflex::Literal("base"), method_52829, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle, std::allocator<pat::PFParticle> > > -------------------------------
static void destructor_52838(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >::~__normal_iterator)();
}
static  void operator_52839( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)arg[0]);
}

static void constructor_52840( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >(*(const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >(*(const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)arg[0]);
}

static void constructor_52841( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >();
}

static void constructor_52842( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >(*(const ::pat::PFParticle* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >(*(const ::pat::PFParticle* const*)arg[0]);
}

static  void operator_52843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator*)();
}

static  void operator_52844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator->)();
}

static  void operator_52845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator++)();
}

static  void operator_52846( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >)((((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_52847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator--)();
}

static  void operator_52848( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >)((((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_52849( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52851( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >)((((const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52852( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52853( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >)((((const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_52854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >*)o)->base)();
}

static void method_newdel_11969( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle, std::allocator<pat::PFParticle> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3013, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >::__traits_type"))
  .AddTypedef(type_17740, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >::iterator_type"))
  .AddTypedef(type_3090, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >::iterator_category"))
  .AddTypedef(type_13478, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >::difference_type"))
  .AddTypedef(type_17742, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >::reference"))
  .AddTypedef(type_17740, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_52838, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73877, type_73878), Reflex::Literal("operator="), operator_52839, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73878), Reflex::Literal("__normal_iterator"), constructor_52840, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_52841, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73879), Reflex::Literal("__normal_iterator"), constructor_52842, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11969, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle, std::allocator<pat::PFParticle> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17740, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle, std::allocator<pat::PFParticle> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17742), Reflex::Literal("operator*"), operator_52843, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17740), Reflex::Literal("operator->"), operator_52844, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73877), Reflex::Literal("operator++"), operator_52845, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11969, type_72), Reflex::Literal("operator++"), operator_52846, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73877), Reflex::Literal("operator--"), operator_52847, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11969, type_72), Reflex::Literal("operator--"), operator_52848, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17742, type_72493), Reflex::Literal("operator[]"), operator_52849, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73877, type_72493), Reflex::Literal("operator+="), operator_52850, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11969, type_72493), Reflex::Literal("operator+"), operator_52851, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73877, type_72493), Reflex::Literal("operator-="), operator_52852, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11969, type_72493), Reflex::Literal("operator-"), operator_52853, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73879), Reflex::Literal("base"), method_52854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> > > -------------------------------
static void destructor_52863(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >::~__normal_iterator)();
}
static  void operator_52864( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)arg[0]);
}

static void constructor_52865( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >(*(const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >(*(const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)arg[0]);
}

static void constructor_52866( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >();
}

static void constructor_52867( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >(*(const ::pat::CompositeCandidate* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >(*(const ::pat::CompositeCandidate* const*)arg[0]);
}

static  void operator_52868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator*)();
}

static  void operator_52869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator->)();
}

static  void operator_52870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator++)();
}

static  void operator_52871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >)((((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_52872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator--)();
}

static  void operator_52873( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >)((((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_52874( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52875( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52876( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >)((((const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >)((((const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_52879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >*)o)->base)();
}

static void method_newdel_11970( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3014, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >::__traits_type"))
  .AddTypedef(type_17751, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >::iterator_type"))
  .AddTypedef(type_3090, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >::iterator_category"))
  .AddTypedef(type_13564, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >::difference_type"))
  .AddTypedef(type_17753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >::reference"))
  .AddTypedef(type_17751, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_52863, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73880, type_73881), Reflex::Literal("operator="), operator_52864, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73881), Reflex::Literal("__normal_iterator"), constructor_52865, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_52866, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73882), Reflex::Literal("__normal_iterator"), constructor_52867, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11970, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17751, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17753), Reflex::Literal("operator*"), operator_52868, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17751), Reflex::Literal("operator->"), operator_52869, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73880), Reflex::Literal("operator++"), operator_52870, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11970, type_72), Reflex::Literal("operator++"), operator_52871, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73880), Reflex::Literal("operator--"), operator_52872, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11970, type_72), Reflex::Literal("operator--"), operator_52873, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17753, type_72493), Reflex::Literal("operator[]"), operator_52874, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73880, type_72493), Reflex::Literal("operator+="), operator_52875, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11970, type_72493), Reflex::Literal("operator+"), operator_52876, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73880, type_72493), Reflex::Literal("operator-="), operator_52877, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11970, type_72493), Reflex::Literal("operator-"), operator_52878, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73882), Reflex::Literal("base"), method_52879, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::Particle*,std::vector<pat::Particle, std::allocator<pat::Particle> > > -------------------------------
static void destructor_52888(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >::~__normal_iterator)();
}
static  void operator_52889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)arg[0]);
}

static void constructor_52890( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)arg[0]);
}

static void constructor_52891( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >();
}

static void constructor_52892( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >(*(const ::pat::Particle* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >(*(const ::pat::Particle* const*)arg[0]);
}

static  void operator_52893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator*)();
}

static  void operator_52894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator->)();
}

static  void operator_52895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator++)();
}

static  void operator_52896( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >)((((::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_52897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator--)();
}

static  void operator_52898( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >)((((::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_52899( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52900( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52901( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52902( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52903( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_52904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >*)o)->base)();
}

static void method_newdel_11971( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::Particle*,std::vector<pat::Particle, std::allocator<pat::Particle> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3015, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >::__traits_type"))
  .AddTypedef(type_17762, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >::iterator_type"))
  .AddTypedef(type_3090, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >::iterator_category"))
  .AddTypedef(type_13527, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >::difference_type"))
  .AddTypedef(type_17764, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >::reference"))
  .AddTypedef(type_17762, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_52888, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73883, type_73884), Reflex::Literal("operator="), operator_52889, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73884), Reflex::Literal("__normal_iterator"), constructor_52890, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_52891, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73885), Reflex::Literal("__normal_iterator"), constructor_52892, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11971, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::Particle*,std::vector<pat::Particle, std::allocator<pat::Particle> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17762, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::Particle*,std::vector<pat::Particle, std::allocator<pat::Particle> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17764), Reflex::Literal("operator*"), operator_52893, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17762), Reflex::Literal("operator->"), operator_52894, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73883), Reflex::Literal("operator++"), operator_52895, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11971, type_72), Reflex::Literal("operator++"), operator_52896, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73883), Reflex::Literal("operator--"), operator_52897, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11971, type_72), Reflex::Literal("operator--"), operator_52898, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17764, type_72493), Reflex::Literal("operator[]"), operator_52899, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73883, type_72493), Reflex::Literal("operator+="), operator_52900, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11971, type_72493), Reflex::Literal("operator+"), operator_52901, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73883, type_72493), Reflex::Literal("operator-="), operator_52902, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11971, type_72493), Reflex::Literal("operator-"), operator_52903, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73885), Reflex::Literal("base"), method_52904, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::MET*,std::vector<pat::MET, std::allocator<pat::MET> > > -------------------------------
static void destructor_52938(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >::~__normal_iterator)();
}
static  void operator_52939( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)arg[0]);
}

static void constructor_52940( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >(*(const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >(*(const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)arg[0]);
}

static void constructor_52941( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >();
}

static void constructor_52942( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >(*(const ::pat::MET* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >(*(const ::pat::MET* const*)arg[0]);
}

static  void operator_52943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator*)();
}

static  void operator_52944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator->)();
}

static  void operator_52945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator++)();
}

static  void operator_52946( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >)((((::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_52947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator--)();
}

static  void operator_52948( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >)((((::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_52949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52950( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >)((((const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52952( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >)((((const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_52954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >*)o)->base)();
}

static void method_newdel_11974( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::MET*,std::vector<pat::MET, std::allocator<pat::MET> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3017, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >::__traits_type"))
  .AddTypedef(type_17784, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >::iterator_type"))
  .AddTypedef(type_3090, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >::iterator_category"))
  .AddTypedef(type_13544, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >::difference_type"))
  .AddTypedef(type_17786, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >::reference"))
  .AddTypedef(type_17784, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_52938, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73889, type_73890), Reflex::Literal("operator="), operator_52939, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73890), Reflex::Literal("__normal_iterator"), constructor_52940, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_52941, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73891), Reflex::Literal("__normal_iterator"), constructor_52942, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11974, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::MET*,std::vector<pat::MET, std::allocator<pat::MET> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17784, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::MET*,std::vector<pat::MET, std::allocator<pat::MET> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17786), Reflex::Literal("operator*"), operator_52943, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17784), Reflex::Literal("operator->"), operator_52944, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73889), Reflex::Literal("operator++"), operator_52945, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11974, type_72), Reflex::Literal("operator++"), operator_52946, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73889), Reflex::Literal("operator--"), operator_52947, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11974, type_72), Reflex::Literal("operator--"), operator_52948, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17786, type_72493), Reflex::Literal("operator[]"), operator_52949, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73889, type_72493), Reflex::Literal("operator+="), operator_52950, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11974, type_72493), Reflex::Literal("operator+"), operator_52951, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73889, type_72493), Reflex::Literal("operator-="), operator_52952, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11974, type_72493), Reflex::Literal("operator-"), operator_52953, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73891), Reflex::Literal("base"), method_52954, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::Jet*,std::vector<pat::Jet, std::allocator<pat::Jet> > > -------------------------------
static void destructor_52963(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >::~__normal_iterator)();
}
static  void operator_52964( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)arg[0]);
}

static void constructor_52965( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)arg[0]);
}

static void constructor_52966( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >();
}

static void constructor_52967( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >(*(const ::pat::Jet* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >(*(const ::pat::Jet* const*)arg[0]);
}

static  void operator_52968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator*)();
}

static  void operator_52969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator->)();
}

static  void operator_52970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator++)();
}

static  void operator_52971( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >)((((::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_52972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator--)();
}

static  void operator_52973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >)((((::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_52974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52977( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_52979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >*)o)->base)();
}

static void method_newdel_11975( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::Jet*,std::vector<pat::Jet, std::allocator<pat::Jet> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3018, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >::__traits_type"))
  .AddTypedef(type_17795, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >::iterator_type"))
  .AddTypedef(type_3090, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >::iterator_category"))
  .AddTypedef(type_13487, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >::difference_type"))
  .AddTypedef(type_17797, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >::reference"))
  .AddTypedef(type_17795, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_52963, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73892, type_73893), Reflex::Literal("operator="), operator_52964, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73893), Reflex::Literal("__normal_iterator"), constructor_52965, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_52966, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73894), Reflex::Literal("__normal_iterator"), constructor_52967, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11975, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::Jet*,std::vector<pat::Jet, std::allocator<pat::Jet> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17795, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::Jet*,std::vector<pat::Jet, std::allocator<pat::Jet> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17797), Reflex::Literal("operator*"), operator_52968, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17795), Reflex::Literal("operator->"), operator_52969, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73892), Reflex::Literal("operator++"), operator_52970, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11975, type_72), Reflex::Literal("operator++"), operator_52971, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73892), Reflex::Literal("operator--"), operator_52972, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11975, type_72), Reflex::Literal("operator--"), operator_52973, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17797, type_72493), Reflex::Literal("operator[]"), operator_52974, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73892, type_72493), Reflex::Literal("operator+="), operator_52975, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11975, type_72493), Reflex::Literal("operator+"), operator_52976, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73892, type_72493), Reflex::Literal("operator-="), operator_52977, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11975, type_72493), Reflex::Literal("operator-"), operator_52978, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73894), Reflex::Literal("base"), method_52979, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::Photon*,std::vector<pat::Photon, std::allocator<pat::Photon> > > -------------------------------
static void destructor_52988(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >::~__normal_iterator)();
}
static  void operator_52989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)arg[0]);
}

static void constructor_52990( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)arg[0]);
}

static void constructor_52991( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >();
}

static void constructor_52992( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >(*(const ::pat::Photon* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >(*(const ::pat::Photon* const*)arg[0]);
}

static  void operator_52993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator*)();
}

static  void operator_52994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator->)();
}

static  void operator_52995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator++)();
}

static  void operator_52996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >)((((::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_52997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator--)();
}

static  void operator_52998( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >)((((::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_52999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53000( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53001( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53002( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53003( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_53004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >*)o)->base)();
}

static void method_newdel_11976( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::Photon*,std::vector<pat::Photon, std::allocator<pat::Photon> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3019, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >::__traits_type"))
  .AddTypedef(type_17806, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >::iterator_type"))
  .AddTypedef(type_3090, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >::iterator_category"))
  .AddTypedef(type_13525, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >::difference_type"))
  .AddTypedef(type_17808, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >::reference"))
  .AddTypedef(type_17806, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_52988, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73895, type_73896), Reflex::Literal("operator="), operator_52989, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73896), Reflex::Literal("__normal_iterator"), constructor_52990, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_52991, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73897), Reflex::Literal("__normal_iterator"), constructor_52992, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11976, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::Photon*,std::vector<pat::Photon, std::allocator<pat::Photon> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17806, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::Photon*,std::vector<pat::Photon, std::allocator<pat::Photon> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17808), Reflex::Literal("operator*"), operator_52993, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17806), Reflex::Literal("operator->"), operator_52994, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73895), Reflex::Literal("operator++"), operator_52995, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11976, type_72), Reflex::Literal("operator++"), operator_52996, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73895), Reflex::Literal("operator--"), operator_52997, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11976, type_72), Reflex::Literal("operator--"), operator_52998, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17808, type_72493), Reflex::Literal("operator[]"), operator_52999, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73895, type_72493), Reflex::Literal("operator+="), operator_53000, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11976, type_72493), Reflex::Literal("operator+"), operator_53001, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73895, type_72493), Reflex::Literal("operator-="), operator_53002, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11976, type_72493), Reflex::Literal("operator-"), operator_53003, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73897), Reflex::Literal("base"), method_53004, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::Tau*,std::vector<pat::Tau, std::allocator<pat::Tau> > > -------------------------------
static void destructor_53013(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >::~__normal_iterator)();
}
static  void operator_53014( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)arg[0]);
}

static void constructor_53015( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)arg[0]);
}

static void constructor_53016( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >();
}

static void constructor_53017( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >(*(const ::pat::Tau* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >(*(const ::pat::Tau* const*)arg[0]);
}

static  void operator_53018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator*)();
}

static  void operator_53019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator->)();
}

static  void operator_53020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator++)();
}

static  void operator_53021( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >)((((::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_53022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator--)();
}

static  void operator_53023( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >)((((::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_53024( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53025( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53026( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53027( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53028( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_53029( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >*)o)->base)();
}

static void method_newdel_11977( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::Tau*,std::vector<pat::Tau, std::allocator<pat::Tau> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3020, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >::__traits_type"))
  .AddTypedef(type_17817, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >::iterator_type"))
  .AddTypedef(type_3090, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >::iterator_category"))
  .AddTypedef(type_13568, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >::difference_type"))
  .AddTypedef(type_17819, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >::reference"))
  .AddTypedef(type_17817, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_53013, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73898, type_73899), Reflex::Literal("operator="), operator_53014, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73899), Reflex::Literal("__normal_iterator"), constructor_53015, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_53016, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73900), Reflex::Literal("__normal_iterator"), constructor_53017, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11977, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::Tau*,std::vector<pat::Tau, std::allocator<pat::Tau> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17817, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::Tau*,std::vector<pat::Tau, std::allocator<pat::Tau> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17819), Reflex::Literal("operator*"), operator_53018, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17817), Reflex::Literal("operator->"), operator_53019, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73898), Reflex::Literal("operator++"), operator_53020, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11977, type_72), Reflex::Literal("operator++"), operator_53021, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73898), Reflex::Literal("operator--"), operator_53022, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11977, type_72), Reflex::Literal("operator--"), operator_53023, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17819, type_72493), Reflex::Literal("operator[]"), operator_53024, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73898, type_72493), Reflex::Literal("operator+="), operator_53025, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11977, type_72493), Reflex::Literal("operator+"), operator_53026, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73898, type_72493), Reflex::Literal("operator-="), operator_53027, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11977, type_72493), Reflex::Literal("operator-"), operator_53028, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73900), Reflex::Literal("base"), method_53029, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::Muon*,std::vector<pat::Muon, std::allocator<pat::Muon> > > -------------------------------
static void destructor_53038(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >::~__normal_iterator)();
}
static  void operator_53039( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)arg[0]);
}

static void constructor_53040( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)arg[0]);
}

static void constructor_53041( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >();
}

static void constructor_53042( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >(*(const ::pat::Muon* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >(*(const ::pat::Muon* const*)arg[0]);
}

static  void operator_53043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator*)();
}

static  void operator_53044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator->)();
}

static  void operator_53045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator++)();
}

static  void operator_53046( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >)((((::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_53047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator--)();
}

static  void operator_53048( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >)((((::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_53049( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53050( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53053( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_53054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >*)o)->base)();
}

static void method_newdel_11978( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::Muon*,std::vector<pat::Muon, std::allocator<pat::Muon> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3021, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >::__traits_type"))
  .AddTypedef(type_17828, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >::iterator_type"))
  .AddTypedef(type_3090, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >::iterator_category"))
  .AddTypedef(type_13465, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >::difference_type"))
  .AddTypedef(type_17830, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >::reference"))
  .AddTypedef(type_17828, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_53038, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73901, type_73902), Reflex::Literal("operator="), operator_53039, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73902), Reflex::Literal("__normal_iterator"), constructor_53040, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_53041, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73903), Reflex::Literal("__normal_iterator"), constructor_53042, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11978, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::Muon*,std::vector<pat::Muon, std::allocator<pat::Muon> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17828, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::Muon*,std::vector<pat::Muon, std::allocator<pat::Muon> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17830), Reflex::Literal("operator*"), operator_53043, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17828), Reflex::Literal("operator->"), operator_53044, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73901), Reflex::Literal("operator++"), operator_53045, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11978, type_72), Reflex::Literal("operator++"), operator_53046, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73901), Reflex::Literal("operator--"), operator_53047, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11978, type_72), Reflex::Literal("operator--"), operator_53048, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17830, type_72493), Reflex::Literal("operator[]"), operator_53049, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73901, type_72493), Reflex::Literal("operator+="), operator_53050, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11978, type_72493), Reflex::Literal("operator+"), operator_53051, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73901, type_72493), Reflex::Literal("operator-="), operator_53052, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11978, type_72493), Reflex::Literal("operator-"), operator_53053, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73903), Reflex::Literal("base"), method_53054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::Electron*,std::vector<pat::Electron, std::allocator<pat::Electron> > > -------------------------------
static void destructor_53063(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >::~__normal_iterator)();
}
static  void operator_53064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)arg[0]);
}

static void constructor_53065( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >(*(const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)arg[0]);
}

static void constructor_53066( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >();
}

static void constructor_53067( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >(*(const ::pat::Electron* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >(*(const ::pat::Electron* const*)arg[0]);
}

static  void operator_53068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator*)();
}

static  void operator_53069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator->)();
}

static  void operator_53070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator++)();
}

static  void operator_53071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >)((((::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_53072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator--)();
}

static  void operator_53073( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >)((((::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_53074( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_53078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >)((((const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_53079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >*)o)->base)();
}

static void method_newdel_11979( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::Electron*,std::vector<pat::Electron, std::allocator<pat::Electron> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3022, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >::__traits_type"))
  .AddTypedef(type_17839, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >::iterator_type"))
  .AddTypedef(type_3090, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >::iterator_category"))
  .AddTypedef(type_13576, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >::difference_type"))
  .AddTypedef(type_17841, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >::reference"))
  .AddTypedef(type_17839, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_53063, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73904, type_73905), Reflex::Literal("operator="), operator_53064, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73905), Reflex::Literal("__normal_iterator"), constructor_53065, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_53066, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73906), Reflex::Literal("__normal_iterator"), constructor_53067, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11979, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::Electron*,std::vector<pat::Electron, std::allocator<pat::Electron> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17839, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::Electron*,std::vector<pat::Electron, std::allocator<pat::Electron> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17841), Reflex::Literal("operator*"), operator_53068, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17839), Reflex::Literal("operator->"), operator_53069, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73904), Reflex::Literal("operator++"), operator_53070, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11979, type_72), Reflex::Literal("operator++"), operator_53071, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73904), Reflex::Literal("operator--"), operator_53072, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11979, type_72), Reflex::Literal("operator--"), operator_53073, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17841, type_72493), Reflex::Literal("operator[]"), operator_53074, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73904, type_72493), Reflex::Literal("operator+="), operator_53075, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11979, type_72493), Reflex::Literal("operator+"), operator_53076, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73904, type_72493), Reflex::Literal("operator-="), operator_53077, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11979, type_72493), Reflex::Literal("operator-"), operator_53078, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73906), Reflex::Literal("base"), method_53079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const pat::MHT*,std::vector<pat::MHT, std::allocator<pat::MHT> > > -------------------------------
static void destructor_52913(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >::~__normal_iterator)();
}
static  void operator_52914( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)arg[0]);
}

static void constructor_52915( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >(*(const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >(*(const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)arg[0]);
}

static void constructor_52916( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >();
}

static void constructor_52917( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >(*(const ::pat::MHT* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >(*(const ::pat::MHT* const*)arg[0]);
}

static  void operator_52918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator*)();
}

static  void operator_52919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator->)();
}

static  void operator_52920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator++)();
}

static  void operator_52921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >)((((::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_52922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator--)();
}

static  void operator_52923( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >)((((::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_52924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52926( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >)((((const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52927( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_52928( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >)((((const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_52929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >*)o)->base)();
}

static void method_newdel_11972( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const pat::MHT*,std::vector<pat::MHT, std::allocator<pat::MHT> > > -------------------------------
void ____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s__datamem_bld(&____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s__funcmem_bld(&____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >"), typeid(::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >), sizeof(::__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3016, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >::__traits_type"))
  .AddTypedef(type_17773, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >::iterator_type"))
  .AddTypedef(type_3090, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >::iterator_category"))
  .AddTypedef(type_13575, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >::difference_type"))
  .AddTypedef(type_17775, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >::reference"))
  .AddTypedef(type_17773, Reflex::Literal("__gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_52913, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73886, type_73887), Reflex::Literal("operator="), operator_52914, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73887), Reflex::Literal("__normal_iterator"), constructor_52915, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_52916, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_73888), Reflex::Literal("__normal_iterator"), constructor_52917, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11972, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const pat::MHT*,std::vector<pat::MHT, std::allocator<pat::MHT> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17773, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const pat::MHT*,std::vector<pat::MHT, std::allocator<pat::MHT> > > -------------------
void ____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17775), Reflex::Literal("operator*"), operator_52918, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17773), Reflex::Literal("operator->"), operator_52919, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73886), Reflex::Literal("operator++"), operator_52920, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11972, type_72), Reflex::Literal("operator++"), operator_52921, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73886), Reflex::Literal("operator--"), operator_52922, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11972, type_72), Reflex::Literal("operator--"), operator_52923, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17775, type_72493), Reflex::Literal("operator[]"), operator_52924, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73886, type_72493), Reflex::Literal("operator+="), operator_52925, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11972, type_72493), Reflex::Literal("operator+"), operator_52926, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73886, type_72493), Reflex::Literal("operator-="), operator_52927, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11972, type_72493), Reflex::Literal("operator-"), operator_52928, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_73888), Reflex::Literal("base"), method_52929, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Association<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------------------
static void destructor_42235(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Association<std::vector<pat::PackedCandidate> >*)o)->::edm::Association<std::vector<pat::PackedCandidate> >::~Association)();
}
static void constructor_42236( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<std::vector<pat::PackedCandidate> >(*(const ::edm::Association<std::vector<pat::PackedCandidate> >*)arg[0]);
  else ::new(mem) ::edm::Association<std::vector<pat::PackedCandidate> >(*(const ::edm::Association<std::vector<pat::PackedCandidate> >*)arg[0]);
}

static void constructor_42237( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<std::vector<pat::PackedCandidate> >();
  else ::new(mem) ::edm::Association<std::vector<pat::PackedCandidate> >();
}

static  void method_42238( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >)((((const ::edm::Association<std::vector<pat::PackedCandidate> >*)o)->get)(*(::size_t*)arg[0]));
  else   (((const ::edm::Association<std::vector<pat::PackedCandidate> >*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_42239( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> >)((((const ::edm::Association<std::vector<pat::PackedCandidate> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::Association<std::vector<pat::PackedCandidate> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_42240( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<std::vector<pat::PackedCandidate> >*)o)->operator+=)(*(const ::edm::Association<std::vector<pat::PackedCandidate> >*)arg[0]);
  else   (((::edm::Association<std::vector<pat::PackedCandidate> >*)o)->operator+=)(*(const ::edm::Association<std::vector<pat::PackedCandidate> >*)arg[0]);
}

static  void method_42241( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<std::vector<pat::PackedCandidate> >*)o)->setRef)(*(const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)arg[0]);
}

static  void method_42242( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<std::vector<pat::PackedCandidate> >*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::Association<std::vector<pat::PackedCandidate> >*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_42243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::Association<std::vector<pat::PackedCandidate> >*)o)->size)());
  else   (((const ::edm::Association<std::vector<pat::PackedCandidate> >*)o)->size)();
}

static  void method_42244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<std::vector<pat::PackedCandidate> >*)o)->empty)());
  else   (((const ::edm::Association<std::vector<pat::PackedCandidate> >*)o)->empty)();
}

static  void method_42245( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::Association<std::vector<pat::PackedCandidate> >*)o)->clear)();
}

static  void method_42246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefProd<std::vector<pat::PackedCandidate> >)((((const ::edm::Association<std::vector<pat::PackedCandidate> >*)o)->ref)());
  else   (((const ::edm::Association<std::vector<pat::PackedCandidate> >*)o)->ref)();
}

static  void method_42247( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<std::vector<pat::PackedCandidate> >*)o)->swap)(*(::edm::Association<std::vector<pat::PackedCandidate> >*)arg[0]);
}

static  void operator_42248( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<std::vector<pat::PackedCandidate> >*)o)->operator=)(*(const ::edm::Association<std::vector<pat::PackedCandidate> >*)arg[0]);
  else   (((::edm::Association<std::vector<pat::PackedCandidate> >*)o)->operator=)(*(const ::edm::Association<std::vector<pat::PackedCandidate> >*)arg[0]);
}

static  void method_42249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Association<std::vector<pat::PackedCandidate> >*)o)->ids)();
  else   (((const ::edm::Association<std::vector<pat::PackedCandidate> >*)o)->ids)();
}

static  void method_42250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Association<std::vector<pat::PackedCandidate> >*)o)->Class_Version)());
  else   (((::edm::Association<std::vector<pat::PackedCandidate> >*)o)->Class_Version)();
}

static void method_newdel_7358( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<pat::PackedCandidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<pat::PackedCandidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<pat::PackedCandidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<pat::PackedCandidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<pat::PackedCandidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x181( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<int>")), ::Reflex::BaseOffset< ::edm::Association<std::vector<pat::PackedCandidate> >,::edm::ValueMap<int> >::Get(),::Reflex::PRIVATE), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Association<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------------------
void __edm__Association_std__vector_pat__PackedCandidate_s__db_datamem(Reflex::Class*);
void __edm__Association_std__vector_pat__PackedCandidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Association_std__vector_pat__PackedCandidate_s__datamem_bld(&__edm__Association_std__vector_pat__PackedCandidate_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Association_std__vector_pat__PackedCandidate_s__funcmem_bld(&__edm__Association_std__vector_pat__PackedCandidate_s__db_funcmem);
void __edm__Association_std__vector_pat__PackedCandidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Association<std::vector<pat::PackedCandidate> >"), typeid(::edm::Association<std::vector<pat::PackedCandidate> >), sizeof(::edm::Association<std::vector<pat::PackedCandidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Association<std::vector<pat::PackedCandidate> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::Association<pat::PackedCandidateCollection>")
  .AddBase(type_6832, ::Reflex::BaseOffset< ::edm::Association<std::vector<pat::PackedCandidate> >, ::edm::ValueMap<int> >::Get(), ::Reflex::PRIVATE)
  .AddTypedef(type_72, Reflex::Literal("edm::Association<std::vector<pat::PackedCandidate> >::index"))
  .AddTypedef(type_6832, Reflex::Literal("edm::Association<std::vector<pat::PackedCandidate> >::base"))
  .AddTypedef(type_227, Reflex::Literal("edm::Association<std::vector<pat::PackedCandidate> >::offset"))
  .AddTypedef(type_7221, Reflex::Literal("edm::Association<std::vector<pat::PackedCandidate> >::refprod_type"))
  .AddTypedef(type_7367, Reflex::Literal("edm::Association<std::vector<pat::PackedCandidate> >::reference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Association"), destructor_42235, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71993), Reflex::Literal("Association"), constructor_42236, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Association"), constructor_42237, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7358, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x181, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Association_std__vector_pat__PackedCandidate_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Association_std__vector_pat__PackedCandidate_s__funcmem_bld);
}

//------Delayed data member builder for class Association<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------
void __edm__Association_std__vector_pat__PackedCandidate_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7221, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__Association_std__vector_pat__PackedCandidate_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Association<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------
void __edm__Association_std__vector_pat__PackedCandidate_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7367, type_2393), Reflex::Literal("get"), method_42238, 0, "rawIdx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7367, type_7365, type_2393), Reflex::Literal("get"), method_42239, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71994, type_71993), Reflex::Literal("operator+="), operator_42240, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_71851), Reflex::Literal("setRef"), method_42241, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_7365), Reflex::Literal("contains"), method_42242, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("size"), method_42243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_42244, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_42245, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7221), Reflex::Literal("ref"), method_42246, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_71994), Reflex::Literal("swap"), method_42247, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71994, type_71993), Reflex::Literal("operator="), operator_42248, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65077), Reflex::Literal("ids"), method_42249, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_42250, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::Association<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > > -------------------------------
static void constructor_39671( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >();
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >();
}

static void constructor_39672( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >(*(::std::auto_ptr<edm::Association<std::vector<pat::PackedCandidate> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >(*(::std::auto_ptr<edm::Association<std::vector<pat::PackedCandidate> > >*)arg[0]);
}

static void destructor_39673(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >::~Wrapper)();
}
static  void method_39674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->product)();
}

static  void operator_39675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->operator->)();
}

static  void method_39676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->productTypeInfo)();
}

static  void method_39677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->typeInfo)();
}

static void constructor_39678( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >((::edm::Association<std::vector<pat::PackedCandidate> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >((::edm::Association<std::vector<pat::PackedCandidate> >*)arg[0]);
}

static  void method_39679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->getInterface)();
}

static  void method_39680( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_39681( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_39682( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_39683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->dynamicTypeInfo)();
}

static  void method_39684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->isPresent)();
}

static  void method_39685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6794( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::Association<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > > -------------------------------
void __edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s__datamem_bld(&__edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s__funcmem_bld(&__edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s__db_funcmem);
void __edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >"), typeid(::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >), sizeof(::edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<edm::Association<pat::PackedCandidateCollection> >")
  .AddTypedef(type_7358, Reflex::Literal("edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >::value_type"))
  .AddTypedef(type_7358, Reflex::Literal("edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_39671, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3232), Reflex::Literal("Wrapper"), constructor_39672, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_39673, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70928), Reflex::Literal("Wrapper"), constructor_39678, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6794, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::Association<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > > -------------------
void __edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7358, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::Association<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > > -------------------
void __edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70927), Reflex::Literal("product"), method_39674, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70927), Reflex::Literal("operator->"), operator_39675, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_39676, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_39677, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70929), Reflex::Literal("getInterface"), method_39679, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_39680, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_39681, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_39682, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_39683, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_39684, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_39685, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion, edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion> > > -------------------------------
static void constructor_39734( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >();
}

static void constructor_39735( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)arg[0]);
}

static void destructor_39736(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >::~Wrapper)();
}
static  void method_39737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->product)();
}

static  void operator_39738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->operator->)();
}

static  void method_39739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->productTypeInfo)();
}

static  void method_39740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->typeInfo)();
}

static void constructor_39741( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >((::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >((::edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> >*)arg[0]);
}

static  void method_39742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->getInterface)();
}

static  void method_39743( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_39744( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_39745( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_39746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->dynamicTypeInfo)();
}

static  void method_39747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->isPresent)();
}

static  void method_39748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6797( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion, edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion> > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::ConversionRefVector>")
  .AddTypedef(type_6478, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >::value_type"))
  .AddTypedef(type_6478, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_39734, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3238), Reflex::Literal("Wrapper"), constructor_39735, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_39736, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70943), Reflex::Literal("Wrapper"), constructor_39741, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6797, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion, edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6478, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion, edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion, std::allocator<pat::Conversion> >, pat::Conversion> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70942), Reflex::Literal("product"), method_39737, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70942), Reflex::Literal("operator->"), operator_39738, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_39739, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_39740, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70944), Reflex::Literal("getInterface"), method_39742, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_39743, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_39744, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_39745, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_39746, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_39747, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_39748, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere, edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere> > > -------------------------------
static void constructor_39755( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >();
}

static void constructor_39756( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)arg[0]);
}

static void destructor_39757(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >::~Wrapper)();
}
static  void method_39758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->product)();
}

static  void operator_39759( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->operator->)();
}

static  void method_39760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->productTypeInfo)();
}

static  void method_39761( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->typeInfo)();
}

static void constructor_39762( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >((::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >((::edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> >*)arg[0]);
}

static  void method_39763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->getInterface)();
}

static  void method_39764( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_39765( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_39766( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_39767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->dynamicTypeInfo)();
}

static  void method_39768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->isPresent)();
}

static  void method_39769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6798( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere, edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere> > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::HemisphereRefVector>")
  .AddTypedef(type_6479, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >::value_type"))
  .AddTypedef(type_6479, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_39755, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3239), Reflex::Literal("Wrapper"), constructor_39756, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_39757, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70948), Reflex::Literal("Wrapper"), constructor_39762, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6798, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere, edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6479, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere, edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere, std::allocator<pat::Hemisphere> >, pat::Hemisphere> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70947), Reflex::Literal("product"), method_39758, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70947), Reflex::Literal("operator->"), operator_39759, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_39760, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_39761, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70949), Reflex::Literal("getInterface"), method_39763, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_39764, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_39765, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_39766, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_39767, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_39768, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_39769, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > > -------------------------------
static void constructor_39776( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >();
}

static void constructor_39777( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)arg[0]);
}

static void destructor_39778(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::~Wrapper)();
}
static  void method_39779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->product)();
}

static  void operator_39780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->operator->)();
}

static  void method_39781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->productTypeInfo)();
}

static  void method_39782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->typeInfo)();
}

static void constructor_39783( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >((::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >((::edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
}

static  void method_39784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->getInterface)();
}

static  void method_39785( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_39786( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_39787( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_39788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->dynamicTypeInfo)();
}

static  void method_39789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->isPresent)();
}

static  void method_39790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6799( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::GenericParticleRefVector>")
  .AddTypedef(type_6480, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::value_type"))
  .AddTypedef(type_6480, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_39776, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3240), Reflex::Literal("Wrapper"), constructor_39777, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_39778, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70953), Reflex::Literal("Wrapper"), constructor_39783, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6799, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6480, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70952), Reflex::Literal("product"), method_39779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70952), Reflex::Literal("operator->"), operator_39780, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_39781, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_39782, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70954), Reflex::Literal("getInterface"), method_39784, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_39785, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_39786, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_39787, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_39788, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_39789, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_39790, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > > -------------------------------
static void constructor_39797( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >();
}

static void constructor_39798( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)arg[0]);
}

static void destructor_39799(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::~Wrapper)();
}
static  void method_39800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->product)();
}

static  void operator_39801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->operator->)();
}

static  void method_39802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->productTypeInfo)();
}

static  void method_39803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->typeInfo)();
}

static void constructor_39804( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >((::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >((::edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
}

static  void method_39805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->getInterface)();
}

static  void method_39806( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_39807( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_39808( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_39809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->dynamicTypeInfo)();
}

static  void method_39810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->isPresent)();
}

static  void method_39811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6800( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::PFParticleRefVector>")
  .AddTypedef(type_6481, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::value_type"))
  .AddTypedef(type_6481, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_39797, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3241), Reflex::Literal("Wrapper"), constructor_39798, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_39799, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70958), Reflex::Literal("Wrapper"), constructor_39804, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6800, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6481, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70957), Reflex::Literal("product"), method_39800, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70957), Reflex::Literal("operator->"), operator_39801, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_39802, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_39803, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70959), Reflex::Literal("getInterface"), method_39805, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_39806, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_39807, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_39808, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_39809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_39810, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_39811, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------------------
static void constructor_39818( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >();
}

static void constructor_39819( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
}

static void destructor_39820(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::~Wrapper)();
}
static  void method_39821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->product)();
}

static  void operator_39822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->operator->)();
}

static  void method_39823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->productTypeInfo)();
}

static  void method_39824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->typeInfo)();
}

static void constructor_39825( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >((::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >((::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
}

static  void method_39826( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->getInterface)();
}

static  void method_39827( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_39828( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_39829( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_39830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->dynamicTypeInfo)();
}

static  void method_39831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->isPresent)();
}

static  void method_39832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6801( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::CompositeCandidateRefVector>")
  .AddTypedef(type_6482, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::value_type"))
  .AddTypedef(type_6482, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_39818, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3242), Reflex::Literal("Wrapper"), constructor_39819, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_39820, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70963), Reflex::Literal("Wrapper"), constructor_39825, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6801, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6482, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70962), Reflex::Literal("product"), method_39821, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70962), Reflex::Literal("operator->"), operator_39822, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_39823, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_39824, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70964), Reflex::Literal("getInterface"), method_39826, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_39827, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_39828, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_39829, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_39830, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_39831, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_39832, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle, edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > > -------------------------------
static void constructor_39839( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >();
}

static void constructor_39840( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)arg[0]);
}

static void destructor_39841(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::~Wrapper)();
}
static  void method_39842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->product)();
}

static  void operator_39843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->operator->)();
}

static  void method_39844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->productTypeInfo)();
}

static  void method_39845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->typeInfo)();
}

static void constructor_39846( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >((::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >((::edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
}

static  void method_39847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->getInterface)();
}

static  void method_39848( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_39849( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_39850( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_39851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->dynamicTypeInfo)();
}

static  void method_39852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->isPresent)();
}

static  void method_39853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6802( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle, edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::ParticleRefVector>")
  .AddTypedef(type_6483, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::value_type"))
  .AddTypedef(type_6483, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_39839, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3243), Reflex::Literal("Wrapper"), constructor_39840, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_39841, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70968), Reflex::Literal("Wrapper"), constructor_39846, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6802, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle, edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6483, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle, edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70967), Reflex::Literal("product"), method_39842, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70967), Reflex::Literal("operator->"), operator_39843, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_39844, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_39845, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70969), Reflex::Literal("getInterface"), method_39847, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_39848, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_39849, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_39850, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_39851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_39852, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_39853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET, edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > > -------------------------------
static void constructor_39860( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >();
}

static void constructor_39861( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)arg[0]);
}

static void destructor_39862(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::~Wrapper)();
}
static  void method_39863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->product)();
}

static  void operator_39864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->operator->)();
}

static  void method_39865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->productTypeInfo)();
}

static  void method_39866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->typeInfo)();
}

static void constructor_39867( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >((::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >((::edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
}

static  void method_39868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->getInterface)();
}

static  void method_39869( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_39870( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_39871( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_39872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->dynamicTypeInfo)();
}

static  void method_39873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->isPresent)();
}

static  void method_39874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6803( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET, edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::METRefVector>")
  .AddTypedef(type_6484, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::value_type"))
  .AddTypedef(type_6484, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_39860, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3244), Reflex::Literal("Wrapper"), constructor_39861, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_39862, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70973), Reflex::Literal("Wrapper"), constructor_39867, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6803, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET, edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6484, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET, edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70972), Reflex::Literal("product"), method_39863, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70972), Reflex::Literal("operator->"), operator_39864, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_39865, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_39866, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70974), Reflex::Literal("getInterface"), method_39868, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_39869, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_39870, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_39871, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_39872, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_39873, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_39874, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet, edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > > -------------------------------
static void constructor_39881( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >();
}

static void constructor_39882( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)arg[0]);
}

static void destructor_39883(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::~Wrapper)();
}
static  void method_39884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->product)();
}

static  void operator_39885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->operator->)();
}

static  void method_39886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->productTypeInfo)();
}

static  void method_39887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->typeInfo)();
}

static void constructor_39888( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >((::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >((::edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
}

static  void method_39889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->getInterface)();
}

static  void method_39890( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_39891( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_39892( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_39893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->dynamicTypeInfo)();
}

static  void method_39894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->isPresent)();
}

static  void method_39895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6804( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet, edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::JetRefVector>")
  .AddTypedef(type_6485, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::value_type"))
  .AddTypedef(type_6485, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_39881, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3245), Reflex::Literal("Wrapper"), constructor_39882, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_39883, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70978), Reflex::Literal("Wrapper"), constructor_39888, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6804, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet, edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6485, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet, edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70977), Reflex::Literal("product"), method_39884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70977), Reflex::Literal("operator->"), operator_39885, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_39886, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_39887, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70979), Reflex::Literal("getInterface"), method_39889, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_39890, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_39891, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_39892, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_39893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_39894, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_39895, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon, edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > > -------------------------------
static void constructor_39902( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >();
}

static void constructor_39903( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)arg[0]);
}

static void destructor_39904(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::~Wrapper)();
}
static  void method_39905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->product)();
}

static  void operator_39906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->operator->)();
}

static  void method_39907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_39908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_39909( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >((::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >((::edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
}

static  void method_39910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->getInterface)();
}

static  void method_39911( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_39912( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_39913( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_39914( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_39915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->isPresent)();
}

static  void method_39916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6805( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon, edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::PhotonRefVector>")
  .AddTypedef(type_6486, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::value_type"))
  .AddTypedef(type_6486, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_39902, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3246), Reflex::Literal("Wrapper"), constructor_39903, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_39904, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70983), Reflex::Literal("Wrapper"), constructor_39909, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6805, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon, edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6486, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon, edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70982), Reflex::Literal("product"), method_39905, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70982), Reflex::Literal("operator->"), operator_39906, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_39907, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_39908, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70984), Reflex::Literal("getInterface"), method_39910, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_39911, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_39912, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_39913, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_39914, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_39915, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_39916, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau, edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > > -------------------------------
static void constructor_39923( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >();
}

static void constructor_39924( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)arg[0]);
}

static void destructor_39925(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::~Wrapper)();
}
static  void method_39926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->product)();
}

static  void operator_39927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->operator->)();
}

static  void method_39928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_39929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_39930( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >((::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >((::edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
}

static  void method_39931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->getInterface)();
}

static  void method_39932( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_39933( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_39934( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_39935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_39936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->isPresent)();
}

static  void method_39937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6806( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau, edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::TauRefVector>")
  .AddTypedef(type_6487, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::value_type"))
  .AddTypedef(type_6487, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_39923, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3247), Reflex::Literal("Wrapper"), constructor_39924, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_39925, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70988), Reflex::Literal("Wrapper"), constructor_39930, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6806, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau, edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6487, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau, edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70987), Reflex::Literal("product"), method_39926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70987), Reflex::Literal("operator->"), operator_39927, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_39928, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_39929, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70989), Reflex::Literal("getInterface"), method_39931, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_39932, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_39933, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_39934, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_39935, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_39936, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_39937, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon, edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > > -------------------------------
static void constructor_39944( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >();
}

static void constructor_39945( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)arg[0]);
}

static void destructor_39946(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::~Wrapper)();
}
static  void method_39947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->product)();
}

static  void operator_39948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->operator->)();
}

static  void method_39949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->productTypeInfo)();
}

static  void method_39950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->typeInfo)();
}

static void constructor_39951( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >((::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >((::edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
}

static  void method_39952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->getInterface)();
}

static  void method_39953( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_39954( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_39955( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_39956( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->dynamicTypeInfo)();
}

static  void method_39957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->isPresent)();
}

static  void method_39958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6807( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon, edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::MuonRefVector>")
  .AddTypedef(type_6488, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::value_type"))
  .AddTypedef(type_6488, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_39944, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3248), Reflex::Literal("Wrapper"), constructor_39945, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_39946, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70993), Reflex::Literal("Wrapper"), constructor_39951, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6807, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon, edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6488, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon, edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70992), Reflex::Literal("product"), method_39947, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70992), Reflex::Literal("operator->"), operator_39948, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_39949, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_39950, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70994), Reflex::Literal("getInterface"), method_39952, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_39953, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_39954, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_39955, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_39956, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_39957, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_39958, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron, edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > > -------------------------------
static void constructor_39965( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >();
}

static void constructor_39966( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >(*(::std::auto_ptr<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)arg[0]);
}

static void destructor_39967(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::~Wrapper)();
}
static  void method_39968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->product)();
}

static  void operator_39969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->operator->)();
}

static  void method_39970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->productTypeInfo)();
}

static  void method_39971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->typeInfo)();
}

static void constructor_39972( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >((::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >((::edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
}

static  void method_39973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->getInterface)();
}

static  void method_39974( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_39975( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_39976( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_39977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->dynamicTypeInfo)();
}

static  void method_39978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->isPresent)();
}

static  void method_39979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6808( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron, edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<pat::ElectronRefVector>")
  .AddTypedef(type_6489, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::value_type"))
  .AddTypedef(type_6489, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_39965, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3249), Reflex::Literal("Wrapper"), constructor_39966, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_39967, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70998), Reflex::Literal("Wrapper"), constructor_39972, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6808, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron, edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1810, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6489, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron, edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70997), Reflex::Literal("product"), method_39968, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70997), Reflex::Literal("operator->"), operator_39969, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("productTypeInfo"), method_39970, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("typeInfo"), method_39971, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70999), Reflex::Literal("getInterface"), method_39973, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35118, type_35211, type_69482), Reflex::Literal("fillView"), method_39974, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_58, type_18241), Reflex::Literal("setPtr"), method_39975, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_35261, type_35275, type_35211), Reflex::Literal("fillPtrVector"), method_39976, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo"), method_39977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isPresent"), method_39978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35261), Reflex::Literal("dynamicTypeInfo_"), method_39979, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate>, std::allocator<edm::Ptr<reco::PFCandidate> > > > -------------------------------
static void constructor_40834( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >();
  else ::new(mem) ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >();
}

static void constructor_40835( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >((::std::vector<edm::Ptr<reco::PFCandidate> >*)arg[0]);
  else ::new(mem) ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >((::std::vector<edm::Ptr<reco::PFCandidate> >*)arg[0]);
}

static void constructor_40836( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >(*(const ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)arg[0]);
  else ::new(mem) ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >(*(const ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)arg[0]);
}

static  void operator_40837( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->operator=)(*(const ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)arg[0]);
  else   (((::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->operator=)(*(const ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)arg[0]);
}

static void destructor_40838(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >::~AtomicPtrCache)();
}
static  void operator_40839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->operator->)());
  else   (((const ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->operator->)();
}

static  void operator_40840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->operator*)();
  else   (((const ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->operator*)();
}

static  void method_40841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->load)());
  else   (((const ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->load)();
}

static  void method_40842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->isSet)());
  else   (((const ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->isSet)();
}

static  void operator_40843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->operator->)());
  else   (((::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->operator->)();
}

static  void operator_40844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->operator*)();
  else   (((::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->operator*)();
}

static  void method_40845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->load)());
  else   (((::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->load)();
}

static  void method_40846( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >*)o)->reset)();
}

static void method_newdel_7115( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate>, std::allocator<edm::Ptr<reco::PFCandidate> > > > -------------------------------
void __edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s__db_datamem(Reflex::Class*);
void __edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s__datamem_bld(&__edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s__funcmem_bld(&__edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s__db_funcmem);
void __edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >"), typeid(::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >), sizeof(::edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::AtomicPtrCache<std::vector<reco::PFCandidatePtr> >")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("AtomicPtrCache"), constructor_40834, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71760), Reflex::Literal("AtomicPtrCache"), constructor_40835, 0, "", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71761), Reflex::Literal("AtomicPtrCache"), constructor_40836, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~AtomicPtrCache"), destructor_40838, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7115, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s__funcmem_bld);
}

//------Delayed data member builder for class AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate>, std::allocator<edm::Ptr<reco::PFCandidate> > > > -------------------
void __edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_71760, Reflex::Literal("m_data"), OffsetOf(__shadow__::__edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s_, m_data), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate>, std::allocator<edm::Ptr<reco::PFCandidate> > > > -------------------
void __edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71762, type_71761), Reflex::Literal("operator="), operator_40837, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71763), Reflex::Literal("operator->"), operator_40839, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65193), Reflex::Literal("operator*"), operator_40840, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71763), Reflex::Literal("load"), method_40841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isSet"), method_40842, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71760), Reflex::Literal("operator->"), operator_40843, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65194), Reflex::Literal("operator*"), operator_40844, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71760), Reflex::Literal("load"), method_40845, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("reset"), method_40846, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class AtomicPtrCache<edm::RefVector<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track, edm::refhelper::FindUsingAdvance<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track> > > -------------------------------
static void constructor_40876( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >();
  else ::new(mem) ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >();
}

static void constructor_40877( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >((::edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >*)arg[0]);
  else ::new(mem) ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >((::edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >*)arg[0]);
}

static void constructor_40878( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >(*(const ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)arg[0]);
  else ::new(mem) ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >(*(const ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)arg[0]);
}

static  void operator_40879( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->operator=)(*(const ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)arg[0]);
  else   (((::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->operator=)(*(const ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)arg[0]);
}

static void destructor_40880(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >::~AtomicPtrCache)();
}
static  void operator_40881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->operator->)());
  else   (((const ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->operator->)();
}

static  void operator_40882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->operator*)();
  else   (((const ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->operator*)();
}

static  void method_40883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->load)());
  else   (((const ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->load)();
}

static  void method_40884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->isSet)());
  else   (((const ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->isSet)();
}

static  void operator_40885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->operator->)());
  else   (((::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->operator->)();
}

static  void operator_40886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->operator*)();
  else   (((::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->operator*)();
}

static  void method_40887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->load)());
  else   (((::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->load)();
}

static  void method_40888( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >*)o)->reset)();
}

static void method_newdel_7118( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class AtomicPtrCache<edm::RefVector<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track, edm::refhelper::FindUsingAdvance<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track> > > -------------------------------
void __edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s__db_datamem(Reflex::Class*);
void __edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s__datamem_bld(&__edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s__funcmem_bld(&__edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s__db_funcmem);
void __edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >"), typeid(::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >), sizeof(::edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::AtomicPtrCache<reco::TrackRefVector>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("AtomicPtrCache"), constructor_40876, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15184), Reflex::Literal("AtomicPtrCache"), constructor_40877, 0, "", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71773), Reflex::Literal("AtomicPtrCache"), constructor_40878, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~AtomicPtrCache"), destructor_40880, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7118, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s__funcmem_bld);
}

//------Delayed data member builder for class AtomicPtrCache<edm::RefVector<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track, edm::refhelper::FindUsingAdvance<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track> > > -------------------
void __edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_15184, Reflex::Literal("m_data"), OffsetOf(__shadow__::__edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s_, m_data), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class AtomicPtrCache<edm::RefVector<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track, edm::refhelper::FindUsingAdvance<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track> > > -------------------
void __edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71774, type_71773), Reflex::Literal("operator="), operator_40879, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24871), Reflex::Literal("operator->"), operator_40881, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24875), Reflex::Literal("operator*"), operator_40882, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24871), Reflex::Literal("load"), method_40883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isSet"), method_40884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15184), Reflex::Literal("operator->"), operator_40885, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24873), Reflex::Literal("operator*"), operator_40886, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15184), Reflex::Literal("load"), method_40887, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("reset"), method_40888, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class RefProd<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------------------
static  void operator_41056( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)arg[0]);
}

static void constructor_41057( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::PackedCandidate> >(*(const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::PackedCandidate> >(*(const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)arg[0]);
}

static void constructor_41058( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::PackedCandidate> >();
  else ::new(mem) ::edm::RefProd<std::vector<pat::PackedCandidate> >();
}

static void constructor_41059( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::PackedCandidate> >(*(const ::edm::Handle<std::vector<pat::PackedCandidate> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::PackedCandidate> >(*(const ::edm::Handle<std::vector<pat::PackedCandidate> >*)arg[0]);
}

static void constructor_41060( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::PackedCandidate> >(*(const ::edm::OrphanHandle<std::vector<pat::PackedCandidate> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::PackedCandidate> >(*(const ::edm::OrphanHandle<std::vector<pat::PackedCandidate> >*)arg[0]);
}

static void constructor_41061( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::PackedCandidate> >((const ::std::vector<pat::PackedCandidate>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::PackedCandidate> >((const ::std::vector<pat::PackedCandidate>*)arg[0]);
}

static void constructor_41062( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::PackedCandidate> >(*(const ::edm::TestHandle<std::vector<pat::PackedCandidate> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::PackedCandidate> >(*(const ::edm::TestHandle<std::vector<pat::PackedCandidate> >*)arg[0]);
}

static void constructor_41063( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::PackedCandidate> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::PackedCandidate> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_41064(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->::edm::RefProd<std::vector<pat::PackedCandidate> >::~RefProd)();
}
static  void operator_41065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->operator*)();
}

static  void operator_41066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->operator->)();
}

static  void method_41067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->get)();
}

static  void method_41068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->product)();
}

static  void method_41069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->refCore)();
}

static  void method_41070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->isNull)();
}

static  void method_41071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->isNonnull)();
}

static  void operator_41072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->operator!)();
}

static  void method_41073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->id)();
}

static  void method_41074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->productGetter)();
}

static  void method_41075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->hasCache)();
}

static  void method_41076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->hasProductCache)();
}

static  void method_41077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->isAvailable)();
}

static  void method_41078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->isTransient)();
}

static  void method_41079( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->swap)(*(::edm::RefProd<std::vector<pat::PackedCandidate> >*)arg[0]);
}

static  void method_41080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<pat::PackedCandidate> >*)o)->Class_Version)();
}

static void method_newdel_7221( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::PackedCandidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::PackedCandidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::PackedCandidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::PackedCandidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::PackedCandidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------------------
void __edm__RefProd_std__vector_pat__PackedCandidate_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_pat__PackedCandidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__PackedCandidate_s__datamem_bld(&__edm__RefProd_std__vector_pat__PackedCandidate_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__PackedCandidate_s__funcmem_bld(&__edm__RefProd_std__vector_pat__PackedCandidate_s__db_funcmem);
void __edm__RefProd_std__vector_pat__PackedCandidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::PackedCandidate> >"), typeid(::edm::RefProd<std::vector<pat::PackedCandidate> >), sizeof(::edm::RefProd<std::vector<pat::PackedCandidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<pat::PackedCandidate> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::RefProd<pat::PackedCandidateCollection>")
  .AddTypedef(type_3508, Reflex::Literal("edm::RefProd<std::vector<pat::PackedCandidate> >::product_type"))
  .AddTypedef(type_3508, Reflex::Literal("edm::RefProd<std::vector<pat::PackedCandidate> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71850, type_71851), Reflex::Literal("operator="), operator_41056, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71851), Reflex::Literal("RefProd"), constructor_41057, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_41058, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71852), Reflex::Literal("RefProd"), constructor_41059, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71776), Reflex::Literal("RefProd"), constructor_41060, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70704), Reflex::Literal("RefProd"), constructor_41061, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71712), Reflex::Literal("RefProd"), constructor_41062, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118, type_35207), Reflex::Literal("RefProd"), constructor_41063, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_41064, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7221, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_pat__PackedCandidate_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_pat__PackedCandidate_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------
void __edm__RefProd_std__vector_pat__PackedCandidate_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7198, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_pat__PackedCandidate_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<pat::PackedCandidate, std::allocator<pat::PackedCandidate> > > -------------------
void __edm__RefProd_std__vector_pat__PackedCandidate_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35501), Reflex::Literal("operator*"), operator_41065, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70704), Reflex::Literal("operator->"), operator_41066, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70704), Reflex::Literal("get"), method_41067, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70704), Reflex::Literal("product"), method_41068, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35224), Reflex::Literal("refCore"), method_41069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNull"), method_41070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isNonnull"), method_41071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("operator!"), operator_41072, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_41073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_41074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasCache"), method_41075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_41076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_41077, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isTransient"), method_41078, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_71850), Reflex::Literal("swap"), method_41079, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_41080, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------------------
static void constructor_71100( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
}

static void constructor_71101( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >();
  else ::new(mem) ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >();
}

static void constructor_71102( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
}

static void constructor_71103( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::ProductID*)arg[0]);
}

static void destructor_71104(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::~RefVectorHolder)();
}
static  void method_71105( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->swap)(*(::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
}

static  void operator_71106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->operator=)(*(const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
  else   (((::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->operator=)(*(const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
}

static  void method_71107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->empty)());
  else   (((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->empty)();
}

static  void method_71108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->size)());
  else   (((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->size)();
}

static  void method_71109( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->clear)();
}

static  void method_71110( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->push_back)((const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_71111( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void method_71112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->id)();
}

static  void method_71113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->productGetter)();
}

static  void method_71114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->clone)();
}

static  void method_71115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->cloneEmpty)());
  else   (((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->cloneEmpty)();
}

static  void method_71116( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->setRefs)(*(const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
}

static  void method_71117( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->reallyFillView)((const void*)arg[0],
    *(const ::edm::ProductID*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_71118( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->keyForIndex)(*(::size_t*)arg[0]));
  else   (((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->keyForIndex)(*(::size_t*)arg[0]);
}

static  void method_71119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->Class_Version)();
}

static  void method_71120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::RefVectorHolderBase::const_iterator)((((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->begin)());
  else   (((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->begin)();
}

static  void method_71121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::RefVectorHolderBase::const_iterator)((((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->end)());
  else   (((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->end)();
}

static  void method_71122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->product)();
}

static  void method_71123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->isAvailable)();
}

static void method_newdel_40424( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x199( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >,::edm::reftobase::RefVectorHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------------------
void __edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__datamem_bld(&__edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__funcmem_bld(&__edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_funcmem);
void __edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >"), typeid(::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >), sizeof(::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefVectorHolder<pat::CompositeCandidateRefVector>")
  .AddBase(type_7200, ::Reflex::BaseOffset< ::edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >, ::edm::reftobase::RefVectorHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_40973, Reflex::Literal("edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::const_iterator_imp"))
  .AddTypedef(type_40974, Reflex::Literal("edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::const_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79149), Reflex::Literal("RefVectorHolder"), constructor_71100, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVectorHolder"), constructor_71101, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70732), Reflex::Literal("RefVectorHolder"), constructor_71102, 0, "refs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("RefVectorHolder"), constructor_71103, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVectorHolder"), destructor_71104, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40424, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x199, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------
void __edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6482, Reflex::Literal("refs_"), OffsetOf(__shadow__::__edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_, refs_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------
void __edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79150), Reflex::Literal("swap"), method_71105, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79150, type_79149), Reflex::Literal("operator="), operator_71106, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_71107, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("size"), method_71108, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_71109, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_71823), Reflex::Literal("push_back"), method_71110, 0, "h", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_2393), Reflex::Literal("reserve"), method_71111, 0, "n", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71112, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71113, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79151), Reflex::Literal("clone"), method_71114, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79151), Reflex::Literal("cloneEmpty"), method_71115, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70732), Reflex::Literal("setRefs"), method_71116, 0, "refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_5416, type_35118, type_35211), Reflex::Literal("reallyFillView"), method_71117, 0, "iProd;iId;oPointers", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393, type_2393), Reflex::Literal("keyForIndex"), method_71118, 0, "idx", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71119, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40974), Reflex::Literal("begin"), method_71120, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40974), Reflex::Literal("end"), method_71121, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71122, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71123, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > > -------------------------------
static  void operator_71147( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)arg[0]);
}

static void constructor_71148( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)arg[0]);
}

static void constructor_71149( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >();
}

static void constructor_71150( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >(*(const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >(*(const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
}

static  void method_71151( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)arg[0]);
}

static void destructor_71152(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::~RefHolder)();
}
static  void method_71153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->clone)();
}

static  void method_71154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->id)();
}

static  void method_71155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->key)();
}

static  void method_71156( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_71157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->getRef)();
}

static  void method_71159( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
}

static  void method_71160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->makeVectorHolder)();
}

static  void method_71161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->productGetter)();
}

static  void method_71162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->hasProductCache)();
}

static  void method_71163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->product)();
}

static  void method_71164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->isAvailable)();
}

static  void method_71165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->Class_Version)();
}

static void method_newdel_40426( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x201( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<pat::GenericParticleRef>")
  .AddBase(type_19497, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79154, type_79155), Reflex::Literal("operator="), operator_71147, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79155), Reflex::Literal("RefHolder"), constructor_71148, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_71149, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70721), Reflex::Literal("RefHolder"), constructor_71150, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_71152, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40426, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x201, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7371, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79154), Reflex::Literal("swap"), method_71151, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37173), Reflex::Literal("clone"), method_71153, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71154, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71155, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_76012), Reflex::Literal("isEqualTo"), method_71156, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71157, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70721), Reflex::Literal("getRef"), method_71158, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70721), Reflex::Literal("setRef"), method_71159, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorHolder"), method_71160, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71161, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71162, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71163, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71164, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71165, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > > -------------------------------
static  void operator_71168( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)arg[0]);
}

static void constructor_71169( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)arg[0]);
}

static void constructor_71170( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >();
}

static void constructor_71171( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >(*(const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >(*(const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
}

static  void method_71172( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)arg[0]);
}

static void destructor_71173(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::~RefHolder)();
}
static  void method_71174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->clone)();
}

static  void method_71175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->id)();
}

static  void method_71176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->key)();
}

static  void method_71177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_71178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->getRef)();
}

static  void method_71180( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
}

static  void method_71181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->makeVectorHolder)();
}

static  void method_71182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->productGetter)();
}

static  void method_71183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->hasProductCache)();
}

static  void method_71184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->product)();
}

static  void method_71185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->isAvailable)();
}

static  void method_71186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->Class_Version)();
}

static void method_newdel_40427( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x203( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<pat::PFParticleRef>")
  .AddBase(type_19497, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79156, type_79157), Reflex::Literal("operator="), operator_71168, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79157), Reflex::Literal("RefHolder"), constructor_71169, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_71170, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70727), Reflex::Literal("RefHolder"), constructor_71171, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_71173, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40427, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x203, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7372, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79156), Reflex::Literal("swap"), method_71172, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37173), Reflex::Literal("clone"), method_71174, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71175, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71176, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_76012), Reflex::Literal("isEqualTo"), method_71177, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71178, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70727), Reflex::Literal("getRef"), method_71179, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70727), Reflex::Literal("setRef"), method_71180, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorHolder"), method_71181, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71182, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71183, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71184, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71185, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71186, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------------------
static  void operator_71189( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
}

static void constructor_71190( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
}

static void constructor_71191( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >();
}

static void constructor_71192( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
}

static  void method_71193( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
}

static void destructor_71194(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::~RefHolder)();
}
static  void method_71195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->clone)();
}

static  void method_71196( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->id)();
}

static  void method_71197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->key)();
}

static  void method_71198( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_71199( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->getRef)();
}

static  void method_71201( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
}

static  void method_71202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->makeVectorHolder)();
}

static  void method_71203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->productGetter)();
}

static  void method_71204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->hasProductCache)();
}

static  void method_71205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->product)();
}

static  void method_71206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->isAvailable)();
}

static  void method_71207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->Class_Version)();
}

static void method_newdel_40428( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x205( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<pat::CompositeCandidateRef>")
  .AddBase(type_19497, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79158, type_79159), Reflex::Literal("operator="), operator_71189, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79159), Reflex::Literal("RefHolder"), constructor_71190, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_71191, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70733), Reflex::Literal("RefHolder"), constructor_71192, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_71194, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40428, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x205, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7373, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79158), Reflex::Literal("swap"), method_71193, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37173), Reflex::Literal("clone"), method_71195, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71196, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71197, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_76012), Reflex::Literal("isEqualTo"), method_71198, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71199, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70733), Reflex::Literal("getRef"), method_71200, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70733), Reflex::Literal("setRef"), method_71201, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorHolder"), method_71202, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71203, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71204, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71205, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71206, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71207, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle, edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > > -------------------------------
static  void operator_71210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)arg[0]);
}

static void constructor_71211( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)arg[0]);
}

static void constructor_71212( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >();
}

static void constructor_71213( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >(*(const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >(*(const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
}

static  void method_71214( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)arg[0]);
}

static void destructor_71215(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::~RefHolder)();
}
static  void method_71216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->clone)();
}

static  void method_71217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->id)();
}

static  void method_71218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->key)();
}

static  void method_71219( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_71220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->getRef)();
}

static  void method_71222( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
}

static  void method_71223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->makeVectorHolder)();
}

static  void method_71224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->productGetter)();
}

static  void method_71225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->hasProductCache)();
}

static  void method_71226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->product)();
}

static  void method_71227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->isAvailable)();
}

static  void method_71228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->Class_Version)();
}

static void method_newdel_40429( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x207( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle, edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<pat::ParticleRef>")
  .AddBase(type_19497, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79160, type_79161), Reflex::Literal("operator="), operator_71210, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79161), Reflex::Literal("RefHolder"), constructor_71211, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_71212, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70739), Reflex::Literal("RefHolder"), constructor_71213, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_71215, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40429, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x207, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle, edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7374, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle, edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79160), Reflex::Literal("swap"), method_71214, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37173), Reflex::Literal("clone"), method_71216, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71217, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71218, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_76012), Reflex::Literal("isEqualTo"), method_71219, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71220, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70739), Reflex::Literal("getRef"), method_71221, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70739), Reflex::Literal("setRef"), method_71222, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorHolder"), method_71223, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71224, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71225, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71226, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71227, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71228, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET, edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > > -------------------------------
static  void operator_71231( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)arg[0]);
}

static void constructor_71232( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)arg[0]);
}

static void constructor_71233( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >();
}

static void constructor_71234( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >(*(const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >(*(const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
}

static  void method_71235( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)arg[0]);
}

static void destructor_71236(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::~RefHolder)();
}
static  void method_71237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->clone)();
}

static  void method_71238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->id)();
}

static  void method_71239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->key)();
}

static  void method_71240( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_71241( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->getRef)();
}

static  void method_71243( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
}

static  void method_71244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->makeVectorHolder)();
}

static  void method_71245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->productGetter)();
}

static  void method_71246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->hasProductCache)();
}

static  void method_71247( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->product)();
}

static  void method_71248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->isAvailable)();
}

static  void method_71249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->Class_Version)();
}

static void method_newdel_40430( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x209( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET, edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<pat::METRef>")
  .AddBase(type_19497, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79162, type_79163), Reflex::Literal("operator="), operator_71231, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79163), Reflex::Literal("RefHolder"), constructor_71232, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_71233, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70745), Reflex::Literal("RefHolder"), constructor_71234, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_71236, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40430, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x209, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET, edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7375, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET, edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79162), Reflex::Literal("swap"), method_71235, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37173), Reflex::Literal("clone"), method_71237, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71238, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71239, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_76012), Reflex::Literal("isEqualTo"), method_71240, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71241, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70745), Reflex::Literal("getRef"), method_71242, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70745), Reflex::Literal("setRef"), method_71243, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorHolder"), method_71244, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71245, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71246, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71247, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71248, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71249, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet, edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > > -------------------------------
static  void operator_71252( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)arg[0]);
}

static void constructor_71253( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)arg[0]);
}

static void constructor_71254( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >();
}

static void constructor_71255( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >(*(const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >(*(const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
}

static  void method_71256( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)arg[0]);
}

static void destructor_71257(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::~RefHolder)();
}
static  void method_71258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->clone)();
}

static  void method_71259( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->id)();
}

static  void method_71260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->key)();
}

static  void method_71261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_71262( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->getRef)();
}

static  void method_71264( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
}

static  void method_71265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->makeVectorHolder)();
}

static  void method_71266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->productGetter)();
}

static  void method_71267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->hasProductCache)();
}

static  void method_71268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->product)();
}

static  void method_71269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->isAvailable)();
}

static  void method_71270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->Class_Version)();
}

static void method_newdel_40431( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x211( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet, edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<pat::JetRef>")
  .AddBase(type_19497, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79164, type_79165), Reflex::Literal("operator="), operator_71252, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79165), Reflex::Literal("RefHolder"), constructor_71253, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_71254, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70751), Reflex::Literal("RefHolder"), constructor_71255, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_71257, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40431, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x211, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet, edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7376, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet, edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79164), Reflex::Literal("swap"), method_71256, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37173), Reflex::Literal("clone"), method_71258, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71259, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71260, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_76012), Reflex::Literal("isEqualTo"), method_71261, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71262, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70751), Reflex::Literal("getRef"), method_71263, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70751), Reflex::Literal("setRef"), method_71264, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorHolder"), method_71265, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71266, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71267, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71268, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71269, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71270, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon, edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > > -------------------------------
static  void operator_71273( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)arg[0]);
}

static void constructor_71274( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)arg[0]);
}

static void constructor_71275( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >();
}

static void constructor_71276( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >(*(const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >(*(const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
}

static  void method_71277( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)arg[0]);
}

static void destructor_71278(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::~RefHolder)();
}
static  void method_71279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->clone)();
}

static  void method_71280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->id)();
}

static  void method_71281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->key)();
}

static  void method_71282( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_71283( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71284( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->getRef)();
}

static  void method_71285( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
}

static  void method_71286( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->makeVectorHolder)();
}

static  void method_71287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->productGetter)();
}

static  void method_71288( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->hasProductCache)();
}

static  void method_71289( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->product)();
}

static  void method_71290( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->isAvailable)();
}

static  void method_71291( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->Class_Version)();
}

static void method_newdel_40432( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x213( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon, edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<pat::PhotonRef>")
  .AddBase(type_19497, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79166, type_79167), Reflex::Literal("operator="), operator_71273, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79167), Reflex::Literal("RefHolder"), constructor_71274, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_71275, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70757), Reflex::Literal("RefHolder"), constructor_71276, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_71278, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40432, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x213, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon, edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7377, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon, edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79166), Reflex::Literal("swap"), method_71277, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37173), Reflex::Literal("clone"), method_71279, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71280, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71281, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_76012), Reflex::Literal("isEqualTo"), method_71282, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71283, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70757), Reflex::Literal("getRef"), method_71284, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70757), Reflex::Literal("setRef"), method_71285, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorHolder"), method_71286, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71287, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71288, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71289, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71290, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71291, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau, edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > > -------------------------------
static  void operator_71294( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)arg[0]);
}

static void constructor_71295( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)arg[0]);
}

static void constructor_71296( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >();
}

static void constructor_71297( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >(*(const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >(*(const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
}

static  void method_71298( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)arg[0]);
}

static void destructor_71299(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::~RefHolder)();
}
static  void method_71300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->clone)();
}

static  void method_71301( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->id)();
}

static  void method_71302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->key)();
}

static  void method_71303( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_71304( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->getRef)();
}

static  void method_71306( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
}

static  void method_71307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->makeVectorHolder)();
}

static  void method_71308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->productGetter)();
}

static  void method_71309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->hasProductCache)();
}

static  void method_71310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->product)();
}

static  void method_71311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->isAvailable)();
}

static  void method_71312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->Class_Version)();
}

static void method_newdel_40433( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x215( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau, edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<pat::TauRef>")
  .AddBase(type_19497, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79168, type_79169), Reflex::Literal("operator="), operator_71294, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79169), Reflex::Literal("RefHolder"), constructor_71295, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_71296, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70763), Reflex::Literal("RefHolder"), constructor_71297, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_71299, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40433, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x215, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau, edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7378, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau, edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79168), Reflex::Literal("swap"), method_71298, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37173), Reflex::Literal("clone"), method_71300, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71301, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71302, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_76012), Reflex::Literal("isEqualTo"), method_71303, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71304, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70763), Reflex::Literal("getRef"), method_71305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70763), Reflex::Literal("setRef"), method_71306, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorHolder"), method_71307, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71308, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71309, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71310, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71311, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71312, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon, edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > > -------------------------------
static  void operator_71315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)arg[0]);
}

static void constructor_71316( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)arg[0]);
}

static void constructor_71317( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >();
}

static void constructor_71318( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >(*(const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >(*(const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
}

static  void method_71319( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)arg[0]);
}

static void destructor_71320(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::~RefHolder)();
}
static  void method_71321( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->clone)();
}

static  void method_71322( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->id)();
}

static  void method_71323( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->key)();
}

static  void method_71324( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_71325( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->getRef)();
}

static  void method_71327( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
}

static  void method_71328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->makeVectorHolder)();
}

static  void method_71329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->productGetter)();
}

static  void method_71330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->hasProductCache)();
}

static  void method_71331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->product)();
}

static  void method_71332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->isAvailable)();
}

static  void method_71333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->Class_Version)();
}

static void method_newdel_40434( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x217( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon, edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<pat::MuonRef>")
  .AddBase(type_19497, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79170, type_79171), Reflex::Literal("operator="), operator_71315, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79171), Reflex::Literal("RefHolder"), constructor_71316, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_71317, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70769), Reflex::Literal("RefHolder"), constructor_71318, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_71320, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40434, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x217, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon, edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7379, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon, edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79170), Reflex::Literal("swap"), method_71319, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37173), Reflex::Literal("clone"), method_71321, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71322, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71323, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_76012), Reflex::Literal("isEqualTo"), method_71324, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71325, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70769), Reflex::Literal("getRef"), method_71326, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70769), Reflex::Literal("setRef"), method_71327, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorHolder"), method_71328, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71329, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71330, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71331, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71332, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71333, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron, edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > > -------------------------------
static  void operator_71336( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)arg[0]);
}

static void constructor_71337( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)arg[0]);
}

static void constructor_71338( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >();
}

static void constructor_71339( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >(*(const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >(*(const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
}

static  void method_71340( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)arg[0]);
}

static void destructor_71341(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::~RefHolder)();
}
static  void method_71342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->clone)();
}

static  void method_71343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->id)();
}

static  void method_71344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->key)();
}

static  void method_71345( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_71346( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->getRef)();
}

static  void method_71348( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
}

static  void method_71349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->makeVectorHolder)();
}

static  void method_71350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->productGetter)();
}

static  void method_71351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->hasProductCache)();
}

static  void method_71352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->product)();
}

static  void method_71353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->isAvailable)();
}

static  void method_71354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->Class_Version)();
}

static void method_newdel_40435( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x219( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron, edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<pat::ElectronRef>")
  .AddBase(type_19497, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79172, type_79173), Reflex::Literal("operator="), operator_71336, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79173), Reflex::Literal("RefHolder"), constructor_71337, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_71338, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70775), Reflex::Literal("RefHolder"), constructor_71339, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_71341, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40435, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x219, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron, edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7380, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron, edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79172), Reflex::Literal("swap"), method_71340, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37173), Reflex::Literal("clone"), method_71342, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71343, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71344, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_76012), Reflex::Literal("isEqualTo"), method_71345, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71346, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70775), Reflex::Literal("getRef"), method_71347, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_70775), Reflex::Literal("setRef"), method_71348, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorHolder"), method_71349, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71350, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71351, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71352, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71353, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71354, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------------------
static void constructor_71394( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >();
  else ::new(mem) ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >();
}

static void constructor_71395( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
}

static void constructor_71396( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
}

static void constructor_71397( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::ProductID*)arg[0]);
}

static void destructor_71398(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::~VectorHolder)();
}
static  void method_71399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->clone)());
  else   (((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->clone)();
}

static  void method_71400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->cloneEmpty)());
  else   (((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->cloneEmpty)();
}

static  void method_71401( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefToBase<reco::Candidate>)((((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->at)(*(::size_t*)arg[0]));
  else   (((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_71402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->empty)());
  else   (((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->empty)();
}

static  void method_71403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->size)());
  else   (((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->size)();
}

static  void method_71404( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->clear)();
}

static  void method_71405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->id)());
  else   (((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->id)();
}

static  void method_71406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->productGetter)();
}

static  void method_71407( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->swap)(*(::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
}

static  void operator_71408( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->operator=)(*(const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
  else   (((::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->operator=)(*(const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
}

static  void method_71409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<reco::Candidate>::const_iterator)((((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->begin)());
  else   (((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->begin)();
}

static  void method_71410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<reco::Candidate>::const_iterator)((((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->end)());
  else   (((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->end)();
}

static  void method_71411( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->push_back)((const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_71412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->vectorHolder)());
  else   (((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->vectorHolder)();
}

static  void method_71413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->product)());
  else   (((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->product)();
}

static  void method_71414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->isAvailable)();
}

static  void method_71415( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->Class_Version)();
}

static void method_newdel_40439( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x221( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >,::edm::reftobase::BaseVectorHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------------------
void __edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__datamem_bld(&__edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__funcmem_bld(&__edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_funcmem);
void __edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >"), typeid(::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >), sizeof(::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::VectorHolder<reco::Candidate, pat::CompositeCandidateRefVector>")
  .AddBase(type_40438, ::Reflex::BaseOffset< ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >, ::edm::reftobase::BaseVectorHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_40438, Reflex::Literal("edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::base_type"))
  .AddTypedef(type_2393, Reflex::Literal("edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::size_type"))
  .AddTypedef(type_9075, Reflex::Literal("edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::element_type"))
  .AddTypedef(type_7298, Reflex::Literal("edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::base_ref_type"))
  .AddTypedef(type_71364, Reflex::Literal("edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::const_iterator"))
  .AddTypedef(type_6482, Reflex::Literal("edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::ref_vector_type"))
  .AddTypedef(type_71363, Reflex::Literal("edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::const_iterator_imp"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("VectorHolder"), constructor_71394, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79180), Reflex::Literal("VectorHolder"), constructor_71395, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70732), Reflex::Literal("VectorHolder"), constructor_71396, 0, "iRefVector", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35118), Reflex::Literal("VectorHolder"), constructor_71397, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~VectorHolder"), destructor_71398, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40439, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x221, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__funcmem_bld);
}

//------Delayed data member builder for class VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------
void __edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6482, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------
void __edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79178), Reflex::Literal("clone"), method_71399, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79178), Reflex::Literal("cloneEmpty"), method_71400, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7298c, type_2393), Reflex::Literal("at"), method_71401, 0, "idx", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("empty"), method_71402, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("size"), method_71403, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("clear"), method_71404, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71405, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71406, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79181), Reflex::Literal("swap"), method_71407, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79181, type_79180), Reflex::Literal("operator="), operator_71408, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71364), Reflex::Literal("begin"), method_71409, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71364), Reflex::Literal("end"), method_71410, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79179), Reflex::Literal("push_back"), method_71411, 0, "r", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("vectorHolder"), method_71412, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71413, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71414, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71415, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > > -------------------------------
static void constructor_71449( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >();
}

static void constructor_71450( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)arg[0]);
}

static void constructor_71451( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >(*(const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >(*(const ::edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> >*)arg[0]);
}

static  void operator_71452( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)arg[0]);
}

static  void method_71453( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)arg[0]);
}

static void destructor_71454(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::~Holder)();
}
static  void method_71455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->clone)();
}

static  void method_71456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->getPtr)();
}

static  void method_71457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->id)();
}

static  void method_71458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->key)();
}

static  void method_71459( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_71460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->getRef)();
}

static  void method_71461( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->holder)();
}

static  void method_71463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->makeVectorHolder)();
}

static  void method_71464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->makeVectorBaseHolder)();
}

static  void method_71465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->productGetter)();
}

static  void method_71466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->hasProductCache)();
}

static  void method_71467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->product)();
}

static  void method_71468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->isAvailable)();
}

static  void method_71469( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >*)o)->Class_Version)();
}

static void method_newdel_40443( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x223( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Candidate, pat::GenericParticleRef>")
  .AddBase(type_40410, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_71449, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79188), Reflex::Literal("Holder"), constructor_71450, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70721), Reflex::Literal("Holder"), constructor_71451, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_71454, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40443, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x223, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7371, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle, std::allocator<pat::GenericParticle> >, pat::GenericParticle> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79189, type_79188), Reflex::Literal("operator="), operator_71452, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79189), Reflex::Literal("swap"), method_71453, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71862), Reflex::Literal("clone"), method_71455, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("getPtr"), method_71456, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71457, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71458, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_79148), Reflex::Literal("isEqualTo"), method_71459, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70721), Reflex::Literal("getRef"), method_71460, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71461, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3235), Reflex::Literal("holder"), method_71462, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3234), Reflex::Literal("makeVectorHolder"), method_71463, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorBaseHolder"), method_71464, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71465, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71466, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71467, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71468, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71469, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > > -------------------------------
static void constructor_71471( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >();
}

static void constructor_71472( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)arg[0]);
}

static void constructor_71473( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >(*(const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >(*(const ::edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> >*)arg[0]);
}

static  void operator_71474( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)arg[0]);
}

static  void method_71475( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)arg[0]);
}

static void destructor_71476(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::~Holder)();
}
static  void method_71477( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->clone)();
}

static  void method_71478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->getPtr)();
}

static  void method_71479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->id)();
}

static  void method_71480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->key)();
}

static  void method_71481( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_71482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->getRef)();
}

static  void method_71483( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71484( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->holder)();
}

static  void method_71485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->makeVectorHolder)();
}

static  void method_71486( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->makeVectorBaseHolder)();
}

static  void method_71487( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->productGetter)();
}

static  void method_71488( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->hasProductCache)();
}

static  void method_71489( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->product)();
}

static  void method_71490( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->isAvailable)();
}

static  void method_71491( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >*)o)->Class_Version)();
}

static void method_newdel_40444( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x225( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Candidate, pat::PFParticleRef>")
  .AddBase(type_40410, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_71471, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79190), Reflex::Literal("Holder"), constructor_71472, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70727), Reflex::Literal("Holder"), constructor_71473, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_71476, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40444, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x225, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7372, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle, edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle, std::allocator<pat::PFParticle> >, pat::PFParticle> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79191, type_79190), Reflex::Literal("operator="), operator_71474, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79191), Reflex::Literal("swap"), method_71475, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71862), Reflex::Literal("clone"), method_71477, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("getPtr"), method_71478, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71479, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71480, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_79148), Reflex::Literal("isEqualTo"), method_71481, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70727), Reflex::Literal("getRef"), method_71482, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71483, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3235), Reflex::Literal("holder"), method_71484, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3234), Reflex::Literal("makeVectorHolder"), method_71485, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorBaseHolder"), method_71486, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71487, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71488, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71489, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71490, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71491, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------------------
static void constructor_71493( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >();
}

static void constructor_71494( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
}

static void constructor_71495( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >(*(const ::edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)arg[0]);
}

static  void operator_71496( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
}

static  void method_71497( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)arg[0]);
}

static void destructor_71498(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::~Holder)();
}
static  void method_71499( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->clone)();
}

static  void method_71500( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->getPtr)();
}

static  void method_71501( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->id)();
}

static  void method_71502( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->key)();
}

static  void method_71503( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_71504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->getRef)();
}

static  void method_71505( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->holder)();
}

static  void method_71507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->makeVectorHolder)();
}

static  void method_71508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->makeVectorBaseHolder)();
}

static  void method_71509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->productGetter)();
}

static  void method_71510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->hasProductCache)();
}

static  void method_71511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->product)();
}

static  void method_71512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->isAvailable)();
}

static  void method_71513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)o)->Class_Version)();
}

static void method_newdel_40445( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x227( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Candidate, pat::CompositeCandidateRef>")
  .AddBase(type_40410, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_71493, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79192), Reflex::Literal("Holder"), constructor_71494, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70733), Reflex::Literal("Holder"), constructor_71495, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_71498, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40445, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x227, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7373, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate, edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate, std::allocator<pat::CompositeCandidate> >, pat::CompositeCandidate> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79193, type_79192), Reflex::Literal("operator="), operator_71496, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79193), Reflex::Literal("swap"), method_71497, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71862), Reflex::Literal("clone"), method_71499, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("getPtr"), method_71500, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71501, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71502, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_79148), Reflex::Literal("isEqualTo"), method_71503, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70733), Reflex::Literal("getRef"), method_71504, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71505, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3235), Reflex::Literal("holder"), method_71506, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3234), Reflex::Literal("makeVectorHolder"), method_71507, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorBaseHolder"), method_71508, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71509, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71510, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71511, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71512, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71513, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle, edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > > -------------------------------
static void constructor_71515( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >();
}

static void constructor_71516( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)arg[0]);
}

static void constructor_71517( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >(*(const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >(*(const ::edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> >*)arg[0]);
}

static  void operator_71518( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)arg[0]);
}

static  void method_71519( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)arg[0]);
}

static void destructor_71520(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::~Holder)();
}
static  void method_71521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->clone)();
}

static  void method_71522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->getPtr)();
}

static  void method_71523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->id)();
}

static  void method_71524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->key)();
}

static  void method_71525( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_71526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->getRef)();
}

static  void method_71527( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->holder)();
}

static  void method_71529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->makeVectorHolder)();
}

static  void method_71530( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->makeVectorBaseHolder)();
}

static  void method_71531( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->productGetter)();
}

static  void method_71532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->hasProductCache)();
}

static  void method_71533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->product)();
}

static  void method_71534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->isAvailable)();
}

static  void method_71535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >*)o)->Class_Version)();
}

static void method_newdel_40446( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x229( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle, edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Candidate, pat::ParticleRef>")
  .AddBase(type_40410, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_71515, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79194), Reflex::Literal("Holder"), constructor_71516, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70739), Reflex::Literal("Holder"), constructor_71517, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_71520, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40446, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x229, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle, edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7374, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle, edm::refhelper::FindUsingAdvance<std::vector<pat::Particle, std::allocator<pat::Particle> >, pat::Particle> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79195, type_79194), Reflex::Literal("operator="), operator_71518, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79195), Reflex::Literal("swap"), method_71519, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71862), Reflex::Literal("clone"), method_71521, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("getPtr"), method_71522, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71523, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71524, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_79148), Reflex::Literal("isEqualTo"), method_71525, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70739), Reflex::Literal("getRef"), method_71526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71527, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3235), Reflex::Literal("holder"), method_71528, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3234), Reflex::Literal("makeVectorHolder"), method_71529, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorBaseHolder"), method_71530, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71531, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71532, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71533, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71534, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71535, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET, edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > > -------------------------------
static void constructor_71537( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >();
}

static void constructor_71538( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)arg[0]);
}

static void constructor_71539( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >(*(const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >(*(const ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >*)arg[0]);
}

static  void operator_71540( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)arg[0]);
}

static  void method_71541( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)arg[0]);
}

static void destructor_71542(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::~Holder)();
}
static  void method_71543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->clone)();
}

static  void method_71544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->getPtr)();
}

static  void method_71545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->id)();
}

static  void method_71546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->key)();
}

static  void method_71547( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_71548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->getRef)();
}

static  void method_71549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->holder)();
}

static  void method_71551( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->makeVectorHolder)();
}

static  void method_71552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->makeVectorBaseHolder)();
}

static  void method_71553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->productGetter)();
}

static  void method_71554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->hasProductCache)();
}

static  void method_71555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->product)();
}

static  void method_71556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->isAvailable)();
}

static  void method_71557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >*)o)->Class_Version)();
}

static void method_newdel_40447( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x231( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET, edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Candidate, pat::METRef>")
  .AddBase(type_40410, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_71537, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79196), Reflex::Literal("Holder"), constructor_71538, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70745), Reflex::Literal("Holder"), constructor_71539, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_71542, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40447, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x231, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET, edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7375, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET, edm::refhelper::FindUsingAdvance<std::vector<pat::MET, std::allocator<pat::MET> >, pat::MET> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79197, type_79196), Reflex::Literal("operator="), operator_71540, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79197), Reflex::Literal("swap"), method_71541, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71862), Reflex::Literal("clone"), method_71543, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("getPtr"), method_71544, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71545, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71546, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_79148), Reflex::Literal("isEqualTo"), method_71547, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70745), Reflex::Literal("getRef"), method_71548, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71549, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3235), Reflex::Literal("holder"), method_71550, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3234), Reflex::Literal("makeVectorHolder"), method_71551, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorBaseHolder"), method_71552, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71553, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71554, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71555, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71556, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71557, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet, edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > > -------------------------------
static void constructor_71559( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >();
}

static void constructor_71560( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)arg[0]);
}

static void constructor_71561( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >(*(const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >(*(const ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >*)arg[0]);
}

static  void operator_71562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)arg[0]);
}

static  void method_71563( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)arg[0]);
}

static void destructor_71564(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::~Holder)();
}
static  void method_71565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->clone)();
}

static  void method_71566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->getPtr)();
}

static  void method_71567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->id)();
}

static  void method_71568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->key)();
}

static  void method_71569( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_71570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->getRef)();
}

static  void method_71571( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->holder)();
}

static  void method_71573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->makeVectorHolder)();
}

static  void method_71574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->makeVectorBaseHolder)();
}

static  void method_71575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->productGetter)();
}

static  void method_71576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->hasProductCache)();
}

static  void method_71577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->product)();
}

static  void method_71578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->isAvailable)();
}

static  void method_71579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >*)o)->Class_Version)();
}

static void method_newdel_40448( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x233( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet, edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Candidate, pat::JetRef>")
  .AddBase(type_40410, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_71559, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79198), Reflex::Literal("Holder"), constructor_71560, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70751), Reflex::Literal("Holder"), constructor_71561, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_71564, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40448, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x233, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet, edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7376, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet, edm::refhelper::FindUsingAdvance<std::vector<pat::Jet, std::allocator<pat::Jet> >, pat::Jet> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79199, type_79198), Reflex::Literal("operator="), operator_71562, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79199), Reflex::Literal("swap"), method_71563, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71862), Reflex::Literal("clone"), method_71565, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("getPtr"), method_71566, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71567, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71568, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_79148), Reflex::Literal("isEqualTo"), method_71569, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70751), Reflex::Literal("getRef"), method_71570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71571, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3235), Reflex::Literal("holder"), method_71572, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3234), Reflex::Literal("makeVectorHolder"), method_71573, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorBaseHolder"), method_71574, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71575, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71576, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71577, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71578, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71579, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon, edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > > -------------------------------
static void constructor_71581( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >();
}

static void constructor_71582( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)arg[0]);
}

static void constructor_71583( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >(*(const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >(*(const ::edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> >*)arg[0]);
}

static  void operator_71584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)arg[0]);
}

static  void method_71585( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)arg[0]);
}

static void destructor_71586(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::~Holder)();
}
static  void method_71587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->clone)();
}

static  void method_71588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->getPtr)();
}

static  void method_71589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->id)();
}

static  void method_71590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->key)();
}

static  void method_71591( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_71592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->getRef)();
}

static  void method_71593( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->holder)();
}

static  void method_71595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->makeVectorHolder)();
}

static  void method_71596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->makeVectorBaseHolder)();
}

static  void method_71597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->productGetter)();
}

static  void method_71598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->hasProductCache)();
}

static  void method_71599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->product)();
}

static  void method_71600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->isAvailable)();
}

static  void method_71601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >*)o)->Class_Version)();
}

static void method_newdel_40449( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x235( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon, edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Candidate, pat::PhotonRef>")
  .AddBase(type_40410, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_71581, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79200), Reflex::Literal("Holder"), constructor_71582, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70757), Reflex::Literal("Holder"), constructor_71583, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_71586, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40449, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x235, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon, edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7377, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon, edm::refhelper::FindUsingAdvance<std::vector<pat::Photon, std::allocator<pat::Photon> >, pat::Photon> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79201, type_79200), Reflex::Literal("operator="), operator_71584, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79201), Reflex::Literal("swap"), method_71585, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71862), Reflex::Literal("clone"), method_71587, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("getPtr"), method_71588, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71589, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71590, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_79148), Reflex::Literal("isEqualTo"), method_71591, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70757), Reflex::Literal("getRef"), method_71592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71593, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3235), Reflex::Literal("holder"), method_71594, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3234), Reflex::Literal("makeVectorHolder"), method_71595, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorBaseHolder"), method_71596, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71597, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71598, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71599, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71600, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71601, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau, edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > > -------------------------------
static void constructor_71603( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >();
}

static void constructor_71604( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)arg[0]);
}

static void constructor_71605( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >(*(const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >(*(const ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >*)arg[0]);
}

static  void operator_71606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)arg[0]);
}

static  void method_71607( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)arg[0]);
}

static void destructor_71608(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::~Holder)();
}
static  void method_71609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->clone)();
}

static  void method_71610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->getPtr)();
}

static  void method_71611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->id)();
}

static  void method_71612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->key)();
}

static  void method_71613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_71614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->getRef)();
}

static  void method_71615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->holder)();
}

static  void method_71617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->makeVectorHolder)();
}

static  void method_71618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->makeVectorBaseHolder)();
}

static  void method_71619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->productGetter)();
}

static  void method_71620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->hasProductCache)();
}

static  void method_71621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->product)();
}

static  void method_71622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->isAvailable)();
}

static  void method_71623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >*)o)->Class_Version)();
}

static void method_newdel_40450( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x237( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau, edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Candidate, pat::TauRef>")
  .AddBase(type_40410, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_71603, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79202), Reflex::Literal("Holder"), constructor_71604, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70763), Reflex::Literal("Holder"), constructor_71605, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_71608, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40450, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x237, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau, edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7378, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau, edm::refhelper::FindUsingAdvance<std::vector<pat::Tau, std::allocator<pat::Tau> >, pat::Tau> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79203, type_79202), Reflex::Literal("operator="), operator_71606, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79203), Reflex::Literal("swap"), method_71607, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71862), Reflex::Literal("clone"), method_71609, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("getPtr"), method_71610, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71611, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71612, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_79148), Reflex::Literal("isEqualTo"), method_71613, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70763), Reflex::Literal("getRef"), method_71614, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71615, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3235), Reflex::Literal("holder"), method_71616, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3234), Reflex::Literal("makeVectorHolder"), method_71617, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorBaseHolder"), method_71618, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71619, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71620, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71621, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71622, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71623, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon, edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > > -------------------------------
static void constructor_71625( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >();
}

static void constructor_71626( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)arg[0]);
}

static void constructor_71627( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >(*(const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >(*(const ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >*)arg[0]);
}

static  void operator_71628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)arg[0]);
}

static  void method_71629( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)arg[0]);
}

static void destructor_71630(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::~Holder)();
}
static  void method_71631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->clone)();
}

static  void method_71632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->getPtr)();
}

static  void method_71633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->id)();
}

static  void method_71634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->key)();
}

static  void method_71635( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_71636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->getRef)();
}

static  void method_71637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->holder)();
}

static  void method_71639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->makeVectorHolder)();
}

static  void method_71640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->makeVectorBaseHolder)();
}

static  void method_71641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->productGetter)();
}

static  void method_71642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->hasProductCache)();
}

static  void method_71643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->product)();
}

static  void method_71644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->isAvailable)();
}

static  void method_71645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >*)o)->Class_Version)();
}

static void method_newdel_40451( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x239( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon, edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Candidate, pat::MuonRef>")
  .AddBase(type_40410, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_71625, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79204), Reflex::Literal("Holder"), constructor_71626, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70769), Reflex::Literal("Holder"), constructor_71627, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_71630, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40451, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x239, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon, edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7379, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon, edm::refhelper::FindUsingAdvance<std::vector<pat::Muon, std::allocator<pat::Muon> >, pat::Muon> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79205, type_79204), Reflex::Literal("operator="), operator_71628, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79205), Reflex::Literal("swap"), method_71629, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71862), Reflex::Literal("clone"), method_71631, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("getPtr"), method_71632, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71633, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71634, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_79148), Reflex::Literal("isEqualTo"), method_71635, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70769), Reflex::Literal("getRef"), method_71636, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71637, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3235), Reflex::Literal("holder"), method_71638, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3234), Reflex::Literal("makeVectorHolder"), method_71639, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorBaseHolder"), method_71640, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71641, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71642, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71643, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71644, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71645, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron, edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > > -------------------------------
static void constructor_71647( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >();
}

static void constructor_71648( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)arg[0]);
}

static void constructor_71649( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >(*(const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >(*(const ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >*)arg[0]);
}

static  void operator_71650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)arg[0]);
}

static  void method_71651( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)arg[0]);
}

static void destructor_71652(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::~Holder)();
}
static  void method_71653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->clone)();
}

static  void method_71654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->getPtr)();
}

static  void method_71655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->id)();
}

static  void method_71656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->key)();
}

static  void method_71657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_71658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->getRef)();
}

static  void method_71659( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_71660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->holder)();
}

static  void method_71661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->makeVectorHolder)();
}

static  void method_71662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->makeVectorBaseHolder)();
}

static  void method_71663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->productGetter)();
}

static  void method_71664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->hasProductCache)();
}

static  void method_71665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->product)();
}

static  void method_71666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->isAvailable)();
}

static  void method_71667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >*)o)->Class_Version)();
}

static void method_newdel_40452( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x241( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron, edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Candidate, pat::ElectronRef>")
  .AddBase(type_40410, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_71647, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_79206), Reflex::Literal("Holder"), constructor_71648, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70775), Reflex::Literal("Holder"), constructor_71649, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_71652, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_40452, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x241, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron, edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7380, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron, edm::refhelper::FindUsingAdvance<std::vector<pat::Electron, std::allocator<pat::Electron> >, pat::Electron> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_79207, type_79206), Reflex::Literal("operator="), operator_71650, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780, type_79207), Reflex::Literal("swap"), method_71651, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71862), Reflex::Literal("clone"), method_71653, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71865), Reflex::Literal("getPtr"), method_71654, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7365), Reflex::Literal("id"), method_71655, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("key"), method_71656, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_79148), Reflex::Literal("isEqualTo"), method_71657, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70775), Reflex::Literal("getRef"), method_71658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810, type_37175, type_18062), Reflex::Literal("fillRefIfMyTypeMatches"), method_71659, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3235), Reflex::Literal("holder"), method_71660, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3234), Reflex::Literal("makeVectorHolder"), method_71661, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("makeVectorBaseHolder"), method_71662, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35207), Reflex::Literal("productGetter"), method_71663, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("hasProductCache"), method_71664, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5416), Reflex::Literal("product"), method_71665, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("isAvailable"), method_71666, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_261), Reflex::Literal("Class_Version"), method_71667, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __pat__PackedGenParticle_dict(); 
      __std__vector_pat__PackedGenParticle__dict(); 
      __pat__PackedCandidate_dict(); 
      __std__vector_pat__PackedCandidate__dict(); 
      __pat__Conversion_dict(); 
      __std__vector_pat__Conversion__dict(); 
      __pat__Hemisphere_dict(); 
      __std__vector_pat__Hemisphere__dict(); 
      __pat__GenericParticle_dict(); 
      __std__vector_pat__GenericParticle__dict(); 
      __pat__PFParticle_dict(); 
      __std__vector_pat__PFParticle__dict(); 
      __pat__CompositeCandidate_dict(); 
      __std__vector_pat__CompositeCandidate__dict(); 
      __pat__Particle_dict(); 
      __std__vector_pat__Particle__dict(); 
      __pat__MET_dict(); 
      __std__vector_pat__MET__dict(); 
      __pat__Jet_dict(); 
      __std__vector_pat__Jet__dict(); 
      __pat__Photon_dict(); 
      __std__vector_pat__Photon__dict(); 
      __pat__Tau_dict(); 
      __std__vector_pat__Tau__dict(); 
      __pat__Muon_dict(); 
      __std__vector_pat__Muon__dict(); 
      __pat__Electron_dict(); 
      __std__vector_pat__Electron__dict(); 
      __pat__MHT_dict(); 
      __std__vector_pat__MHT__dict(); 
      __pat__MET__PackedMETUncertainty_dict(); 
      __std__vector_pat__MET__PackedMETUncertainty__dict(); 
      __pat__tau__TauPFSpecific_dict(); 
      __std__vector_pat__tau__TauPFSpecific__dict(); 
      __pat__tau__TauCaloSpecific_dict(); 
      __std__vector_pat__tau__TauCaloSpecific__dict(); 
      __pat__tau__TauPFEssential_dict(); 
      __std__vector_pat__tau__TauPFEssential__dict(); 
      __edm__Wrapper_std__vector_pat__PackedGenParticle_s__dict(); 
      __edm__Wrapper_std__vector_pat__PackedCandidate_s__dict(); 
      __edm__Wrapper_std__vector_pat__Conversion_s__dict(); 
      __edm__Wrapper_std__vector_pat__Hemisphere_s__dict(); 
      __edm__Wrapper_std__vector_pat__GenericParticle_s__dict(); 
      __edm__Wrapper_std__vector_pat__PFParticle_s__dict(); 
      __edm__Wrapper_std__vector_pat__CompositeCandidate_s__dict(); 
      __edm__Wrapper_std__vector_pat__Particle_s__dict(); 
      __edm__Wrapper_std__vector_pat__MHT_s__dict(); 
      __edm__Wrapper_std__vector_pat__MET_s__dict(); 
      __edm__Wrapper_std__vector_pat__Jet_s__dict(); 
      __edm__Wrapper_std__vector_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_pat__Muon_s__dict(); 
      __edm__Wrapper_std__vector_pat__Electron_s__dict(); 
      __edm__AtomicPtrCache_std__vector_reco__SuperCluster_s__dict(); 
      __edm__Ptr_pat__Tau__dict(); 
      __edm__Ptr_pat__Muon__dict(); 
      __edm__Ptr_pat__Conversion__dict(); 
      __edm__Ptr_pat__Electron__dict(); 
      __edm__Ptr_pat__MET__dict(); 
      __edm__Ptr_pat__Jet__dict(); 
      __pat__Lepton_reco__BaseTau__dict(); 
      __pat__Lepton_reco__Muon__dict(); 
      __pat__Lepton_reco__GsfElectron__dict(); 
      __pat__PATObject_reco__RecoCandidate__dict(); 
      __pat__PATObject_reco__PFCandidate__dict(); 
      __pat__PATObject_reco__CompositeCandidate__dict(); 
      __pat__PATObject_reco__LeafCandidate__dict(); 
      __pat__PATObject_reco__MET__dict(); 
      __pat__PATObject_reco__Jet__dict(); 
      __pat__PATObject_reco__Photon__dict(); 
      __pat__PATObject_reco__BaseTau__dict(); 
      __pat__PATObject_reco__Muon__dict(); 
      __pat__PATObject_reco__GsfElectron__dict(); 
      __edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__dict(); 
      __edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__dict(); 
      __edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__dict(); 
      __edm__Ref_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__dict(); 
      __edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__dict(); 
      __edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__dict(); 
      __edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s__dict(); 
      __edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s__dict(); 
      __edm__RefVector_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__dict(); 
      __edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__dict(); 
      __edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__dict(); 
      __edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__dict(); 
      __edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__dict(); 
      __edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__dict(); 
      __edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s__dict(); 
      __edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s__dict(); 
      __edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__dict(); 
      __edm__Ref_std__vector_pat__PackedCandidate__pat__PackedCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedCandidate__pat__PackedCandidate_s__dict(); 
      __edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s__dict(); 
      __edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s__dict(); 
      __edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s__dict(); 
      __edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s__dict(); 
      __edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s__dict(); 
      __edm__Ref_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s__dict(); 
      __edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__dict(); 
      __edm__Ref_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s__dict(); 
      __edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s__dict(); 
      __edm__RefVector_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PackedGenParticle__pat__PackedGenParticle_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__PackedGenParticlep_std__vector_pat__PackedGenParticle_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__PackedCandidatep_std__vector_pat__PackedCandidate_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__Conversionp_std__vector_pat__Conversion_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__Hemispherep_std__vector_pat__Hemisphere_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__GenericParticlep_std__vector_pat__GenericParticle_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__PFParticlep_std__vector_pat__PFParticle_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__CompositeCandidatep_std__vector_pat__CompositeCandidate_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__Particlep_std__vector_pat__Particle_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__METp_std__vector_pat__MET_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__Jetp_std__vector_pat__Jet_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__Photonp_std__vector_pat__Photon_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__Taup_std__vector_pat__Tau_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__Muonp_std__vector_pat__Muon_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__Electronp_std__vector_pat__Electron_s__dict(); 
      ____gnu_cxx____normal_iterator_constspat__MHTp_std__vector_pat__MHT_s__dict(); 
      __edm__Association_std__vector_pat__PackedCandidate_s__dict(); 
      __edm__Wrapper_edm__Association_std__vector_pat__PackedCandidate_s_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_pat__Conversion__pat__Conversion_edm__refhelper__FindUsingAdvance_std__vector_pat__Conversion__pat__Conversion_s_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_pat__Hemisphere__pat__Hemisphere_edm__refhelper__FindUsingAdvance_std__vector_pat__Hemisphere__pat__Hemisphere_s_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__dict(); 
      __edm__AtomicPtrCache_std__vector_edm__Ptr_reco__PFCandidate_s_s__dict(); 
      __edm__AtomicPtrCache_edm__RefVector_std__vector_reco__Track__reco__Track_edm__refhelper__FindUsingAdvance_std__vector_reco__Track__reco__Track_s_s__dict(); 
      __edm__RefProd_std__vector_pat__PackedCandidate_s__dict(); 
      __edm__reftobase__RefVectorHolder_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__dict(); 
      __edm__reftobase__VectorHolder_reco__Candidate_edm__RefVector_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__GenericParticle__pat__GenericParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__GenericParticle__pat__GenericParticle_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__PFParticle__pat__PFParticle_edm__refhelper__FindUsingAdvance_std__vector_pat__PFParticle__pat__PFParticle_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_edm__refhelper__FindUsingAdvance_std__vector_pat__CompositeCandidate__pat__CompositeCandidate_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Particle__pat__Particle_edm__refhelper__FindUsingAdvance_std__vector_pat__Particle__pat__Particle_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__MET__pat__MET_edm__refhelper__FindUsingAdvance_std__vector_pat__MET__pat__MET_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Jet__pat__Jet_edm__refhelper__FindUsingAdvance_std__vector_pat__Jet__pat__Jet_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Photon__pat__Photon_edm__refhelper__FindUsingAdvance_std__vector_pat__Photon__pat__Photon_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Tau__pat__Tau_edm__refhelper__FindUsingAdvance_std__vector_pat__Tau__pat__Tau_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Muon__pat__Muon_edm__refhelper__FindUsingAdvance_std__vector_pat__Muon__pat__Muon_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_pat__Electron__pat__Electron_edm__refhelper__FindUsingAdvance_std__vector_pat__Electron__pat__Electron_s_s__dict(); 
    }
    ~Dictionaries() {
      type_9072.Unload(); // class pat::PackedGenParticle 
      type_3507.Unload(); // class std::vector<pat::PackedGenParticle> 
      type_9073.Unload(); // class pat::PackedCandidate 
      type_3508.Unload(); // class std::vector<pat::PackedCandidate> 
      type_13535.Unload(); // class pat::Conversion 
      type_3509.Unload(); // class std::vector<pat::Conversion> 
      type_13517.Unload(); // class pat::Hemisphere 
      type_3510.Unload(); // class std::vector<pat::Hemisphere> 
      type_13540.Unload(); // class pat::GenericParticle 
      type_3511.Unload(); // class std::vector<pat::GenericParticle> 
      type_13478.Unload(); // class pat::PFParticle 
      type_3512.Unload(); // class std::vector<pat::PFParticle> 
      type_13564.Unload(); // class pat::CompositeCandidate 
      type_3513.Unload(); // class std::vector<pat::CompositeCandidate> 
      type_13527.Unload(); // class pat::Particle 
      type_3514.Unload(); // class std::vector<pat::Particle> 
      type_13544.Unload(); // class pat::MET 
      type_3515.Unload(); // class std::vector<pat::MET> 
      type_13487.Unload(); // class pat::Jet 
      type_3516.Unload(); // class std::vector<pat::Jet> 
      type_13525.Unload(); // class pat::Photon 
      type_3517.Unload(); // class std::vector<pat::Photon> 
      type_13568.Unload(); // class pat::Tau 
      type_3518.Unload(); // class std::vector<pat::Tau> 
      type_13465.Unload(); // class pat::Muon 
      type_3519.Unload(); // class std::vector<pat::Muon> 
      type_13576.Unload(); // class pat::Electron 
      type_3520.Unload(); // class std::vector<pat::Electron> 
      type_13575.Unload(); // class pat::MHT 
      type_3521.Unload(); // class std::vector<pat::MHT> 
      type_22727.Unload(); // class pat::MET::PackedMETUncertainty 
      type_3541.Unload(); // class std::vector<pat::MET::PackedMETUncertainty> 
      type_25966.Unload(); // class pat::tau::TauPFSpecific 
      type_3597.Unload(); // class std::vector<pat::tau::TauPFSpecific> 
      type_26032.Unload(); // class pat::tau::TauCaloSpecific 
      type_3598.Unload(); // class std::vector<pat::tau::TauCaloSpecific> 
      type_26098.Unload(); // class pat::tau::TauPFEssential 
      type_3599.Unload(); // class std::vector<pat::tau::TauPFEssential> 
      type_6809.Unload(); // class edm::Wrapper<std::vector<pat::PackedGenParticle> > 
      type_6810.Unload(); // class edm::Wrapper<std::vector<pat::PackedCandidate> > 
      type_6811.Unload(); // class edm::Wrapper<std::vector<pat::Conversion> > 
      type_6812.Unload(); // class edm::Wrapper<std::vector<pat::Hemisphere> > 
      type_6813.Unload(); // class edm::Wrapper<std::vector<pat::GenericParticle> > 
      type_6814.Unload(); // class edm::Wrapper<std::vector<pat::PFParticle> > 
      type_6815.Unload(); // class edm::Wrapper<std::vector<pat::CompositeCandidate> > 
      type_6816.Unload(); // class edm::Wrapper<std::vector<pat::Particle> > 
      type_6817.Unload(); // class edm::Wrapper<std::vector<pat::MHT> > 
      type_6818.Unload(); // class edm::Wrapper<std::vector<pat::MET> > 
      type_6819.Unload(); // class edm::Wrapper<std::vector<pat::Jet> > 
      type_6820.Unload(); // class edm::Wrapper<std::vector<pat::Photon> > 
      type_6821.Unload(); // class edm::Wrapper<std::vector<pat::Tau> > 
      type_6822.Unload(); // class edm::Wrapper<std::vector<pat::Muon> > 
      type_6823.Unload(); // class edm::Wrapper<std::vector<pat::Electron> > 
      type_7117.Unload(); // class edm::AtomicPtrCache<std::vector<reco::SuperCluster> > 
      type_7319.Unload(); // class edm::Ptr<pat::Tau> 
      type_7320.Unload(); // class edm::Ptr<pat::Muon> 
      type_7321.Unload(); // class edm::Ptr<pat::Conversion> 
      type_7322.Unload(); // class edm::Ptr<pat::Electron> 
      type_7323.Unload(); // class edm::Ptr<pat::MET> 
      type_7324.Unload(); // class edm::Ptr<pat::Jet> 
      type_13528.Unload(); // class pat::Lepton<reco::BaseTau> 
      type_13529.Unload(); // class pat::Lepton<reco::Muon> 
      type_13530.Unload(); // class pat::Lepton<reco::GsfElectron> 
      type_13546.Unload(); // class pat::PATObject<reco::RecoCandidate> 
      type_13547.Unload(); // class pat::PATObject<reco::PFCandidate> 
      type_13548.Unload(); // class pat::PATObject<reco::CompositeCandidate> 
      type_13549.Unload(); // class pat::PATObject<reco::LeafCandidate> 
      type_13550.Unload(); // class pat::PATObject<reco::MET> 
      type_13551.Unload(); // class pat::PATObject<reco::Jet> 
      type_13552.Unload(); // class pat::PATObject<reco::Photon> 
      type_13553.Unload(); // class pat::PATObject<reco::BaseTau> 
      type_13554.Unload(); // class pat::PATObject<reco::Muon> 
      type_13555.Unload(); // class pat::PATObject<reco::GsfElectron> 
      type_6483.Unload(); // class edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > 
      type_6486.Unload(); // class edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > 
      type_6488.Unload(); // class edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > 
      type_7368.Unload(); // class edm::Ref<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> > 
      type_6485.Unload(); // class edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > 
      type_6480.Unload(); // class edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > 
      type_7374.Unload(); // class edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > 
      type_7371.Unload(); // class edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > 
      type_6477.Unload(); // class edm::RefVector<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> > 
      type_6479.Unload(); // class edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > 
      type_6482.Unload(); // class edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > 
      type_7372.Unload(); // class edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > 
      type_6478.Unload(); // class edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > 
      type_7378.Unload(); // class edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > 
      type_7373.Unload(); // class edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > 
      type_6487.Unload(); // class edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > 
      type_6484.Unload(); // class edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > 
      type_7367.Unload(); // class edm::Ref<std::vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedCandidate>,pat::PackedCandidate> > 
      type_7375.Unload(); // class edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > 
      type_7377.Unload(); // class edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > 
      type_6481.Unload(); // class edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > 
      type_7379.Unload(); // class edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > 
      type_7376.Unload(); // class edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > 
      type_7370.Unload(); // class edm::Ref<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > 
      type_6489.Unload(); // class edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > 
      type_7369.Unload(); // class edm::Ref<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > 
      type_7380.Unload(); // class edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > 
      type_6476.Unload(); // class edm::RefVector<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PackedGenParticle>,pat::PackedGenParticle> > 
      type_11964.Unload(); // class __gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,std::vector<pat::PackedGenParticle> > 
      type_11965.Unload(); // class __gnu_cxx::__normal_iterator<const pat::PackedCandidate*,std::vector<pat::PackedCandidate> > 
      type_11966.Unload(); // class __gnu_cxx::__normal_iterator<const pat::Conversion*,std::vector<pat::Conversion> > 
      type_11967.Unload(); // class __gnu_cxx::__normal_iterator<const pat::Hemisphere*,std::vector<pat::Hemisphere> > 
      type_11968.Unload(); // class __gnu_cxx::__normal_iterator<const pat::GenericParticle*,std::vector<pat::GenericParticle> > 
      type_11969.Unload(); // class __gnu_cxx::__normal_iterator<const pat::PFParticle*,std::vector<pat::PFParticle> > 
      type_11970.Unload(); // class __gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,std::vector<pat::CompositeCandidate> > 
      type_11971.Unload(); // class __gnu_cxx::__normal_iterator<const pat::Particle*,std::vector<pat::Particle> > 
      type_11974.Unload(); // class __gnu_cxx::__normal_iterator<const pat::MET*,std::vector<pat::MET> > 
      type_11975.Unload(); // class __gnu_cxx::__normal_iterator<const pat::Jet*,std::vector<pat::Jet> > 
      type_11976.Unload(); // class __gnu_cxx::__normal_iterator<const pat::Photon*,std::vector<pat::Photon> > 
      type_11977.Unload(); // class __gnu_cxx::__normal_iterator<const pat::Tau*,std::vector<pat::Tau> > 
      type_11978.Unload(); // class __gnu_cxx::__normal_iterator<const pat::Muon*,std::vector<pat::Muon> > 
      type_11979.Unload(); // class __gnu_cxx::__normal_iterator<const pat::Electron*,std::vector<pat::Electron> > 
      type_11972.Unload(); // class __gnu_cxx::__normal_iterator<const pat::MHT*,std::vector<pat::MHT> > 
      type_7358.Unload(); // class edm::Association<std::vector<pat::PackedCandidate> > 
      type_6794.Unload(); // class edm::Wrapper<edm::Association<std::vector<pat::PackedCandidate> > > 
      type_6797.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<std::vector<pat::Conversion>,pat::Conversion> > > 
      type_6798.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<std::vector<pat::Hemisphere>,pat::Hemisphere> > > 
      type_6799.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > 
      type_6800.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > 
      type_6801.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > 
      type_6802.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > 
      type_6803.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > 
      type_6804.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > 
      type_6805.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > 
      type_6806.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > 
      type_6807.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > 
      type_6808.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > 
      type_7115.Unload(); // class edm::AtomicPtrCache<std::vector<edm::Ptr<reco::PFCandidate> > > 
      type_7118.Unload(); // class edm::AtomicPtrCache<edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > > 
      type_7221.Unload(); // class edm::RefProd<std::vector<pat::PackedCandidate> > 
      type_40424.Unload(); // class edm::reftobase::RefVectorHolder<edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > 
      type_40426.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > 
      type_40427.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > 
      type_40428.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > 
      type_40429.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > 
      type_40430.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > 
      type_40431.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > 
      type_40432.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > 
      type_40433.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > 
      type_40434.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > 
      type_40435.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > 
      type_40439.Unload(); // class edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > 
      type_40443.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::GenericParticle>,pat::GenericParticle> > > 
      type_40444.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<std::vector<pat::PFParticle>,pat::PFParticle> > > 
      type_40445.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > 
      type_40446.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<std::vector<pat::Particle>,pat::Particle> > > 
      type_40447.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > > 
      type_40448.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > > 
      type_40449.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<std::vector<pat::Photon>,pat::Photon> > > 
      type_40450.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > > 
      type_40451.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > > 
      type_40452.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
